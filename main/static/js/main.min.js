(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const signin_1 = __importDefault(require("./blocks/signin"));
const signup_1 = __importDefault(require("./blocks/signup"));
exports.default = () => {
    new signin_1.default();
    new signup_1.default();
};
},{"./blocks/signin":3,"./blocks/signup":4}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PageBlock {
    constructor() {
        if (!this.init()) {
            return;
        }
        this.start();
    }
}
exports.default = PageBlock;
},{}],3:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-nocheck
const UIkit = __importStar(require("uikit"));
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const PageBlock_1 = __importDefault(require("./PageBlock"));
class signin extends PageBlock_1.default {
    constructor() {
        super(...arguments);
        this.signinRequestHandler = (data) => {
            if (data.status == 'error') {
                this.updateFormError(data.error);
                UIkit.notification(data.error);
                return;
            }
            window.location.href = '/';
        };
    }
    init() {
        if (!document.querySelector('.signin')) {
            return false;
        }
        this.formDom = document.querySelector(".signin__form");
        this.formErrorsDom = this.formDom.querySelector(".signup__form-error");
        return true;
    }
    start() {
        this.formHandler();
    }
    updateFormError(errorText) {
        this.formErrorsDom.innerHTML = errorText;
    }
    formHandler() {
        this.formDom.addEventListener('submit', (event) => {
            event.preventDefault();
            (0, cross_fetch_1.default)('/signin/post', {
                method: 'POST',
                body: new FormData(this.formDom)
            })
                .then(response => response.json())
                .then(this.signinRequestHandler)
                .catch(error => {
                console.log(error);
                UIkit.notification('Ошибка!');
            });
        });
    }
}
exports.default = signin;
},{"./PageBlock":2,"cross-fetch":8,"uikit":10}],4:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-nocheck
const UIkit = __importStar(require("uikit"));
const PageBlock_1 = __importDefault(require("./PageBlock"));
class signup extends PageBlock_1.default {
    constructor() {
        super(...arguments);
        this.clearFieldErrors = () => {
            const fieldErrorsDom = this.formDom.querySelectorAll(`.signup__form-error`);
            fieldErrorsDom.forEach((fieldErrorDom) => {
                fieldErrorDom.innerHTML = '';
            });
        };
        this.printFieldError = (fieldName, error) => {
            const fieldDom = this.formDom.querySelector(`.signup__field-${fieldName} p.signup__form-error`);
            fieldDom.innerHTML = error;
        };
        this.signinRequestHandler = (data) => {
            if (data.status == 'error') {
                this.updateFormErrors(data.errors);
                return;
            }
            window.location.href = '/signin';
        };
    }
    init() {
        if (!document.querySelector('.signup')) {
            return false;
        }
        this.formDom = document.querySelector(".signup__form");
        return true;
    }
    start() {
        this.formHandler();
    }
    updateFormErrors(errors) {
        this.clearFieldErrors();
        Object.entries(errors).forEach(([fieldName, error]) => {
            this.printFieldError(fieldName, error);
        });
    }
    formHandler() {
        this.formDom.addEventListener('submit', (event) => {
            event.preventDefault();
            fetch('/signup/post', {
                method: 'POST',
                body: new FormData(this.formDom)
            })
                .then(response => response.json())
                .then(this.signinRequestHandler)
                .catch(error => {
                console.log(error);
                UIkit.notification('Ошибка!');
            });
        });
    }
}
exports.default = signup;
},{"./PageBlock":2,"uikit":10}],5:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const uikit_1 = __importDefault(require("./libs/uikit"));
exports.default = () => {
    (0, uikit_1.default)();
};
},{"./libs/uikit":6}],6:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-nocheck
const UIkit = __importStar(require("uikit"));
const uikit_icons_1 = __importDefault(require("uikit/dist/js/uikit-icons"));
exports.default = () => {
    UIkit.use(uikit_icons_1.default);
};
},{"uikit":10,"uikit/dist/js/uikit-icons":9}],7:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const libs_1 = __importDefault(require("./libs"));
const blocks_1 = __importDefault(require("./blocks"));
const main = () => __awaiter(void 0, void 0, void 0, function* () {
    (0, libs_1.default)();
    (0, blocks_1.default)();
});
main();
},{"./blocks":1,"./libs":5}],8:[function(require,module,exports){
var global = typeof self !== 'undefined' ? self : this;
var __self__ = (function () {
function F() {
this.fetch = false;
this.DOMException = global.DOMException
}
F.prototype = global;
return new F();
})();
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch // To enable: import fetch from 'cross-fetch'
exports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers
exports.Request = ctx.Request
exports.Response = ctx.Response
module.exports = exports

},{}],9:[function(require,module,exports){
/*! UIkit 3.13.9 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define('uikiticons', factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.UIkitIcons = factory());
})(this, (function () { 'use strict';

    function plugin(UIkit) {
      if (plugin.installed) {
        return;
      }

      UIkit.icon.add({
        "500px": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.624,11.866c-0.141,0.132,0.479,0.658,0.662,0.418c0.051-0.046,0.607-0.61,0.662-0.664c0,0,0.738,0.719,0.814,0.719 c0.1,0,0.207-0.055,0.322-0.17c0.27-0.269,0.135-0.416,0.066-0.495l-0.631-0.616l0.658-0.668c0.146-0.156,0.021-0.314-0.1-0.449 c-0.182-0.18-0.359-0.226-0.471-0.125l-0.656,0.654l-0.654-0.654c-0.033-0.034-0.08-0.045-0.124-0.045 c-0.079,0-0.191,0.068-0.307,0.181c-0.202,0.202-0.247,0.351-0.133,0.462l0.665,0.665L9.624,11.866z\"/><path d=\"M11.066,2.884c-1.061,0-2.185,0.248-3.011,0.604c-0.087,0.034-0.141,0.106-0.15,0.205C7.893,3.784,7.919,3.909,7.982,4.066 c0.05,0.136,0.187,0.474,0.452,0.372c0.844-0.326,1.779-0.507,2.633-0.507c0.963,0,1.9,0.191,2.781,0.564 c0.695,0.292,1.357,0.719,2.078,1.34c0.051,0.044,0.105,0.068,0.164,0.068c0.143,0,0.273-0.137,0.389-0.271 c0.191-0.214,0.324-0.395,0.135-0.575c-0.686-0.654-1.436-1.138-2.363-1.533C13.24,3.097,12.168,2.884,11.066,2.884z\"/><path d=\"M16.43,15.747c-0.092-0.028-0.242,0.05-0.309,0.119l0,0c-0.652,0.652-1.42,1.169-2.268,1.521 c-0.877,0.371-1.814,0.551-2.779,0.551c-0.961,0-1.896-0.189-2.775-0.564c-0.848-0.36-1.612-0.879-2.268-1.53 c-0.682-0.688-1.196-1.455-1.529-2.268c-0.325-0.799-0.471-1.643-0.471-1.643c-0.045-0.24-0.258-0.249-0.567-0.203 c-0.128,0.021-0.519,0.079-0.483,0.36v0.01c0.105,0.644,0.289,1.284,0.545,1.895c0.417,0.969,1.002,1.849,1.756,2.604 c0.757,0.754,1.636,1.34,2.604,1.757C8.901,18.785,9.97,19,11.088,19c1.104,0,2.186-0.215,3.188-0.645 c1.838-0.896,2.604-1.757,2.604-1.757c0.182-0.204,0.227-0.317-0.1-0.643C16.779,15.956,16.525,15.774,16.43,15.747z\"/><path d=\"M5.633,13.287c0.293,0.71,0.723,1.341,1.262,1.882c0.54,0.54,1.172,0.971,1.882,1.264c0.731,0.303,1.509,0.461,2.298,0.461 c0.801,0,1.578-0.158,2.297-0.461c0.711-0.293,1.344-0.724,1.883-1.264c0.543-0.541,0.971-1.172,1.264-1.882 c0.314-0.721,0.463-1.5,0.463-2.298c0-0.79-0.148-1.569-0.463-2.289c-0.293-0.699-0.721-1.329-1.264-1.881 c-0.539-0.541-1.172-0.959-1.867-1.263c-0.721-0.303-1.5-0.461-2.299-0.461c-0.802,0-1.613,0.159-2.322,0.461 c-0.577,0.25-1.544,0.867-2.119,1.454v0.012V2.108h8.16C15.1,2.104,15.1,1.69,15.1,1.552C15.1,1.417,15.1,1,14.809,1H5.915 C5.676,1,5.527,1.192,5.527,1.384v6.84c0,0.214,0.273,0.372,0.529,0.428c0.5,0.105,0.614-0.056,0.737-0.224l0,0 c0.18-0.273,0.776-0.884,0.787-0.894c0.901-0.905,2.117-1.408,3.416-1.408c1.285,0,2.5,0.501,3.412,1.408 c0.914,0.914,1.408,2.122,1.408,3.405c0,1.288-0.508,2.496-1.408,3.405c-0.9,0.896-2.152,1.406-3.438,1.406 c-0.877,0-1.711-0.229-2.433-0.671v-4.158c0-0.553,0.237-1.151,0.643-1.614c0.462-0.519,1.094-0.799,1.782-0.799 c0.664,0,1.293,0.253,1.758,0.715c0.459,0.459,0.709,1.071,0.709,1.723c0,1.385-1.094,2.468-2.488,2.468 c-0.273,0-0.769-0.121-0.781-0.125c-0.281-0.087-0.405,0.306-0.438,0.436c-0.159,0.496,0.079,0.585,0.123,0.607 c0.452,0.137,0.743,0.157,1.129,0.157c1.973,0,3.572-1.6,3.572-3.57c0-1.964-1.6-3.552-3.572-3.552c-0.97,0-1.872,0.36-2.546,1.038 c-0.656,0.631-1.027,1.487-1.027,2.322v3.438v-0.011c-0.372-0.42-0.732-1.041-0.981-1.682c-0.102-0.248-0.315-0.202-0.607-0.113 c-0.135,0.035-0.519,0.157-0.44,0.439C5.372,12.799,5.577,13.164,5.633,13.287z\"/></svg>",
        "album": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"5\" y=\"2\" width=\"10\" height=\"1\"/><rect x=\"3\" y=\"4\" width=\"14\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"6.5\" width=\"17\" height=\"11\"/></svg>",
        "arrow-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10.5,16.08 5.63,10.66 6.37,10 10.5,14.58 14.63,10 15.37,10.66\"/><line fill=\"none\" stroke=\"#000\" x1=\"10.5\" y1=\"4\" x2=\"10.5\" y2=\"15\"/></svg>",
        "arrow-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"10 14 5 9.5 10 5\"/><line fill=\"none\" stroke=\"#000\" x1=\"16\" y1=\"9.5\" x2=\"5\" y2=\"9.52\"/></svg>",
        "arrow-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"10 5 15 9.5 10 14\"/><line fill=\"none\" stroke=\"#000\" x1=\"4\" y1=\"9.5\" x2=\"15\" y2=\"9.5\"/></svg>",
        "arrow-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10.5,4 15.37,9.4 14.63,10.08 10.5,5.49 6.37,10.08 5.63,9.4\"/><line fill=\"none\" stroke=\"#000\" x1=\"10.5\" y1=\"16\" x2=\"10.5\" y2=\"5\"/></svg>",
        "bag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M7.5,7.5V4A2.48,2.48,0,0,1,10,1.5,2.54,2.54,0,0,1,12.5,4V7.5\"/><polygon fill=\"none\" stroke=\"#000\" points=\"16.5 7.5 3.5 7.5 2.5 18.5 17.5 18.5 16.5 7.5\"/></svg>",
        "ban": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"4\" y1=\"3.5\" x2=\"16\" y2=\"16.5\"/></svg>",
        "behance": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.5,10.6c-0.4-0.5-0.9-0.9-1.6-1.1c1.7-1,2.2-3.2,0.7-4.7C7.8,4,6.3,4,5.2,4C3.5,4,1.7,4,0,4v12c1.7,0,3.4,0,5.2,0 c1,0,2.1,0,3.1-0.5C10.2,14.6,10.5,12.3,9.5,10.6L9.5,10.6z M5.6,6.1c1.8,0,1.8,2.7-0.1,2.7c-1,0-2,0-2.9,0V6.1H5.6z M2.6,13.8v-3.1 c1.1,0,2.1,0,3.2,0c2.1,0,2.1,3.2,0.1,3.2L2.6,13.8z\"/><path d=\"M19.9,10.9C19.7,9.2,18.7,7.6,17,7c-4.2-1.3-7.3,3.4-5.3,7.1c0.9,1.7,2.8,2.3,4.7,2.1c1.7-0.2,2.9-1.3,3.4-2.9h-2.2 c-0.4,1.3-2.4,1.5-3.5,0.6c-0.4-0.4-0.6-1.1-0.6-1.7H20C20,11.7,19.9,10.9,19.9,10.9z M13.5,10.6c0-1.6,2.3-2.7,3.5-1.4 c0.4,0.4,0.5,0.9,0.6,1.4H13.5L13.5,10.6z\"/><rect x=\"13\" y=\"4\" width=\"5\" height=\"1.4\"/></svg>",
        "bell": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17,15.5 L3,15.5 C2.99,14.61 3.79,13.34 4.1,12.51 C4.58,11.3 4.72,10.35 5.19,7.01 C5.54,4.53 5.89,3.2 7.28,2.16 C8.13,1.56 9.37,1.5 9.81,1.5 L9.96,1.5 C9.96,1.5 11.62,1.41 12.67,2.17 C14.08,3.2 14.42,4.54 14.77,7.02 C15.26,10.35 15.4,11.31 15.87,12.52 C16.2,13.34 17.01,14.61 17,15.5 L17,15.5 Z\"/><path fill=\"none\" stroke=\"#000\" d=\"M12.39,16 C12.39,17.37 11.35,18.43 9.91,18.43 C8.48,18.43 7.42,17.37 7.42,16\"/></svg>",
        "bold": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5,15.3 C5.66,15.3 5.9,15 5.9,14.53 L5.9,5.5 C5.9,4.92 5.56,4.7 5,4.7 L5,4 L8.95,4 C12.6,4 13.7,5.37 13.7,6.9 C13.7,7.87 13.14,9.17 10.86,9.59 L10.86,9.7 C13.25,9.86 14.29,11.28 14.3,12.54 C14.3,14.47 12.94,16 9,16 L5,16 L5,15.3 Z M9,9.3 C11.19,9.3 11.8,8.5 11.85,7 C11.85,5.65 11.3,4.8 9,4.8 L7.67,4.8 L7.67,9.3 L9,9.3 Z M9.185,15.22 C11.97,15 12.39,14 12.4,12.58 C12.4,11.15 11.39,10 9,10 L7.67,10 L7.67,15 L9.18,15 Z\"/></svg>",
        "bolt": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.74,20 L7.73,12 L3,12 L15.43,1 L12.32,9 L17.02,9 L4.74,20 L4.74,20 L4.74,20 Z M9.18,11 L7.1,16.39 L14.47,10 L10.86,10 L12.99,4.67 L5.61,11 L9.18,11 L9.18,11 L9.18,11 Z\"/></svg>",
        "bookmark": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"5.5 1.5 15.5 1.5 15.5 17.5 10.5 12.5 5.5 17.5\"/></svg>",
        "calendar": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M 2,3 2,17 18,17 18,3 2,3 Z M 17,16 3,16 3,8 17,8 17,16 Z M 17,7 3,7 3,4 17,4 17,7 Z\"/><rect width=\"1\" height=\"3\" x=\"6\" y=\"2\"/><rect width=\"1\" height=\"3\" x=\"13\" y=\"2\"/></svg>",
        "camera": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10.8\" r=\"3.8\"/><path fill=\"none\" stroke=\"#000\" d=\"M1,4.5 C0.7,4.5 0.5,4.7 0.5,5 L0.5,17 C0.5,17.3 0.7,17.5 1,17.5 L19,17.5 C19.3,17.5 19.5,17.3 19.5,17 L19.5,5 C19.5,4.7 19.3,4.5 19,4.5 L13.5,4.5 L13.5,2.9 C13.5,2.6 13.3,2.5 13,2.5 L7,2.5 C6.7,2.5 6.5,2.6 6.5,2.9 L6.5,4.5 L1,4.5 L1,4.5 Z\"/></svg>",
        "cart": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"7.3\" cy=\"17.3\" r=\"1.4\"/><circle cx=\"13.3\" cy=\"17.3\" r=\"1.4\"/><polyline fill=\"none\" stroke=\"#000\" points=\"0 2 3.2 4 5.3 12.5 16 12.5 18 6.5 8 6.5\"/></svg>",
        "check": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"4,10 8,15 17,4\"/></svg>",
        "chevron-double-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"10 14 6 10 10 6\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"14 14 10 10 14 6\"/></svg>",
        "chevron-double-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"10 6 14 10 10 14\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"6 6 10 10 6 14\"/></svg>",
        "chevron-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"16 7 10 13 4 7\"/></svg>",
        "chevron-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"13 16 7 10 13 4\"/></svg>",
        "chevron-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"7 4 13 10 7 16\"/></svg>",
        "chevron-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"4 13 10 7 16 13\"/></svg>",
        "clock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.018,14.197 L9.445,10.625\"/></svg>",
        "close": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.06\" d=\"M16,16 L4,4\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.06\" d=\"M16,4 L4,16\"/></svg>",
        "cloud-download": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.3,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\"/><polyline fill=\"none\" stroke=\"#000\" points=\"11.75 16 9.5 18.25 7.25 16\"/><path fill=\"none\" stroke=\"#000\" d=\"M9.5,18 L9.5,9.5\"/></svg>",
        "cloud-upload": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.31,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\"/><polyline fill=\"none\" stroke=\"#000\" points=\"7.25 11.75 9.5 9.5 11.75 11.75\"/><path fill=\"none\" stroke=\"#000\" d=\"M9.5,18 L9.5,9.5\"/></svg>",
        "code": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"13,4 19,10 13,16\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"7,4 1,10 7,16\"/></svg>",
        "cog": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"9.997\" cy=\"10\" r=\"3.31\"/><path fill=\"none\" stroke=\"#000\" d=\"M18.488,12.285 L16.205,16.237 C15.322,15.496 14.185,15.281 13.303,15.791 C12.428,16.289 12.047,17.373 12.246,18.5 L7.735,18.5 C7.938,17.374 7.553,16.299 6.684,15.791 C5.801,15.27 4.655,15.492 3.773,16.237 L1.5,12.285 C2.573,11.871 3.317,10.999 3.317,9.991 C3.305,8.98 2.573,8.121 1.5,7.716 L3.765,3.784 C4.645,4.516 5.794,4.738 6.687,4.232 C7.555,3.722 7.939,2.637 7.735,1.5 L12.263,1.5 C12.072,2.637 12.441,3.71 13.314,4.22 C14.206,4.73 15.343,4.516 16.225,3.794 L18.487,7.714 C17.404,8.117 16.661,8.988 16.67,10.009 C16.672,11.018 17.415,11.88 18.488,12.285 L18.488,12.285 Z\"/></svg>",
        "comment": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6,18.71 L6,14 L1,14 L1,1 L19,1 L19,14 L10.71,14 L6,18.71 L6,18.71 Z M2,13 L7,13 L7,16.29 L10.29,13 L18,13 L18,2 L2,2 L2,13 L2,13 Z\"/></svg>",
        "commenting": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"1.5,1.5 18.5,1.5 18.5,13.5 10.5,13.5 6.5,17.5 6.5,13.5 1.5,13.5\"/><circle cx=\"10\" cy=\"8\" r=\"1\"/><circle cx=\"6\" cy=\"8\" r=\"1\"/><circle cx=\"14\" cy=\"8\" r=\"1\"/></svg>",
        "comments": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"2 0.5 19.5 0.5 19.5 13\"/><path d=\"M5,19.71 L5,15 L0,15 L0,2 L18,2 L18,15 L9.71,15 L5,19.71 L5,19.71 L5,19.71 Z M1,14 L6,14 L6,17.29 L9.29,14 L17,14 L17,3 L1,3 L1,14 L1,14 L1,14 Z\"/></svg>",
        "copy": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"2.5\" width=\"12\" height=\"16\"/><polyline fill=\"none\" stroke=\"#000\" points=\"5 0.5 17.5 0.5 17.5 17\"/></svg>",
        "credit-card": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"4.5\" width=\"17\" height=\"12\"/><rect x=\"1\" y=\"7\" width=\"18\" height=\"3\"/></svg>",
        "database": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><ellipse fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"4.64\" rx=\"7.5\" ry=\"3.14\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.5,8.11 C17.5,9.85 14.14,11.25 10,11.25 C5.86,11.25 2.5,9.84 2.5,8.11\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.5,11.25 C17.5,12.99 14.14,14.39 10,14.39 C5.86,14.39 2.5,12.98 2.5,11.25\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.49,4.64 L17.5,14.36 C17.5,16.1 14.14,17.5 10,17.5 C5.86,17.5 2.5,16.09 2.5,14.36 L2.5,4.64\"/></svg>",
        "desktop": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"8\" y=\"15\" width=\"1\" height=\"2\"/><rect x=\"11\" y=\"15\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"16\" width=\"10\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"3.5\" width=\"17\" height=\"11\"/></svg>",
        "discord": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path d=\"M16.074,4.361a14.243,14.243,0,0,0-3.61-1.134,10.61,10.61,0,0,0-.463.96,13.219,13.219,0,0,0-4,0,10.138,10.138,0,0,0-.468-.96A14.206,14.206,0,0,0,3.919,4.364,15.146,15.146,0,0,0,1.324,14.5a14.435,14.435,0,0,0,4.428,2.269A10.982,10.982,0,0,0,6.7,15.21a9.294,9.294,0,0,1-1.494-.727c.125-.093.248-.19.366-.289a10.212,10.212,0,0,0,8.854,0c.119.1.242.2.366.289a9.274,9.274,0,0,1-1.5.728,10.8,10.8,0,0,0,.948,1.562,14.419,14.419,0,0,0,4.431-2.27A15.128,15.128,0,0,0,16.074,4.361Zm-8.981,8.1a1.7,1.7,0,0,1-1.573-1.79A1.689,1.689,0,0,1,7.093,8.881a1.679,1.679,0,0,1,1.573,1.791A1.687,1.687,0,0,1,7.093,12.462Zm5.814,0a1.7,1.7,0,0,1-1.573-1.79,1.689,1.689,0,0,1,1.573-1.791,1.679,1.679,0,0,1,1.573,1.791A1.688,1.688,0,0,1,12.907,12.462Z\"/></svg>",
        "download": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"14,10 9.5,14.5 5,10\"/><rect x=\"3\" y=\"17\" width=\"13\" height=\"1\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"13.91\" x2=\"9.5\" y2=\"3\"/></svg>",
        "dribbble": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M1.3,8.9c0,0,5,0.1,8.6-1c1.4-0.4,2.6-0.9,4-1.9 c1.4-1.1,2.5-2.5,2.5-2.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M3.9,16.6c0,0,1.7-2.8,3.5-4.2 c1.8-1.3,4-2,5.7-2.2C16,10,19,10.6,19,10.6\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M6.9,1.6c0,0,3.3,4.6,4.2,6.8 c0.4,0.9,1.3,3.1,1.9,5.2c0.6,2,0.9,4.4,0.9,4.4\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
        "etsy": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path d=\"M8,4.26C8,4.07,8,4,8.31,4h4.46c.79,0,1.22.67,1.53,1.91l.25,1h.76c.14-2.82.26-4,.26-4S13.65,3,12.52,3H6.81L3.75,2.92v.84l1,.2c.73.11.9.27,1,1,0,0,.06,2,.06,5.17s-.06,5.14-.06,5.14c0,.59-.23.81-1,.94l-1,.2v.84l3.06-.1h5.11c1.15,0,3.82.1,3.82.1,0-.7.45-3.88.51-4.22h-.73l-.76,1.69a2.25,2.25,0,0,1-2.45,1.47H9.4c-1,0-1.44-.4-1.44-1.24V10.44s2.16,0,2.86.06c.55,0,.85.19,1.06,1l.23,1H13L12.9,9.94,13,7.41h-.85l-.28,1.13c-.16.74-.28.84-1,1-1,.1-2.89.09-2.89.09Z\"/></svg>",
        "expand": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"13 2 18 2 18 7 17 7 17 3 13 3\"/><polygon points=\"2 13 3 13 3 17 7 17 7 18 2 18\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M11,9 L17,3\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M3,17 L9,11\"/></svg>",
        "facebook": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11,10h2.6l0.4-3H11V5.3c0-0.9,0.2-1.5,1.5-1.5H14V1.1c-0.3,0-1-0.1-2.1-0.1C9.6,1,8,2.4,8,5v2H5.5v3H8v8h3V10z\"/></svg>",
        "file-edit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M18.65,1.68 C18.41,1.45 18.109,1.33 17.81,1.33 C17.499,1.33 17.209,1.45 16.98,1.68 L8.92,9.76 L8,12.33 L10.55,11.41 L18.651,3.34 C19.12,2.87 19.12,2.15 18.65,1.68 L18.65,1.68 L18.65,1.68 Z\"/><polyline fill=\"none\" stroke=\"#000\" points=\"16.5 8.482 16.5 18.5 3.5 18.5 3.5 1.5 14.211 1.5\"/></svg>",
        "file-pdf": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" width=\"13\" height=\"17\" x=\"3.5\" y=\"1.5\"/><path d=\"M14.65 11.67c-.48.3-1.37-.19-1.79-.37a4.65 4.65 0 0 1 1.49.06c.35.1.36.28.3.31zm-6.3.06l.43-.79a14.7 14.7 0 0 0 .75-1.64 5.48 5.48 0 0 0 1.25 1.55l.2.15a16.36 16.36 0 0 0-2.63.73zM9.5 5.32c.2 0 .32.5.32.97a1.99 1.99 0 0 1-.23 1.04 5.05 5.05 0 0 1-.17-1.3s0-.71.08-.71zm-3.9 9a4.35 4.35 0 0 1 1.21-1.46l.24-.22a4.35 4.35 0 0 1-1.46 1.68zm9.23-3.3a2.05 2.05 0 0 0-1.32-.3 11.07 11.07 0 0 0-1.58.11 4.09 4.09 0 0 1-.74-.5 5.39 5.39 0 0 1-1.32-2.06 10.37 10.37 0 0 0 .28-2.62 1.83 1.83 0 0 0-.07-.25.57.57 0 0 0-.52-.4H9.4a.59.59 0 0 0-.6.38 6.95 6.95 0 0 0 .37 3.14c-.26.63-1 2.12-1 2.12-.3.58-.57 1.08-.82 1.5l-.8.44A3.11 3.11 0 0 0 5 14.16a.39.39 0 0 0 .15.42l.24.13c1.15.56 2.28-1.74 2.66-2.42a23.1 23.1 0 0 1 3.59-.85 4.56 4.56 0 0 0 2.91.8.5.5 0 0 0 .3-.21 1.1 1.1 0 0 0 .12-.75.84.84 0 0 0-.14-.25z\"/></svg>",
        "file-text": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" width=\"13\" height=\"17\" x=\"3.5\" y=\"1.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"12\" y1=\"12.5\" y2=\"12.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"8.5\" y2=\"8.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"6.5\" y2=\"6.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"10.5\" y2=\"10.5\"/></svg>",
        "file": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"1.5\" width=\"13\" height=\"17\"/></svg>",
        "flickr": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"5.5\" cy=\"9.5\" r=\"3.5\"/><circle cx=\"14.5\" cy=\"9.5\" r=\"3.5\"/></svg>",
        "folder": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"9.5 5.5 8.5 3.5 1.5 3.5 1.5 16.5 18.5 16.5 18.5 5.5\"/></svg>",
        "forward": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.47,13.11 C4.02,10.02 6.27,7.85 9.04,6.61 C9.48,6.41 10.27,6.13 11,5.91 L11,2 L18.89,9 L11,16 L11,12.13 C9.25,12.47 7.58,13.19 6.02,14.25 C3.03,16.28 1.63,18.54 1.63,18.54 C1.63,18.54 1.38,15.28 2.47,13.11 L2.47,13.11 Z M5.3,13.53 C6.92,12.4 9.04,11.4 12,10.92 L12,13.63 L17.36,9 L12,4.25 L12,6.8 C11.71,6.86 10.86,7.02 9.67,7.49 C6.79,8.65 4.58,10.96 3.49,13.08 C3.18,13.7 2.68,14.87 2.49,16 C3.28,15.05 4.4,14.15 5.3,13.53 L5.3,13.53 Z\"/></svg>",
        "foursquare": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.23,2 C15.96,2 16.4,2.41 16.5,2.86 C16.57,3.15 16.56,3.44 16.51,3.73 C16.46,4.04 14.86,11.72 14.75,12.03 C14.56,12.56 14.16,12.82 13.61,12.83 C13.03,12.84 11.09,12.51 10.69,13 C10.38,13.38 7.79,16.39 6.81,17.53 C6.61,17.76 6.4,17.96 6.08,17.99 C5.68,18.04 5.29,17.87 5.17,17.45 C5.12,17.28 5.1,17.09 5.1,16.91 C5.1,12.4 4.86,7.81 5.11,3.31 C5.17,2.5 5.81,2.12 6.53,2 L15.23,2 L15.23,2 Z M9.76,11.42 C9.94,11.19 10.17,11.1 10.45,11.1 L12.86,11.1 C13.12,11.1 13.31,10.94 13.36,10.69 C13.37,10.64 13.62,9.41 13.74,8.83 C13.81,8.52 13.53,8.28 13.27,8.28 C12.35,8.29 11.42,8.28 10.5,8.28 C9.84,8.28 9.83,7.69 9.82,7.21 C9.8,6.85 10.13,6.55 10.5,6.55 C11.59,6.56 12.67,6.55 13.76,6.55 C14.03,6.55 14.23,6.4 14.28,6.14 C14.34,5.87 14.67,4.29 14.67,4.29 C14.67,4.29 14.82,3.74 14.19,3.74 L7.34,3.74 C7,3.75 6.84,4.02 6.84,4.33 C6.84,7.58 6.85,14.95 6.85,14.99 C6.87,15 8.89,12.51 9.76,11.42 L9.76,11.42 Z\"/></svg>",
        "future": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"19 2 18 2 18 6 14 6 14 7 19 7 19 2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M18,6.548 C16.709,3.29 13.354,1 9.6,1 C4.6,1 0.6,5 0.6,10 C0.6,15 4.6,19 9.6,19 C14.6,19 18.6,15 18.6,10\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path d=\"M13.018,14.197 L9.445,10.625\" fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\"/></svg>",
        "git-branch": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"7\" cy=\"3\" r=\"2\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"14\" cy=\"6\" r=\"2\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"7\" cy=\"17\" r=\"2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"2\" d=\"M14,8 C14,10.41 12.43,10.87 10.56,11.25 C9.09,11.54 7,12.06 7,15 L7,5\"/></svg>",
        "git-fork": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"5.79\" cy=\"2.79\" r=\"1.79\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"14.19\" cy=\"2.79\" r=\"1.79\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"10.03\" cy=\"16.79\" r=\"1.79\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"2\" d=\"M5.79,4.57 L5.79,6.56 C5.79,9.19 10.03,10.22 10.03,13.31 C10.03,14.86 10.04,14.55 10.04,14.55 C10.04,14.37 10.04,14.86 10.04,13.31 C10.04,10.22 14.2,9.19 14.2,6.56 L14.2,4.57\"/></svg>",
        "github-alt": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5 C4.75,0.5 0.5,4.76 0.5,10.01 C0.5,15.26 4.75,19.51 10,19.51 C15.24,19.51 19.5,15.26 19.5,10.01 C19.5,4.76 15.25,0.5 10,0.5 L10,0.5 Z M12.81,17.69 C12.81,17.69 12.81,17.7 12.79,17.69 C12.47,17.75 12.35,17.59 12.35,17.36 L12.35,16.17 C12.35,15.45 12.09,14.92 11.58,14.56 C12.2,14.51 12.77,14.39 13.26,14.21 C13.87,13.98 14.36,13.69 14.74,13.29 C15.42,12.59 15.76,11.55 15.76,10.17 C15.76,9.25 15.45,8.46 14.83,7.8 C15.1,7.08 15.07,6.29 14.75,5.44 L14.51,5.42 C14.34,5.4 14.06,5.46 13.67,5.61 C13.25,5.78 12.79,6.03 12.31,6.35 C11.55,6.16 10.81,6.05 10.09,6.05 C9.36,6.05 8.61,6.15 7.88,6.35 C7.28,5.96 6.75,5.68 6.26,5.54 C6.07,5.47 5.9,5.44 5.78,5.44 L5.42,5.44 C5.06,6.29 5.04,7.08 5.32,7.8 C4.7,8.46 4.4,9.25 4.4,10.17 C4.4,11.94 4.96,13.16 6.08,13.84 C6.53,14.13 7.05,14.32 7.69,14.43 C8.03,14.5 8.32,14.54 8.55,14.55 C8.07,14.89 7.82,15.42 7.82,16.16 L7.82,17.51 C7.8,17.69 7.7,17.8 7.51,17.8 C4.21,16.74 1.82,13.65 1.82,10.01 C1.82,5.5 5.49,1.83 10,1.83 C14.5,1.83 18.17,5.5 18.17,10.01 C18.18,13.53 15.94,16.54 12.81,17.69 L12.81,17.69 Z\"/></svg>",
        "github": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,1 C5.03,1 1,5.03 1,10 C1,13.98 3.58,17.35 7.16,18.54 C7.61,18.62 7.77,18.34 7.77,18.11 C7.77,17.9 7.76,17.33 7.76,16.58 C5.26,17.12 4.73,15.37 4.73,15.37 C4.32,14.33 3.73,14.05 3.73,14.05 C2.91,13.5 3.79,13.5 3.79,13.5 C4.69,13.56 5.17,14.43 5.17,14.43 C5.97,15.8 7.28,15.41 7.79,15.18 C7.87,14.6 8.1,14.2 8.36,13.98 C6.36,13.75 4.26,12.98 4.26,9.53 C4.26,8.55 4.61,7.74 5.19,7.11 C5.1,6.88 4.79,5.97 5.28,4.73 C5.28,4.73 6.04,4.49 7.75,5.65 C8.47,5.45 9.24,5.35 10,5.35 C10.76,5.35 11.53,5.45 12.25,5.65 C13.97,4.48 14.72,4.73 14.72,4.73 C15.21,5.97 14.9,6.88 14.81,7.11 C15.39,7.74 15.73,8.54 15.73,9.53 C15.73,12.99 13.63,13.75 11.62,13.97 C11.94,14.25 12.23,14.8 12.23,15.64 C12.23,16.84 12.22,17.81 12.22,18.11 C12.22,18.35 12.38,18.63 12.84,18.54 C16.42,17.35 19,13.98 19,10 C19,5.03 14.97,1 10,1 L10,1 Z\"/></svg>",
        "gitter": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"3.5\" y=\"1\" width=\"1.531\" height=\"11.471\"/><rect x=\"7.324\" y=\"4.059\" width=\"1.529\" height=\"15.294\"/><rect x=\"11.148\" y=\"4.059\" width=\"1.527\" height=\"15.294\"/><rect x=\"14.971\" y=\"4.059\" width=\"1.529\" height=\"8.412\"/></svg>",
        "google": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.86,9.09 C18.46,12.12 17.14,16.05 13.81,17.56 C9.45,19.53 4.13,17.68 2.47,12.87 C0.68,7.68 4.22,2.42 9.5,2.03 C11.57,1.88 13.42,2.37 15.05,3.65 C15.22,3.78 15.37,3.93 15.61,4.14 C14.9,4.81 14.23,5.45 13.5,6.14 C12.27,5.08 10.84,4.72 9.28,4.98 C8.12,5.17 7.16,5.76 6.37,6.63 C4.88,8.27 4.62,10.86 5.76,12.82 C6.95,14.87 9.17,15.8 11.57,15.25 C13.27,14.87 14.76,13.33 14.89,11.75 L10.51,11.75 L10.51,9.09 L17.86,9.09 L17.86,9.09 Z\"/></svg>",
        "grid": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"2\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"2\" y=\"14\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"14\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"14\" width=\"3\" height=\"3\"/></svg>",
        "happy": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"13\" cy=\"7\" r=\"1\"/><circle cx=\"7\" cy=\"7\" r=\"1\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10\" r=\"8.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M14.6,11.4 C13.9,13.3 12.1,14.5 10,14.5 C7.9,14.5 6.1,13.3 5.4,11.4\"/></svg>",
        "hashtag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.431,8 L15.661,7 L12.911,7 L13.831,3 L12.901,3 L11.98,7 L9.29,7 L10.21,3 L9.281,3 L8.361,7 L5.23,7 L5,8 L8.13,8 L7.21,12 L4.23,12 L4,13 L6.98,13 L6.061,17 L6.991,17 L7.911,13 L10.601,13 L9.681,17 L10.611,17 L11.531,13 L14.431,13 L14.661,12 L11.76,12 L12.681,8 L15.431,8 Z M10.831,12 L8.141,12 L9.061,8 L11.75,8 L10.831,12 Z\"/></svg>",
        "heart": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" d=\"M10,4 C10,4 8.1,2 5.74,2 C3.38,2 1,3.55 1,6.73 C1,8.84 2.67,10.44 2.67,10.44 L10,18 L17.33,10.44 C17.33,10.44 19,8.84 19,6.73 C19,3.55 16.62,2 14.26,2 C11.9,2 10,4 10,4 L10,4 Z\"/></svg>",
        "history": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"#000\" points=\"1 2 2 2 2 6 6 6 6 7 1 7 1 2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M2.1,6.548 C3.391,3.29 6.746,1 10.5,1 C15.5,1 19.5,5 19.5,10 C19.5,15 15.5,19 10.5,19 C5.5,19 1.5,15 1.5,10\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.018,14.197 L9.445,10.625\"/></svg>",
        "home": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"18.65 11.35 10 2.71 1.35 11.35 0.65 10.65 10 1.29 19.35 10.65\"/><polygon points=\"15 4 18 4 18 7 17 7 17 5 15 5\"/><polygon points=\"3 11 4 11 4 18 7 18 7 12 12 12 12 18 16 18 16 11 17 11 17 19 11 19 11 13 8 13 8 19 3 19\"/></svg>",
        "image": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"16.1\" cy=\"6.1\" r=\"1.1\"/><rect fill=\"none\" stroke=\"#000\" x=\".5\" y=\"2.5\" width=\"19\" height=\"15\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"4,13 8,9 13,14\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"11,12 12.5,10.5 16,14\"/></svg>",
        "info": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.13,11.59 C11.97,12.84 10.35,14.12 9.1,14.16 C6.17,14.2 9.89,9.46 8.74,8.37 C9.3,8.16 10.62,7.83 10.62,8.81 C10.62,9.63 10.12,10.55 9.88,11.32 C8.66,15.16 12.13,11.15 12.14,11.18 C12.16,11.21 12.16,11.35 12.13,11.59 C12.08,11.95 12.16,11.35 12.13,11.59 L12.13,11.59 Z M11.56,5.67 C11.56,6.67 9.36,7.15 9.36,6.03 C9.36,5 11.56,4.54 11.56,5.67 L11.56,5.67 Z\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
        "instagram": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.55,1H6.46C3.45,1,1,3.44,1,6.44v7.12c0,3,2.45,5.44,5.46,5.44h7.08c3.02,0,5.46-2.44,5.46-5.44V6.44 C19.01,3.44,16.56,1,13.55,1z M17.5,14c0,1.93-1.57,3.5-3.5,3.5H6c-1.93,0-3.5-1.57-3.5-3.5V6c0-1.93,1.57-3.5,3.5-3.5h8 c1.93,0,3.5,1.57,3.5,3.5V14z\"/><circle cx=\"14.87\" cy=\"5.26\" r=\"1.09\"/><path d=\"M10.03,5.45c-2.55,0-4.63,2.06-4.63,4.6c0,2.55,2.07,4.61,4.63,4.61c2.56,0,4.63-2.061,4.63-4.61 C14.65,7.51,12.58,5.45,10.03,5.45L10.03,5.45L10.03,5.45z M10.08,13c-1.66,0-3-1.34-3-2.99c0-1.65,1.34-2.99,3-2.99s3,1.34,3,2.99 C13.08,11.66,11.74,13,10.08,13L10.08,13L10.08,13z\"/></svg>",
        "italic": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.63,5.48 L10.15,14.52 C10,15.08 10.37,15.25 11.92,15.3 L11.72,16 L6,16 L6.2,15.31 C7.78,15.26 8.19,15.09 8.34,14.53 L10.82,5.49 C10.97,4.92 10.63,4.76 9.09,4.71 L9.28,4 L15,4 L14.81,4.69 C13.23,4.75 12.78,4.91 12.63,5.48 L12.63,5.48 Z\"/></svg>",
        "joomla": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7.8,13.4l1.7-1.7L5.9,8c-0.6-0.5-0.6-1.5,0-2c0.6-0.6,1.4-0.6,2,0l1.7-1.7c-1-1-2.3-1.3-3.6-1C5.8,2.2,4.8,1.4,3.7,1.4 c-1.3,0-2.3,1-2.3,2.3c0,1.1,0.8,2,1.8,2.3c-0.4,1.3-0.1,2.8,1,3.8L7.8,13.4L7.8,13.4z\"/><path d=\"M10.2,4.3c1-1,2.5-1.4,3.8-1c0.2-1.1,1.1-2,2.3-2c1.3,0,2.3,1,2.3,2.3c0,1.2-0.9,2.2-2,2.3c0.4,1.3,0,2.8-1,3.8L13.9,8 c0.6-0.5,0.6-1.5,0-2c-0.5-0.6-1.5-0.6-2,0L8.2,9.7L6.5,8\"/><path d=\"M14.1,16.8c-1.3,0.4-2.8,0.1-3.8-1l1.7-1.7c0.6,0.6,1.5,0.6,2,0c0.5-0.6,0.6-1.5,0-2l-3.7-3.7L12,6.7l3.7,3.7 c1,1,1.3,2.4,1,3.6c1.1,0.2,2,1.1,2,2.3c0,1.3-1,2.3-2.3,2.3C15.2,18.6,14.3,17.8,14.1,16.8\"/><path d=\"M13.2,12.2l-3.7,3.7c-1,1-2.4,1.3-3.6,1c-0.2,1-1.2,1.8-2.2,1.8c-1.3,0-2.3-1-2.3-2.3c0-1.1,0.8-2,1.8-2.3 c-0.3-1.3,0-2.7,1-3.7l1.7,1.7c-0.6,0.6-0.6,1.5,0,2c0.6,0.6,1.4,0.6,2,0l3.7-3.7\"/></svg>",
        "laptop": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"16\" width=\"20\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"2.5\" y=\"4.5\" width=\"15\" height=\"10\"/></svg>",
        "lifesaver": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5 C4.76,0.5 0.5,4.76 0.5,10 C0.5,15.24 4.76,19.5 10,19.5 C15.24,19.5 19.5,15.24 19.5,10 C19.5,4.76 15.24,0.5 10,0.5 L10,0.5 Z M10,1.5 C11.49,1.5 12.89,1.88 14.11,2.56 L11.85,4.82 C11.27,4.61 10.65,4.5 10,4.5 C9.21,4.5 8.47,4.67 7.79,4.96 L5.58,2.75 C6.87,1.95 8.38,1.5 10,1.5 L10,1.5 Z M4.96,7.8 C4.67,8.48 4.5,9.21 4.5,10 C4.5,10.65 4.61,11.27 4.83,11.85 L2.56,14.11 C1.88,12.89 1.5,11.49 1.5,10 C1.5,8.38 1.95,6.87 2.75,5.58 L4.96,7.79 L4.96,7.8 L4.96,7.8 Z M10,18.5 C8.25,18.5 6.62,17.97 5.27,17.06 L7.46,14.87 C8.22,15.27 9.08,15.5 10,15.5 C10.79,15.5 11.53,15.33 12.21,15.04 L14.42,17.25 C13.13,18.05 11.62,18.5 10,18.5 L10,18.5 Z M10,14.5 C7.52,14.5 5.5,12.48 5.5,10 C5.5,7.52 7.52,5.5 10,5.5 C12.48,5.5 14.5,7.52 14.5,10 C14.5,12.48 12.48,14.5 10,14.5 L10,14.5 Z M15.04,12.21 C15.33,11.53 15.5,10.79 15.5,10 C15.5,9.08 15.27,8.22 14.87,7.46 L17.06,5.27 C17.97,6.62 18.5,8.25 18.5,10 C18.5,11.62 18.05,13.13 17.25,14.42 L15.04,12.21 L15.04,12.21 Z\"/></svg>",
        "link": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M10.625,12.375 L7.525,15.475 C6.825,16.175 5.925,16.175 5.225,15.475 L4.525,14.775 C3.825,14.074 3.825,13.175 4.525,12.475 L7.625,9.375\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M9.325,7.375 L12.425,4.275 C13.125,3.575 14.025,3.575 14.724,4.275 L15.425,4.975 C16.125,5.675 16.125,6.575 15.425,7.275 L12.325,10.375\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M7.925,11.875 L11.925,7.975\"/></svg>",
        "linkedin": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.77,17.89 L5.77,7.17 L2.21,7.17 L2.21,17.89 L5.77,17.89 L5.77,17.89 Z M3.99,5.71 C5.23,5.71 6.01,4.89 6.01,3.86 C5.99,2.8 5.24,2 4.02,2 C2.8,2 2,2.8 2,3.85 C2,4.88 2.77,5.7 3.97,5.7 L3.99,5.7 L3.99,5.71 L3.99,5.71 Z\"/><path d=\"M7.75,17.89 L11.31,17.89 L11.31,11.9 C11.31,11.58 11.33,11.26 11.43,11.03 C11.69,10.39 12.27,9.73 13.26,9.73 C14.55,9.73 15.06,10.71 15.06,12.15 L15.06,17.89 L18.62,17.89 L18.62,11.74 C18.62,8.45 16.86,6.92 14.52,6.92 C12.6,6.92 11.75,7.99 11.28,8.73 L11.3,8.73 L11.3,7.17 L7.75,7.17 C7.79,8.17 7.75,17.89 7.75,17.89 L7.75,17.89 L7.75,17.89 Z\"/></svg>",
        "list": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"6\" y=\"4\" width=\"12\" height=\"1\"/><rect x=\"6\" y=\"9\" width=\"12\" height=\"1\"/><rect x=\"6\" y=\"14\" width=\"12\" height=\"1\"/><rect x=\"2\" y=\"4\" width=\"2\" height=\"1\"/><rect x=\"2\" y=\"9\" width=\"2\" height=\"1\"/><rect x=\"2\" y=\"14\" width=\"2\" height=\"1\"/></svg>",
        "location": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" d=\"M10,0.5 C6.41,0.5 3.5,3.39 3.5,6.98 C3.5,11.83 10,19 10,19 C10,19 16.5,11.83 16.5,6.98 C16.5,3.39 13.59,0.5 10,0.5 L10,0.5 Z\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"6.8\" r=\"2.3\"/></svg>",
        "lock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" height=\"10\" width=\"13\" y=\"8.5\" x=\"3.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M6.5,8 L6.5,4.88 C6.5,3.01 8.07,1.5 10,1.5 C11.93,1.5 13.5,3.01 13.5,4.88 L13.5,8\"/></svg>",
        "mail": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"1.4,6.5 10,11 18.6,6.5\"/><path d=\"M 1,4 1,16 19,16 19,4 1,4 Z M 18,15 2,15 2,5 18,5 18,15 Z\"/></svg>",
        "menu": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"4\" width=\"16\" height=\"1\"/><rect x=\"2\" y=\"9\" width=\"16\" height=\"1\"/><rect x=\"2\" y=\"14\" width=\"16\" height=\"1\"/></svg>",
        "microphone": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" x1=\"10\" x2=\"10\" y1=\"16.44\" y2=\"18.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"7\" x2=\"13\" y1=\"18.5\" y2=\"18.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.5 4.89v5.87a3.5 3.5 0 0 1-7 0V4.89a3.5 3.5 0 0 1 7 0z\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M15.5 10.36V11a5.5 5.5 0 0 1-11 0v-.6\"/></svg>",
        "minus-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" x1=\"5\" y1=\"9.5\" x2=\"14\" y2=\"9.5\"/></svg>",
        "minus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect height=\"1\" width=\"18\" y=\"9\" x=\"1\"/></svg>",
        "more-vertical": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"10\" cy=\"3\" r=\"2\"/><circle cx=\"10\" cy=\"10\" r=\"2\"/><circle cx=\"10\" cy=\"17\" r=\"2\"/></svg>",
        "more": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"3\" cy=\"10\" r=\"2\"/><circle cx=\"10\" cy=\"10\" r=\"2\"/><circle cx=\"17\" cy=\"10\" r=\"2\"/></svg>",
        "move": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"4,5 1,5 1,9 2,9 2,6 4,6\"/><polygon points=\"1,16 2,16 2,18 4,18 4,19 1,19\"/><polygon points=\"14,16 14,19 11,19 11,18 13,18 13,16\"/><rect fill=\"none\" stroke=\"#000\" x=\"5.5\" y=\"1.5\" width=\"13\" height=\"13\"/><rect x=\"1\" y=\"11\" width=\"1\" height=\"3\"/><rect x=\"6\" y=\"18\" width=\"3\" height=\"1\"/></svg>",
        "nut": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"2.5,5.7 10,1.3 17.5,5.7 17.5,14.3 10,18.7 2.5,14.3\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10\" r=\"3.5\"/></svg>",
        "pagekit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"3,1 17,1 17,16 10,16 10,13 14,13 14,4 6,4 6,16 10,16 10,19 3,19\"/></svg>",
        "paint-bucket": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.21,1 L0,11.21 L8.1,19.31 L18.31,9.1 L10.21,1 L10.21,1 Z M16.89,9.1 L15,11 L1.7,11 L10.21,2.42 L16.89,9.1 Z\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.42,2.33 L11.7,7.61\"/><path d=\"M18.49,12 C18.49,12 20,14.06 20,15.36 C20,16.28 19.24,17 18.49,17 L18.49,17 C17.74,17 17,16.28 17,15.36 C17,14.06 18.49,12 18.49,12 L18.49,12 Z\"/></svg>",
        "pencil": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M17.25,6.01 L7.12,16.1 L3.82,17.2 L5.02,13.9 L15.12,3.88 C15.71,3.29 16.66,3.29 17.25,3.88 C17.83,4.47 17.83,5.42 17.25,6.01 L17.25,6.01 Z\"/><path fill=\"none\" stroke=\"#000\" d=\"M15.98,7.268 L13.851,5.148\"/></svg>",
        "phone-landscape": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M17,5.5 C17.8,5.5 18.5,6.2 18.5,7 L18.5,14 C18.5,14.8 17.8,15.5 17,15.5 L3,15.5 C2.2,15.5 1.5,14.8 1.5,14 L1.5,7 C1.5,6.2 2.2,5.5 3,5.5 L17,5.5 L17,5.5 L17,5.5 Z\"/><circle cx=\"3.8\" cy=\"10.5\" r=\".8\"/></svg>",
        "phone": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M15.5,17 C15.5,17.8 14.8,18.5 14,18.5 L7,18.5 C6.2,18.5 5.5,17.8 5.5,17 L5.5,3 C5.5,2.2 6.2,1.5 7,1.5 L14,1.5 C14.8,1.5 15.5,2.2 15.5,3 L15.5,17 L15.5,17 L15.5,17 Z\"/><circle cx=\"10.5\" cy=\"16.5\" r=\".8\"/></svg>",
        "pinterest": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.21,1 C5.5,1 3,4.16 3,7.61 C3,9.21 3.85,11.2 5.22,11.84 C5.43,11.94 5.54,11.89 5.58,11.69 C5.62,11.54 5.8,10.8 5.88,10.45 C5.91,10.34 5.89,10.24 5.8,10.14 C5.36,9.59 5,8.58 5,7.65 C5,5.24 6.82,2.91 9.93,2.91 C12.61,2.91 14.49,4.74 14.49,7.35 C14.49,10.3 13,12.35 11.06,12.35 C9.99,12.35 9.19,11.47 9.44,10.38 C9.75,9.08 10.35,7.68 10.35,6.75 C10.35,5.91 9.9,5.21 8.97,5.21 C7.87,5.21 6.99,6.34 6.99,7.86 C6.99,8.83 7.32,9.48 7.32,9.48 C7.32,9.48 6.24,14.06 6.04,14.91 C5.7,16.35 6.08,18.7 6.12,18.9 C6.14,19.01 6.26,19.05 6.33,18.95 C6.44,18.81 7.74,16.85 8.11,15.44 C8.24,14.93 8.79,12.84 8.79,12.84 C9.15,13.52 10.19,14.09 11.29,14.09 C14.58,14.09 16.96,11.06 16.96,7.3 C16.94,3.7 14,1 10.21,1\"/></svg>",
        "play-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"8.5 7 13.5 10 8.5 13\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
        "play": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"6.5,5 14.5,10 6.5,15\"/></svg>",
        "plus-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"5\" x2=\"9.5\" y2=\"14\"/><line fill=\"none\" stroke=\"#000\" x1=\"5\" y1=\"9.5\" x2=\"14\" y2=\"9.5\"/></svg>",
        "plus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"1\" width=\"1\" height=\"17\"/><rect x=\"1\" y=\"9\" width=\"17\" height=\"1\"/></svg>",
        "print": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"4.5 13.5 1.5 13.5 1.5 6.5 18.5 6.5 18.5 13.5 15.5 13.5\"/><polyline fill=\"none\" stroke=\"#000\" points=\"15.5 6.5 15.5 2.5 4.5 2.5 4.5 6.5\"/><rect fill=\"none\" stroke=\"#000\" width=\"11\" height=\"6\" x=\"4.5\" y=\"11.5\"/><rect width=\"8\" height=\"1\" x=\"6\" y=\"13\"/><rect width=\"8\" height=\"1\" x=\"6\" y=\"15\"/></svg>",
        "pull": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"6.85,8 9.5,10.6 12.15,8 12.85,8.7 9.5,12 6.15,8.7\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"11\" x2=\"9.5\" y2=\"2\"/><polyline fill=\"none\" stroke=\"#000\" points=\"6,5.5 3.5,5.5 3.5,18.5 15.5,18.5 15.5,5.5 13,5.5\"/></svg>",
        "push": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"12.15,4 9.5,1.4 6.85,4 6.15,3.3 9.5,0 12.85,3.3\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"10\" x2=\"9.5\" y2=\"1\"/><polyline fill=\"none\" stroke=\"#000\" points=\"6 5.5 3.5 5.5 3.5 18.5 15.5 18.5 15.5 5.5 13 5.5\"/></svg>",
        "question": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><circle cx=\"10.44\" cy=\"14.42\" r=\"1.05\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" d=\"M8.17,7.79 C8.17,4.75 12.72,4.73 12.72,7.72 C12.72,8.67 11.81,9.15 11.23,9.75 C10.75,10.24 10.51,10.73 10.45,11.4 C10.44,11.53 10.43,11.64 10.43,11.75\"/></svg>",
        "quote-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.27,7.79 C17.27,9.45 16.97,10.43 15.99,12.02 C14.98,13.64 13,15.23 11.56,15.97 L11.1,15.08 C12.34,14.2 13.14,13.51 14.02,11.82 C14.27,11.34 14.41,10.92 14.49,10.54 C14.3,10.58 14.09,10.6 13.88,10.6 C12.06,10.6 10.59,9.12 10.59,7.3 C10.59,5.48 12.06,4 13.88,4 C15.39,4 16.67,5.02 17.05,6.42 C17.19,6.82 17.27,7.27 17.27,7.79 L17.27,7.79 Z\"/><path d=\"M8.68,7.79 C8.68,9.45 8.38,10.43 7.4,12.02 C6.39,13.64 4.41,15.23 2.97,15.97 L2.51,15.08 C3.75,14.2 4.55,13.51 5.43,11.82 C5.68,11.34 5.82,10.92 5.9,10.54 C5.71,10.58 5.5,10.6 5.29,10.6 C3.47,10.6 2,9.12 2,7.3 C2,5.48 3.47,4 5.29,4 C6.8,4 8.08,5.02 8.46,6.42 C8.6,6.82 8.68,7.27 8.68,7.79 L8.68,7.79 Z\"/></svg>",
        "receiver": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" d=\"M6.189,13.611C8.134,15.525 11.097,18.239 13.867,18.257C16.47,18.275 18.2,16.241 18.2,16.241L14.509,12.551L11.539,13.639L6.189,8.29L7.313,5.355L3.76,1.8C3.76,1.8 1.732,3.537 1.7,6.092C1.667,8.809 4.347,11.738 6.189,13.611\"/></svg>",
        "reddit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19 9.05a2.56 2.56 0 0 0-2.56-2.56 2.59 2.59 0 0 0-1.88.82 10.63 10.63 0 0 0-4.14-1v-.08c.58-1.62 1.58-3.89 2.7-4.1.38-.08.77.12 1.19.57a1.15 1.15 0 0 0-.06.37 1.48 1.48 0 1 0 1.51-1.45 1.43 1.43 0 0 0-.76.19A2.29 2.29 0 0 0 12.91 1c-2.11.43-3.39 4.38-3.63 5.19 0 0 0 .11-.06.11a10.65 10.65 0 0 0-3.75 1A2.56 2.56 0 0 0 1 9.05a2.42 2.42 0 0 0 .72 1.76A5.18 5.18 0 0 0 1.24 13c0 3.66 3.92 6.64 8.73 6.64s8.74-3 8.74-6.64a5.23 5.23 0 0 0-.46-2.13A2.58 2.58 0 0 0 19 9.05zm-16.88 0a1.44 1.44 0 0 1 2.27-1.19 7.68 7.68 0 0 0-2.07 1.91 1.33 1.33 0 0 1-.2-.72zM10 18.4c-4.17 0-7.55-2.4-7.55-5.4S5.83 7.53 10 7.53 17.5 10 17.5 13s-3.38 5.4-7.5 5.4zm7.69-8.61a7.62 7.62 0 0 0-2.09-1.91 1.41 1.41 0 0 1 .84-.28 1.47 1.47 0 0 1 1.44 1.45 1.34 1.34 0 0 1-.21.72z\"/><path d=\"M6.69 12.58a1.39 1.39 0 1 1 1.39-1.39 1.38 1.38 0 0 1-1.38 1.39z\"/><path d=\"M14.26 11.2a1.39 1.39 0 1 1-1.39-1.39 1.39 1.39 0 0 1 1.39 1.39z\"/><path d=\"M13.09 14.88a.54.54 0 0 1-.09.77 5.3 5.3 0 0 1-3.26 1.19 5.61 5.61 0 0 1-3.4-1.22.55.55 0 1 1 .73-.83 4.09 4.09 0 0 0 5.25 0 .56.56 0 0 1 .77.09z\"/></svg>",
        "refresh": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17.08,11.15 C17.09,11.31 17.1,11.47 17.1,11.64 C17.1,15.53 13.94,18.69 10.05,18.69 C6.16,18.68 3,15.53 3,11.63 C3,7.74 6.16,4.58 10.05,4.58 C10.9,4.58 11.71,4.73 12.46,5\"/><polyline fill=\"none\" stroke=\"#000\" points=\"9.9 2 12.79 4.89 9.79 7.9\"/></svg>",
        "reply": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.7,13.11 C16.12,10.02 13.84,7.85 11.02,6.61 C10.57,6.41 9.75,6.13 9,5.91 L9,2 L1,9 L9,16 L9,12.13 C10.78,12.47 12.5,13.19 14.09,14.25 C17.13,16.28 18.56,18.54 18.56,18.54 C18.56,18.54 18.81,15.28 17.7,13.11 L17.7,13.11 Z M14.82,13.53 C13.17,12.4 11.01,11.4 8,10.92 L8,13.63 L2.55,9 L8,4.25 L8,6.8 C8.3,6.86 9.16,7.02 10.37,7.49 C13.3,8.65 15.54,10.96 16.65,13.08 C16.97,13.7 17.48,14.86 17.68,16 C16.87,15.05 15.73,14.15 14.82,13.53 L14.82,13.53 Z\"/></svg>",
        "rss": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"3.12\" cy=\"16.8\" r=\"1.85\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,8.2 C1.78,8.18 2.06,8.16 2.35,8.16 C7.57,8.16 11.81,12.37 11.81,17.57 C11.81,17.89 11.79,18.19 11.76,18.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,2.52 C1.78,2.51 2.06,2.5 2.35,2.5 C10.72,2.5 17.5,9.24 17.5,17.57 C17.5,17.89 17.49,18.19 17.47,18.5\"/></svg>",
        "search": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>",
        "server": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"3\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"7\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"16\" y=\"3\" width=\"1\" height=\"1\"/><rect x=\"16\" y=\"10\" width=\"1\" height=\"1\"/><circle fill=\"none\" stroke=\"#000\" cx=\"9.9\" cy=\"17.4\" r=\"1.4\"/><rect x=\"3\" y=\"10\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"10\" width=\"1\" height=\"2\"/><rect x=\"9.5\" y=\"14\" width=\"1\" height=\"2\"/><rect x=\"3\" y=\"17\" width=\"6\" height=\"1\"/><rect x=\"11\" y=\"17\" width=\"6\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"1.5\" width=\"17\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"8.5\" width=\"17\" height=\"5\"/></svg>",
        "settings": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><ellipse fill=\"none\" stroke=\"#000\" cx=\"6.11\" cy=\"3.55\" rx=\"2.11\" ry=\"2.15\"/><ellipse fill=\"none\" stroke=\"#000\" cx=\"6.11\" cy=\"15.55\" rx=\"2.11\" ry=\"2.15\"/><circle fill=\"none\" stroke=\"#000\" cx=\"13.15\" cy=\"9.55\" r=\"2.15\"/><rect x=\"1\" y=\"3\" width=\"3\" height=\"1\"/><rect x=\"10\" y=\"3\" width=\"8\" height=\"1\"/><rect x=\"1\" y=\"9\" width=\"8\" height=\"1\"/><rect x=\"15\" y=\"9\" width=\"3\" height=\"1\"/><rect x=\"1\" y=\"15\" width=\"3\" height=\"1\"/><rect x=\"10\" y=\"15\" width=\"8\" height=\"1\"/></svg>",
        "shrink": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"11 4 12 4 12 8 16 8 16 9 11 9\"/><polygon points=\"4 11 9 11 9 16 8 16 8 12 4 12\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M12,8 L18,2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M2,18 L8,12\"/></svg>",
        "sign-in": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"7 2 17 2 17 17 7 17 7 16 16 16 16 3 7 3\"/><polygon points=\"9.1 13.4 8.5 12.8 11.28 10 4 10 4 9 11.28 9 8.5 6.2 9.1 5.62 13 9.5\"/></svg>",
        "sign-out": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"13.1 13.4 12.5 12.8 15.28 10 8 10 8 9 15.28 9 12.5 6.2 13.1 5.62 17 9.5\"/><polygon points=\"13 2 3 2 3 17 13 17 13 16 4 16 4 3 13 3\"/></svg>",
        "social": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13.4\" y1=\"14\" x2=\"6.3\" y2=\"10.7\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13.5\" y1=\"5.5\" x2=\"6.5\" y2=\"8.8\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"15.5\" cy=\"4.6\" r=\"2.3\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"15.5\" cy=\"14.8\" r=\"2.3\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"4.5\" cy=\"9.8\" r=\"2.3\"/></svg>",
        "soundcloud": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.2,9.4c-0.4,0-0.8,0.1-1.101,0.2c-0.199-2.5-2.399-4.5-5-4.5c-0.6,0-1.2,0.1-1.7,0.3C9.2,5.5,9.1,5.6,9.1,5.6V15h8 c1.601,0,2.801-1.2,2.801-2.8C20,10.7,18.7,9.4,17.2,9.4L17.2,9.4z\"/><rect x=\"6\" y=\"6.5\" width=\"1.5\" height=\"8.5\"/><rect x=\"3\" y=\"8\" width=\"1.5\" height=\"7\"/><rect y=\"10\" width=\"1.5\" height=\"5\"/></svg>",
        "star": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"10 2 12.63 7.27 18.5 8.12 14.25 12.22 15.25 18 10 15.27 4.75 18 5.75 12.22 1.5 8.12 7.37 7.27\"/></svg>",
        "strikethrough": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6,13.02 L6.65,13.02 C7.64,15.16 8.86,16.12 10.41,16.12 C12.22,16.12 12.92,14.93 12.92,13.89 C12.92,12.55 11.99,12.03 9.74,11.23 C8.05,10.64 6.23,10.11 6.23,7.83 C6.23,5.5 8.09,4.09 10.4,4.09 C11.44,4.09 12.13,4.31 12.72,4.54 L13.33,4 L13.81,4 L13.81,7.59 L13.16,7.59 C12.55,5.88 11.52,4.89 10.07,4.89 C8.84,4.89 7.89,5.69 7.89,7.03 C7.89,8.29 8.89,8.78 10.88,9.45 C12.57,10.03 14.38,10.6 14.38,12.91 C14.38,14.75 13.27,16.93 10.18,16.93 C9.18,16.93 8.17,16.69 7.46,16.39 L6.52,17 L6,17 L6,13.02 L6,13.02 Z\"/><rect x=\"3\" y=\"10\" width=\"15\" height=\"1\"/></svg>",
        "table": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"1\" y=\"3\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"7\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"11\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"15\" width=\"18\" height=\"1\"/></svg>",
        "tablet-landscape": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M1.5,5 C1.5,4.2 2.2,3.5 3,3.5 L17,3.5 C17.8,3.5 18.5,4.2 18.5,5 L18.5,16 C18.5,16.8 17.8,17.5 17,17.5 L3,17.5 C2.2,17.5 1.5,16.8 1.5,16 L1.5,5 L1.5,5 L1.5,5 Z\"/><circle cx=\"3.7\" cy=\"10.5\" r=\".8\"/></svg>",
        "tablet": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M5,18.5 C4.2,18.5 3.5,17.8 3.5,17 L3.5,3 C3.5,2.2 4.2,1.5 5,1.5 L16,1.5 C16.8,1.5 17.5,2.2 17.5,3 L17.5,17 C17.5,17.8 16.8,18.5 16,18.5 L5,18.5 L5,18.5 L5,18.5 Z\"/><circle cx=\"10.5\" cy=\"16.3\" r=\".8\"/></svg>",
        "tag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17.5,3.71 L17.5,7.72 C17.5,7.96 17.4,8.2 17.21,8.39 L8.39,17.2 C7.99,17.6 7.33,17.6 6.93,17.2 L2.8,13.07 C2.4,12.67 2.4,12.01 2.8,11.61 L11.61,2.8 C11.81,2.6 12.08,2.5 12.34,2.5 L16.19,2.5 C16.52,2.5 16.86,2.63 17.11,2.88 C17.35,3.11 17.48,3.4 17.5,3.71 L17.5,3.71 Z\"/><circle cx=\"14\" cy=\"6\" r=\"1\"/></svg>",
        "thumbnails": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"3.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"11.5\" y=\"3.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"11.5\" y=\"11.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"11.5\" width=\"5\" height=\"5\"/></svg>",
        "tiktok": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.24,6V8.82a6.79,6.79,0,0,1-4-1.28v5.81A5.26,5.26,0,1,1,8,8.1a4.36,4.36,0,0,1,.72.05v2.9A2.57,2.57,0,0,0,7.64,11a2.4,2.4,0,1,0,2.77,2.38V2h2.86a4,4,0,0,0,1.84,3.38A4,4,0,0,0,17.24,6Z\"/></svg>",
        "trash": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"6.5 3 6.5 1.5 13.5 1.5 13.5 3\"/><polyline fill=\"none\" stroke=\"#000\" points=\"4.5 4 4.5 18.5 15.5 18.5 15.5 4\"/><rect x=\"8\" y=\"7\" width=\"1\" height=\"9\"/><rect x=\"11\" y=\"7\" width=\"1\" height=\"9\"/><rect x=\"2\" y=\"3\" width=\"16\" height=\"1\"/></svg>",
        "triangle-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"5 7 15 7 10 12\"/></svg>",
        "triangle-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"12 5 7 10 12 15\"/></svg>",
        "triangle-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"8 5 13 10 8 15\"/></svg>",
        "triangle-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"5 13 10 8 15 13\"/></svg>",
        "tripadvisor": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19.021,7.866C19.256,6.862,20,5.854,20,5.854h-3.346C14.781,4.641,12.504,4,9.98,4C7.363,4,4.999,4.651,3.135,5.876H0\tc0,0,0.738,0.987,0.976,1.988c-0.611,0.837-0.973,1.852-0.973,2.964c0,2.763,2.249,5.009,5.011,5.009\tc1.576,0,2.976-0.737,3.901-1.879l1.063,1.599l1.075-1.615c0.475,0.611,1.1,1.111,1.838,1.451c1.213,0.547,2.574,0.612,3.825,0.15\tc2.589-0.963,3.913-3.852,2.964-6.439c-0.175-0.463-0.4-0.876-0.675-1.238H19.021z M16.38,14.594\tc-1.002,0.371-2.088,0.328-3.06-0.119c-0.688-0.317-1.252-0.817-1.657-1.438c-0.164-0.25-0.313-0.52-0.417-0.811\tc-0.124-0.328-0.186-0.668-0.217-1.014c-0.063-0.689,0.037-1.396,0.339-2.043c0.448-0.971,1.251-1.71,2.25-2.079\tc2.075-0.765,4.375,0.3,5.14,2.366c0.762,2.066-0.301,4.37-2.363,5.134L16.38,14.594L16.38,14.594z M8.322,13.066\tc-0.72,1.059-1.935,1.76-3.309,1.76c-2.207,0-4.001-1.797-4.001-3.996c0-2.203,1.795-4.002,4.001-4.002\tc2.204,0,3.999,1.8,3.999,4.002c0,0.137-0.024,0.261-0.04,0.396c-0.067,0.678-0.284,1.313-0.648,1.853v-0.013H8.322z M2.472,10.775\tc0,1.367,1.112,2.479,2.476,2.479c1.363,0,2.472-1.11,2.472-2.479c0-1.359-1.11-2.468-2.472-2.468\tC3.584,8.306,2.473,9.416,2.472,10.775L2.472,10.775z M12.514,10.775c0,1.367,1.104,2.479,2.471,2.479\tc1.363,0,2.474-1.108,2.474-2.479c0-1.359-1.11-2.468-2.474-2.468c-1.364,0-2.477,1.109-2.477,2.468H12.514z M3.324,10.775\tc0-0.893,0.726-1.618,1.614-1.618c0.889,0,1.625,0.727,1.625,1.618c0,0.898-0.725,1.627-1.625,1.627\tc-0.901,0-1.625-0.729-1.625-1.627H3.324z M13.354,10.775c0-0.893,0.726-1.618,1.627-1.618c0.886,0,1.61,0.727,1.61,1.618\tc0,0.898-0.726,1.627-1.626,1.627s-1.625-0.729-1.625-1.627H13.354z M9.977,4.875c1.798,0,3.425,0.324,4.849,0.968\tc-0.535,0.015-1.061,0.108-1.586,0.3c-1.264,0.463-2.264,1.388-2.815,2.604c-0.262,0.551-0.398,1.133-0.448,1.72\tC9.79,7.905,7.677,5.873,5.076,5.82C6.501,5.208,8.153,4.875,9.94,4.875H9.977z\"/></svg>",
        "tumblr": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.885,8.598c0,0,0,3.393,0,4.996c0,0.282,0,0.66,0.094,0.942c0.377,1.509,1.131,2.545,2.545,3.11 c1.319,0.472,2.356,0.472,3.676,0c0.565-0.188,1.132-0.659,1.132-0.659l-0.849-2.263c0,0-1.036,0.378-1.603,0.283 c-0.565-0.094-1.226-0.66-1.226-1.508c0-1.603,0-4.902,0-4.902h2.828V5.771h-2.828V2H8.205c0,0-0.094,0.66-0.188,0.942 C7.828,3.791,7.262,4.733,6.603,5.394C5.848,6.147,5,6.43,5,6.43v2.168H6.885z\"/></svg>",
        "tv": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"7\" y=\"16\" width=\"6\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\".5\" y=\"3.5\" width=\"19\" height=\"11\"/></svg>",
        "twitch": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.23,1,2,4.23V15.85H5.88v3.23L9.1,15.85h2.59L17.5,10V1Zm11,8.4L13.62,12H11L8.78,14.24V12H5.88V2.29H16.21Z\"/><rect x=\"12.98\" y=\"4.55\" width=\"1.29\" height=\"3.88\"/><rect x=\"9.43\" y=\"4.55\" width=\"1.29\" height=\"3.88\"/></svg>",
        "twitter": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19,4.74 C18.339,5.029 17.626,5.229 16.881,5.32 C17.644,4.86 18.227,4.139 18.503,3.28 C17.79,3.7 17.001,4.009 16.159,4.17 C15.485,3.45 14.526,3 13.464,3 C11.423,3 9.771,4.66 9.771,6.7 C9.771,6.99 9.804,7.269 9.868,7.539 C6.795,7.38 4.076,5.919 2.254,3.679 C1.936,4.219 1.754,4.86 1.754,5.539 C1.754,6.82 2.405,7.95 3.397,8.61 C2.79,8.589 2.22,8.429 1.723,8.149 L1.723,8.189 C1.723,9.978 2.997,11.478 4.686,11.82 C4.376,11.899 4.049,11.939 3.713,11.939 C3.475,11.939 3.245,11.919 3.018,11.88 C3.49,13.349 4.852,14.419 6.469,14.449 C5.205,15.429 3.612,16.019 1.882,16.019 C1.583,16.019 1.29,16.009 1,15.969 C2.635,17.019 4.576,17.629 6.662,17.629 C13.454,17.629 17.17,12 17.17,7.129 C17.17,6.969 17.166,6.809 17.157,6.649 C17.879,6.129 18.504,5.478 19,4.74\"/></svg>",
        "uikit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"14.4,3.1 11.3,5.1 15,7.3 15,12.9 10,15.7 5,12.9 5,8.5 2,6.8 2,14.8 9.9,19.5 18,14.8 18,5.3\"/><polygon points=\"9.8,4.2 6.7,2.4 9.8,0.4 12.9,2.3\"/></svg>",
        "unlock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"8.5\" width=\"13\" height=\"10\"/><path fill=\"none\" stroke=\"#000\" d=\"M6.5,8.5 L6.5,4.9 C6.5,3 8.1,1.5 10,1.5 C11.9,1.5 13.5,3 13.5,4.9\"/></svg>",
        "upload": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"5 8 9.5 3.5 14 8\"/><rect x=\"3\" y=\"17\" width=\"13\" height=\"1\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"15\" x2=\"9.5\" y2=\"4\"/></svg>",
        "user": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.9\" cy=\"6.4\" r=\"4.4\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,19 C2.3,14.5 5.8,11.2 10,11.2 C14.2,11.2 17.7,14.6 18.5,19.2\"/></svg>",
        "users": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"7.7\" cy=\"8.6\" r=\"3.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1,18.1 C1.7,14.6 4.4,12.1 7.6,12.1 C10.9,12.1 13.7,14.8 14.3,18.3\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M11.4,4 C12.8,2.4 15.4,2.8 16.3,4.7 C17.2,6.6 15.7,8.9 13.6,8.9 C16.5,8.9 18.8,11.3 19.2,14.1\"/></svg>",
        "video-camera": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"17.5 6.9 17.5 13.1 13.5 10.4 13.5 14.5 2.5 14.5 2.5 5.5 13.5 5.5 13.5 9.6 17.5 6.9\"/></svg>",
        "vimeo": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.065,7.59C1.84,7.367,1.654,7.082,1.468,6.838c-0.332-0.42-0.137-0.411,0.274-0.772c1.026-0.91,2.004-1.896,3.127-2.688 c1.017-0.713,2.365-1.173,3.286-0.039c0.849,1.045,0.869,2.629,1.084,3.891c0.215,1.309,0.421,2.648,0.88,3.901 c0.127,0.352,0.37,1.018,0.81,1.074c0.567,0.078,1.145-0.917,1.408-1.289c0.684-0.987,1.611-2.317,1.494-3.587 c-0.115-1.349-1.572-1.095-2.482-0.773c0.146-1.514,1.555-3.216,2.912-3.792c1.439-0.597,3.579-0.587,4.302,1.036 c0.772,1.759,0.078,3.802-0.763,5.396c-0.918,1.731-2.1,3.333-3.363,4.829c-1.114,1.329-2.432,2.787-4.093,3.422 c-1.897,0.723-3.021-0.686-3.667-2.318c-0.705-1.777-1.056-3.771-1.565-5.621C4.898,8.726,4.644,7.836,4.136,7.191 C3.473,6.358,2.72,7.141,2.065,7.59C1.977,7.502,2.115,7.551,2.065,7.59L2.065,7.59z\"/></svg>",
        "warning": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"10\" cy=\"14\" r=\"1\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M10.97,7.72 C10.85,9.54 10.56,11.29 10.56,11.29 C10.51,11.87 10.27,12 9.99,12 C9.69,12 9.49,11.87 9.43,11.29 C9.43,11.29 9.16,9.54 9.03,7.72 C8.96,6.54 9.03,6 9.03,6 C9.03,5.45 9.46,5.02 9.99,5 C10.53,5.01 10.97,5.44 10.97,6 C10.97,6 11.04,6.54 10.97,7.72 L10.97,7.72 Z\"/></svg>",
        "whatsapp": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16.7,3.3c-1.8-1.8-4.1-2.8-6.7-2.8c-5.2,0-9.4,4.2-9.4,9.4c0,1.7,0.4,3.3,1.3,4.7l-1.3,4.9l5-1.3c1.4,0.8,2.9,1.2,4.5,1.2 l0,0l0,0c5.2,0,9.4-4.2,9.4-9.4C19.5,7.4,18.5,5,16.7,3.3 M10.1,17.7L10.1,17.7c-1.4,0-2.8-0.4-4-1.1l-0.3-0.2l-3,0.8l0.8-2.9 l-0.2-0.3c-0.8-1.2-1.2-2.7-1.2-4.2c0-4.3,3.5-7.8,7.8-7.8c2.1,0,4.1,0.8,5.5,2.3c1.5,1.5,2.3,3.4,2.3,5.5 C17.9,14.2,14.4,17.7,10.1,17.7 M14.4,11.9c-0.2-0.1-1.4-0.7-1.6-0.8c-0.2-0.1-0.4-0.1-0.5,0.1c-0.2,0.2-0.6,0.8-0.8,0.9 c-0.1,0.2-0.3,0.2-0.5,0.1c-0.2-0.1-1-0.4-1.9-1.2c-0.7-0.6-1.2-1.4-1.3-1.6c-0.1-0.2,0-0.4,0.1-0.5C8,8.8,8.1,8.7,8.2,8.5 c0.1-0.1,0.2-0.2,0.2-0.4c0.1-0.2,0-0.3,0-0.4C8.4,7.6,7.9,6.5,7.7,6C7.5,5.5,7.3,5.6,7.2,5.6c-0.1,0-0.3,0-0.4,0 c-0.2,0-0.4,0.1-0.6,0.3c-0.2,0.2-0.8,0.8-0.8,2c0,1.2,0.8,2.3,1,2.4c0.1,0.2,1.7,2.5,4,3.5c0.6,0.2,1,0.4,1.3,0.5 c0.6,0.2,1.1,0.2,1.5,0.1c0.5-0.1,1.4-0.6,1.6-1.1c0.2-0.5,0.2-1,0.1-1.1C14.8,12.1,14.6,12,14.4,11.9\"/></svg>",
        "wordpress": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5c-5.2,0-9.5,4.3-9.5,9.5s4.3,9.5,9.5,9.5c5.2,0,9.5-4.3,9.5-9.5S15.2,0.5,10,0.5L10,0.5L10,0.5z M15.6,3.9h-0.1 c-0.8,0-1.4,0.7-1.4,1.5c0,0.7,0.4,1.3,0.8,1.9c0.3,0.6,0.7,1.3,0.7,2.3c0,0.7-0.3,1.5-0.6,2.7L14.1,15l-3-8.9 c0.5,0,0.9-0.1,0.9-0.1C12.5,6,12.5,5.3,12,5.4c0,0-1.3,0.1-2.2,0.1C9,5.5,7.7,5.4,7.7,5.4C7.2,5.3,7.2,6,7.6,6c0,0,0.4,0.1,0.9,0.1 l1.3,3.5L8,15L5,6.1C5.5,6.1,5.9,6,5.9,6C6.4,6,6.3,5.3,5.9,5.4c0,0-1.3,0.1-2.2,0.1c-0.2,0-0.3,0-0.5,0c1.5-2.2,4-3.7,6.9-3.7 C12.2,1.7,14.1,2.6,15.6,3.9L15.6,3.9L15.6,3.9z M2.5,6.6l3.9,10.8c-2.7-1.3-4.6-4.2-4.6-7.4C1.8,8.8,2,7.6,2.5,6.6L2.5,6.6L2.5,6.6 z M10.2,10.7l2.5,6.9c0,0,0,0.1,0.1,0.1C11.9,18,11,18.2,10,18.2c-0.8,0-1.6-0.1-2.3-0.3L10.2,10.7L10.2,10.7L10.2,10.7z M14.2,17.1 l2.5-7.3c0.5-1.2,0.6-2.1,0.6-2.9c0-0.3,0-0.6-0.1-0.8c0.6,1.2,1,2.5,1,4C18.3,13,16.6,15.7,14.2,17.1L14.2,17.1L14.2,17.1z\"/></svg>",
        "world": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M1,10.5 L19,10.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M2.35,15.5 L17.65,15.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M2.35,5.5 L17.523,5.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M10,19.46 L9.98,19.46 C7.31,17.33 5.61,14.141 5.61,10.58 C5.61,7.02 7.33,3.83 10,1.7 C10.01,1.7 9.99,1.7 10,1.7 L10,1.7 C12.67,3.83 14.4,7.02 14.4,10.58 C14.4,14.141 12.67,17.33 10,19.46 L10,19.46 L10,19.46 L10,19.46 Z\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10.5\" r=\"9\"/></svg>",
        "xing": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.4,4.56 C4.24,4.56 4.11,4.61 4.05,4.72 C3.98,4.83 3.99,4.97 4.07,5.12 L5.82,8.16 L5.82,8.17 L3.06,13.04 C2.99,13.18 2.99,13.33 3.06,13.44 C3.12,13.55 3.24,13.62 3.4,13.62 L6,13.62 C6.39,13.62 6.57,13.36 6.71,13.12 C6.71,13.12 9.41,8.35 9.51,8.16 C9.49,8.14 7.72,5.04 7.72,5.04 C7.58,4.81 7.39,4.56 6.99,4.56 L4.4,4.56 L4.4,4.56 Z\"/><path d=\"M15.3,1 C14.91,1 14.74,1.25 14.6,1.5 C14.6,1.5 9.01,11.42 8.82,11.74 C8.83,11.76 12.51,18.51 12.51,18.51 C12.64,18.74 12.84,19 13.23,19 L15.82,19 C15.98,19 16.1,18.94 16.16,18.83 C16.23,18.72 16.23,18.57 16.16,18.43 L12.5,11.74 L12.5,11.72 L18.25,1.56 C18.32,1.42 18.32,1.27 18.25,1.16 C18.21,1.06 18.08,1 17.93,1 L15.3,1 L15.3,1 Z\"/></svg>",
        "yelp": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.175,14.971c-0.112,0.77-1.686,2.767-2.406,3.054c-0.246,0.1-0.487,0.076-0.675-0.069\tc-0.122-0.096-2.446-3.859-2.446-3.859c-0.194-0.293-0.157-0.682,0.083-0.978c0.234-0.284,0.581-0.393,0.881-0.276\tc0.016,0.01,4.21,1.394,4.332,1.482c0.178,0.148,0.263,0.379,0.225,0.646L17.175,14.971L17.175,14.971z M11.464,10.789\tc-0.203-0.307-0.199-0.666,0.009-0.916c0,0,2.625-3.574,2.745-3.657c0.203-0.135,0.452-0.141,0.69-0.025\tc0.691,0.335,2.085,2.405,2.167,3.199v0.027c0.024,0.271-0.082,0.491-0.273,0.623c-0.132,0.083-4.43,1.155-4.43,1.155\tc-0.322,0.096-0.68-0.06-0.882-0.381L11.464,10.789z M9.475,9.563C9.32,9.609,8.848,9.757,8.269,8.817c0,0-3.916-6.16-4.007-6.351\tc-0.057-0.212,0.011-0.455,0.202-0.65C5.047,1.211,8.21,0.327,9.037,0.529c0.27,0.069,0.457,0.238,0.522,0.479\tc0.047,0.266,0.433,5.982,0.488,7.264C10.098,9.368,9.629,9.517,9.475,9.563z M9.927,19.066c-0.083,0.225-0.273,0.373-0.54,0.421\tc-0.762,0.13-3.15-0.751-3.647-1.342c-0.096-0.131-0.155-0.262-0.167-0.394c-0.011-0.095,0-0.189,0.036-0.272\tc0.061-0.155,2.917-3.538,2.917-3.538c0.214-0.272,0.595-0.355,0.952-0.213c0.345,0.13,0.56,0.428,0.536,0.749\tC10.014,14.479,9.977,18.923,9.927,19.066z M3.495,13.912c-0.235-0.009-0.444-0.148-0.568-0.382c-0.089-0.17-0.151-0.453-0.19-0.794\tC2.63,11.701,2.761,10.144,3.07,9.648c0.145-0.226,0.357-0.345,0.592-0.336c0.154,0,4.255,1.667,4.255,1.667\tc0.321,0.118,0.521,0.453,0.5,0.833c-0.023,0.37-0.236,0.655-0.551,0.738L3.495,13.912z\"/></svg>",
        "youtube": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15,4.1c1,0.1,2.3,0,3,0.8c0.8,0.8,0.9,2.1,0.9,3.1C19,9.2,19,10.9,19,12c-0.1,1.1,0,2.4-0.5,3.4c-0.5,1.1-1.4,1.5-2.5,1.6 c-1.2,0.1-8.6,0.1-11,0c-1.1-0.1-2.4-0.1-3.2-1c-0.7-0.8-0.7-2-0.8-3C1,11.8,1,10.1,1,8.9c0-1.1,0-2.4,0.5-3.4C2,4.5,3,4.3,4.1,4.2 C5.3,4.1,12.6,4,15,4.1z M8,7.5v6l5.5-3L8,7.5z\"/></svg>" });

    }

    if (typeof window !== 'undefined' && window.UIkit) {
      window.UIkit.use(plugin);
    }

    return plugin;

}));

},{}],10:[function(require,module,exports){
/*! UIkit 3.13.9 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define('uikit', factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.UIkit = factory());
})(this, (function () { 'use strict';

    const { hasOwnProperty, toString } = Object.prototype;

    function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
    }

    const hyphenateRe = /\B([A-Z])/g;

    const hyphenate = memoize((str) => str.replace(hyphenateRe, '-$1').toLowerCase());

    const camelizeRe = /-(\w)/g;

    const camelize = memoize((str) => str.replace(camelizeRe, toUpper));

    const ucfirst = memoize((str) =>
    str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '');


    function toUpper(_, c) {
      return c ? c.toUpperCase() : '';
    }

    function startsWith(str, search) {
      return str == null ? void 0 : str.startsWith == null ? void 0 : str.startsWith(search);
    }

    function endsWith(str, search) {
      return str == null ? void 0 : str.endsWith == null ? void 0 : str.endsWith(search);
    }

    function includes(obj, search) {
      return obj == null ? void 0 : obj.includes == null ? void 0 : obj.includes(search);
    }

    function findIndex(array, predicate) {
      return array == null ? void 0 : array.findIndex == null ? void 0 : array.findIndex(predicate);
    }

    const { isArray, from: toArray } = Array;
    const { assign } = Object;

    function isFunction(obj) {
      return typeof obj === 'function';
    }

    function isObject(obj) {
      return obj !== null && typeof obj === 'object';
    }

    function isPlainObject(obj) {
      return toString.call(obj) === '[object Object]';
    }

    function isWindow(obj) {
      return isObject(obj) && obj === obj.window;
    }

    function isDocument(obj) {
      return nodeType(obj) === 9;
    }

    function isNode(obj) {
      return nodeType(obj) >= 1;
    }

    function isElement(obj) {
      return nodeType(obj) === 1;
    }

    function nodeType(obj) {
      return !isWindow(obj) && isObject(obj) && obj.nodeType;
    }

    function isBoolean(value) {
      return typeof value === 'boolean';
    }

    function isString(value) {
      return typeof value === 'string';
    }

    function isNumber(value) {
      return typeof value === 'number';
    }

    function isNumeric(value) {
      return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));
    }

    function isEmpty(obj) {
      return !(isArray(obj) ? obj.length : isObject(obj) ? Object.keys(obj).length : false);
    }

    function isUndefined(value) {
      return value === void 0;
    }

    function toBoolean(value) {
      return isBoolean(value) ?
      value :
      value === 'true' || value === '1' || value === '' ?
      true :
      value === 'false' || value === '0' ?
      false :
      value;
    }

    function toNumber(value) {
      const number = Number(value);
      return isNaN(number) ? false : number;
    }

    function toFloat(value) {
      return parseFloat(value) || 0;
    }

    function toNode(element) {
      return toNodes(element)[0];
    }

    function toNodes(element) {
      return element && (isNode(element) ? [element] : Array.from(element).filter(isNode)) || [];
    }

    function toWindow(element) {var _element;
      if (isWindow(element)) {
        return element;
      }

      element = toNode(element);
      const document = isDocument(element) ? element : (_element = element) == null ? void 0 : _element.ownerDocument;

      return (document == null ? void 0 : document.defaultView) || window;
    }

    function toMs(time) {
      return time ? endsWith(time, 'ms') ? toFloat(time) : toFloat(time) * 1000 : 0;
    }

    function isEqual(value, other) {
      return (
        value === other ||
        isObject(value) &&
        isObject(other) &&
        Object.keys(value).length === Object.keys(other).length &&
        each(value, (val, key) => val === other[key]));

    }

    function swap(value, a, b) {
      return value.replace(new RegExp(a + "|" + b, 'g'), (match) => match === a ? b : a);
    }

    function last(array) {
      return array[array.length - 1];
    }

    function each(obj, cb) {
      for (const key in obj) {
        if (false === cb(obj[key], key)) {
          return false;
        }
      }
      return true;
    }

    function sortBy$1(array, prop) {
      return array.
      slice().
      sort((_ref, _ref2) => {let { [prop]: propA = 0 } = _ref;let { [prop]: propB = 0 } = _ref2;return (
          propA > propB ? 1 : propB > propA ? -1 : 0);});

    }

    function uniqueBy(array, prop) {
      const seen = new Set();
      return array.filter((_ref3) => {let { [prop]: check } = _ref3;return seen.has(check) ? false : seen.add(check);});
    }

    function clamp(number, min, max) {if (min === void 0) {min = 0;}if (max === void 0) {max = 1;}
      return Math.min(Math.max(toNumber(number) || 0, min), max);
    }

    function noop() {}

    function intersectRect() {for (var _len = arguments.length, rects = new Array(_len), _key = 0; _key < _len; _key++) {rects[_key] = arguments[_key];}
      return [
      ['bottom', 'top'],
      ['right', 'left']].
      every(
      (_ref4) => {let [minProp, maxProp] = _ref4;return (
          Math.min(...rects.map((_ref5) => {let { [minProp]: min } = _ref5;return min;})) -
          Math.max(...rects.map((_ref6) => {let { [maxProp]: max } = _ref6;return max;})) >
          0);});

    }

    function pointInRect(point, rect) {
      return (
        point.x <= rect.right &&
        point.x >= rect.left &&
        point.y <= rect.bottom &&
        point.y >= rect.top);

    }

    const Dimensions = {
      ratio(dimensions, prop, value) {
        const aProp = prop === 'width' ? 'height' : 'width';

        return {
          [aProp]: dimensions[prop] ?
          Math.round(value * dimensions[aProp] / dimensions[prop]) :
          dimensions[aProp],
          [prop]: value };

      },

      contain(dimensions, maxDimensions) {
        dimensions = { ...dimensions };

        each(
        dimensions,
        (_, prop) =>
        dimensions =
        dimensions[prop] > maxDimensions[prop] ?
        this.ratio(dimensions, prop, maxDimensions[prop]) :
        dimensions);


        return dimensions;
      },

      cover(dimensions, maxDimensions) {
        dimensions = this.contain(dimensions, maxDimensions);

        each(
        dimensions,
        (_, prop) =>
        dimensions =
        dimensions[prop] < maxDimensions[prop] ?
        this.ratio(dimensions, prop, maxDimensions[prop]) :
        dimensions);


        return dimensions;
      } };


    function getIndex(i, elements, current, finite) {if (current === void 0) {current = 0;}if (finite === void 0) {finite = false;}
      elements = toNodes(elements);

      const { length } = elements;

      if (!length) {
        return -1;
      }

      i = isNumeric(i) ?
      toNumber(i) :
      i === 'next' ?
      current + 1 :
      i === 'previous' ?
      current - 1 :
      elements.indexOf(toNode(i));

      if (finite) {
        return clamp(i, 0, length - 1);
      }

      i %= length;

      return i < 0 ? i + length : i;
    }

    function memoize(fn) {
      const cache = Object.create(null);
      return (key) => cache[key] || (cache[key] = fn(key));
    }

    class Deferred {
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this.reject = reject;
          this.resolve = resolve;
        });
      }}

    function attr(element, name, value) {
      if (isObject(name)) {
        for (const key in name) {
          attr(element, key, name[key]);
        }
        return;
      }

      if (isUndefined(value)) {var _toNode;
        return (_toNode = toNode(element)) == null ? void 0 : _toNode.getAttribute(name);
      } else {
        for (const el of toNodes(element)) {
          if (isFunction(value)) {
            value = value.call(el, attr(el, name));
          }

          if (value === null) {
            removeAttr(el, name);
          } else {
            el.setAttribute(name, value);
          }
        }
      }
    }

    function hasAttr(element, name) {
      return toNodes(element).some((element) => element.hasAttribute(name));
    }

    function removeAttr(element, name) {
      const elements = toNodes(element);
      for (const attribute of name.split(' ')) {
        for (const element of elements) {
          element.removeAttribute(attribute);
        }
      }
    }

    function data(element, attribute) {
      for (const name of [attribute, "data-" + attribute]) {
        if (hasAttr(element, name)) {
          return attr(element, name);
        }
      }
    }

    const voidElements = {
      area: true,
      base: true,
      br: true,
      col: true,
      embed: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      menuitem: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true };

    function isVoidElement(element) {
      return toNodes(element).some((element) => voidElements[element.tagName.toLowerCase()]);
    }

    function isVisible(element) {
      return toNodes(element).some(
      (element) => element.offsetWidth || element.offsetHeight || element.getClientRects().length);

    }

    const selInput = 'input,select,textarea,button';
    function isInput(element) {
      return toNodes(element).some((element) => matches(element, selInput));
    }

    const selFocusable = selInput + ",a[href],[tabindex]";
    function isFocusable(element) {
      return matches(element, selFocusable);
    }

    function parent(element) {var _toNode;
      return (_toNode = toNode(element)) == null ? void 0 : _toNode.parentElement;
    }

    function filter$1(element, selector) {
      return toNodes(element).filter((element) => matches(element, selector));
    }

    function matches(element, selector) {
      return toNodes(element).some((element) => element.matches(selector));
    }

    function closest(element, selector) {
      if (startsWith(selector, '>')) {
        selector = selector.slice(1);
      }

      return isElement(element) ?
      element.closest(selector) :
      toNodes(element).
      map((element) => closest(element, selector)).
      filter(Boolean);
    }

    function within(element, selector) {
      return isString(selector) ?
      matches(element, selector) || !!closest(element, selector) :
      element === selector || toNode(selector).contains(toNode(element));
    }

    function parents(element, selector) {
      const elements = [];

      while (element = parent(element)) {
        if (!selector || matches(element, selector)) {
          elements.push(element);
        }
      }

      return elements;
    }

    function children(element, selector) {
      element = toNode(element);
      const children = element ? toNodes(element.children) : [];
      return selector ? filter$1(children, selector) : children;
    }

    function index(element, ref) {
      return ref ? toNodes(element).indexOf(toNode(ref)) : children(parent(element)).indexOf(element);
    }

    function query(selector, context) {
      return find(selector, getContext(selector, context));
    }

    function queryAll(selector, context) {
      return findAll(selector, getContext(selector, context));
    }

    function find(selector, context) {
      return toNode(_query(selector, context, 'querySelector'));
    }

    function findAll(selector, context) {
      return toNodes(_query(selector, context, 'querySelectorAll'));
    }

    const contextSelectorRe = /(^|[^\\],)\s*[!>+~-]/;
    const isContextSelector = memoize((selector) => selector.match(contextSelectorRe));

    function getContext(selector, context) {if (context === void 0) {context = document;}
      return isString(selector) && isContextSelector(selector) || isDocument(context) ?
      context :
      context.ownerDocument;
    }

    const contextSanitizeRe = /([!>+~-])(?=\s+[!>+~-]|\s*$)/g;
    const sanatize = memoize((selector) => selector.replace(contextSanitizeRe, '$1 *'));

    function _query(selector, context, queryFn) {if (context === void 0) {context = document;}
      if (!selector || !isString(selector)) {
        return selector;
      }

      selector = sanatize(selector);

      if (isContextSelector(selector)) {
        const split = splitSelector(selector);
        selector = '';
        for (let sel of split) {
          let ctx = context;

          if (sel[0] === '!') {
            const selectors = sel.substr(1).trim().split(' ');
            ctx = closest(parent(context), selectors[0]);
            sel = selectors.slice(1).join(' ').trim();
            if (!sel.length && split.length === 1) {
              return ctx;
            }
          }

          if (sel[0] === '-') {
            const selectors = sel.substr(1).trim().split(' ');
            const prev = (ctx || context).previousElementSibling;
            ctx = matches(prev, sel.substr(1)) ? prev : null;
            sel = selectors.slice(1).join(' ');
          }

          if (ctx) {
            selector += "" + (selector ? ',' : '') + domPath(ctx) + " " + sel;
          }
        }

        context = document;
      }

      try {
        return context[queryFn](selector);
      } catch (e) {
        return null;
      }
    }

    const selectorRe = /.*?[^\\](?:,|$)/g;

    const splitSelector = memoize((selector) =>
    selector.match(selectorRe).map((selector) => selector.replace(/,$/, '').trim()));


    function domPath(element) {
      const names = [];
      while (element.parentNode) {
        const id = attr(element, 'id');
        if (id) {
          names.unshift("#" + escape(id));
          break;
        } else {
          let { tagName } = element;
          if (tagName !== 'HTML') {
            tagName += ":nth-child(" + (index(element) + 1) + ")";
          }
          names.unshift(tagName);
          element = element.parentNode;
        }
      }
      return names.join(' > ');
    }

    function escape(css) {
      return isString(css) ? CSS.escape(css) : '';
    }

    function on() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
      let [targets, types, selector, listener, useCapture = false] = getArgs(args);

      if (listener.length > 1) {
        listener = detail(listener);
      }

      if (useCapture != null && useCapture.self) {
        listener = selfFilter(listener);
      }

      if (selector) {
        listener = delegate(selector, listener);
      }

      for (const type of types) {
        for (const target of targets) {
          target.addEventListener(type, listener, useCapture);
        }
      }

      return () => off(targets, types, listener, useCapture);
    }

    function off() {for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}
      let [targets, types,, listener, useCapture = false] = getArgs(args);
      for (const type of types) {
        for (const target of targets) {
          target.removeEventListener(type, listener, useCapture);
        }
      }
    }

    function once() {for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {args[_key3] = arguments[_key3];}
      const [element, types, selector, listener, useCapture = false, condition] = getArgs(args);
      const off = on(
      element,
      types,
      selector,
      (e) => {
        const result = !condition || condition(e);
        if (result) {
          off();
          listener(e, result);
        }
      },
      useCapture);


      return off;
    }

    function trigger(targets, event, detail) {
      return toEventTargets(targets).every((target) =>
      target.dispatchEvent(createEvent(event, true, true, detail)));

    }

    function createEvent(e, bubbles, cancelable, detail) {if (bubbles === void 0) {bubbles = true;}if (cancelable === void 0) {cancelable = false;}
      if (isString(e)) {
        e = new CustomEvent(e, { bubbles, cancelable, detail });
      }

      return e;
    }

    function getArgs(args) {
      // Event targets
      args[0] = toEventTargets(args[0]);

      // Event types
      if (isString(args[1])) {
        args[1] = args[1].split(' ');
      }

      // Delegate?
      if (isFunction(args[2])) {
        args.splice(2, 0, false);
      }

      return args;
    }

    function delegate(selector, listener) {
      return (e) => {
        const current =
        selector[0] === '>' ?
        findAll(selector, e.currentTarget).
        reverse().
        filter((element) => within(e.target, element))[0] :
        closest(e.target, selector);

        if (current) {
          e.current = current;
          listener.call(this, e);
        }
      };
    }

    function detail(listener) {
      return (e) => isArray(e.detail) ? listener(e, ...e.detail) : listener(e);
    }

    function selfFilter(listener) {
      return function (e) {
        if (e.target === e.currentTarget || e.target === e.current) {
          return listener.call(null, e);
        }
      };
    }

    function isEventTarget(target) {
      return target && 'addEventListener' in target;
    }

    function toEventTarget(target) {
      return isEventTarget(target) ? target : toNode(target);
    }

    function toEventTargets(target) {
      return isArray(target) ?
      target.map(toEventTarget).filter(Boolean) :
      isString(target) ?
      findAll(target) :
      isEventTarget(target) ?
      [target] :
      toNodes(target);
    }

    function isTouch(e) {
      return e.pointerType === 'touch' || !!e.touches;
    }

    function getEventPos(e) {var _e$touches, _e$changedTouches;
      const { clientX: x, clientY: y } = ((_e$touches = e.touches) == null ? void 0 : _e$touches[0]) || ((_e$changedTouches = e.changedTouches) == null ? void 0 : _e$changedTouches[0]) || e;

      return { x, y };
    }

    function ajax(url, options) {
      const env = {
        data: null,
        method: 'GET',
        headers: {},
        xhr: new XMLHttpRequest(),
        beforeSend: noop,
        responseType: '',
        ...options };

      return Promise.resolve().
      then(() => env.beforeSend(env)).
      then(() => send(url, env));
    }

    function send(url, env) {
      return new Promise((resolve, reject) => {
        const { xhr } = env;

        for (const prop in env) {
          if (prop in xhr) {
            try {
              xhr[prop] = env[prop];
            } catch (e) {
              // noop
            }
          }
        }

        xhr.open(env.method.toUpperCase(), url);

        for (const header in env.headers) {
          xhr.setRequestHeader(header, env.headers[header]);
        }

        on(xhr, 'load', () => {
          if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
            resolve(xhr);
          } else {
            reject(
            assign(Error(xhr.statusText), {
              xhr,
              status: xhr.status }));


          }
        });

        on(xhr, 'error', () => reject(assign(Error('Network Error'), { xhr })));
        on(xhr, 'timeout', () => reject(assign(Error('Network Timeout'), { xhr })));

        xhr.send(env.data);
      });
    }

    function getImage(src, srcset, sizes) {
      return new Promise((resolve, reject) => {
        const img = new Image();

        img.onerror = (e) => {
          reject(e);
        };
        img.onload = () => {
          resolve(img);
        };

        sizes && (img.sizes = sizes);
        srcset && (img.srcset = srcset);
        img.src = src;
      });
    }

    const cssNumber = {
      'animation-iteration-count': true,
      'column-count': true,
      'fill-opacity': true,
      'flex-grow': true,
      'flex-shrink': true,
      'font-weight': true,
      'line-height': true,
      opacity: true,
      order: true,
      orphans: true,
      'stroke-dasharray': true,
      'stroke-dashoffset': true,
      widows: true,
      'z-index': true,
      zoom: true };


    function css(element, property, value, priority) {if (priority === void 0) {priority = '';}
      const elements = toNodes(element);
      for (const element of elements) {
        if (isString(property)) {
          property = propName(property);

          if (isUndefined(value)) {
            return getComputedStyle(element).getPropertyValue(property);
          } else {
            element.style.setProperty(
            property,
            isNumeric(value) && !cssNumber[property] ?
            value + "px" :
            value || isNumber(value) ?
            value :
            '',
            priority);

          }
        } else if (isArray(property)) {
          const props = {};
          for (const prop of property) {
            props[prop] = css(element, prop);
          }
          return props;
        } else if (isObject(property)) {
          priority = value;
          each(property, (value, property) => css(element, property, value, priority));
        }
      }
      return elements[0];
    }

    const propertyRe = /^\s*(["'])?(.*?)\1\s*$/;
    function getCssVar(name, element) {if (element === void 0) {element = document.documentElement;}
      return css(element, "--uk-" + name).replace(propertyRe, '$2');
    }

    // https://drafts.csswg.org/cssom/#dom-cssstyledeclaration-setproperty
    const propName = memoize((name) => vendorPropName(name));

    const cssPrefixes = ['webkit', 'moz'];

    function vendorPropName(name) {
      if (name[0] === '-') {
        return name;
      }

      name = hyphenate(name);

      const { style } = document.documentElement;

      if (name in style) {
        return name;
      }

      let i = cssPrefixes.length,
      prefixedName;

      while (i--) {
        prefixedName = "-" + cssPrefixes[i] + "-" + name;
        if (prefixedName in style) {
          return prefixedName;
        }
      }
    }

    function addClass(element) {for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {args[_key - 1] = arguments[_key];}
      apply$1(element, args, 'add');
    }

    function removeClass(element) {for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {args[_key2 - 1] = arguments[_key2];}
      apply$1(element, args, 'remove');
    }

    function removeClasses(element, cls) {
      attr(element, 'class', (value) => (value || '').replace(new RegExp("\\b" + cls + "\\b", 'g'), ''));
    }

    function replaceClass(element) {
      (arguments.length <= 1 ? undefined : arguments[1]) && removeClass(element, arguments.length <= 1 ? undefined : arguments[1]);
      (arguments.length <= 2 ? undefined : arguments[2]) && addClass(element, arguments.length <= 2 ? undefined : arguments[2]);
    }

    function hasClass(element, cls) {
      [cls] = getClasses(cls);
      return !!cls && toNodes(element).some((node) => node.classList.contains(cls));
    }

    function toggleClass(element, cls, force) {
      const classes = getClasses(cls);

      if (!isUndefined(force)) {
        force = !!force;
      }

      for (const node of toNodes(element)) {
        for (const cls of classes) {
          node.classList.toggle(cls, force);
        }
      }
    }

    function apply$1(element, args, fn) {
      args = args.reduce((args, arg) => args.concat(getClasses(arg)), []);

      for (const node of toNodes(element)) {
        node.classList[fn](...args);
      }
    }

    function getClasses(str) {
      return String(str).split(/\s|,/).filter(Boolean);
    }

    function transition(element, props, duration, timing) {if (duration === void 0) {duration = 400;}if (timing === void 0) {timing = 'linear';}
      return Promise.all(
      toNodes(element).map(
      (element) =>
      new Promise((resolve, reject) => {
        for (const name in props) {
          const value = css(element, name);
          if (value === '') {
            css(element, name, value);
          }
        }

        const timer = setTimeout(() => trigger(element, 'transitionend'), duration);

        once(
        element,
        'transitionend transitioncanceled',
        (_ref) => {let { type } = _ref;
          clearTimeout(timer);
          removeClass(element, 'uk-transition');
          css(element, {
            transitionProperty: '',
            transitionDuration: '',
            transitionTimingFunction: '' });

          type === 'transitioncanceled' ? reject() : resolve(element);
        },
        { self: true });


        addClass(element, 'uk-transition');
        css(element, {
          transitionProperty: Object.keys(props).map(propName).join(','),
          transitionDuration: duration + "ms",
          transitionTimingFunction: timing,
          ...props });

      })));


    }

    const Transition = {
      start: transition,

      stop(element) {
        trigger(element, 'transitionend');
        return Promise.resolve();
      },

      cancel(element) {
        trigger(element, 'transitioncanceled');
      },

      inProgress(element) {
        return hasClass(element, 'uk-transition');
      } };


    const animationPrefix = 'uk-animation-';

    function animate$1(element, animation, duration, origin, out) {if (duration === void 0) {duration = 200;}
      return Promise.all(
      toNodes(element).map(
      (element) =>
      new Promise((resolve, reject) => {
        trigger(element, 'animationcanceled');
        const timer = setTimeout(() => trigger(element, 'animationend'), duration);

        once(
        element,
        'animationend animationcanceled',
        (_ref2) => {let { type } = _ref2;
          clearTimeout(timer);

          type === 'animationcanceled' ? reject() : resolve(element);

          css(element, 'animationDuration', '');
          removeClasses(element, animationPrefix + "\\S*");
        },
        { self: true });


        css(element, 'animationDuration', duration + "ms");
        addClass(element, animation, animationPrefix + (out ? 'leave' : 'enter'));

        if (startsWith(animation, animationPrefix)) {
          origin && addClass(element, "uk-transform-origin-" + origin);
          out && addClass(element, animationPrefix + "reverse");
        }
      })));


    }

    const inProgress = new RegExp(animationPrefix + "(enter|leave)");
    const Animation = {
      in: animate$1,

      out(element, animation, duration, origin) {
        return animate$1(element, animation, duration, origin, true);
      },

      inProgress(element) {
        return inProgress.test(attr(element, 'class'));
      },

      cancel(element) {
        trigger(element, 'animationcanceled');
      } };

    const dirs$1 = {
      width: ['left', 'right'],
      height: ['top', 'bottom'] };


    function dimensions$1(element) {
      const rect = isElement(element) ?
      toNode(element).getBoundingClientRect() :
      { height: height(element), width: width(element), top: 0, left: 0 };

      return {
        height: rect.height,
        width: rect.width,
        top: rect.top,
        left: rect.left,
        bottom: rect.top + rect.height,
        right: rect.left + rect.width };

    }

    function offset(element, coordinates) {
      const currentOffset = dimensions$1(element);

      if (element) {
        const { scrollY, scrollX } = toWindow(element);
        const offsetBy = { height: scrollY, width: scrollX };

        for (const dir in dirs$1) {
          for (const prop of dirs$1[dir]) {
            currentOffset[prop] += offsetBy[dir];
          }
        }
      }

      if (!coordinates) {
        return currentOffset;
      }

      const pos = css(element, 'position');

      each(css(element, ['left', 'top']), (value, prop) =>
      css(
      element,
      prop,
      coordinates[prop] -
      currentOffset[prop] +
      toFloat(pos === 'absolute' && value === 'auto' ? position(element)[prop] : value)));


    }

    function position(element) {
      let { top, left } = offset(element);

      const {
        ownerDocument: { body, documentElement },
        offsetParent } =
      toNode(element);
      let parent = offsetParent || documentElement;

      while (
      parent && (
      parent === body || parent === documentElement) &&
      css(parent, 'position') === 'static')
      {
        parent = parent.parentNode;
      }

      if (isElement(parent)) {
        const parentOffset = offset(parent);
        top -= parentOffset.top + toFloat(css(parent, 'borderTopWidth'));
        left -= parentOffset.left + toFloat(css(parent, 'borderLeftWidth'));
      }

      return {
        top: top - toFloat(css(element, 'marginTop')),
        left: left - toFloat(css(element, 'marginLeft')) };

    }

    function offsetPosition(element) {
      const offset = [0, 0];

      element = toNode(element);

      do {
        offset[0] += element.offsetTop;
        offset[1] += element.offsetLeft;

        if (css(element, 'position') === 'fixed') {
          const win = toWindow(element);
          offset[0] += win.scrollY;
          offset[1] += win.scrollX;
          return offset;
        }
      } while (element = element.offsetParent);

      return offset;
    }

    const height = dimension('height');
    const width = dimension('width');

    function dimension(prop) {
      const propName = ucfirst(prop);
      return (element, value) => {
        if (isUndefined(value)) {
          if (isWindow(element)) {
            return element["inner" + propName];
          }

          if (isDocument(element)) {
            const doc = element.documentElement;
            return Math.max(doc["offset" + propName], doc["scroll" + propName]);
          }

          element = toNode(element);

          value = css(element, prop);
          value = value === 'auto' ? element["offset" + propName] : toFloat(value) || 0;

          return value - boxModelAdjust(element, prop);
        } else {
          return css(
          element,
          prop,
          !value && value !== 0 ? '' : +value + boxModelAdjust(element, prop) + 'px');

        }
      };
    }

    function boxModelAdjust(element, prop, sizing) {if (sizing === void 0) {sizing = 'border-box';}
      return css(element, 'boxSizing') === sizing ?
      dirs$1[prop].
      map(ucfirst).
      reduce(
      (value, prop) =>
      value +
      toFloat(css(element, "padding" + prop)) +
      toFloat(css(element, "border" + prop + "Width")),
      0) :

      0;
    }

    function flipPosition(pos) {
      for (const dir in dirs$1) {
        for (const i in dirs$1[dir]) {
          if (dirs$1[dir][i] === pos) {
            return dirs$1[dir][1 - i];
          }
        }
      }
      return pos;
    }

    function toPx(value, property, element, offsetDim) {if (property === void 0) {property = 'width';}if (element === void 0) {element = window;}if (offsetDim === void 0) {offsetDim = false;}
      if (!isString(value)) {
        return toFloat(value);
      }

      return parseCalc(value).reduce((result, value) => {
        const unit = parseUnit(value);
        if (unit) {
          value = percent(
          unit === 'vh' ?
          height(toWindow(element)) :
          unit === 'vw' ?
          width(toWindow(element)) :
          offsetDim ?
          element["offset" + ucfirst(property)] :
          dimensions$1(element)[property],
          value);

        }

        return result + toFloat(value);
      }, 0);
    }

    const calcRe = /-?\d+(?:\.\d+)?(?:v[wh]|%|px)?/g;
    const parseCalc = memoize((calc) => calc.toString().replace(/\s/g, '').match(calcRe) || []);
    const unitRe$1 = /(?:v[hw]|%)$/;
    const parseUnit = memoize((str) => (str.match(unitRe$1) || [])[0]);

    function percent(base, value) {
      return base * toFloat(value) / 100;
    }

    function ready(fn) {
      if (document.readyState !== 'loading') {
        fn();
        return;
      }

      once(document, 'DOMContentLoaded', fn);
    }

    function isTag(element, tagName) {var _element$tagName;
      return (element == null ? void 0 : (_element$tagName = element.tagName) == null ? void 0 : _element$tagName.toLowerCase()) === tagName.toLowerCase();
    }

    function empty(element) {
      return replaceChildren(element, '');
    }

    function html(parent, html) {
      return isUndefined(html) ? $(parent).innerHTML : replaceChildren(parent, html);
    }

    const replaceChildren = applyFn('replaceChildren');
    const prepend = applyFn('prepend');
    const append = applyFn('append');
    const before = applyFn('before');
    const after = applyFn('after');

    function applyFn(fn) {
      return function (ref, element) {var _$;
        const nodes = toNodes(isString(element) ? fragment(element) : element);
        (_$ = $(ref)) == null ? void 0 : _$[fn](...nodes);
        return unwrapSingle(nodes);
      };
    }

    function remove$1(element) {
      toNodes(element).forEach((element) => element.remove());
    }

    function wrapAll(element, structure) {
      structure = toNode(before(element, structure));

      while (structure.firstChild) {
        structure = structure.firstChild;
      }

      append(structure, element);

      return structure;
    }

    function wrapInner(element, structure) {
      return toNodes(
      toNodes(element).map((element) =>
      element.hasChildNodes() ?
      wrapAll(toNodes(element.childNodes), structure) :
      append(element, structure)));


    }

    function unwrap(element) {
      toNodes(element).
      map(parent).
      filter((value, index, self) => self.indexOf(value) === index).
      forEach((parent) => parent.replaceWith(...parent.childNodes));
    }

    const fragmentRe = /^\s*<(\w+|!)[^>]*>/;
    const singleTagRe = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;

    function fragment(html) {
      const matches = singleTagRe.exec(html);
      if (matches) {
        return document.createElement(matches[1]);
      }

      const container = document.createElement('div');
      if (fragmentRe.test(html)) {
        container.insertAdjacentHTML('beforeend', html.trim());
      } else {
        container.textContent = html;
      }

      return unwrapSingle(container.childNodes);
    }

    function unwrapSingle(nodes) {
      return nodes.length > 1 ? nodes : nodes[0];
    }

    function apply(node, fn) {
      if (!isElement(node)) {
        return;
      }

      fn(node);
      node = node.firstElementChild;
      while (node) {
        const next = node.nextElementSibling;
        apply(node, fn);
        node = next;
      }
    }

    function $(selector, context) {
      return isHtml(selector) ? toNode(fragment(selector)) : find(selector, context);
    }

    function $$(selector, context) {
      return isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context);
    }

    function isHtml(str) {
      return isString(str) && startsWith(str.trim(), '<');
    }

    const inBrowser = typeof window !== 'undefined';
    const isRtl = inBrowser && attr(document.documentElement, 'dir') === 'rtl';

    const hasTouch = inBrowser && 'ontouchstart' in window;
    const hasPointerEvents = inBrowser && window.PointerEvent;

    const pointerDown = hasPointerEvents ? 'pointerdown' : hasTouch ? 'touchstart' : 'mousedown';
    const pointerMove = hasPointerEvents ? 'pointermove' : hasTouch ? 'touchmove' : 'mousemove';
    const pointerUp = hasPointerEvents ? 'pointerup' : hasTouch ? 'touchend' : 'mouseup';
    const pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouch ? '' : 'mouseenter';
    const pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouch ? '' : 'mouseleave';
    const pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';

    /*
        Based on:
        Copyright (c) 2016 Wilson Page wilsonpage@me.com
        https://github.com/wilsonpage/fastdom
    */

    const fastdom = {
      reads: [],
      writes: [],

      read(task) {
        this.reads.push(task);
        scheduleFlush();
        return task;
      },

      write(task) {
        this.writes.push(task);
        scheduleFlush();
        return task;
      },

      clear(task) {
        remove(this.reads, task);
        remove(this.writes, task);
      },

      flush };


    function flush(recursion) {
      runTasks(fastdom.reads);
      runTasks(fastdom.writes.splice(0));

      fastdom.scheduled = false;

      if (fastdom.reads.length || fastdom.writes.length) {
        scheduleFlush(recursion + 1);
      }
    }

    const RECURSION_LIMIT = 4;
    function scheduleFlush(recursion) {
      if (fastdom.scheduled) {
        return;
      }

      fastdom.scheduled = true;
      if (recursion && recursion < RECURSION_LIMIT) {
        Promise.resolve().then(() => flush(recursion));
      } else {
        requestAnimationFrame(() => flush(1));
      }
    }

    function runTasks(tasks) {
      let task;
      while (task = tasks.shift()) {
        try {
          task();
        } catch (e) {
          console.error(e);
        }
      }
    }

    function remove(array, item) {
      const index = array.indexOf(item);
      return ~index && array.splice(index, 1);
    }

    function MouseTracker() {}

    MouseTracker.prototype = {
      positions: [],

      init() {
        this.positions = [];

        let position;
        this.unbind = on(document, 'mousemove', (e) => position = getEventPos(e));
        this.interval = setInterval(() => {
          if (!position) {
            return;
          }

          this.positions.push(position);

          if (this.positions.length > 5) {
            this.positions.shift();
          }
        }, 50);
      },

      cancel() {var _this$unbind;
        (_this$unbind = this.unbind) == null ? void 0 : _this$unbind.call(this);
        this.interval && clearInterval(this.interval);
      },

      movesTo(target) {
        if (this.positions.length < 2) {
          return false;
        }

        const p = target.getBoundingClientRect();
        const { left, right, top, bottom } = p;

        const [prevPosition] = this.positions;
        const position = last(this.positions);
        const path = [prevPosition, position];

        if (pointInRect(position, p)) {
          return false;
        }

        const diagonals = [
        [
        { x: left, y: top },
        { x: right, y: bottom }],

        [
        { x: left, y: bottom },
        { x: right, y: top }]];



        return diagonals.some((diagonal) => {
          const intersection = intersect(path, diagonal);
          return intersection && pointInRect(intersection, p);
        });
      } };


    // Inspired by http://paulbourke.net/geometry/pointlineplane/
    function intersect(_ref, _ref2) {let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = _ref;let [{ x: x3, y: y3 }, { x: x4, y: y4 }] = _ref2;
      const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

      // Lines are parallel
      if (denominator === 0) {
        return false;
      }

      const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;

      if (ua < 0) {
        return false;
      }

      // Return an object with the x and y coordinates of the intersection
      return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };
    }

    function observeIntersection(targets, cb, options, intersecting) {if (intersecting === void 0) {intersecting = true;}
      const observer = new IntersectionObserver(
      intersecting ?
      (entries, observer) => {
        if (entries.some((entry) => entry.isIntersecting)) {
          cb(entries, observer);
        }
      } :
      cb,
      options);

      for (const el of toNodes(targets)) {
        observer.observe(el);
      }

      return observer;
    }

    const hasResizeObserver = inBrowser && window.ResizeObserver;
    function observeResize(targets, cb, options) {if (options === void 0) {options = { box: 'border-box' };}
      if (hasResizeObserver) {
        return observe(ResizeObserver, targets, cb, options);
      }

      // Fallback Safari < 13.1
      initResizeListener();
      listeners.add(cb);

      return {
        disconnect() {
          listeners.delete(cb);
        } };

    }

    let listeners;
    function initResizeListener() {
      if (listeners) {
        return;
      }

      listeners = new Set();

      // throttle 'resize'
      let pendingResize;
      const handleResize = () => {
        if (pendingResize) {
          return;
        }
        pendingResize = true;
        fastdom.read(() => pendingResize = false);
        for (const listener of listeners) {
          listener();
        }
      };

      on(window, 'load resize', handleResize);
      on(document, 'loadedmetadata load', handleResize, true);
    }

    function observeMutation(targets, cb, options) {
      return observe(MutationObserver, targets, cb, options);
    }

    function observe(Observer, targets, cb, options) {
      const observer = new Observer(cb);
      for (const el of toNodes(targets)) {
        observer.observe(el, options);
      }

      return observer;
    }

    const strats = {};

    strats.events =
    strats.created =
    strats.beforeConnect =
    strats.connected =
    strats.beforeDisconnect =
    strats.disconnected =
    strats.destroy =
    concatStrat;

    // args strategy
    strats.args = function (parentVal, childVal) {
      return childVal !== false && concatStrat(childVal || parentVal);
    };

    // update strategy
    strats.update = function (parentVal, childVal) {
      return sortBy$1(
      concatStrat(parentVal, isFunction(childVal) ? { read: childVal } : childVal),
      'order');

    };

    // property strategy
    strats.props = function (parentVal, childVal) {
      if (isArray(childVal)) {
        const value = {};
        for (const key of childVal) {
          value[key] = String;
        }
        childVal = value;
      }

      return strats.methods(parentVal, childVal);
    };

    // extend strategy
    strats.computed = strats.methods = function (parentVal, childVal) {
      return childVal ? parentVal ? { ...parentVal, ...childVal } : childVal : parentVal;
    };

    // data strategy
    strats.data = function (parentVal, childVal, vm) {
      if (!vm) {
        if (!childVal) {
          return parentVal;
        }

        if (!parentVal) {
          return childVal;
        }

        return function (vm) {
          return mergeFnData(parentVal, childVal, vm);
        };
      }

      return mergeFnData(parentVal, childVal, vm);
    };

    function mergeFnData(parentVal, childVal, vm) {
      return strats.computed(
      isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal,
      isFunction(childVal) ? childVal.call(vm, vm) : childVal);

    }

    // concat strategy
    function concatStrat(parentVal, childVal) {
      parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;

      return childVal ?
      parentVal ?
      parentVal.concat(childVal) :
      isArray(childVal) ?
      childVal :
      [childVal] :
      parentVal;
    }

    // default strategy
    function defaultStrat(parentVal, childVal) {
      return isUndefined(childVal) ? parentVal : childVal;
    }

    function mergeOptions(parent, child, vm) {
      const options = {};

      if (isFunction(child)) {
        child = child.options;
      }

      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }

      if (child.mixins) {
        for (const mixin of child.mixins) {
          parent = mergeOptions(parent, mixin, vm);
        }
      }

      for (const key in parent) {
        mergeKey(key);
      }

      for (const key in child) {
        if (!hasOwn(parent, key)) {
          mergeKey(key);
        }
      }

      function mergeKey(key) {
        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);
      }

      return options;
    }

    function parseOptions(options, args) {if (args === void 0) {args = [];}
      try {
        return options ?
        startsWith(options, '{') ?
        JSON.parse(options) :
        args.length && !includes(options, ':') ?
        { [args[0]]: options } :
        options.split(';').reduce((options, option) => {
          const [key, value] = option.split(/:(.*)/);
          if (key && !isUndefined(value)) {
            options[key.trim()] = value.trim();
          }
          return options;
        }, {}) :
        {};
      } catch (e) {
        return {};
      }
    }

    function play(el) {
      if (isIFrame(el)) {
        call(el, { func: 'playVideo', method: 'play' });
      }

      if (isHTML5(el)) {
        try {
          el.play().catch(noop);
        } catch (e) {
          // noop
        }
      }
    }

    function pause(el) {
      if (isIFrame(el)) {
        call(el, { func: 'pauseVideo', method: 'pause' });
      }

      if (isHTML5(el)) {
        el.pause();
      }
    }

    function mute(el) {
      if (isIFrame(el)) {
        call(el, { func: 'mute', method: 'setVolume', value: 0 });
      }

      if (isHTML5(el)) {
        el.muted = true;
      }
    }

    function isVideo(el) {
      return isHTML5(el) || isIFrame(el);
    }

    function isHTML5(el) {
      return isTag(el, 'video');
    }

    function isIFrame(el) {
      return isTag(el, 'iframe') && (isYoutube(el) || isVimeo(el));
    }

    function isYoutube(el) {
      return !!el.src.match(
      /\/\/.*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.*/);

    }

    function isVimeo(el) {
      return !!el.src.match(/vimeo\.com\/video\/.*/);
    }

    async function call(el, cmd) {
      await enableApi(el);
      post(el, cmd);
    }

    function post(el, cmd) {
      try {
        el.contentWindow.postMessage(JSON.stringify({ event: 'command', ...cmd }), '*');
      } catch (e) {
        // noop
      }
    }

    const stateKey = '_ukPlayer';
    let counter = 0;
    function enableApi(el) {
      if (el[stateKey]) {
        return el[stateKey];
      }

      const youtube = isYoutube(el);
      const vimeo = isVimeo(el);

      const id = ++counter;
      let poller;

      return el[stateKey] = new Promise((resolve) => {
        youtube &&
        once(el, 'load', () => {
          const listener = () => post(el, { event: 'listening', id });
          poller = setInterval(listener, 100);
          listener();
        });

        once(window, 'message', resolve, false, (_ref) => {let { data } = _ref;
          try {
            data = JSON.parse(data);
            return (
              data && (
              youtube && data.id === id && data.event === 'onReady' ||
              vimeo && Number(data.player_id) === id));

          } catch (e) {
            // noop
          }
        });

        el.src = "" + el.src + (includes(el.src, '?') ? '&' : '?') + (
        youtube ? 'enablejsapi=1' : "api=1&player_id=" + id);

      }).then(() => clearInterval(poller));
    }

    function isInView(element, offsetTop, offsetLeft) {if (offsetTop === void 0) {offsetTop = 0;}if (offsetLeft === void 0) {offsetLeft = 0;}
      if (!isVisible(element)) {
        return false;
      }

      return intersectRect(
      ...scrollParents(element).
      map((parent) => {
        const { top, left, bottom, right } = offset(getViewport$1(parent));

        return {
          top: top - offsetTop,
          left: left - offsetLeft,
          bottom: bottom + offsetTop,
          right: right + offsetLeft };

      }).
      concat(offset(element)));

    }

    function scrollTop(element, top) {
      if (isWindow(element) || isDocument(element)) {
        element = getScrollingElement(element);
      } else {
        element = toNode(element);
      }

      if (isUndefined(top)) {
        return element.scrollTop;
      } else {
        element.scrollTop = top;
      }
    }

    function scrollIntoView(element, _temp) {let { offset: offsetBy = 0 } = _temp === void 0 ? {} : _temp;
      const parents = isVisible(element) ? scrollParents(element) : [];
      return parents.reduce(
      (fn, scrollElement, i) => {
        const { scrollTop, scrollHeight, offsetHeight } = scrollElement;
        const maxScroll = scrollHeight - getViewportClientHeight(scrollElement);
        const { height: elHeight, top: elTop } = offset(parents[i - 1] || element);

        let top = Math.ceil(
        elTop - offset(getViewport$1(scrollElement)).top - offsetBy + scrollTop);


        if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) {
          top += offsetBy;
        } else {
          offsetBy = 0;
        }

        if (top > maxScroll) {
          offsetBy -= top - maxScroll;
          top = maxScroll;
        } else if (top < 0) {
          offsetBy -= top;
          top = 0;
        }

        return () => scrollTo(scrollElement, top - scrollTop).then(fn);
      },
      () => Promise.resolve())();


      function scrollTo(element, top) {
        return new Promise((resolve) => {
          const scroll = element.scrollTop;
          const duration = getDuration(Math.abs(top));
          const start = Date.now();

          (function step() {
            const percent = ease(clamp((Date.now() - start) / duration));

            scrollTop(element, scroll + top * percent);

            // scroll more if we have not reached our destination
            if (percent === 1) {
              resolve();
            } else {
              requestAnimationFrame(step);
            }
          })();
        });
      }

      function getDuration(dist) {
        return 40 * Math.pow(dist, 0.375);
      }

      function ease(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      }
    }

    function scrolledOver(element, startOffset, endOffset) {if (startOffset === void 0) {startOffset = 0;}if (endOffset === void 0) {endOffset = 0;}
      if (!isVisible(element)) {
        return 0;
      }

      const [scrollElement] = scrollParents(element, /auto|scroll/, true);
      const { scrollHeight, scrollTop } = scrollElement;
      const viewportHeight = getViewportClientHeight(scrollElement);
      const maxScroll = scrollHeight - viewportHeight;
      const elementOffsetTop = offsetPosition(element)[0] - offsetPosition(scrollElement)[0];

      const start = Math.max(0, elementOffsetTop - viewportHeight + startOffset);
      const end = Math.min(maxScroll, elementOffsetTop + element.offsetHeight - endOffset);

      return clamp((scrollTop - start) / (end - start));
    }

    function scrollParents(element, overflowRe, scrollable) {if (overflowRe === void 0) {overflowRe = /auto|scroll|hidden/;}if (scrollable === void 0) {scrollable = false;}
      const scrollEl = getScrollingElement(element);

      let ancestors = parents(element).reverse();
      ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1);

      const fixedIndex = findIndex(ancestors, (el) => css(el, 'position') === 'fixed');
      if (~fixedIndex) {
        ancestors = ancestors.slice(fixedIndex);
      }

      return [scrollEl].
      concat(
      ancestors.filter(
      (parent) =>
      overflowRe.test(css(parent, 'overflow')) && (
      !scrollable || parent.scrollHeight > getViewportClientHeight(parent)))).


      reverse();
    }

    function getViewport$1(scrollElement) {
      return scrollElement === getScrollingElement(scrollElement) ? window : scrollElement;
    }

    // iOS 12 returns <body> as scrollingElement
    function getViewportClientHeight(scrollElement) {
      return (
      scrollElement === getScrollingElement(scrollElement) ?
      document.documentElement :
      scrollElement).
      clientHeight;
    }

    function getScrollingElement(element) {
      const { document } = toWindow(element);
      return document.scrollingElement || document.documentElement;
    }

    const dirs = {
      width: ['x', 'left', 'right'],
      height: ['y', 'top', 'bottom'] };


    function positionAt(
    element,
    target,
    elAttach,
    targetAttach,
    elOffset,
    targetOffset,
    flip,
    boundary)
    {
      elAttach = getPos(elAttach);
      targetAttach = getPos(targetAttach);

      const flipped = { element: elAttach, target: targetAttach };

      if (!element || !target) {
        return flipped;
      }

      const dim = offset(element);
      const targetDim = offset(target);
      const position = targetDim;

      moveTo(position, elAttach, dim, -1);
      moveTo(position, targetAttach, targetDim, 1);

      elOffset = getOffsets(elOffset, dim.width, dim.height);
      targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);

      elOffset['x'] += targetOffset['x'];
      elOffset['y'] += targetOffset['y'];

      position.left += elOffset['x'];
      position.top += elOffset['y'];

      if (flip) {
        let boundaries = scrollParents(element).map(getViewport$1);

        if (boundary && !includes(boundaries, boundary)) {
          boundaries.unshift(boundary);
        }

        boundaries = boundaries.map((el) => offset(el));

        each(dirs, (_ref, prop) => {let [dir, align, alignFlip] = _ref;
          if (!(flip === true || includes(flip, dir))) {
            return;
          }

          boundaries.some((boundary) => {
            const elemOffset =
            elAttach[dir] === align ?
            -dim[prop] :
            elAttach[dir] === alignFlip ?
            dim[prop] :
            0;

            const targetOffset =
            targetAttach[dir] === align ?
            targetDim[prop] :
            targetAttach[dir] === alignFlip ?
            -targetDim[prop] :
            0;

            if (
            position[align] < boundary[align] ||
            position[align] + dim[prop] > boundary[alignFlip])
            {
              const centerOffset = dim[prop] / 2;
              const centerTargetOffset =
              targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;

              return (
                elAttach[dir] === 'center' && (
                apply(centerOffset, centerTargetOffset) ||
                apply(-centerOffset, -centerTargetOffset)) ||
                apply(elemOffset, targetOffset));

            }

            function apply(elemOffset, targetOffset) {
              const newVal = toFloat(
              (position[align] + elemOffset + targetOffset - elOffset[dir] * 2).toFixed(4));


              if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {
                position[align] = newVal;

                for (const el of ['element', 'target']) {
                  if (elemOffset) {
                    flipped[el][dir] =
                    flipped[el][dir] === dirs[prop][1] ?
                    dirs[prop][2] :
                    dirs[prop][1];
                  }
                }

                return true;
              }
            }
          });
        });
      }

      offset(element, position);

      return flipped;
    }

    function moveTo(position, attach, dim, factor) {
      each(dirs, (_ref2, prop) => {let [dir, align, alignFlip] = _ref2;
        if (attach[dir] === alignFlip) {
          position[align] += dim[prop] * factor;
        } else if (attach[dir] === 'center') {
          position[align] += dim[prop] * factor / 2;
        }
      });
    }

    function getPos(pos) {
      const x = /left|center|right/;
      const y = /top|center|bottom/;

      pos = (pos || '').split(' ');

      if (pos.length === 1) {
        pos = x.test(pos[0]) ?
        pos.concat('center') :
        y.test(pos[0]) ?
        ['center'].concat(pos) :
        ['center', 'center'];
      }

      return {
        x: x.test(pos[0]) ? pos[0] : 'center',
        y: y.test(pos[1]) ? pos[1] : 'center' };

    }

    function getOffsets(offsets, width, height) {
      const [x, y] = (offsets || '').split(' ');

      return {
        x: x ? toFloat(x) * (endsWith(x, '%') ? width / 100 : 1) : 0,
        y: y ? toFloat(y) * (endsWith(y, '%') ? height / 100 : 1) : 0 };

    }

    var util = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ajax: ajax,
        getImage: getImage,
        transition: transition,
        Transition: Transition,
        animate: animate$1,
        Animation: Animation,
        attr: attr,
        hasAttr: hasAttr,
        removeAttr: removeAttr,
        data: data,
        addClass: addClass,
        removeClass: removeClass,
        removeClasses: removeClasses,
        replaceClass: replaceClass,
        hasClass: hasClass,
        toggleClass: toggleClass,
        dimensions: dimensions$1,
        offset: offset,
        position: position,
        offsetPosition: offsetPosition,
        height: height,
        width: width,
        boxModelAdjust: boxModelAdjust,
        flipPosition: flipPosition,
        toPx: toPx,
        ready: ready,
        isTag: isTag,
        empty: empty,
        html: html,
        replaceChildren: replaceChildren,
        prepend: prepend,
        append: append,
        before: before,
        after: after,
        remove: remove$1,
        wrapAll: wrapAll,
        wrapInner: wrapInner,
        unwrap: unwrap,
        fragment: fragment,
        apply: apply,
        $: $,
        $$: $$,
        inBrowser: inBrowser,
        isRtl: isRtl,
        hasTouch: hasTouch,
        pointerDown: pointerDown,
        pointerMove: pointerMove,
        pointerUp: pointerUp,
        pointerEnter: pointerEnter,
        pointerLeave: pointerLeave,
        pointerCancel: pointerCancel,
        on: on,
        off: off,
        once: once,
        trigger: trigger,
        createEvent: createEvent,
        toEventTargets: toEventTargets,
        isTouch: isTouch,
        getEventPos: getEventPos,
        fastdom: fastdom,
        isVoidElement: isVoidElement,
        isVisible: isVisible,
        selInput: selInput,
        isInput: isInput,
        selFocusable: selFocusable,
        isFocusable: isFocusable,
        parent: parent,
        filter: filter$1,
        matches: matches,
        closest: closest,
        within: within,
        parents: parents,
        children: children,
        index: index,
        hasOwn: hasOwn,
        hyphenate: hyphenate,
        camelize: camelize,
        ucfirst: ucfirst,
        startsWith: startsWith,
        endsWith: endsWith,
        includes: includes,
        findIndex: findIndex,
        isArray: isArray,
        toArray: toArray,
        assign: assign,
        isFunction: isFunction,
        isObject: isObject,
        isPlainObject: isPlainObject,
        isWindow: isWindow,
        isDocument: isDocument,
        isNode: isNode,
        isElement: isElement,
        isBoolean: isBoolean,
        isString: isString,
        isNumber: isNumber,
        isNumeric: isNumeric,
        isEmpty: isEmpty,
        isUndefined: isUndefined,
        toBoolean: toBoolean,
        toNumber: toNumber,
        toFloat: toFloat,
        toNode: toNode,
        toNodes: toNodes,
        toWindow: toWindow,
        toMs: toMs,
        isEqual: isEqual,
        swap: swap,
        last: last,
        each: each,
        sortBy: sortBy$1,
        uniqueBy: uniqueBy,
        clamp: clamp,
        noop: noop,
        intersectRect: intersectRect,
        pointInRect: pointInRect,
        Dimensions: Dimensions,
        getIndex: getIndex,
        memoize: memoize,
        Deferred: Deferred,
        MouseTracker: MouseTracker,
        observeIntersection: observeIntersection,
        observeResize: observeResize,
        observeMutation: observeMutation,
        mergeOptions: mergeOptions,
        parseOptions: parseOptions,
        play: play,
        pause: pause,
        mute: mute,
        isVideo: isVideo,
        positionAt: positionAt,
        query: query,
        queryAll: queryAll,
        find: find,
        findAll: findAll,
        escape: escape,
        css: css,
        getCssVar: getCssVar,
        propName: propName,
        isInView: isInView,
        scrollTop: scrollTop,
        scrollIntoView: scrollIntoView,
        scrolledOver: scrolledOver,
        scrollParents: scrollParents,
        getViewport: getViewport$1,
        getViewportClientHeight: getViewportClientHeight,
        getScrollingElement: getScrollingElement
    });

    function globalAPI (UIkit) {
      const DATA = UIkit.data;

      UIkit.use = function (plugin) {
        if (plugin.installed) {
          return;
        }

        plugin.call(null, this);
        plugin.installed = true;

        return this;
      };

      UIkit.mixin = function (mixin, component) {
        component = (isString(component) ? UIkit.component(component) : component) || this;
        component.options = mergeOptions(component.options, mixin);
      };

      UIkit.extend = function (options) {
        options = options || {};

        const Super = this;
        const Sub = function UIkitComponent(options) {
          this._init(options);
        };

        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.options = mergeOptions(Super.options, options);

        Sub.super = Super;
        Sub.extend = Super.extend;

        return Sub;
      };

      UIkit.update = function (element, e) {
        element = element ? toNode(element) : document.body;

        for (const parentEl of parents(element).reverse()) {
          update(parentEl[DATA], e);
        }

        apply(element, (element) => update(element[DATA], e));
      };

      let container;
      Object.defineProperty(UIkit, 'container', {
        get() {
          return container || document.body;
        },

        set(element) {
          container = $(element);
        } });


      function update(data, e) {
        if (!data) {
          return;
        }

        for (const name in data) {
          if (data[name]._connected) {
            data[name]._callUpdate(e);
          }
        }
      }
    }

    function hooksAPI (UIkit) {
      UIkit.prototype._callHook = function (hook) {var _this$$options$hook;
        (_this$$options$hook = this.$options[hook]) == null ? void 0 : _this$$options$hook.forEach((handler) => handler.call(this));
      };

      UIkit.prototype._callConnected = function () {
        if (this._connected) {
          return;
        }

        this._data = {};
        this._computed = {};

        this._initProps();

        this._callHook('beforeConnect');
        this._connected = true;

        this._initEvents();
        this._initObservers();

        this._callHook('connected');
        this._callUpdate();
      };

      UIkit.prototype._callDisconnected = function () {
        if (!this._connected) {
          return;
        }

        this._callHook('beforeDisconnect');
        this._disconnectObservers();
        this._unbindEvents();
        this._callHook('disconnected');

        this._connected = false;
        delete this._watch;
      };

      UIkit.prototype._callUpdate = function (e) {if (e === void 0) {e = 'update';}
        if (!this._connected) {
          return;
        }

        if (e === 'update' || e === 'resize') {
          this._callWatches();
        }

        if (!this.$options.update) {
          return;
        }

        if (!this._updates) {
          this._updates = new Set();
          fastdom.read(() => {
            if (this._connected) {
              runUpdates.call(this, this._updates);
            }
            delete this._updates;
          });
        }

        this._updates.add(e.type || e);
      };

      UIkit.prototype._callWatches = function () {
        if (this._watch) {
          return;
        }

        const initial = !hasOwn(this, '_watch');

        this._watch = fastdom.read(() => {
          if (this._connected) {
            runWatches.call(this, initial);
          }
          this._watch = null;
        });
      };

      function runUpdates(types) {
        for (const { read, write, events = [] } of this.$options.update) {
          if (!types.has('update') && !events.some((type) => types.has(type))) {
            continue;
          }

          let result;
          if (read) {
            result = read.call(this, this._data, types);

            if (result && isPlainObject(result)) {
              assign(this._data, result);
            }
          }

          if (write && result !== false) {
            fastdom.write(() => write.call(this, this._data, types));
          }
        }
      }

      function runWatches(initial) {
        const {
          $options: { computed } } =
        this;
        const values = { ...(initial ? {} : this._computed) };
        this._computed = {};

        for (const key in computed) {
          const { watch, immediate } = computed[key];
          if (
          watch && (
          initial && immediate ||
          hasOwn(values, key) && !isEqual(values[key], this[key])))
          {
            watch.call(this, this[key], values[key]);
          }
        }
      }
    }

    function stateAPI (UIkit) {
      let uid = 0;

      UIkit.prototype._init = function (options) {
        options = options || {};
        options.data = normalizeData(options, this.constructor.options);

        this.$options = mergeOptions(this.constructor.options, options, this);
        this.$el = null;
        this.$props = {};

        this._uid = uid++;
        this._initData();
        this._initMethods();
        this._initComputeds();
        this._callHook('created');

        if (options.el) {
          this.$mount(options.el);
        }
      };

      UIkit.prototype._initData = function () {
        const { data = {} } = this.$options;

        for (const key in data) {
          this.$props[key] = this[key] = data[key];
        }
      };

      UIkit.prototype._initMethods = function () {
        const { methods } = this.$options;

        if (methods) {
          for (const key in methods) {
            this[key] = methods[key].bind(this);
          }
        }
      };

      UIkit.prototype._initComputeds = function () {
        const { computed } = this.$options;

        this._computed = {};

        if (computed) {
          for (const key in computed) {
            registerComputed(this, key, computed[key]);
          }
        }
      };

      UIkit.prototype._initProps = function (props) {
        let key;

        props = props || getProps$1(this.$options, this.$name);

        for (key in props) {
          if (!isUndefined(props[key])) {
            this.$props[key] = props[key];
          }
        }

        const exclude = [this.$options.computed, this.$options.methods];
        for (key in this.$props) {
          if (key in props && notIn(exclude, key)) {
            this[key] = this.$props[key];
          }
        }
      };

      UIkit.prototype._initEvents = function () {
        this._events = [];
        for (const event of this.$options.events || []) {
          if (hasOwn(event, 'handler')) {
            registerEvent(this, event);
          } else {
            for (const key in event) {
              registerEvent(this, event[key], key);
            }
          }
        }
      };

      UIkit.prototype._unbindEvents = function () {
        this._events.forEach((unbind) => unbind());
        delete this._events;
      };

      UIkit.prototype._initObservers = function () {
        this._observers = [initPropsObserver(this)];

        if (this.$options.computed) {
          this.registerObserver(initChildListObserver(this));
        }
      };

      UIkit.prototype.registerObserver = function (observer) {
        this._observers.push(observer);
      };

      UIkit.prototype._disconnectObservers = function () {
        this._observers.forEach((observer) => observer == null ? void 0 : observer.disconnect());
      };
    }

    function getProps$1(opts, name) {
      const data$1 = {};
      const { args = [], props = {}, el } = opts;

      if (!props) {
        return data$1;
      }

      for (const key in props) {
        const prop = hyphenate(key);
        let value = data(el, prop);

        if (isUndefined(value)) {
          continue;
        }

        value = props[key] === Boolean && value === '' ? true : coerce(props[key], value);

        if (prop === 'target' && (!value || startsWith(value, '_'))) {
          continue;
        }

        data$1[key] = value;
      }

      const options = parseOptions(data(el, name), args);

      for (const key in options) {
        const prop = camelize(key);
        if (props[prop] !== undefined) {
          data$1[prop] = coerce(props[prop], options[key]);
        }
      }

      return data$1;
    }

    function registerComputed(component, key, cb) {
      Object.defineProperty(component, key, {
        enumerable: true,

        get() {
          const { _computed, $props, $el } = component;

          if (!hasOwn(_computed, key)) {
            _computed[key] = (cb.get || cb).call(component, $props, $el);
          }

          return _computed[key];
        },

        set(value) {
          const { _computed } = component;

          _computed[key] = cb.set ? cb.set.call(component, value) : value;

          if (isUndefined(_computed[key])) {
            delete _computed[key];
          }
        } });

    }

    function registerEvent(component, event, key) {
      if (!isPlainObject(event)) {
        event = { name: key, handler: event };
      }

      let { name, el, handler, capture, passive, delegate, filter, self } = event;
      el = isFunction(el) ? el.call(component) : el || component.$el;

      if (isArray(el)) {
        el.forEach((el) => registerEvent(component, { ...event, el }, key));
        return;
      }

      if (!el || filter && !filter.call(component)) {
        return;
      }

      component._events.push(
      on(
      el,
      name,
      delegate ? isString(delegate) ? delegate : delegate.call(component) : null,
      isString(handler) ? component[handler] : handler.bind(component),
      { passive, capture, self }));


    }

    function notIn(options, key) {
      return options.every((arr) => !arr || !hasOwn(arr, key));
    }

    function coerce(type, value) {
      if (type === Boolean) {
        return toBoolean(value);
      } else if (type === Number) {
        return toNumber(value);
      } else if (type === 'list') {
        return toList(value);
      }

      return type ? type(value) : value;
    }

    function toList(value) {
      return isArray(value) ?
      value :
      isString(value) ?
      value.
      split(/,(?![^(]*\))/).
      map((value) => isNumeric(value) ? toNumber(value) : toBoolean(value.trim())) :
      [value];
    }

    function normalizeData(_ref, _ref2) {let { data = {} } = _ref;let { args = [], props = {} } = _ref2;
      if (isArray(data)) {
        data = data.slice(0, args.length).reduce((data, value, index) => {
          if (isPlainObject(value)) {
            assign(data, value);
          } else {
            data[args[index]] = value;
          }
          return data;
        }, {});
      }

      for (const key in data) {
        if (isUndefined(data[key])) {
          delete data[key];
        } else if (props[key]) {
          data[key] = coerce(props[key], data[key]);
        }
      }

      return data;
    }

    function initChildListObserver(component) {
      const { el } = component.$options;

      const observer = new MutationObserver(() => component.$emit());
      observer.observe(el, {
        childList: true,
        subtree: true });


      return observer;
    }

    function initPropsObserver(component) {
      const { $name, $options, $props } = component;
      const { attrs, props, el } = $options;

      if (!props || attrs === false) {
        return;
      }

      const attributes = isArray(attrs) ? attrs : Object.keys(props);
      const filter = attributes.map((key) => hyphenate(key)).concat($name);

      const observer = new MutationObserver((records) => {
        const data = getProps$1($options, $name);
        if (
        records.some((_ref3) => {let { attributeName } = _ref3;
          const prop = attributeName.replace('data-', '');
          return (
          prop === $name ? attributes : [camelize(prop), camelize(attributeName)]).
          some((prop) => !isUndefined(data[prop]) && data[prop] !== $props[prop]);
        }))
        {
          component.$reset();
        }
      });

      observer.observe(el, {
        attributes: true,
        attributeFilter: filter.concat(filter.map((key) => "data-" + key)) });


      return observer;
    }

    function instanceAPI (UIkit) {
      const DATA = UIkit.data;

      UIkit.prototype.$create = function (component, element, data) {
        return UIkit[component](element, data);
      };

      UIkit.prototype.$mount = function (el) {
        const { name } = this.$options;

        if (!el[DATA]) {
          el[DATA] = {};
        }

        if (el[DATA][name]) {
          return;
        }

        el[DATA][name] = this;

        this.$el = this.$options.el = this.$options.el || el;

        if (within(el, document)) {
          this._callConnected();
        }
      };

      UIkit.prototype.$reset = function () {
        this._callDisconnected();
        this._callConnected();
      };

      UIkit.prototype.$destroy = function (removeEl) {if (removeEl === void 0) {removeEl = false;}
        const { el, name } = this.$options;

        if (el) {
          this._callDisconnected();
        }

        this._callHook('destroy');

        if (!(el != null && el[DATA])) {
          return;
        }

        delete el[DATA][name];

        if (!isEmpty(el[DATA])) {
          delete el[DATA];
        }

        if (removeEl) {
          remove$1(this.$el);
        }
      };

      UIkit.prototype.$emit = function (e) {
        this._callUpdate(e);
      };

      UIkit.prototype.$update = function (element, e) {if (element === void 0) {element = this.$el;}
        UIkit.update(element, e);
      };

      UIkit.prototype.$getComponent = UIkit.getComponent;

      const componentName = memoize((name) => UIkit.prefix + hyphenate(name));
      Object.defineProperties(UIkit.prototype, {
        $container: Object.getOwnPropertyDescriptor(UIkit, 'container'),

        $name: {
          get() {
            return componentName(this.$options.name);
          } } });


    }

    function componentAPI (UIkit) {
      const DATA = UIkit.data;

      const components = {};

      UIkit.component = function (name, options) {
        const id = hyphenate(name);

        name = camelize(id);

        if (!options) {
          if (isPlainObject(components[name])) {
            components[name] = UIkit.extend(components[name]);
          }

          return components[name];
        }

        UIkit[name] = function (element, data) {
          const component = UIkit.component(name);

          return component.options.functional ?
          new component({ data: isPlainObject(element) ? element : [...arguments] }) :
          element ?
          $$(element).map(init)[0] :
          init();

          function init(element) {
            const instance = UIkit.getComponent(element, name);

            if (instance) {
              if (data) {
                instance.$destroy();
              } else {
                return instance;
              }
            }

            return new component({ el: element, data });
          }
        };

        const opt = isPlainObject(options) ? { ...options } : options.options;

        opt.name = name;

        opt.install == null ? void 0 : opt.install(UIkit, opt, name);

        if (UIkit._initialized && !opt.functional) {
          fastdom.read(() => UIkit[name]("[uk-" + id + "],[data-uk-" + id + "]"));
        }

        return components[name] = isPlainObject(options) ? opt : options;
      };

      UIkit.getComponents = (element) => (element == null ? void 0 : element[DATA]) || {};
      UIkit.getComponent = (element, name) => UIkit.getComponents(element)[name];

      UIkit.connect = (node) => {
        if (node[DATA]) {
          for (const name in node[DATA]) {
            node[DATA][name]._callConnected();
          }
        }

        for (const attribute of node.attributes) {
          const name = getComponentName(attribute.name);

          if (name && name in components) {
            UIkit[name](node);
          }
        }
      };

      UIkit.disconnect = (node) => {
        for (const name in node[DATA]) {
          node[DATA][name]._callDisconnected();
        }
      };
    }

    const getComponentName = memoize((attribute) => {
      return startsWith(attribute, 'uk-') || startsWith(attribute, 'data-uk-') ?
      camelize(attribute.replace('data-uk-', '').replace('uk-', '')) :
      false;
    });

    const UIkit = function (options) {
      this._init(options);
    };

    UIkit.util = util;
    UIkit.data = '__uikit__';
    UIkit.prefix = 'uk-';
    UIkit.options = {};
    UIkit.version = '3.13.9';

    globalAPI(UIkit);
    hooksAPI(UIkit);
    stateAPI(UIkit);
    componentAPI(UIkit);
    instanceAPI(UIkit);

    function Core () {
      if (!inBrowser) {
        return;
      }

      let started = 0;
      on(
      document,
      'animationstart',
      (_ref) => {let { target } = _ref;
        if ((css(target, 'animationName') || '').match(/^uk-.*(left|right)/)) {
          started++;
          css(document.documentElement, 'overflowX', 'hidden');
          setTimeout(() => {
            if (! --started) {
              css(document.documentElement, 'overflowX', '');
            }
          }, toMs(css(target, 'animationDuration')) + 100);
        }
      },
      true);

    }

    function boot (UIkit) {
      const { connect, disconnect } = UIkit;

      if (!inBrowser || !window.MutationObserver) {
        return;
      }

      fastdom.read(function () {
        if (document.body) {
          apply(document.body, connect);
        }

        new MutationObserver((records) => records.forEach(applyChildListMutation)).observe(
        document,
        {
          childList: true,
          subtree: true });



        new MutationObserver((records) => records.forEach(applyAttributeMutation)).observe(
        document,
        {
          attributes: true,
          subtree: true });



        UIkit._initialized = true;
      });

      function applyChildListMutation(_ref) {let { addedNodes, removedNodes } = _ref;
        for (const node of addedNodes) {
          apply(node, connect);
        }

        for (const node of removedNodes) {
          apply(node, disconnect);
        }
      }

      function applyAttributeMutation(_ref2) {var _UIkit$getComponent;let { target, attributeName } = _ref2;
        const name = getComponentName(attributeName);

        if (!name || !(name in UIkit)) {
          return;
        }

        if (hasAttr(target, attributeName)) {
          UIkit[name](target);
          return;
        }

        (_UIkit$getComponent = UIkit.getComponent(target, name)) == null ? void 0 : _UIkit$getComponent.$destroy();
      }
    }

    var Class = {
      connected() {
        !hasClass(this.$el, this.$name) && addClass(this.$el, this.$name);
      } };

    var Lazyload = {
      methods: {
        lazyload(observeTargets, targets) {if (observeTargets === void 0) {observeTargets = this.$el;}if (targets === void 0) {targets = this.$el;}
          this.registerObserver(
          observeIntersection(observeTargets, (entries, observer) => {
            for (const el of toNodes(isFunction(targets) ? targets() : targets)) {
              $$('[loading="lazy"]', el).forEach((el) => removeAttr(el, 'loading'));
            }
            for (const el of entries.
            filter((_ref) => {let { isIntersecting } = _ref;return isIntersecting;}).
            map((_ref2) => {let { target } = _ref2;return target;})) {
              observer.unobserve(el);
            }
          }));

        } } };

    var Togglable = {
      props: {
        cls: Boolean,
        animation: 'list',
        duration: Number,
        origin: String,
        transition: String },


      data: {
        cls: false,
        animation: [false],
        duration: 200,
        origin: false,
        transition: 'linear',
        clsEnter: 'uk-togglabe-enter',
        clsLeave: 'uk-togglabe-leave',

        initProps: {
          overflow: '',
          height: '',
          paddingTop: '',
          paddingBottom: '',
          marginTop: '',
          marginBottom: '' },


        hideProps: {
          overflow: 'hidden',
          height: 0,
          paddingTop: 0,
          paddingBottom: 0,
          marginTop: 0,
          marginBottom: 0 } },



      computed: {
        hasAnimation(_ref) {let { animation } = _ref;
          return !!animation[0];
        },

        hasTransition(_ref2) {let { animation } = _ref2;
          return this.hasAnimation && animation[0] === true;
        } },


      methods: {
        toggleElement(targets, toggle, animate) {
          return new Promise((resolve) =>
          Promise.all(
          toNodes(targets).map((el) => {
            const show = isBoolean(toggle) ? toggle : !this.isToggled(el);

            if (!trigger(el, "before" + (show ? 'show' : 'hide'), [this])) {
              return Promise.reject();
            }

            const promise = (
            isFunction(animate) ?
            animate :
            animate === false || !this.hasAnimation ?
            this._toggle :
            this.hasTransition ?
            toggleHeight(this) :
            toggleAnimation(this))(
            el, show);

            const cls = show ? this.clsEnter : this.clsLeave;

            addClass(el, cls);

            trigger(el, show ? 'show' : 'hide', [this]);

            const done = () => {
              removeClass(el, cls);
              trigger(el, show ? 'shown' : 'hidden', [this]);
              this.$update(el);
            };

            return promise ?
            promise.then(done, () => {
              removeClass(el, cls);
              return Promise.reject();
            }) :
            done();
          })).
          then(resolve, noop));

        },

        isToggled(el) {if (el === void 0) {el = this.$el;}
          [el] = toNodes(el);
          return hasClass(el, this.clsEnter) ?
          true :
          hasClass(el, this.clsLeave) ?
          false :
          this.cls ?
          hasClass(el, this.cls.split(' ')[0]) :
          isVisible(el);
        },

        _toggle(el, toggled) {
          if (!el) {
            return;
          }

          toggled = Boolean(toggled);

          let changed;
          if (this.cls) {
            changed = includes(this.cls, ' ') || toggled !== hasClass(el, this.cls);
            changed && toggleClass(el, this.cls, includes(this.cls, ' ') ? undefined : toggled);
          } else {
            changed = toggled === el.hidden;
            changed && (el.hidden = !toggled);
          }

          $$('[autofocus]', el).some((el) => isVisible(el) ? el.focus() || true : el.blur());

          if (changed) {
            trigger(el, 'toggled', [toggled, this]);
            this.$update(el);
          }
        } } };



    function toggleHeight(_ref3) {let { isToggled, duration, initProps, hideProps, transition, _toggle } = _ref3;
      return (el, show) => {
        const inProgress = Transition.inProgress(el);
        const inner = el.hasChildNodes() ?
        toFloat(css(el.firstElementChild, 'marginTop')) +
        toFloat(css(el.lastElementChild, 'marginBottom')) :
        0;
        const currentHeight = isVisible(el) ? height(el) + (inProgress ? 0 : inner) : 0;

        Transition.cancel(el);

        if (!isToggled(el)) {
          _toggle(el, true);
        }

        height(el, '');

        // Update child components first
        fastdom.flush();

        const endHeight = height(el) + (inProgress ? 0 : inner);
        height(el, currentHeight);

        return (
        show ?
        Transition.start(
        el,
        { ...initProps, overflow: 'hidden', height: endHeight },
        Math.round(duration * (1 - currentHeight / endHeight)),
        transition) :

        Transition.start(
        el,
        hideProps,
        Math.round(duration * (currentHeight / endHeight)),
        transition).
        then(() => _toggle(el, false))).
        then(() => css(el, initProps));
      };
    }

    function toggleAnimation(cmp) {
      return (el, show) => {
        Animation.cancel(el);

        const { animation, duration, _toggle } = cmp;

        if (show) {
          _toggle(el, true);
          return Animation.in(el, animation[0], duration, cmp.origin);
        }

        return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then(() =>
        _toggle(el, false));

      };
    }

    var Accordion = {
      mixins: [Class, Lazyload, Togglable],

      props: {
        targets: String,
        active: null,
        collapsible: Boolean,
        multiple: Boolean,
        toggle: String,
        content: String,
        transition: String,
        offset: Number },


      data: {
        targets: '> *',
        active: false,
        animation: [true],
        collapsible: true,
        multiple: false,
        clsOpen: 'uk-open',
        toggle: '> .uk-accordion-title',
        content: '> .uk-accordion-content',
        transition: 'ease',
        offset: 0 },


      computed: {
        items: {
          get(_ref, $el) {let { targets } = _ref;
            return $$(targets, $el).filter((el) => $(this.content, el));
          },

          watch(items, prev) {
            items.forEach((el) => hide($(this.content, el), !hasClass(el, this.clsOpen)));

            if (prev || hasClass(items, this.clsOpen)) {
              return;
            }

            const active =
            this.active !== false && items[Number(this.active)] ||
            !this.collapsible && items[0];

            if (active) {
              this.toggle(active, false);
            }
          },

          immediate: true },


        toggles(_ref2) {let { toggle } = _ref2;
          return this.items.map((item) => $(toggle, item));
        } },


      connected() {
        this.lazyload();
      },

      events: [
      {
        name: 'click',

        delegate() {
          return this.targets + " " + this.$props.toggle;
        },

        handler(e) {
          e.preventDefault();
          this.toggle(index(this.toggles, e.current));
        } }],



      methods: {
        toggle(item, animate) {
          let items = [this.items[getIndex(item, this.items)]];
          const activeItems = filter$1(this.items, "." + this.clsOpen);

          if (!this.multiple && !includes(activeItems, items[0])) {
            items = items.concat(activeItems);
          }

          if (
          !this.collapsible &&
          activeItems.length < 2 &&
          !filter$1(items, ":not(." + this.clsOpen + ")").length)
          {
            return;
          }

          for (const el of items) {
            this.toggleElement(el, !hasClass(el, this.clsOpen), async (el, show) => {
              toggleClass(el, this.clsOpen, show);
              attr($(this.$props.toggle, el), 'aria-expanded', show);

              const content = $("" + (el._wrapper ? '> * ' : '') + this.content, el);

              if (animate === false || !this.hasTransition) {
                hide(content, !show);
                return;
              }

              if (!el._wrapper) {
                el._wrapper = wrapAll(content, "<div" + (show ? ' hidden' : '') + ">");
              }

              hide(content, false);
              await toggleHeight(this)(el._wrapper, show);
              hide(content, !show);

              delete el._wrapper;
              unwrap(content);

              if (show) {
                const toggle = $(this.$props.toggle, el);
                fastdom.read(() => {
                  if (!isInView(toggle)) {
                    scrollIntoView(toggle, { offset: this.offset });
                  }
                });
              }
            });
          }
        } } };



    function hide(el, hide) {
      el && (el.hidden = hide);
    }

    var alert = {
      mixins: [Class, Togglable],

      args: 'animation',

      props: {
        close: String },


      data: {
        animation: [true],
        selClose: '.uk-alert-close',
        duration: 150,
        hideProps: { opacity: 0, ...Togglable.data.hideProps } },


      events: [
      {
        name: 'click',

        delegate() {
          return this.selClose;
        },

        handler(e) {
          e.preventDefault();
          this.close();
        } }],



      methods: {
        async close() {
          await this.toggleElement(this.$el);
          this.$destroy(true);
        } } };

    var Video = {
      args: 'autoplay',

      props: {
        automute: Boolean,
        autoplay: Boolean },


      data: {
        automute: false,
        autoplay: true },


      connected() {
        this.inView = this.autoplay === 'inview';

        if (this.inView && !hasAttr(this.$el, 'preload')) {
          this.$el.preload = 'none';
        }

        if (this.automute) {
          mute(this.$el);
        }

        this.registerObserver(observeIntersection(this.$el, () => this.$emit(), {}, false));
      },

      update: {
        read() {
          if (!isVideo(this.$el)) {
            return false;
          }

          return {
            visible: isVisible(this.$el) && css(this.$el, 'visibility') !== 'hidden',
            inView: this.inView && isInView(this.$el) };

        },

        write(_ref) {let { visible, inView } = _ref;
          if (!visible || this.inView && !inView) {
            pause(this.$el);
          } else if (this.autoplay === true || this.inView && inView) {
            play(this.$el);
          }
        } } };

    var Resize = {
      connected() {var _this$$options$resize;
        this.registerObserver(
        observeResize(((_this$$options$resize = this.$options.resizeTargets) == null ? void 0 : _this$$options$resize.call(this)) || this.$el, () =>
        this.$emit('resize')));


      } };

    var cover = {
      mixins: [Resize, Video],

      props: {
        width: Number,
        height: Number },


      data: {
        automute: true },


      events: {
        'load loadedmetadata'() {
          this.$emit('resize');
        } },


      resizeTargets() {
        return [this.$el, parent(this.$el)];
      },

      update: {
        read() {
          const el = this.$el;
          const { offsetHeight: height, offsetWidth: width } =
          getPositionedParent(el) || parent(el);
          const dim = Dimensions.cover(
          {
            width: this.width || el.naturalWidth || el.videoWidth || el.clientWidth,
            height: this.height || el.naturalHeight || el.videoHeight || el.clientHeight },

          {
            width: width + (width % 2 ? 1 : 0),
            height: height + (height % 2 ? 1 : 0) });



          if (!dim.width || !dim.height) {
            return false;
          }

          return dim;
        },

        write(_ref) {let { height, width } = _ref;
          css(this.$el, { height, width });
        },

        events: ['resize'] } };



    function getPositionedParent(el) {
      while (el = parent(el)) {
        if (css(el, 'position') !== 'static') {
          return el;
        }
      }
    }

    var Container = {
      props: {
        container: Boolean },


      data: {
        container: true },


      computed: {
        container(_ref) {let { container } = _ref;
          return container === true && this.$container || container && $(container);
        } } };

    var Position = {
      props: {
        pos: String,
        offset: null,
        flip: Boolean },


      data: {
        pos: "bottom-" + (isRtl ? 'right' : 'left'),
        flip: true,
        offset: false },


      connected() {
        this.pos = this.$props.pos.split('-').concat('center').slice(0, 2);
        this.dir = this.pos[0];
        this.align = this.pos[1];
      },

      methods: {
        positionAt(element, target, boundary) {
          const axis = this.getAxis();
          const dir = this.pos[0];
          const align = this.pos[1];

          let { offset: offset$1 } = this;
          if (!isNumeric(offset$1)) {
            const node = $(offset$1);
            offset$1 = node ?
            offset(node)[axis === 'x' ? 'left' : 'top'] -
            offset(target)[axis === 'x' ? 'right' : 'bottom'] :
            0;
          }
          offset$1 = toPx(offset$1) + toPx(getCssVar('position-offset', element));

          const { x, y } = positionAt(
          element,
          target,
          axis === 'x' ? flipPosition(dir) + " " + align : align + " " + flipPosition(dir),
          axis === 'x' ? dir + " " + align : align + " " + dir,
          axis === 'x' ? "" + (
          dir === 'left' ? -offset$1 : offset$1) : " " + (
          dir === 'top' ? -offset$1 : offset$1),
          null,
          this.flip,
          boundary).
          target;

          this.dir = axis === 'x' ? x : y;
          this.align = axis === 'x' ? y : x;
        },

        getAxis() {
          return this.dir === 'top' || this.dir === 'bottom' ? 'y' : 'x';
        } } };

    let active$1;

    var drop = {
      mixins: [Container, Lazyload, Position, Togglable],

      args: 'pos',

      props: {
        mode: 'list',
        toggle: Boolean,
        boundary: Boolean,
        boundaryAlign: Boolean,
        delayShow: Number,
        delayHide: Number,
        clsDrop: String },


      data: {
        mode: ['click', 'hover'],
        toggle: '- *',
        boundary: true,
        boundaryAlign: false,
        delayShow: 0,
        delayHide: 800,
        clsDrop: false,
        animation: ['uk-animation-fade'],
        cls: 'uk-open',
        container: false },


      created() {
        this.tracker = new MouseTracker();
      },

      beforeConnect() {
        this.clsDrop = this.$props.clsDrop || "uk-" + this.$options.name;
      },

      connected() {
        addClass(this.$el, this.clsDrop);

        if (this.toggle && !this.target) {
          this.target = this.$create('toggle', query(this.toggle, this.$el), {
            target: this.$el,
            mode: this.mode }).
          $el;
          attr(this.target, 'aria-haspopup', true);
          this.lazyload(this.target);
        }
      },

      disconnected() {
        if (this.isActive()) {
          active$1 = null;
        }
      },

      events: [
      {
        name: 'click',

        delegate() {
          return "." + this.clsDrop + "-close";
        },

        handler(e) {
          e.preventDefault();
          this.hide(false);
        } },


      {
        name: 'click',

        delegate() {
          return 'a[href^="#"]';
        },

        handler(_ref) {let { defaultPrevented, current: { hash } } = _ref;
          if (!defaultPrevented && hash && !within(hash, this.$el)) {
            this.hide(false);
          }
        } },


      {
        name: 'beforescroll',

        handler() {
          this.hide(false);
        } },


      {
        name: 'toggle',

        self: true,

        handler(e, toggle) {
          e.preventDefault();

          if (this.isToggled()) {
            this.hide(false);
          } else {
            this.show(toggle == null ? void 0 : toggle.$el, false);
          }
        } },


      {
        name: 'toggleshow',

        self: true,

        handler(e, toggle) {
          e.preventDefault();
          this.show(toggle == null ? void 0 : toggle.$el);
        } },


      {
        name: 'togglehide',

        self: true,

        handler(e) {
          e.preventDefault();
          if (!matches(this.$el, ':focus,:hover')) {
            this.hide();
          }
        } },


      {
        name: pointerEnter + " focusin",

        filter() {
          return includes(this.mode, 'hover');
        },

        handler(e) {
          if (!isTouch(e)) {
            this.clearTimers();
          }
        } },


      {
        name: pointerLeave + " focusout",

        filter() {
          return includes(this.mode, 'hover');
        },

        handler(e) {
          if (!isTouch(e) && e.relatedTarget) {
            this.hide();
          }
        } },


      {
        name: 'toggled',

        self: true,

        handler(e, toggled) {
          if (!toggled) {
            return;
          }

          this.clearTimers();
          this.position();
        } },


      {
        name: 'show',

        self: true,

        handler() {
          active$1 = this;

          this.tracker.init();

          for (const handler of [
          on(
          document,
          pointerDown,
          (_ref2) => {let { target } = _ref2;return (
              !within(target, this.$el) &&
              once(
              document,
              pointerUp + " " + pointerCancel + " scroll",
              (_ref3) => {let { defaultPrevented, type, target: newTarget } = _ref3;
                if (
                !defaultPrevented &&
                type === pointerUp &&
                target === newTarget &&
                !(this.target && within(target, this.target)))
                {
                  this.hide(false);
                }
              },
              true));}),



          on(document, 'keydown', (e) => {
            if (e.keyCode === 27) {
              this.hide(false);
            }
          }),
          on(window, 'resize', () => this.$emit()),
          on(
          document,
          'scroll',
          (_ref4) => {let { target } = _ref4;return target.contains(this.$el) && this.$emit();},
          true)])

          {
            once(this.$el, 'hide', handler, { self: true });
          }
        } },


      {
        name: 'beforehide',

        self: true,

        handler() {
          this.clearTimers();
        } },


      {
        name: 'hide',

        handler(_ref5) {let { target } = _ref5;
          if (this.$el !== target) {
            active$1 =
            active$1 === null && within(target, this.$el) && this.isToggled() ?
            this :
            active$1;
            return;
          }

          active$1 = this.isActive() ? null : active$1;
          this.tracker.cancel();
        } }],



      update: {
        write() {
          if (this.isToggled() && !hasClass(this.$el, this.clsEnter)) {
            this.position();
          }
        } },


      methods: {
        show(target, delay) {if (target === void 0) {target = this.target;}if (delay === void 0) {delay = true;}
          if (this.isToggled() && target && this.target && target !== this.target) {
            this.hide(false);
          }

          this.target = target;

          this.clearTimers();

          if (this.isActive()) {
            return;
          }

          if (active$1) {
            if (delay && active$1.isDelaying) {
              this.showTimer = setTimeout(() => matches(target, ':hover') && this.show(), 10);
              return;
            }

            let prev;
            while (active$1 && prev !== active$1 && !within(this.$el, active$1.$el)) {
              prev = active$1;
              active$1.hide(false);
            }
          }

          if (this.container && parent(this.$el) !== this.container) {
            append(this.container, this.$el);
          }

          this.showTimer = setTimeout(
          () => this.toggleElement(this.$el, true),
          delay && this.delayShow || 0);

        },

        hide(delay) {if (delay === void 0) {delay = true;}
          const hide = () => this.toggleElement(this.$el, false, false);

          this.clearTimers();

          this.isDelaying = getPositionedElements(this.$el).some((el) =>
          this.tracker.movesTo(el));


          if (delay && this.isDelaying) {
            this.hideTimer = setTimeout(this.hide, 50);
          } else if (delay && this.delayHide) {
            this.hideTimer = setTimeout(hide, this.delayHide);
          } else {
            hide();
          }
        },

        clearTimers() {
          clearTimeout(this.showTimer);
          clearTimeout(this.hideTimer);
          this.showTimer = null;
          this.hideTimer = null;
          this.isDelaying = false;
        },

        isActive() {
          return active$1 === this;
        },

        position() {
          const boundary = query(this.boundary, this.$el) || window;
          removeClass(this.$el, this.clsDrop + "-stack");
          toggleClass(this.$el, this.clsDrop + "-boundary", this.boundaryAlign);

          const boundaryOffset = offset(boundary);
          const targetOffset = offset(this.target);
          const alignTo = this.boundaryAlign ? boundaryOffset : targetOffset;

          if (this.pos[1] === 'justify') {
            const prop = this.getAxis() === 'y' ? 'width' : 'height';
            css(this.$el, prop, alignTo[prop]);
          } else if (
          this.$el.offsetWidth >
          Math.max(boundaryOffset.right - alignTo.left, alignTo.right - boundaryOffset.left))
          {
            addClass(this.$el, this.clsDrop + "-stack");
          }

          this.positionAt(this.$el, this.boundaryAlign ? boundary : this.target, boundary);
        } } };



    function getPositionedElements(el) {
      const result = [];
      apply(el, (el) => css(el, 'position') !== 'static' && result.push(el));
      return result;
    }

    var formCustom = {
      mixins: [Class],

      args: 'target',

      props: {
        target: Boolean },


      data: {
        target: false },


      computed: {
        input(_, $el) {
          return $(selInput, $el);
        },

        state() {
          return this.input.nextElementSibling;
        },

        target(_ref, $el) {let { target } = _ref;
          return (
            target && (
            target === true && parent(this.input) === $el && this.input.nextElementSibling ||
            $(target, $el)));

        } },


      update() {var _input$files;
        const { target, input } = this;

        if (!target) {
          return;
        }

        let option;
        const prop = isInput(target) ? 'value' : 'textContent';
        const prev = target[prop];
        const value = (_input$files = input.files) != null && _input$files[0] ?
        input.files[0].name :
        matches(input, 'select') && (
        option = $$('option', input).filter((el) => el.selected)[0]) // eslint-disable-line prefer-destructuring
        ? option.textContent :
        input.value;

        if (prev !== value) {
          target[prop] = value;
        }
      },

      events: [
      {
        name: 'change',

        handler() {
          this.$emit();
        } },


      {
        name: 'reset',

        el() {
          return closest(this.$el, 'form');
        },

        handler() {
          this.$emit();
        } }] };

    var Margin = {
      mixins: [Resize],

      props: {
        margin: String,
        firstColumn: Boolean },


      data: {
        margin: 'uk-margin-small-top',
        firstColumn: 'uk-first-column' },


      resizeTargets() {
        return [this.$el, this.$el.children];
      },

      connected() {
        this.registerObserver(
        observeMutation(this.$el, () => this.$reset(), {
          childList: true }));


      },

      update: {
        read() {
          const rows = getRows(this.$el.children);

          return {
            rows,
            columns: getColumns(rows) };

        },

        write(_ref) {let { columns, rows } = _ref;
          for (const row of rows) {
            for (const column of row) {
              toggleClass(column, this.margin, rows[0] !== row);
              toggleClass(column, this.firstColumn, !!~columns[0].indexOf(column));
            }
          }
        },

        events: ['resize'] } };



    function getRows(items) {
      return sortBy(items, 'top', 'bottom');
    }

    function getColumns(rows) {
      const columns = [];

      for (const row of rows) {
        const sorted = sortBy(row, 'left', 'right');
        for (let j = 0; j < sorted.length; j++) {
          columns[j] = columns[j] ? columns[j].concat(sorted[j]) : sorted[j];
        }
      }

      return isRtl ? columns.reverse() : columns;
    }

    function sortBy(items, startProp, endProp) {
      const sorted = [[]];

      for (const el of items) {
        if (!isVisible(el)) {
          continue;
        }

        let dim = getOffset(el);

        for (let i = sorted.length - 1; i >= 0; i--) {
          const current = sorted[i];

          if (!current[0]) {
            current.push(el);
            break;
          }

          let startDim;
          if (current[0].offsetParent === el.offsetParent) {
            startDim = getOffset(current[0]);
          } else {
            dim = getOffset(el, true);
            startDim = getOffset(current[0], true);
          }

          if (dim[startProp] >= startDim[endProp] - 1 && dim[startProp] !== startDim[startProp]) {
            sorted.push([el]);
            break;
          }

          if (dim[endProp] - 1 > startDim[startProp] || dim[startProp] === startDim[startProp]) {
            current.push(el);
            break;
          }

          if (i === 0) {
            sorted.unshift([el]);
            break;
          }
        }
      }

      return sorted;
    }

    function getOffset(element, offset) {if (offset === void 0) {offset = false;}
      let { offsetTop, offsetLeft, offsetHeight, offsetWidth } = element;

      if (offset) {
        [offsetTop, offsetLeft] = offsetPosition(element);
      }

      return {
        top: offsetTop,
        left: offsetLeft,
        bottom: offsetTop + offsetHeight,
        right: offsetLeft + offsetWidth };

    }

    var Scroll = {
      connected() {
        registerScrollListener(this._uid, () => this.$emit('scroll'));
      },

      disconnected() {
        unregisterScrollListener(this._uid);
      } };


    const scrollListeners = new Map();
    let unbindScrollListener;
    function registerScrollListener(id, listener) {
      unbindScrollListener =
      unbindScrollListener ||
      on(window, 'scroll', () => scrollListeners.forEach((listener) => listener()), {
        passive: true,
        capture: true });


      scrollListeners.set(id, listener);
    }

    function unregisterScrollListener(id) {
      scrollListeners.delete(id);
      if (unbindScrollListener && !scrollListeners.size) {
        unbindScrollListener();
        unbindScrollListener = null;
      }
    }

    var grid = {
      extends: Margin,

      mixins: [Class, Scroll],

      name: 'grid',

      props: {
        masonry: Boolean,
        parallax: Number },


      data: {
        margin: 'uk-grid-margin',
        clsStack: 'uk-grid-stack',
        masonry: false,
        parallax: 0 },


      connected() {
        this.masonry && addClass(this.$el, 'uk-flex-top uk-flex-wrap-top');
      },

      update: [
      {
        write(_ref) {let { columns } = _ref;
          toggleClass(this.$el, this.clsStack, columns.length < 2);
        },

        events: ['resize'] },


      {
        read(data) {
          let { columns, rows } = data;

          // Filter component makes elements positioned absolute
          if (
          !columns.length ||
          !this.masonry && !this.parallax ||
          positionedAbsolute(this.$el))
          {
            data.translates = false;
            return false;
          }

          let translates = false;

          const nodes = children(this.$el);
          const columnHeights = getColumnHeights(columns);
          const margin = getMarginTop(nodes, this.margin) * (rows.length - 1);
          const elHeight = Math.max(...columnHeights) + margin;

          if (this.masonry) {
            columns = columns.map((column) => sortBy$1(column, 'offsetTop'));
            translates = getTranslates(rows, columns);
          }

          let padding = Math.abs(this.parallax);
          if (padding) {
            padding = columnHeights.reduce(
            (newPadding, hgt, i) =>
            Math.max(
            newPadding,
            hgt + margin + (i % 2 ? padding : padding / 8) - elHeight),

            0);

          }

          return { padding, columns, translates, height: translates ? elHeight : '' };
        },

        write(_ref2) {let { height, padding } = _ref2;
          css(this.$el, 'paddingBottom', padding || '');
          height !== false && css(this.$el, 'height', height);
        },

        events: ['resize'] },


      {
        read() {
          if (this.parallax && positionedAbsolute(this.$el)) {
            return false;
          }

          return {
            scrolled: this.parallax ?
            scrolledOver(this.$el) * Math.abs(this.parallax) :
            false };

        },

        write(_ref3) {let { columns, scrolled, translates } = _ref3;
          if (scrolled === false && !translates) {
            return;
          }

          columns.forEach((column, i) =>
          column.forEach((el, j) =>
          css(
          el,
          'transform',
          !scrolled && !translates ?
          '' : "translateY(" + (

          (translates && -translates[i][j]) + (
          scrolled ? i % 2 ? scrolled : scrolled / 8 : 0)) + "px)")));




        },

        events: ['scroll', 'resize'] }] };




    function positionedAbsolute(el) {
      return children(el).some((el) => css(el, 'position') === 'absolute');
    }

    function getTranslates(rows, columns) {
      const rowHeights = rows.map((row) => Math.max(...row.map((el) => el.offsetHeight)));

      return columns.map((elements) => {
        let prev = 0;
        return elements.map(
        (element, row) =>
        prev += row ? rowHeights[row - 1] - elements[row - 1].offsetHeight : 0);

      });
    }

    function getMarginTop(nodes, cls) {
      const [node] = nodes.filter((el) => hasClass(el, cls));

      return toFloat(node ? css(node, 'marginTop') : css(nodes[0], 'paddingLeft'));
    }

    function getColumnHeights(columns) {
      return columns.map((column) => column.reduce((sum, el) => sum + el.offsetHeight, 0));
    }

    var heightMatch = {
      mixins: [Resize],

      args: 'target',

      props: {
        target: String,
        row: Boolean },


      data: {
        target: '> *',
        row: true },


      computed: {
        elements: {
          get(_ref, $el) {let { target } = _ref;
            return $$(target, $el);
          },

          watch() {
            this.$reset();
          } } },



      resizeTargets() {
        return [this.$el, this.elements];
      },

      update: {
        read() {
          return {
            rows: (this.row ? getRows(this.elements) : [this.elements]).map(match$1) };

        },

        write(_ref2) {let { rows } = _ref2;
          for (const { heights, elements } of rows) {
            elements.forEach((el, i) => css(el, 'minHeight', heights[i]));
          }
        },

        events: ['resize'] } };



    function match$1(elements) {
      if (elements.length < 2) {
        return { heights: [''], elements };
      }

      css(elements, 'minHeight', '');
      let heights = elements.map(getHeight);
      const max = Math.max(...heights);

      return {
        heights: elements.map((el, i) => heights[i].toFixed(2) === max.toFixed(2) ? '' : max),
        elements };

    }

    function getHeight(element) {
      let style = false;
      if (!isVisible(element)) {
        style = element.style.display;
        css(element, 'display', 'block', 'important');
      }

      const height = dimensions$1(element).height - boxModelAdjust(element, 'height', 'content-box');

      if (style !== false) {
        css(element, 'display', style);
      }

      return height;
    }

    var heightViewport = {
      mixins: [Class, Resize],

      props: {
        expand: Boolean,
        offsetTop: Boolean,
        offsetBottom: Boolean,
        minHeight: Number },


      data: {
        expand: false,
        offsetTop: false,
        offsetBottom: false,
        minHeight: 0 },


      resizeTargets() {
        // check for offsetTop change
        return [this.$el, document.documentElement];
      },

      update: {
        read(_ref) {let { minHeight: prev } = _ref;
          if (!isVisible(this.$el)) {
            return false;
          }

          let minHeight = '';
          const box = boxModelAdjust(this.$el, 'height', 'content-box');

          if (this.expand) {
            minHeight = Math.max(
            height(window) - (
            dimensions$1(document.documentElement).height -
            dimensions$1(this.$el).height) -
            box,
            0);

          } else {
            // on mobile devices (iOS and Android) window.innerHeight !== 100vh
            minHeight = 'calc(100vh';

            if (this.offsetTop) {
              const { top } = offset(this.$el);
              minHeight += top > 0 && top < height(window) / 2 ? " - " + top + "px" : '';
            }

            if (this.offsetBottom === true) {
              minHeight += " - " + dimensions$1(this.$el.nextElementSibling).height + "px";
            } else if (isNumeric(this.offsetBottom)) {
              minHeight += " - " + this.offsetBottom + "vh";
            } else if (this.offsetBottom && endsWith(this.offsetBottom, 'px')) {
              minHeight += " - " + toFloat(this.offsetBottom) + "px";
            } else if (isString(this.offsetBottom)) {
              minHeight += " - " + dimensions$1(query(this.offsetBottom, this.$el)).height + "px";
            }

            minHeight += (box ? " - " + box + "px" : '') + ")";
          }

          return { minHeight, prev };
        },

        write(_ref2) {let { minHeight } = _ref2;
          css(this.$el, { minHeight });

          if (this.minHeight && toFloat(css(this.$el, 'minHeight')) < this.minHeight) {
            css(this.$el, 'minHeight', this.minHeight);
          }
        },

        events: ['resize'] } };

    var SVG = {
      args: 'src',

      props: {
        id: Boolean,
        icon: String,
        src: String,
        style: String,
        width: Number,
        height: Number,
        ratio: Number,
        class: String,
        strokeAnimation: Boolean,
        focusable: Boolean, // IE 11
        attributes: 'list' },


      data: {
        ratio: 1,
        include: ['style', 'class', 'focusable'],
        class: '',
        strokeAnimation: false },


      beforeConnect() {
        this.class += ' uk-svg';
      },

      connected() {
        if (!this.icon && includes(this.src, '#')) {
          [this.src, this.icon] = this.src.split('#');
        }

        this.svg = this.getSvg().then((el) => {
          if (this._connected) {
            const svg = insertSVG(el, this.$el);

            if (this.svgEl && svg !== this.svgEl) {
              remove$1(this.svgEl);
            }

            this.applyAttributes(svg, el);

            return this.svgEl = svg;
          }
        }, noop);

        if (this.strokeAnimation) {
          this.svg.then((el) => {
            if (this._connected) {
              applyAnimation(el);
              this.registerObserver(
              observeIntersection(el, (records, observer) => {
                applyAnimation(el);
                observer.disconnect();
              }));

            }
          });
        }
      },

      disconnected() {
        this.svg.then((svg) => {
          if (this._connected) {
            return;
          }

          if (isVoidElement(this.$el)) {
            this.$el.hidden = false;
          }

          remove$1(svg);
          this.svgEl = null;
        });

        this.svg = null;
      },

      methods: {
        async getSvg() {
          if (isTag(this.$el, 'img') && !this.$el.complete && this.$el.loading === 'lazy') {
            return new Promise((resolve) =>
            once(this.$el, 'load', () => resolve(this.getSvg())));

          }

          return parseSVG(await loadSVG(this.src), this.icon) || Promise.reject('SVG not found.');
        },

        applyAttributes(el, ref) {
          for (const prop in this.$options.props) {
            if (includes(this.include, prop) && prop in this) {
              attr(el, prop, this[prop]);
            }
          }

          for (const attribute in this.attributes) {
            const [prop, value] = this.attributes[attribute].split(':', 2);
            attr(el, prop, value);
          }

          if (!this.id) {
            removeAttr(el, 'id');
          }

          const props = ['width', 'height'];
          let dimensions = props.map((prop) => this[prop]);

          if (!dimensions.some((val) => val)) {
            dimensions = props.map((prop) => attr(ref, prop));
          }

          const viewBox = attr(ref, 'viewBox');
          if (viewBox && !dimensions.some((val) => val)) {
            dimensions = viewBox.split(' ').slice(2);
          }

          dimensions.forEach((val, i) => attr(el, props[i], toFloat(val) * this.ratio || null));
        } } };



    const loadSVG = memoize(async (src) => {
      if (src) {
        if (startsWith(src, 'data:')) {
          return decodeURIComponent(src.split(',')[1]);
        } else {
          return (await fetch(src)).text();
        }
      } else {
        return Promise.reject();
      }
    });

    function parseSVG(svg, icon) {var _svg;
      if (icon && includes(svg, '<symbol')) {
        svg = parseSymbols(svg, icon) || svg;
      }

      svg = $(svg.substr(svg.indexOf('<svg')));
      return ((_svg = svg) == null ? void 0 : _svg.hasChildNodes()) && svg;
    }

    const symbolRe = /<symbol([^]*?id=(['"])(.+?)\2[^]*?<\/)symbol>/g;
    const symbols = {};

    function parseSymbols(svg, icon) {
      if (!symbols[svg]) {
        symbols[svg] = {};

        symbolRe.lastIndex = 0;

        let match;
        while (match = symbolRe.exec(svg)) {
          symbols[svg][match[3]] = "<svg xmlns=\"http://www.w3.org/2000/svg\"" + match[1] + "svg>";
        }
      }

      return symbols[svg][icon];
    }

    function applyAnimation(el) {
      const length = getMaxPathLength(el);

      if (length) {
        el.style.setProperty('--uk-animation-stroke', length);
      }
    }

    function getMaxPathLength(el) {
      return Math.ceil(
      Math.max(
      0,
      ...$$('[stroke]', el).map((stroke) => {
        try {
          return stroke.getTotalLength();
        } catch (e) {
          return 0;
        }
      })));


    }

    function insertSVG(el, root) {
      if (isVoidElement(root) || isTag(root, 'canvas')) {
        root.hidden = true;

        const next = root.nextElementSibling;
        return equals(el, next) ? next : after(root, el);
      }

      const last = root.lastElementChild;
      return equals(el, last) ? last : append(root, el);
    }

    function equals(el, other) {
      return isTag(el, 'svg') && isTag(other, 'svg') && innerHTML(el) === innerHTML(other);
    }

    function innerHTML(el) {
      return (
      el.innerHTML ||
      new XMLSerializer().serializeToString(el).replace(/<svg.*?>(.*?)<\/svg>/g, '$1')).
      replace(/\s/g, '');
    }

    var closeIcon = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"1\" y1=\"1\" x2=\"13\" y2=\"13\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13\" y1=\"1\" x2=\"1\" y2=\"13\"/></svg>";

    var closeLarge = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"1\" y1=\"1\" x2=\"19\" y2=\"19\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"19\" y1=\"1\" x2=\"1\" y2=\"19\"/></svg>";

    var marker = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"4\" width=\"1\" height=\"11\"/><rect x=\"4\" y=\"9\" width=\"11\" height=\"1\"/></svg>";

    var navbarToggleIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"9\" width=\"20\" height=\"2\"/><rect y=\"3\" width=\"20\" height=\"2\"/><rect y=\"15\" width=\"20\" height=\"2\"/></svg>";

    var overlayIcon = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"19\" y=\"0\" width=\"1\" height=\"40\"/><rect x=\"0\" y=\"19\" width=\"40\" height=\"1\"/></svg>";

    var paginationNext = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 1 6 6 1 11\"/></svg>";

    var paginationPrevious = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"6 1 1 6 6 11\"/></svg>";

    var searchIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>";

    var searchLarge = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" cx=\"17.5\" cy=\"17.5\" r=\"16.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" x1=\"38\" y1=\"39\" x2=\"29\" y2=\"30\"/></svg>";

    var searchNavbar = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10.5\" cy=\"10.5\" r=\"9.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"23\" y1=\"23\" x2=\"17\" y2=\"17\"/></svg>";

    var slidenavNext = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"1.225,23 12.775,12 1.225,1 \"/></svg>";

    var slidenavNextLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"4.002,38.547 22.527,20.024 4,1.5 \"/></svg>";

    var slidenavPrevious = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"12.775,1 1.225,12 12.775,23 \"/></svg>";

    var slidenavPreviousLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"20.527,1.5 2,20.024 20.525,38.547 \"/></svg>";

    var spinner = "<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"15\" cy=\"15\" r=\"14\"/></svg>";

    var totop = "<svg width=\"18\" height=\"10\" viewBox=\"0 0 18 10\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 9 9 1 17 9 \"/></svg>";

    const icons = {
      spinner,
      totop,
      marker,
      'close-icon': closeIcon,
      'close-large': closeLarge,
      'navbar-toggle-icon': navbarToggleIcon,
      'overlay-icon': overlayIcon,
      'pagination-next': paginationNext,
      'pagination-previous': paginationPrevious,
      'search-icon': searchIcon,
      'search-large': searchLarge,
      'search-navbar': searchNavbar,
      'slidenav-next': slidenavNext,
      'slidenav-next-large': slidenavNextLarge,
      'slidenav-previous': slidenavPrevious,
      'slidenav-previous-large': slidenavPreviousLarge };


    const Icon = {
      install: install$3,

      extends: SVG,

      args: 'icon',

      props: ['icon'],

      data: {
        include: ['focusable'] },


      isIcon: true,

      beforeConnect() {
        addClass(this.$el, 'uk-icon');
      },

      methods: {
        async getSvg() {
          const icon = getIcon(this.icon);

          if (!icon) {
            throw 'Icon not found.';
          }

          return icon;
        } } };

    const IconComponent = {
      args: false,

      extends: Icon,

      data: (vm) => ({
        icon: hyphenate(vm.constructor.options.name) }),


      beforeConnect() {
        addClass(this.$el, this.$name);
      } };


    const Slidenav = {
      extends: IconComponent,

      beforeConnect() {
        addClass(this.$el, 'uk-slidenav');
        const icon = this.$props.icon;
        this.icon = hasClass(this.$el, 'uk-slidenav-large') ? icon + "-large" : icon;
      } };


    const Search = {
      extends: IconComponent,

      beforeConnect() {
        this.icon =
        hasClass(this.$el, 'uk-search-icon') && parents(this.$el, '.uk-search-large').length ?
        'search-large' :
        parents(this.$el, '.uk-search-navbar').length ?
        'search-navbar' :
        this.$props.icon;
      } };


    const Close = {
      extends: IconComponent,

      beforeConnect() {
        this.icon = "close-" + (hasClass(this.$el, 'uk-close-large') ? 'large' : 'icon');
      } };


    const Spinner = {
      extends: IconComponent,

      methods: {
        async getSvg() {
          const icon = await Icon.methods.getSvg.call(this);

          if (this.ratio !== 1) {
            css($('circle', icon), 'strokeWidth', 1 / this.ratio);
          }

          return icon;
        } } };



    const parsed = {};
    function install$3(UIkit) {
      UIkit.icon.add = (name, svg) => {
        const added = isString(name) ? { [name]: svg } : name;
        each(added, (svg, name) => {
          icons[name] = svg;
          delete parsed[name];
        });

        if (UIkit._initialized) {
          apply(document.body, (el) =>
          each(UIkit.getComponents(el), (cmp) => {
            cmp.$options.isIcon && cmp.icon in added && cmp.$reset();
          }));

        }
      };
    }

    function getIcon(icon) {
      if (!icons[icon]) {
        return null;
      }

      if (!parsed[icon]) {
        parsed[icon] = $((icons[applyRtl(icon)] || icons[icon]).trim());
      }

      return parsed[icon].cloneNode(true);
    }

    function applyRtl(icon) {
      return isRtl ? swap(swap(icon, 'left', 'right'), 'previous', 'next') : icon;
    }

    const nativeLazyLoad = inBrowser && 'loading' in HTMLImageElement.prototype;

    var img = {
      args: 'dataSrc',

      props: {
        dataSrc: String,
        sources: String,
        offsetTop: String,
        offsetLeft: String,
        target: String,
        loading: String },


      data: {
        dataSrc: '',
        sources: false,
        offsetTop: '50vh',
        offsetLeft: '50vw',
        target: false,
        loading: 'lazy' },


      connected() {
        if (this.loading !== 'lazy') {
          this.load();
          return;
        }

        const target = [this.$el, ...queryAll(this.$props.target, this.$el)];

        if (nativeLazyLoad && isImg(this.$el)) {
          this.$el.loading = 'lazy';
          setSrcAttrs(this.$el);

          if (target.length === 1) {
            return;
          }
        }

        ensureSrcAttribute(this.$el);

        this.registerObserver(
        observeIntersection(
        target,
        (entries, observer) => {
          this.load();
          observer.disconnect();
        },
        {
          rootMargin: toPx(this.offsetTop, 'height') + "px " + toPx(
          this.offsetLeft,
          'width') + "px" }));




      },

      disconnected() {
        if (this._data.image) {
          this._data.image.onload = '';
        }
      },

      methods: {
        load() {
          if (this._data.image) {
            return this._data.image;
          }

          const image = isImg(this.$el) ?
          this.$el :
          getImageFromElement(this.$el, this.dataSrc, this.sources);

          removeAttr(image, 'loading');
          setSrcAttrs(this.$el, image.currentSrc);
          return this._data.image = image;
        } } };



    function setSrcAttrs(el, src) {
      if (isImg(el)) {
        const parentNode = parent(el);
        const elements = isPicture(parentNode) ? children(parentNode) : [el];
        elements.forEach((el) => setSourceProps(el, el));
      } else if (src) {
        const change = !includes(el.style.backgroundImage, src);
        if (change) {
          css(el, 'backgroundImage', "url(" + escape(src) + ")");
          trigger(el, createEvent('load', false));
        }
      }
    }

    const srcProps = ['data-src', 'data-srcset', 'sizes'];
    function setSourceProps(sourceEl, targetEl) {
      srcProps.forEach((prop) => {
        const value = data(sourceEl, prop);
        if (value) {
          attr(targetEl, prop.replace(/^(data-)+/, ''), value);
        }
      });
    }

    function getImageFromElement(el, src, sources) {
      const img = new Image();

      wrapInPicture(img, sources);
      setSourceProps(el, img);
      img.onload = () => {
        setSrcAttrs(el, img.currentSrc);
      };
      attr(img, 'src', src);
      return img;
    }

    function wrapInPicture(img, sources) {
      sources = parseSources(sources);

      if (sources.length) {
        const picture = fragment('<picture>');
        for (const attrs of sources) {
          const source = fragment('<source>');
          attr(source, attrs);
          append(picture, source);
        }
        append(picture, img);
      }
    }

    function parseSources(sources) {
      if (!sources) {
        return [];
      }

      if (startsWith(sources, '[')) {
        try {
          sources = JSON.parse(sources);
        } catch (e) {
          sources = [];
        }
      } else {
        sources = parseOptions(sources);
      }

      if (!isArray(sources)) {
        sources = [sources];
      }

      return sources.filter((source) => !isEmpty(source));
    }

    function ensureSrcAttribute(el) {
      if (isImg(el) && !hasAttr(el, 'src')) {
        attr(el, 'src', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg"></svg>');
      }
    }

    function isPicture(el) {
      return isTag(el, 'picture');
    }

    function isImg(el) {
      return isTag(el, 'img');
    }

    var Media = {
      props: {
        media: Boolean },


      data: {
        media: false },


      connected() {
        const media = toMedia(this.media);
        this.mediaObj = window.matchMedia(media);
        const handler = () => {
          this.matchMedia = this.mediaObj.matches;
          trigger(this.$el, createEvent('mediachange', false, true, [this.mediaObj]));
        };
        this.offMediaObj = on(this.mediaObj, 'change', () => {
          handler();
          this.$emit('resize');
        });
        handler();
      },

      disconnected() {var _this$offMediaObj;
        (_this$offMediaObj = this.offMediaObj) == null ? void 0 : _this$offMediaObj.call(this);
      } };


    function toMedia(value) {
      if (isString(value)) {
        if (startsWith(value, '@')) {
          const name = "breakpoint-" + value.substr(1);
          value = toFloat(getCssVar(name));
        } else if (isNaN(value)) {
          return value;
        }
      }

      return value && isNumeric(value) ? "(min-width: " + value + "px)" : '';
    }

    var leader = {
      mixins: [Class, Media, Resize],

      props: {
        fill: String },


      data: {
        fill: '',
        clsWrapper: 'uk-leader-fill',
        clsHide: 'uk-leader-hide',
        attrFill: 'data-fill' },


      computed: {
        fill(_ref) {let { fill } = _ref;
          return fill || getCssVar('leader-fill-content');
        } },


      connected() {
        [this.wrapper] = wrapInner(this.$el, "<span class=\"" + this.clsWrapper + "\">");
      },

      disconnected() {
        unwrap(this.wrapper.childNodes);
      },

      update: {
        read() {
          const width = Math.trunc(this.$el.offsetWidth / 2);

          return {
            width,
            fill: this.fill,
            hide: !this.matchMedia };

        },

        write(_ref2) {let { width, fill, hide } = _ref2;
          toggleClass(this.wrapper, this.clsHide, hide);
          attr(this.wrapper, this.attrFill, new Array(width).join(fill));
        },

        events: ['resize'] } };

    const active = [];

    var Modal = {
      mixins: [Class, Container, Togglable],

      props: {
        selPanel: String,
        selClose: String,
        escClose: Boolean,
        bgClose: Boolean,
        stack: Boolean },


      data: {
        cls: 'uk-open',
        escClose: true,
        bgClose: true,
        overlay: true,
        stack: false },


      computed: {
        panel(_ref, $el) {let { selPanel } = _ref;
          return $(selPanel, $el);
        },

        transitionElement() {
          return this.panel;
        },

        bgClose(_ref2) {let { bgClose } = _ref2;
          return bgClose && this.panel;
        } },


      beforeDisconnect() {
        if (includes(active, this)) {
          this.toggleElement(this.$el, false, false);
        }
      },

      events: [
      {
        name: 'click',

        delegate() {
          return this.selClose;
        },

        handler(e) {
          e.preventDefault();
          this.hide();
        } },


      {
        name: 'toggle',

        self: true,

        handler(e) {
          if (e.defaultPrevented) {
            return;
          }

          e.preventDefault();

          if (this.isToggled() === includes(active, this)) {
            this.toggle();
          }
        } },


      {
        name: 'beforeshow',

        self: true,

        handler(e) {
          if (includes(active, this)) {
            return false;
          }

          if (!this.stack && active.length) {
            Promise.all(active.map((modal) => modal.hide())).then(this.show);
            e.preventDefault();
          } else {
            active.push(this);
          }
        } },


      {
        name: 'show',

        self: true,

        handler() {
          const docEl = document.documentElement;

          if (width(window) > docEl.clientWidth && this.overlay) {
            css(document.body, 'overflowY', 'scroll');
          }

          if (this.stack) {
            css(this.$el, 'zIndex', toFloat(css(this.$el, 'zIndex')) + active.length);
          }

          addClass(docEl, this.clsPage);

          if (this.bgClose) {
            once(
            this.$el,
            'hide',
            on(document, pointerDown, (_ref3) => {let { target } = _ref3;
              if (
              last(active) !== this ||
              this.overlay && !within(target, this.$el) ||
              within(target, this.panel))
              {
                return;
              }

              once(
              document,
              pointerUp + " " + pointerCancel + " scroll",
              (_ref4) => {let { defaultPrevented, type, target: newTarget } = _ref4;
                if (
                !defaultPrevented &&
                type === pointerUp &&
                target === newTarget)
                {
                  this.hide();
                }
              },
              true);

            }),
            { self: true });

          }

          if (this.escClose) {
            once(
            this.$el,
            'hide',
            on(document, 'keydown', (e) => {
              if (e.keyCode === 27 && last(active) === this) {
                this.hide();
              }
            }),
            { self: true });

          }
        } },


      {
        name: 'shown',

        self: true,

        handler() {
          if (!isFocusable(this.$el)) {
            attr(this.$el, 'tabindex', '-1');
          }

          if (!$(':focus', this.$el)) {
            this.$el.focus();
          }
        } },


      {
        name: 'hidden',

        self: true,

        handler() {
          if (includes(active, this)) {
            active.splice(active.indexOf(this), 1);
          }

          if (!active.length) {
            css(document.body, 'overflowY', '');
          }

          css(this.$el, 'zIndex', '');

          if (!active.some((modal) => modal.clsPage === this.clsPage)) {
            removeClass(document.documentElement, this.clsPage);
          }
        } }],



      methods: {
        toggle() {
          return this.isToggled() ? this.hide() : this.show();
        },

        show() {
          if (this.container && parent(this.$el) !== this.container) {
            append(this.container, this.$el);
            return new Promise((resolve) =>
            requestAnimationFrame(() => this.show().then(resolve)));

          }

          return this.toggleElement(this.$el, true, animate(this));
        },

        hide() {
          return this.toggleElement(this.$el, false, animate(this));
        } } };



    function animate(_ref5) {let { transitionElement, _toggle } = _ref5;
      return (el, show) =>
      new Promise((resolve, reject) =>
      once(el, 'show hide', () => {
        el._reject && el._reject();
        el._reject = reject;

        _toggle(el, show);

        const off = once(
        transitionElement,
        'transitionstart',
        () => {
          once(transitionElement, 'transitionend transitioncancel', resolve, {
            self: true });

          clearTimeout(timer);
        },
        { self: true });


        const timer = setTimeout(() => {
          off();
          resolve();
        }, toMs(css(transitionElement, 'transitionDuration')));
      })).
      then(() => delete el._reject);
    }

    var modal = {
      install: install$2,

      mixins: [Modal],

      data: {
        clsPage: 'uk-modal-page',
        selPanel: '.uk-modal-dialog',
        selClose:
        '.uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full' },


      events: [
      {
        name: 'show',

        self: true,

        handler() {
          if (hasClass(this.panel, 'uk-margin-auto-vertical')) {
            addClass(this.$el, 'uk-flex');
          } else {
            css(this.$el, 'display', 'block');
          }

          height(this.$el); // force reflow
        } },


      {
        name: 'hidden',

        self: true,

        handler() {
          css(this.$el, 'display', '');
          removeClass(this.$el, 'uk-flex');
        } }] };




    function install$2(_ref) {let { modal } = _ref;
      modal.dialog = function (content, options) {
        const dialog = modal("<div class=\"uk-modal\"> <div class=\"uk-modal-dialog\">" +

        content + "</div> </div>",

        options);


        dialog.show();

        on(
        dialog.$el,
        'hidden',
        async () => {
          await Promise.resolve();
          dialog.$destroy(true);
        },
        { self: true });


        return dialog;
      };

      modal.alert = function (message, options) {
        return openDialog(
        (_ref2) => {let { labels } = _ref2;return "<div class=\"uk-modal-body\">" + (
          isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-primary uk-modal-close\" autofocus>" +



          labels.ok + "</button> </div>";},


        options,
        (deferred) => deferred.resolve());

      };

      modal.confirm = function (message, options) {
        return openDialog(
        (_ref3) => {let { labels } = _ref3;return "<form> <div class=\"uk-modal-body\">" + (
          isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" +


          labels.cancel + "</button> <button class=\"uk-button uk-button-primary\" autofocus>" +

          labels.ok + "</button> </div> </form>";},


        options,
        (deferred) => deferred.reject());

      };

      modal.prompt = function (message, value, options) {
        return openDialog(
        (_ref4) => {let { labels } = _ref4;return "<form class=\"uk-form-stacked\"> <div class=\"uk-modal-body\"> <label>" + (

          isString(message) ? message : html(message)) + "</label> <input class=\"uk-input\" value=\"" + (
          value || '') + "\" autofocus> </div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" +



          labels.cancel + "</button> <button class=\"uk-button uk-button-primary\">" +

          labels.ok + "</button> </div> </form>";},


        options,
        (deferred) => deferred.resolve(null),
        (dialog) => $('input', dialog.$el).value);

      };

      modal.labels = {
        ok: 'Ok',
        cancel: 'Cancel' };


      function openDialog(tmpl, options, hideFn, submitFn) {
        options = { bgClose: false, escClose: true, labels: modal.labels, ...options };

        const dialog = modal.dialog(tmpl(options), options);
        const deferred = new Deferred();

        let resolved = false;

        on(dialog.$el, 'submit', 'form', (e) => {
          e.preventDefault();
          deferred.resolve(submitFn == null ? void 0 : submitFn(dialog));
          resolved = true;
          dialog.hide();
        });

        on(dialog.$el, 'hide', () => !resolved && hideFn(deferred));

        deferred.promise.dialog = dialog;

        return deferred.promise;
      }
    }

    var nav = {
      extends: Accordion,

      data: {
        targets: '> .uk-parent',
        toggle: '> a',
        content: '> ul' } };

    const navItem = '.uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle';

    var navbar = {
      mixins: [Class, Container],

      props: {
        dropdown: String,
        mode: 'list',
        align: String,
        offset: Number,
        boundary: Boolean,
        boundaryAlign: Boolean,
        clsDrop: String,
        delayShow: Number,
        delayHide: Number,
        dropbar: Boolean,
        dropbarAnchor: Boolean,
        duration: Number },


      data: {
        dropdown: navItem,
        align: isRtl ? 'right' : 'left',
        clsDrop: 'uk-navbar-dropdown',
        mode: undefined,
        offset: undefined,
        delayShow: undefined,
        delayHide: undefined,
        boundaryAlign: undefined,
        flip: 'x',
        boundary: true,
        dropbar: false,
        dropbarAnchor: false,
        duration: 200,
        container: false },


      computed: {
        boundary(_ref, $el) {let { boundary } = _ref;
          return boundary === true ? $el : boundary;
        },

        dropbarAnchor(_ref2, $el) {let { dropbarAnchor } = _ref2;
          return query(dropbarAnchor, $el);
        },

        pos(_ref3) {let { align } = _ref3;
          return "bottom-" + align;
        },

        dropbar: {
          get(_ref4) {let { dropbar } = _ref4;
            if (!dropbar) {
              return null;
            }

            dropbar =
            this._dropbar ||
            query(dropbar, this.$el) ||
            $('+ .uk-navbar-dropbar', this.$el);

            return dropbar ? dropbar : this._dropbar = $('<div></div>');
          },

          watch(dropbar) {
            addClass(dropbar, 'uk-navbar-dropbar');
          },

          immediate: true },


        dropContainer(_, $el) {
          return this.container || $el;
        },

        dropdowns: {
          get(_ref5, $el) {let { clsDrop } = _ref5;
            const dropdowns = $$("." + clsDrop, $el);

            if (this.dropContainer !== $el) {
              for (const el of $$("." + clsDrop, this.dropContainer)) {var _this$getDropdown;
                const target = (_this$getDropdown = this.getDropdown(el)) == null ? void 0 : _this$getDropdown.target;
                if (!includes(dropdowns, el) && target && within(target, this.$el)) {
                  dropdowns.push(el);
                }
              }
            }

            return dropdowns;
          },

          watch(dropdowns) {
            this.$create(
            'drop',
            dropdowns.filter((el) => !this.getDropdown(el)),
            {
              ...this.$props,
              boundary: this.boundary,
              pos: this.pos,
              offset: this.dropbar || this.offset });


          },

          immediate: true },


        toggles(_ref6, $el) {let { dropdown } = _ref6;
          return $$(dropdown, $el);
        } },


      disconnected() {
        this.dropbar && remove$1(this.dropbar);
        delete this._dropbar;
      },

      events: [
      {
        name: 'mouseover focusin',

        delegate() {
          return this.dropdown;
        },

        handler(_ref7) {let { current } = _ref7;
          const active = this.getActive();
          if (
          active &&
          includes(active.mode, 'hover') &&
          active.target &&
          !within(active.target, current) &&
          !active.isDelaying)
          {
            active.hide(false);
          }
        } },


      {
        name: 'keydown',

        delegate() {
          return this.dropdown;
        },

        handler(e) {
          const { current, keyCode } = e;
          const active = this.getActive();

          if (keyCode === keyMap.DOWN && hasAttr(current, 'aria-expanded')) {
            e.preventDefault();

            if (!active || active.target !== current) {
              current.click();
              once(this.dropContainer, 'show', (_ref8) => {let { target } = _ref8;return (
                  focusFirstFocusableElement(target));});

            } else {
              focusFirstFocusableElement(active.$el);
            }
          }

          handleNavItemNavigation(e, this.toggles, active);
        } },


      {
        name: 'keydown',

        el() {
          return this.dropContainer;
        },

        delegate() {
          return "." + this.clsDrop;
        },

        handler(e) {
          const { current, keyCode } = e;

          if (!includes(this.dropdowns, current)) {
            return;
          }

          const active = this.getActive();
          const elements = $$(selFocusable, current);
          const i = findIndex(elements, (el) => matches(el, ':focus'));

          if (keyCode === keyMap.UP) {
            e.preventDefault();
            if (i > 0) {
              elements[i - 1].focus();
            }
          }

          if (keyCode === keyMap.DOWN) {
            e.preventDefault();
            if (i < elements.length - 1) {
              elements[i + 1].focus();
            }
          }

          if (keyCode === keyMap.ESC) {var _active$target;
            active == null ? void 0 : (_active$target = active.target) == null ? void 0 : _active$target.focus();
          }

          handleNavItemNavigation(e, this.toggles, active);
        } },


      {
        name: 'mouseleave',

        el() {
          return this.dropbar;
        },

        filter() {
          return this.dropbar;
        },

        handler() {
          const active = this.getActive();

          if (
          active &&
          includes(active.mode, 'hover') &&
          !this.dropdowns.some((el) => matches(el, ':hover')))
          {
            active.hide();
          }
        } },


      {
        name: 'beforeshow',

        el() {
          return this.dropContainer;
        },

        filter() {
          return this.dropbar;
        },

        handler(_, _ref9) {let { $el } = _ref9;
          if (!hasClass($el, this.clsDrop)) {
            return;
          }

          if (!parent(this.dropbar)) {
            after(this.dropbarAnchor || this.$el, this.dropbar);
          }

          addClass($el, this.clsDrop + "-dropbar");
        } },


      {
        name: 'show',

        el() {
          return this.dropContainer;
        },

        filter() {
          return this.dropbar;
        },

        handler(_, _ref10) {let { $el, dir } = _ref10;
          if (!hasClass($el, this.clsDrop)) {
            return;
          }

          if (dir === 'bottom') {
            this.transitionTo(
            offset($el).bottom -
            offset(this.dropbar).top +
            toFloat(css($el, 'marginBottom')),
            $el);

          }
        } },


      {
        name: 'beforehide',

        el() {
          return this.dropContainer;
        },

        filter() {
          return this.dropbar;
        },

        handler(e, _ref11) {let { $el } = _ref11;
          const active = this.getActive();

          if (
          matches(this.dropbar, ':hover') &&
          (active == null ? void 0 : active.$el) === $el &&
          !this.toggles.some((el) => active.target !== el && matches(el, ':focus')))
          {
            e.preventDefault();
          }
        } },


      {
        name: 'hide',

        el() {
          return this.dropContainer;
        },

        filter() {
          return this.dropbar;
        },

        handler(_, _ref12) {let { $el } = _ref12;
          if (!hasClass($el, this.clsDrop)) {
            return;
          }

          const active = this.getActive();

          if (!active || (active == null ? void 0 : active.$el) === $el) {
            this.transitionTo(0);
          }
        } }],



      methods: {
        getActive() {
          return active$1 && within(active$1.target, this.$el) && active$1;
        },

        transitionTo(newHeight, el) {
          const { dropbar } = this;
          const oldHeight = isVisible(dropbar) ? height(dropbar) : 0;

          el = oldHeight < newHeight && el;

          css(el, 'clip', "rect(0," + el.offsetWidth + "px," + oldHeight + "px,0)");

          height(dropbar, oldHeight);

          Transition.cancel([el, dropbar]);
          return Promise.all([
          Transition.start(dropbar, { height: newHeight }, this.duration),
          Transition.start(
          el,
          { clip: "rect(0," + el.offsetWidth + "px," + newHeight + "px,0)" },
          this.duration)]).


          catch(noop).
          then(() => {
            css(el, { clip: '' });
            this.$update(dropbar);
          });
        },

        getDropdown(el) {
          return this.$getComponent(el, 'drop') || this.$getComponent(el, 'dropdown');
        } } };



    function handleNavItemNavigation(e, toggles, active) {
      const { current, keyCode } = e;
      const target = (active == null ? void 0 : active.target) || current;
      const i = toggles.indexOf(target);

      // Left
      if (keyCode === keyMap.LEFT && i > 0) {
        active == null ? void 0 : active.hide(false);
        toggles[i - 1].focus();
      }

      // Right
      if (keyCode === keyMap.RIGHT && i < toggles.length - 1) {
        active == null ? void 0 : active.hide(false);
        toggles[i + 1].focus();
      }

      if (keyCode === keyMap.TAB) {
        target.focus();
        active == null ? void 0 : active.hide(false);
      }
    }

    function focusFirstFocusableElement(el) {
      if (!$(':focus', el)) {var _$;
        (_$ = $(selFocusable, el)) == null ? void 0 : _$.focus();
      }
    }

    const keyMap = {
      TAB: 9,
      ESC: 27,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40 };

    var Swipe = {
      props: {
        swiping: Boolean },


      data: {
        swiping: true },


      computed: {
        swipeTarget(props, $el) {
          return $el;
        } },


      connected() {
        if (!this.swiping) {
          return;
        }

        registerEvent(this, {
          el: this.swipeTarget,
          name: pointerDown,
          passive: true,
          handler(e) {
            if (!isTouch(e)) {
              return;
            }

            // Handle Swipe Gesture
            const pos = getEventPos(e);
            const target = 'tagName' in e.target ? e.target : parent(e.target);
            once(document, pointerUp + " " + pointerCancel + " scroll", (e) => {
              const { x, y } = getEventPos(e);

              // swipe
              if (
              e.type !== 'scroll' && target && x && Math.abs(pos.x - x) > 100 ||
              y && Math.abs(pos.y - y) > 100)
              {
                setTimeout(() => {
                  trigger(target, 'swipe');
                  trigger(target, "swipe" + swipeDirection(pos.x, pos.y, x, y));
                });
              }
            });
          } });

      } };


    function swipeDirection(x1, y1, x2, y2) {
      return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ?
      x1 - x2 > 0 ?
      'Left' :
      'Right' :
      y1 - y2 > 0 ?
      'Up' :
      'Down';
    }

    var offcanvas = {
      mixins: [Modal, Swipe],

      args: 'mode',

      props: {
        mode: String,
        flip: Boolean,
        overlay: Boolean },


      data: {
        mode: 'slide',
        flip: false,
        overlay: false,
        clsPage: 'uk-offcanvas-page',
        clsContainer: 'uk-offcanvas-container',
        selPanel: '.uk-offcanvas-bar',
        clsFlip: 'uk-offcanvas-flip',
        clsContainerAnimation: 'uk-offcanvas-container-animation',
        clsSidebarAnimation: 'uk-offcanvas-bar-animation',
        clsMode: 'uk-offcanvas',
        clsOverlay: 'uk-offcanvas-overlay',
        selClose: '.uk-offcanvas-close',
        container: false },


      computed: {
        clsFlip(_ref) {let { flip, clsFlip } = _ref;
          return flip ? clsFlip : '';
        },

        clsOverlay(_ref2) {let { overlay, clsOverlay } = _ref2;
          return overlay ? clsOverlay : '';
        },

        clsMode(_ref3) {let { mode, clsMode } = _ref3;
          return clsMode + "-" + mode;
        },

        clsSidebarAnimation(_ref4) {let { mode, clsSidebarAnimation } = _ref4;
          return mode === 'none' || mode === 'reveal' ? '' : clsSidebarAnimation;
        },

        clsContainerAnimation(_ref5) {let { mode, clsContainerAnimation } = _ref5;
          return mode !== 'push' && mode !== 'reveal' ? '' : clsContainerAnimation;
        },

        transitionElement(_ref6) {let { mode } = _ref6;
          return mode === 'reveal' ? parent(this.panel) : this.panel;
        } },


      update: {
        read() {
          if (this.isToggled() && !isVisible(this.$el)) {
            this.hide();
          }
        },

        events: ['resize'] },


      events: [
      {
        name: 'click',

        delegate() {
          return 'a[href^="#"]';
        },

        handler(_ref7) {let { current: { hash }, defaultPrevented } = _ref7;
          if (!defaultPrevented && hash && $(hash, document.body)) {
            this.hide();
          }
        } },


      {
        name: 'touchstart',

        passive: true,

        el() {
          return this.panel;
        },

        handler(_ref8) {let { targetTouches } = _ref8;
          if (targetTouches.length === 1) {
            this.clientY = targetTouches[0].clientY;
          }
        } },


      {
        name: 'touchmove',

        self: true,
        passive: false,

        filter() {
          return this.overlay;
        },

        handler(e) {
          e.cancelable && e.preventDefault();
        } },


      {
        name: 'touchmove',

        passive: false,

        el() {
          return this.panel;
        },

        handler(e) {
          if (e.targetTouches.length !== 1) {
            return;
          }

          const clientY = e.targetTouches[0].clientY - this.clientY;
          const { scrollTop, scrollHeight, clientHeight } = this.panel;

          if (
          clientHeight >= scrollHeight ||
          scrollTop === 0 && clientY > 0 ||
          scrollHeight - scrollTop <= clientHeight && clientY < 0)
          {
            e.cancelable && e.preventDefault();
          }
        } },


      {
        name: 'show',

        self: true,

        handler() {
          if (this.mode === 'reveal' && !hasClass(parent(this.panel), this.clsMode)) {
            wrapAll(this.panel, '<div>');
            addClass(parent(this.panel), this.clsMode);
          }

          css(document.documentElement, 'overflowY', this.overlay ? 'hidden' : '');
          addClass(document.body, this.clsContainer, this.clsFlip);
          css(document.body, 'touch-action', 'pan-y pinch-zoom');
          css(this.$el, 'display', 'block');
          addClass(this.$el, this.clsOverlay);
          addClass(
          this.panel,
          this.clsSidebarAnimation,
          this.mode !== 'reveal' ? this.clsMode : '');


          height(document.body); // force reflow
          addClass(document.body, this.clsContainerAnimation);

          this.clsContainerAnimation && suppressUserScale();
        } },


      {
        name: 'hide',

        self: true,

        handler() {
          removeClass(document.body, this.clsContainerAnimation);
          css(document.body, 'touch-action', '');
        } },


      {
        name: 'hidden',

        self: true,

        handler() {
          this.clsContainerAnimation && resumeUserScale();

          if (this.mode === 'reveal') {
            unwrap(this.panel);
          }

          removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);
          removeClass(this.$el, this.clsOverlay);
          css(this.$el, 'display', '');
          removeClass(document.body, this.clsContainer, this.clsFlip);

          css(document.documentElement, 'overflowY', '');
        } },


      {
        name: 'swipeLeft swipeRight',

        handler(e) {
          if (this.isToggled() && endsWith(e.type, 'Left') ^ this.flip) {
            this.hide();
          }
        } }] };




    // Chrome in responsive mode zooms page upon opening offcanvas
    function suppressUserScale() {
      getViewport().content += ',user-scalable=0';
    }

    function resumeUserScale() {
      const viewport = getViewport();
      viewport.content = viewport.content.replace(/,user-scalable=0$/, '');
    }

    function getViewport() {
      return (
        $('meta[name="viewport"]', document.head) || append(document.head, '<meta name="viewport">'));

    }

    var overflowAuto = {
      mixins: [Class, Resize],

      props: {
        selContainer: String,
        selContent: String,
        minHeight: Number },


      data: {
        selContainer: '.uk-modal',
        selContent: '.uk-modal-dialog',
        minHeight: 150 },


      computed: {
        container(_ref, $el) {let { selContainer } = _ref;
          return closest($el, selContainer);
        },

        content(_ref2, $el) {let { selContent } = _ref2;
          return closest($el, selContent);
        } },


      resizeTargets() {
        return [this.container, this.content];
      },

      update: {
        read() {
          if (!this.content || !this.container || !isVisible(this.$el)) {
            return false;
          }

          return {
            max: Math.max(
            this.minHeight,
            height(this.container) - (dimensions$1(this.content).height - height(this.$el))) };


        },

        write(_ref3) {let { max } = _ref3;
          css(this.$el, { minHeight: this.minHeight, maxHeight: max });
        },

        events: ['resize'] } };

    var responsive = {
      mixins: [Resize],

      props: ['width', 'height'],

      resizeTargets() {
        return [this.$el, parent(this.$el)];
      },

      connected() {
        addClass(this.$el, 'uk-responsive-width');
      },

      update: {
        read() {
          return isVisible(this.$el) && this.width && this.height ?
          { width: width(parent(this.$el)), height: this.height } :
          false;
        },

        write(dim) {
          height(
          this.$el,
          Dimensions.contain(
          {
            height: this.height,
            width: this.width },

          dim).
          height);

        },

        events: ['resize'] } };

    var scroll = {
      props: {
        offset: Number },


      data: {
        offset: 0 },


      methods: {
        async scrollTo(el) {
          el = el && $(el) || document.body;

          if (trigger(this.$el, 'beforescroll', [this, el])) {
            await scrollIntoView(el, { offset: this.offset });
            trigger(this.$el, 'scrolled', [this, el]);
          }
        } },


      events: {
        click(e) {
          if (e.defaultPrevented) {
            return;
          }

          e.preventDefault();
          this.scrollTo(getTargetElement(this.$el));
        } } };



    function getTargetElement(el) {
      return document.getElementById(decodeURIComponent(el.hash).substring(1));
    }

    var scrollspy = {
      mixins: [Scroll],

      args: 'cls',

      props: {
        cls: String,
        target: String,
        hidden: Boolean,
        offsetTop: Number,
        offsetLeft: Number,
        repeat: Boolean,
        delay: Number },


      data: () => ({
        cls: '',
        target: false,
        hidden: true,
        offsetTop: 0,
        offsetLeft: 0,
        repeat: false,
        delay: 0,
        inViewClass: 'uk-scrollspy-inview' }),


      computed: {
        elements: {
          get(_ref, $el) {let { target } = _ref;
            return target ? $$(target, $el) : [$el];
          },

          watch(elements, prev) {
            if (this.hidden) {
              css(filter$1(elements, ":not(." + this.inViewClass + ")"), 'visibility', 'hidden');
            }

            if (prev) {
              this.$reset();
            }
          },

          immediate: true } },



      connected() {
        this._data.elements = new Map();
        this.registerObserver(
        observeIntersection(
        this.elements,
        (records) => {
          const elements = this._data.elements;
          for (const { target: el, isIntersecting } of records) {
            if (!elements.has(el)) {
              elements.set(el, {
                cls: data(el, 'uk-scrollspy-class') || this.cls });

            }

            const state = elements.get(el);
            if (!this.repeat && state.show) {
              continue;
            }

            state.show = isIntersecting;
          }

          this.$emit();
        },
        {
          rootMargin: toPx(this.offsetTop, 'height') - 1 + "px " + (
          toPx(this.offsetLeft, 'width') - 1) + "px" },


        false));


      },

      disconnected() {
        for (const [el, state] of this._data.elements.entries()) {
          removeClass(el, this.inViewClass, (state == null ? void 0 : state.cls) || '');
        }
      },

      update: [
      {
        write(data) {
          for (const [el, state] of data.elements.entries()) {
            if (state.show && !state.inview && !state.queued) {
              state.queued = true;

              data.promise = (data.promise || Promise.resolve()).
              then(() => new Promise((resolve) => setTimeout(resolve, this.delay))).
              then(() => {
                this.toggle(el, true);
                setTimeout(() => {
                  state.queued = false;
                  this.$emit();
                }, 300);
              });
            } else if (!state.show && state.inview && !state.queued && this.repeat) {
              this.toggle(el, false);
            }
          }
        } }],



      methods: {
        toggle(el, inview) {
          const state = this._data.elements.get(el);

          state.off == null ? void 0 : state.off();

          css(el, 'visibility', !inview && this.hidden ? 'hidden' : '');

          toggleClass(el, this.inViewClass, inview);
          toggleClass(el, state.cls);

          if (/\buk-animation-/.test(state.cls)) {
            const removeAnimationClasses = () => removeClasses(el, 'uk-animation-[\\w-]+');
            if (inview) {
              state.off = once(el, 'animationcancel animationend', removeAnimationClasses);
            } else {
              removeAnimationClasses();
            }
          }

          trigger(el, inview ? 'inview' : 'outview');

          state.inview = inview;

          this.$update(el);
        } } };

    var scrollspyNav = {
      mixins: [Scroll],

      props: {
        cls: String,
        closest: String,
        scroll: Boolean,
        overflow: Boolean,
        offset: Number },


      data: {
        cls: 'uk-active',
        closest: false,
        scroll: false,
        overflow: true,
        offset: 0 },


      computed: {
        links: {
          get(_, $el) {
            return $$('a[href^="#"]', $el).filter((el) => el.hash);
          },

          watch(links) {
            if (this.scroll) {
              this.$create('scroll', links, { offset: this.offset || 0 });
            }
          },

          immediate: true },


        elements(_ref) {let { closest: selector } = _ref;
          return closest(this.links, selector || '*');
        } },


      update: [
      {
        read() {
          const targets = this.links.map(getTargetElement).filter(Boolean);

          const { length } = targets;

          if (!length || !isVisible(this.$el)) {
            return false;
          }

          const [scrollElement] = scrollParents(targets, /auto|scroll/, true);
          const { scrollTop, scrollHeight } = scrollElement;
          const max = scrollHeight - getViewportClientHeight(scrollElement);
          let active = false;

          if (scrollTop === max) {
            active = length - 1;
          } else {
            for (const i in targets) {
              if (
              offset(targets[i]).top -
              offset(getViewport$1(scrollElement)).top -
              this.offset >
              0)
              {
                break;
              }
              active = +i;
            }

            if (active === false && this.overflow) {
              active = 0;
            }
          }

          return { active };
        },

        write(_ref2) {let { active } = _ref2;
          const changed = active !== false && !hasClass(this.elements[active], this.cls);

          this.links.forEach((el) => el.blur());
          for (const i in this.elements) {
            toggleClass(this.elements[i], this.cls, +i === active);
          }

          if (changed) {
            trigger(this.$el, 'active', [active, this.elements[active]]);
          }
        },

        events: ['scroll', 'resize'] }] };

    var sticky = {
      mixins: [Class, Media, Resize, Scroll],

      props: {
        position: String,
        top: null,
        bottom: Boolean,
        offset: String,
        animation: String,
        clsActive: String,
        clsInactive: String,
        clsFixed: String,
        clsBelow: String,
        selTarget: String,
        showOnUp: Boolean,
        targetOffset: Number },


      data: {
        position: 'top',
        top: 0,
        bottom: false,
        offset: 0,
        animation: '',
        clsActive: 'uk-active',
        clsInactive: '',
        clsFixed: 'uk-sticky-fixed',
        clsBelow: 'uk-sticky-below',
        selTarget: '',
        showOnUp: false,
        targetOffset: false },


      computed: {
        selTarget(_ref, $el) {let { selTarget } = _ref;
          return selTarget && $(selTarget, $el) || $el;
        } },


      resizeTargets() {
        return document.documentElement;
      },

      connected() {
        this.placeholder =
        $('+ .uk-sticky-placeholder', this.$el) ||
        $('<div class="uk-sticky-placeholder"></div>');
        this.isFixed = false;
        this.setActive(false);
      },

      disconnected() {
        if (this.isFixed) {
          this.hide();
          removeClass(this.selTarget, this.clsInactive);
        }

        remove$1(this.placeholder);
        this.placeholder = null;
      },

      events: [
      {
        name: 'load hashchange popstate',

        el() {
          return window;
        },

        filter() {
          return this.targetOffset !== false;
        },

        handler() {
          if (!location.hash || scrollTop(window) === 0) {
            return;
          }

          fastdom.read(() => {
            const targetOffset = offset($(location.hash));
            const elOffset = offset(this.$el);

            if (this.isFixed && intersectRect(targetOffset, elOffset)) {
              scrollTop(
              window,
              targetOffset.top -
              elOffset.height -
              toPx(this.targetOffset, 'height') -
              toPx(this.offset, 'height'));

            }
          });
        } }],



      update: [
      {
        read(_ref2, types) {let { height: height$1, margin } = _ref2;
          this.inactive = !this.matchMedia || !isVisible(this.$el);

          if (this.inactive) {
            return false;
          }

          const hide = this.active && types.has('resize');
          if (hide) {
            css(this.selTarget, 'transition', '0s');
            this.hide();
          }

          if (!this.active) {
            height$1 = offset(this.$el).height;
            margin = css(this.$el, 'margin');
          }

          if (hide) {
            this.show();
            fastdom.write(() => css(this.selTarget, 'transition', ''));
          }

          const referenceElement = this.isFixed ? this.placeholder : this.$el;
          const windowHeight = height(window);

          let position = this.position;
          if (position === 'auto' && height$1 > windowHeight) {
            position = 'bottom';
          }

          let offset$1 = toPx(this.offset, 'height', referenceElement);
          if (position === 'bottom') {
            offset$1 += windowHeight - height$1;
          }

          const overflow = Math.max(0, height$1 + offset$1 - windowHeight);
          const topOffset = offset(referenceElement).top;

          const top = parseProp(this.top, this.$el, topOffset);
          const bottom = parseProp(this.bottom, this.$el, topOffset + height$1, true);

          const start = Math.max(top, topOffset) - offset$1;
          const end = bottom ?
          bottom - offset(this.$el).height + overflow - offset$1 :
          getScrollingElement(this.$el).scrollHeight - windowHeight;

          return {
            start,
            end,
            offset: offset$1,
            overflow,
            topOffset,
            height: height$1,
            margin,
            width: dimensions$1(referenceElement).width,
            top: offsetPosition(referenceElement)[0] };

        },

        write(_ref3) {let { height, margin } = _ref3;
          const { placeholder } = this;

          css(placeholder, { height, margin });

          if (!within(placeholder, document)) {
            after(this.$el, placeholder);
            placeholder.hidden = true;
          }
        },

        events: ['resize'] },


      {
        read(_ref4)






        {let { scroll: prevScroll = 0, dir: prevDir = 'down', overflow, overflowScroll = 0, start, end } = _ref4;
          const scroll = scrollTop(window);
          const dir = prevScroll <= scroll ? 'down' : 'up';

          return {
            dir,
            prevDir,
            scroll,
            prevScroll,
            offsetParentTop: offset(this.$el.offsetParent).top,
            overflowScroll: clamp(
            overflowScroll + clamp(scroll, start, end) - clamp(prevScroll, start, end),
            0,
            overflow) };


        },

        write(data, types) {
          const isScrollUpdate = types.has('scroll');
          const {
            initTimestamp = 0,
            dir,
            prevDir,
            scroll,
            prevScroll = 0,
            top,
            start,
            topOffset,
            height } =
          data;

          if (
          scroll < 0 ||
          scroll === prevScroll && isScrollUpdate ||
          this.showOnUp && !isScrollUpdate && !this.isFixed)
          {
            return;
          }

          const now = Date.now();
          if (now - initTimestamp > 300 || dir !== prevDir) {
            data.initScroll = scroll;
            data.initTimestamp = now;
          }

          if (
          this.showOnUp &&
          !this.isFixed &&
          Math.abs(data.initScroll - scroll) <= 30 &&
          Math.abs(prevScroll - scroll) <= 10)
          {
            return;
          }

          if (
          this.inactive ||
          scroll < start ||
          this.showOnUp && (
          scroll <= start ||
          dir === 'down' && isScrollUpdate ||
          dir === 'up' && !this.isFixed && scroll <= topOffset + height))
          {
            if (!this.isFixed) {
              if (Animation.inProgress(this.$el) && top > scroll) {
                Animation.cancel(this.$el);
                this.hide();
              }

              return;
            }

            this.isFixed = false;

            if (this.animation && scroll > topOffset) {
              Animation.cancel(this.$el);
              Animation.out(this.$el, this.animation).then(() => this.hide(), noop);
            } else {
              this.hide();
            }
          } else if (this.isFixed) {
            this.update();
          } else if (this.animation && scroll > topOffset) {
            Animation.cancel(this.$el);
            this.show();
            Animation.in(this.$el, this.animation).catch(noop);
          } else {
            this.show();
          }
        },

        events: ['resize', 'scroll'] }],



      methods: {
        show() {
          this.isFixed = true;
          this.update();
          this.placeholder.hidden = false;
        },

        hide() {
          this.setActive(false);
          removeClass(this.$el, this.clsFixed, this.clsBelow);
          css(this.$el, { position: '', top: '', width: '' });
          this.placeholder.hidden = true;
        },

        update() {
          let {
            width,
            scroll = 0,
            overflow,
            overflowScroll = 0,
            start,
            end,
            offset,
            topOffset,
            height,
            offsetParentTop } =
          this._data;
          const active = start !== 0 || scroll > start;
          let position = 'fixed';

          if (scroll > end) {
            offset += end - offsetParentTop;
            position = 'absolute';
          }

          if (overflow) {
            offset -= overflowScroll;
          }

          css(this.$el, {
            position,
            top: offset + "px",
            width });


          this.setActive(active);
          toggleClass(this.$el, this.clsBelow, scroll > topOffset + height);
          addClass(this.$el, this.clsFixed);
        },

        setActive(active) {
          const prev = this.active;
          this.active = active;
          if (active) {
            replaceClass(this.selTarget, this.clsInactive, this.clsActive);
            prev !== active && trigger(this.$el, 'active');
          } else {
            replaceClass(this.selTarget, this.clsActive, this.clsInactive);
            prev !== active && trigger(this.$el, 'inactive');
          }
        } } };



    function parseProp(value, el, propOffset, padding) {
      if (!value) {
        return 0;
      }

      if (isString(value) && value.match(/^-?\d/)) {
        return propOffset + toPx(value);
      } else {
        const refElement = value === true ? parent(el) : query(value, el);
        return (
          offset(refElement).bottom - (
          padding && refElement && within(el, refElement) ?
          toFloat(css(refElement, 'paddingBottom')) :
          0));

      }
    }

    var Switcher = {
      mixins: [Lazyload, Swipe, Togglable],

      args: 'connect',

      props: {
        connect: String,
        toggle: String,
        itemNav: String,
        active: Number },


      data: {
        connect: '~.uk-switcher',
        toggle: '> * > :first-child',
        itemNav: false,
        active: 0,
        cls: 'uk-active',
        attrItem: 'uk-switcher-item' },


      computed: {
        connects: {
          get(_ref, $el) {let { connect } = _ref;
            return queryAll(connect, $el);
          },

          watch(connects) {
            if (this.swiping) {
              css(connects, 'touch-action', 'pan-y pinch-zoom');
            }

            const index = this.index();
            this.connects.forEach((el) =>
            children(el).forEach((child, i) => toggleClass(child, this.cls, i === index)));

          },

          immediate: true },


        toggles: {
          get(_ref2, $el) {let { toggle } = _ref2;
            return $$(toggle, $el).filter(
            (el) => !matches(el, '.uk-disabled *, .uk-disabled, [disabled]'));

          },

          watch(toggles) {
            const active = this.index();
            this.show(~active ? active : toggles[this.active] || toggles[0]);
          },

          immediate: true },


        children() {
          return children(this.$el).filter((child) =>
          this.toggles.some((toggle) => within(toggle, child)));

        },

        swipeTarget() {
          return this.connects;
        } },


      connected() {
        this.lazyload(this.$el, this.connects);

        // check for connects
        ready(() => this.$emit());
      },

      events: [
      {
        name: 'click',

        delegate() {
          return this.toggle;
        },

        handler(e) {
          e.preventDefault();
          this.show(e.current);
        } },


      {
        name: 'click',

        el() {
          return this.connects.concat(this.itemNav ? queryAll(this.itemNav, this.$el) : []);
        },

        delegate() {
          return "[" + this.attrItem + "],[data-" + this.attrItem + "]";
        },

        handler(e) {
          e.preventDefault();
          this.show(data(e.current, this.attrItem));
        } },


      {
        name: 'swipeRight swipeLeft',

        filter() {
          return this.swiping;
        },

        el() {
          return this.connects;
        },

        handler(_ref3) {let { type } = _ref3;
          this.show(endsWith(type, 'Left') ? 'next' : 'previous');
        } }],



      methods: {
        index() {
          return findIndex(this.children, (el) => hasClass(el, this.cls));
        },

        show(item) {
          const prev = this.index();
          const next = getIndex(item, this.toggles, prev);
          const active = getIndex(this.children[next], children(this.$el));
          children(this.$el).forEach((child, i) => {
            toggleClass(child, this.cls, active === i);
            attr(this.toggles[i], 'aria-expanded', active === i);
          });

          const animate = prev >= 0 && prev !== next;
          this.connects.forEach(async (_ref4) => {let { children } = _ref4;
            await this.toggleElement(
            toNodes(children).filter((child) => hasClass(child, this.cls)),
            false,
            animate);

            await this.toggleElement(children[active], true, animate);
          });
        } } };

    var tab = {
      mixins: [Class],

      extends: Switcher,

      props: {
        media: Boolean },


      data: {
        media: 960,
        attrItem: 'uk-tab-item' },


      connected() {
        const cls = hasClass(this.$el, 'uk-tab-left') ?
        'uk-tab-left' :
        hasClass(this.$el, 'uk-tab-right') ?
        'uk-tab-right' :
        false;

        if (cls) {
          this.$create('toggle', this.$el, { cls, mode: 'media', media: this.media });
        }
      } };

    const KEY_SPACE = 32;

    var toggle = {
      mixins: [Lazyload, Media, Togglable],

      args: 'target',

      props: {
        href: String,
        target: null,
        mode: 'list',
        queued: Boolean },


      data: {
        href: false,
        target: false,
        mode: 'click',
        queued: true },


      computed: {
        target: {
          get(_ref, $el) {let { href, target } = _ref;
            target = queryAll(target || href, $el);
            return target.length && target || [$el];
          },

          watch() {
            this.updateAria();
          },

          immediate: true } },



      connected() {
        if (!includes(this.mode, 'media') && !isFocusable(this.$el)) {
          attr(this.$el, 'tabindex', '0');
        }

        this.lazyload(this.$el, this.target);

        // check for target
        ready(() => this.$emit());
      },

      events: [
      {
        name: pointerDown,

        filter() {
          return includes(this.mode, 'hover');
        },

        handler(e) {
          if (!isTouch(e) || this._showState) {
            return;
          }

          // Clicking a button does not give it focus on all browsers and platforms
          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus
          trigger(this.$el, 'focus');
          once(
          document,
          pointerDown,
          () => trigger(this.$el, 'blur'),
          true,
          (e) => !within(e.target, this.$el));


          // Prevent initial click to prevent double toggle through focus + click
          if (includes(this.mode, 'click')) {
            this._preventClick = true;
          }
        } },


      {
        name: pointerEnter + " " + pointerLeave + " focus blur",

        filter() {
          return includes(this.mode, 'hover');
        },

        handler(e) {
          if (isTouch(e)) {
            return;
          }

          const show = includes([pointerEnter, 'focus'], e.type);
          const expanded = attr(this.$el, 'aria-expanded');

          // Skip hide if still hovered or focused
          if (
          !show && (
          e.type === pointerLeave && matches(this.$el, ':focus') ||
          e.type === 'blur' && matches(this.$el, ':hover')))
          {
            return;
          }

          // Skip if state does not change e.g. hover + focus received
          if (this._showState && show && expanded !== this._showState) {
            // Ensure reset if state has changed through click
            if (!show) {
              this._showState = null;
            }
            return;
          }

          this._showState = show ? expanded : null;

          this.toggle("toggle" + (show ? 'show' : 'hide'));
        } },


      {
        name: 'keydown',

        filter() {
          return includes(this.mode, 'click') && !isTag(this.$el, 'input');
        },

        handler(e) {
          if (e.keyCode === KEY_SPACE) {
            e.preventDefault();
            this.$el.click();
          }
        } },


      {
        name: 'click',

        filter() {
          return includes(this.mode, 'click');
        },

        handler(e) {
          if (this._preventClick) {
            return this._preventClick = null;
          }

          let link;
          if (
          closest(e.target, 'a[href="#"], a[href=""]') ||
          (link = closest(e.target, 'a[href]')) && (
          attr(this.$el, 'aria-expanded') !== 'true' ||
          link.hash && matches(this.target, link.hash)))
          {
            e.preventDefault();
          }

          this.toggle();
        } },


      {
        name: 'toggled',

        self: true,

        el() {
          return this.target;
        },

        handler(e, toggled) {
          if (e.target === this.target[0]) {
            this.updateAria(toggled);
          }
        } },


      {
        name: 'mediachange',

        filter() {
          return includes(this.mode, 'media');
        },

        el() {
          return this.target;
        },

        handler(e, mediaObj) {
          if (mediaObj.matches ^ this.isToggled(this.target)) {
            this.toggle();
          }
        } }],



      methods: {
        async toggle(type) {
          if (!trigger(this.target, type || 'toggle', [this])) {
            return;
          }

          if (!this.queued) {
            return this.toggleElement(this.target);
          }

          const leaving = this.target.filter((el) => hasClass(el, this.clsLeave));

          if (leaving.length) {
            for (const el of this.target) {
              const isLeaving = includes(leaving, el);
              this.toggleElement(el, isLeaving, isLeaving);
            }
            return;
          }

          const toggled = this.target.filter(this.isToggled);
          await this.toggleElement(toggled, false);
          await this.toggleElement(
          this.target.filter((el) => !includes(toggled, el)),
          true);

        },

        updateAria(toggled) {
          if (includes(this.mode, 'media')) {
            return;
          }

          attr(
          this.$el,
          'aria-expanded',
          isBoolean(toggled) ? toggled : this.isToggled(this.target));

        } } };

    var components$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Accordion: Accordion,
        Alert: alert,
        Cover: cover,
        Drop: drop,
        Dropdown: drop,
        FormCustom: formCustom,
        Grid: grid,
        HeightMatch: heightMatch,
        HeightViewport: heightViewport,
        Icon: Icon,
        Img: img,
        Leader: leader,
        Margin: Margin,
        Modal: modal,
        Nav: nav,
        Navbar: navbar,
        Offcanvas: offcanvas,
        OverflowAuto: overflowAuto,
        Responsive: responsive,
        Scroll: scroll,
        Scrollspy: scrollspy,
        ScrollspyNav: scrollspyNav,
        Sticky: sticky,
        Svg: SVG,
        Switcher: Switcher,
        Tab: tab,
        Toggle: toggle,
        Video: Video,
        Close: Close,
        Spinner: Spinner,
        SlidenavNext: Slidenav,
        SlidenavPrevious: Slidenav,
        SearchIcon: Search,
        Marker: IconComponent,
        NavbarToggleIcon: IconComponent,
        OverlayIcon: IconComponent,
        PaginationNext: IconComponent,
        PaginationPrevious: IconComponent,
        Totop: IconComponent
    });

    // register components
    each(components$1, (component, name) => UIkit.component(name, component));

    // core functionality
    UIkit.use(Core);

    boot(UIkit);

    const units = ['days', 'hours', 'minutes', 'seconds'];

    var countdown = {
      mixins: [Class],

      props: {
        date: String,
        clsWrapper: String },


      data: {
        date: '',
        clsWrapper: '.uk-countdown-%unit%' },


      connected() {
        this.date = Date.parse(this.$props.date);
        this.start();
      },

      disconnected() {
        this.stop();
      },

      events: [
      {
        name: 'visibilitychange',

        el() {
          return document;
        },

        handler() {
          if (document.hidden) {
            this.stop();
          } else {
            this.start();
          }
        } }],



      methods: {
        start() {
          this.stop();
          this.update();
          this.timer = setInterval(this.update, 1000);
        },

        stop() {
          clearInterval(this.timer);
        },

        update() {
          const timespan = getTimeSpan(this.date);

          if (!this.date || timespan.total <= 0) {
            this.stop();

            timespan.days = timespan.hours = timespan.minutes = timespan.seconds = 0;
          }

          for (const unit of units) {
            const el = $(this.clsWrapper.replace('%unit%', unit), this.$el);

            if (!el) {
              continue;
            }

            let digits = String(Math.trunc(timespan[unit]));

            digits = digits.length < 2 ? "0" + digits : digits;

            if (el.textContent !== digits) {
              digits = digits.split('');

              if (digits.length !== el.children.length) {
                html(el, digits.map(() => '<span></span>').join(''));
              }

              digits.forEach((digit, i) => el.children[i].textContent = digit);
            }
          }
        } } };



    function getTimeSpan(date) {
      const total = date - Date.now();

      return {
        total,
        seconds: total / 1000 % 60,
        minutes: total / 1000 / 60 % 60,
        hours: total / 1000 / 60 / 60 % 24,
        days: total / 1000 / 60 / 60 / 24 };

    }

    const clsLeave = 'uk-transition-leave';
    const clsEnter = 'uk-transition-enter';

    function fade(action, target, duration, stagger) {if (stagger === void 0) {stagger = 0;}
      const index = transitionIndex(target, true);
      const propsIn = { opacity: 1 };
      const propsOut = { opacity: 0 };

      const wrapIndexFn = (fn) => () => index === transitionIndex(target) ? fn() : Promise.reject();

      const leaveFn = wrapIndexFn(() => {
        addClass(target, clsLeave);

        return Promise.all(
        getTransitionNodes(target).map(
        (child, i) =>
        new Promise((resolve) =>
        setTimeout(
        () =>
        Transition.start(child, propsOut, duration / 2, 'ease').then(
        resolve),

        i * stagger)))).



        then(() => removeClass(target, clsLeave));
      });

      const enterFn = wrapIndexFn(() => {
        const oldHeight = height(target);

        addClass(target, clsEnter);
        action();

        css(children(target), { opacity: 0 });

        // Ensure UIkit updates have propagated
        return new Promise((resolve) =>
        requestAnimationFrame(() => {
          const nodes = children(target);
          const newHeight = height(target);

          // Ensure Grid cells do not stretch when height is applied
          css(target, 'alignContent', 'flex-start');
          height(target, oldHeight);

          const transitionNodes = getTransitionNodes(target);
          css(nodes, propsOut);

          const transitions = transitionNodes.map(
          (child, i) =>
          new Promise((resolve) =>
          setTimeout(
          () =>
          Transition.start(child, propsIn, duration / 2, 'ease').then(
          resolve),

          i * stagger)));




          if (oldHeight !== newHeight) {
            transitions.push(
            Transition.start(
            target,
            { height: newHeight },
            duration / 2 + transitionNodes.length * stagger,
            'ease'));


          }

          Promise.all(transitions).then(() => {
            removeClass(target, clsEnter);
            if (index === transitionIndex(target)) {
              css(target, { height: '', alignContent: '' });
              css(nodes, { opacity: '' });
              delete target.dataset.transition;
            }
            resolve();
          });
        }));

      });

      return hasClass(target, clsLeave) ?
      waitTransitionend(target).then(enterFn) :
      hasClass(target, clsEnter) ?
      waitTransitionend(target).then(leaveFn).then(enterFn) :
      leaveFn().then(enterFn);
    }

    function transitionIndex(target, next) {
      if (next) {
        target.dataset.transition = 1 + transitionIndex(target);
      }

      return toNumber(target.dataset.transition) || 0;
    }

    function waitTransitionend(target) {
      return Promise.all(
      children(target).
      filter(Transition.inProgress).
      map(
      (el) =>
      new Promise((resolve) => once(el, 'transitionend transitioncanceled', resolve))));


    }

    function getTransitionNodes(target) {
      return getRows(children(target)).reduce(
      (nodes, row) =>
      nodes.concat(
      sortBy$1(
      row.filter((el) => isInView(el)),
      'offsetLeft')),


      []);

    }

    function slide (action, target, duration) {
      return new Promise((resolve) =>
      requestAnimationFrame(() => {
        let nodes = children(target);

        // Get current state
        const currentProps = nodes.map((el) => getProps(el, true));
        const targetProps = css(target, ['height', 'padding']);

        // Cancel previous animations
        Transition.cancel(target);
        nodes.forEach(Transition.cancel);
        reset(target);

        // Adding, sorting, removing nodes
        action();

        // Find new nodes
        nodes = nodes.concat(children(target).filter((el) => !includes(nodes, el)));

        // Wait for update to propagate
        Promise.resolve().then(() => {
          // Force update
          fastdom.flush();

          // Get new state
          const targetPropsTo = css(target, ['height', 'padding']);
          const [propsTo, propsFrom] = getTransitionProps(target, nodes, currentProps);

          // Reset to previous state
          nodes.forEach((el, i) => propsFrom[i] && css(el, propsFrom[i]));
          css(target, { display: 'block', ...targetProps });

          // Start transitions on next frame
          requestAnimationFrame(() => {
            const transitions = nodes.
            map(
            (el, i) =>
            parent(el) === target &&
            Transition.start(el, propsTo[i], duration, 'ease')).

            concat(Transition.start(target, targetPropsTo, duration, 'ease'));

            Promise.all(transitions).
            then(() => {
              nodes.forEach(
              (el, i) =>
              parent(el) === target &&
              css(el, 'display', propsTo[i].opacity === 0 ? 'none' : ''));

              reset(target);
            }, noop).
            then(resolve);
          });
        });
      }));

    }

    function getProps(el, opacity) {
      const zIndex = css(el, 'zIndex');

      return isVisible(el) ?
      {
        display: '',
        opacity: opacity ? css(el, 'opacity') : '0',
        pointerEvents: 'none',
        position: 'absolute',
        zIndex: zIndex === 'auto' ? index(el) : zIndex,
        ...getPositionWithMargin(el) } :

      false;
    }

    function getTransitionProps(target, nodes, currentProps) {
      const propsTo = nodes.map((el, i) =>
      parent(el) && i in currentProps ?
      currentProps[i] ?
      isVisible(el) ?
      getPositionWithMargin(el) :
      { opacity: 0 } :
      { opacity: isVisible(el) ? 1 : 0 } :
      false);


      const propsFrom = propsTo.map((props, i) => {
        const from = parent(nodes[i]) === target && (currentProps[i] || getProps(nodes[i]));

        if (!from) {
          return false;
        }

        if (!props) {
          delete from.opacity;
        } else if (!('opacity' in props)) {
          const { opacity } = from;

          if (opacity % 1) {
            props.opacity = 1;
          } else {
            delete from.opacity;
          }
        }

        return from;
      });

      return [propsTo, propsFrom];
    }

    function reset(el) {
      css(el.children, {
        height: '',
        left: '',
        opacity: '',
        pointerEvents: '',
        position: '',
        top: '',
        marginTop: '',
        marginLeft: '',
        transform: '',
        width: '',
        zIndex: '' });

      css(el, { height: '', display: '', padding: '' });
    }

    function getPositionWithMargin(el) {
      const { height, width } = offset(el);
      const { top, left } = position(el);
      const { marginLeft, marginTop } = css(el, ['marginTop', 'marginLeft']);

      return { top, left, height, width, marginLeft, marginTop, transform: '' };
    }

    var Animate = {
      props: {
        duration: Number,
        animation: Boolean },


      data: {
        duration: 150,
        animation: 'slide' },


      methods: {
        animate(action, target) {if (target === void 0) {target = this.$el;}
          const name = this.animation;
          const animationFn =
          name === 'fade' ?
          fade :
          name === 'delayed-fade' ?
          function () {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}return fade(...args, 40);} :
          name ?
          slide :
          () => {
            action();
            return Promise.resolve();
          };

          return animationFn(action, target, this.duration).then(
          () => this.$update(target, 'resize'),
          noop);

        } } };

    var filter = {
      mixins: [Animate],

      args: 'target',

      props: {
        target: Boolean,
        selActive: Boolean },


      data: {
        target: null,
        selActive: false,
        attrItem: 'uk-filter-control',
        cls: 'uk-active',
        duration: 250 },


      computed: {
        toggles: {
          get(_ref, $el) {let { attrItem } = _ref;
            return $$("[" + attrItem + "],[data-" + attrItem + "]", $el);
          },

          watch() {
            this.updateState();

            if (this.selActive !== false) {
              const actives = $$(this.selActive, this.$el);
              this.toggles.forEach((el) => toggleClass(el, this.cls, includes(actives, el)));
            }
          },

          immediate: true },


        children: {
          get(_ref2, $el) {let { target } = _ref2;
            return $$(target + " > *", $el);
          },

          watch(list, old) {
            if (old && !isEqualList(list, old)) {
              this.updateState();
            }
          },

          immediate: true } },



      events: [
      {
        name: 'click',

        delegate() {
          return "[" + this.attrItem + "],[data-" + this.attrItem + "]";
        },

        handler(e) {
          e.preventDefault();
          this.apply(e.current);
        } }],



      methods: {
        apply(el) {
          const prevState = this.getState();
          const newState = mergeState(el, this.attrItem, this.getState());

          if (!isEqualState(prevState, newState)) {
            this.setState(newState);
          }
        },

        getState() {
          return this.toggles.
          filter((item) => hasClass(item, this.cls)).
          reduce((state, el) => mergeState(el, this.attrItem, state), {
            filter: { '': '' },
            sort: [] });

        },

        setState(state, animate) {if (animate === void 0) {animate = true;}
          state = { filter: { '': '' }, sort: [], ...state };

          trigger(this.$el, 'beforeFilter', [this, state]);

          this.toggles.forEach((el) =>
          toggleClass(el, this.cls, !!matchFilter(el, this.attrItem, state)));


          Promise.all(
          $$(this.target, this.$el).map((target) => {
            const filterFn = () => {
              applyState(state, target, children(target));
              this.$update(this.$el);
            };
            return animate ? this.animate(filterFn, target) : filterFn();
          })).
          then(() => trigger(this.$el, 'afterFilter', [this]));
        },

        updateState() {
          fastdom.write(() => this.setState(this.getState(), false));
        } } };



    function getFilter(el, attr) {
      return parseOptions(data(el, attr), ['filter']);
    }

    function isEqualState(stateA, stateB) {
      return ['filter', 'sort'].every((prop) => isEqual(stateA[prop], stateB[prop]));
    }

    function applyState(state, target, children) {
      const selector = getSelector(state);

      children.forEach((el) => css(el, 'display', selector && !matches(el, selector) ? 'none' : ''));

      const [sort, order] = state.sort;

      if (sort) {
        const sorted = sortItems(children, sort, order);
        if (!isEqual(sorted, children)) {
          append(target, sorted);
        }
      }
    }

    function mergeState(el, attr, state) {
      const filterBy = getFilter(el, attr);
      const { filter, group, sort, order = 'asc' } = filterBy;

      if (filter || isUndefined(sort)) {
        if (group) {
          if (filter) {
            delete state.filter[''];
            state.filter[group] = filter;
          } else {
            delete state.filter[group];

            if (isEmpty(state.filter) || '' in state.filter) {
              state.filter = { '': filter || '' };
            }
          }
        } else {
          state.filter = { '': filter || '' };
        }
      }

      if (!isUndefined(sort)) {
        state.sort = [sort, order];
      }

      return state;
    }

    function matchFilter(
    el,
    attr, _ref3)

    {let { filter: stateFilter = { '': '' }, sort: [stateSort, stateOrder] } = _ref3;
      const { filter = '', group = '', sort, order = 'asc' } = getFilter(el, attr);

      return isUndefined(sort) ?
      group in stateFilter && filter === stateFilter[group] ||
      !filter && group && !(group in stateFilter) && !stateFilter[''] :
      stateSort === sort && stateOrder === order;
    }

    function isEqualList(listA, listB) {
      return listA.length === listB.length && listA.every((el) => ~listB.indexOf(el));
    }

    function getSelector(_ref4) {let { filter } = _ref4;
      let selector = '';
      each(filter, (value) => selector += value || '');
      return selector;
    }

    function sortItems(nodes, sort, order) {
      return [...nodes].sort(
      (a, b) =>
      data(a, sort).localeCompare(data(b, sort), undefined, { numeric: true }) * (
      order === 'asc' || -1));

    }

    var Animations$2 = {
      slide: {
        show(dir) {
          return [{ transform: translate(dir * -100) }, { transform: translate() }];
        },

        percent(current) {
          return translated(current);
        },

        translate(percent, dir) {
          return [
          { transform: translate(dir * -100 * percent) },
          { transform: translate(dir * 100 * (1 - percent)) }];

        } } };



    function translated(el) {
      return Math.abs(css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;
    }

    function translate(value, unit) {if (value === void 0) {value = 0;}if (unit === void 0) {unit = '%';}
      value += value ? unit : '';
      return "translate3d(" + value + ", 0, 0)";
    }

    function scale3d(value) {
      return "scale3d(" + value + ", " + value + ", 1)";
    }

    var Animations$1 = {
      ...Animations$2,
      fade: {
        show() {
          return [{ opacity: 0 }, { opacity: 1 }];
        },

        percent(current) {
          return 1 - css(current, 'opacity');
        },

        translate(percent) {
          return [{ opacity: 1 - percent }, { opacity: percent }];
        } },


      scale: {
        show() {
          return [
          { opacity: 0, transform: scale3d(1 - 0.2) },
          { opacity: 1, transform: scale3d(1) }];

        },

        percent(current) {
          return 1 - css(current, 'opacity');
        },

        translate(percent) {
          return [
          { opacity: 1 - percent, transform: scale3d(1 - 0.2 * percent) },
          { opacity: percent, transform: scale3d(1 - 0.2 + 0.2 * percent) }];

        } } };

    function Transitioner$1(prev, next, dir, _ref) {let { animation, easing } = _ref;
      const { percent, translate, show = noop } = animation;
      const props = show(dir);
      const deferred = new Deferred();

      return {
        dir,

        show(duration, percent, linear) {if (percent === void 0) {percent = 0;}
          const timing = linear ? 'linear' : easing;
          duration -= Math.round(duration * clamp(percent, -1, 1));

          this.translate(percent);

          triggerUpdate$1(next, 'itemin', { percent, duration, timing, dir });
          triggerUpdate$1(prev, 'itemout', { percent: 1 - percent, duration, timing, dir });

          Promise.all([
          Transition.start(next, props[1], duration, timing),
          Transition.start(prev, props[0], duration, timing)]).
          then(() => {
            this.reset();
            deferred.resolve();
          }, noop);

          return deferred.promise;
        },

        cancel() {
          Transition.cancel([next, prev]);
        },

        reset() {
          for (const prop in props[0]) {
            css([next, prev], prop, '');
          }
        },

        forward(duration, percent) {if (percent === void 0) {percent = this.percent();}
          Transition.cancel([next, prev]);
          return this.show(duration, percent, true);
        },

        translate(percent) {
          this.reset();

          const props = translate(percent, dir);
          css(next, props[1]);
          css(prev, props[0]);
          triggerUpdate$1(next, 'itemtranslatein', { percent, dir });
          triggerUpdate$1(prev, 'itemtranslateout', { percent: 1 - percent, dir });
        },

        percent() {
          return percent(prev || next, next, dir);
        },

        getDistance() {
          return prev == null ? void 0 : prev.offsetWidth;
        } };

    }

    function triggerUpdate$1(el, type, data) {
      trigger(el, createEvent(type, false, false, data));
    }

    var SliderAutoplay = {
      props: {
        autoplay: Boolean,
        autoplayInterval: Number,
        pauseOnHover: Boolean },


      data: {
        autoplay: false,
        autoplayInterval: 7000,
        pauseOnHover: true },


      connected() {
        this.autoplay && this.startAutoplay();
      },

      disconnected() {
        this.stopAutoplay();
      },

      update() {
        attr(this.slides, 'tabindex', '-1');
      },

      events: [
      {
        name: 'visibilitychange',

        el() {
          return document;
        },

        filter() {
          return this.autoplay;
        },

        handler() {
          if (document.hidden) {
            this.stopAutoplay();
          } else {
            this.startAutoplay();
          }
        } }],



      methods: {
        startAutoplay() {
          this.stopAutoplay();

          this.interval = setInterval(
          () =>
          (!this.draggable || !$(':focus', this.$el)) && (
          !this.pauseOnHover || !matches(this.$el, ':hover')) &&
          !this.stack.length &&
          this.show('next'),
          this.autoplayInterval);

        },

        stopAutoplay() {
          this.interval && clearInterval(this.interval);
        } } };

    var SliderDrag = {
      props: {
        draggable: Boolean },


      data: {
        draggable: true,
        threshold: 10 },


      created() {
        for (const key of ['start', 'move', 'end']) {
          const fn = this[key];
          this[key] = (e) => {
            const pos = getEventPos(e).x * (isRtl ? -1 : 1);

            this.prevPos = pos === this.pos ? this.prevPos : this.pos;
            this.pos = pos;

            fn(e);
          };
        }
      },

      events: [
      {
        name: pointerDown,

        delegate() {
          return this.selSlides;
        },

        handler(e) {
          if (
          !this.draggable ||
          !isTouch(e) && hasTextNodesOnly(e.target) ||
          closest(e.target, selInput) ||
          e.button > 0 ||
          this.length < 2)
          {
            return;
          }

          this.start(e);
        } },


      {
        name: 'dragstart',

        handler(e) {
          e.preventDefault();
        } }],



      methods: {
        start() {
          this.drag = this.pos;

          if (this._transitioner) {
            this.percent = this._transitioner.percent();
            this.drag += this._transitioner.getDistance() * this.percent * this.dir;

            this._transitioner.cancel();
            this._transitioner.translate(this.percent);

            this.dragging = true;

            this.stack = [];
          } else {
            this.prevIndex = this.index;
          }

          on(document, pointerMove, this.move, { passive: false });

          // 'input' event is triggered by video controls
          on(document, pointerUp + " " + pointerCancel + " input", this.end, true);

          css(this.list, 'userSelect', 'none');
        },

        move(e) {
          const distance = this.pos - this.drag;

          if (
          distance === 0 ||
          this.prevPos === this.pos ||
          !this.dragging && Math.abs(distance) < this.threshold)
          {
            return;
          }

          // prevent click event
          css(this.list, 'pointerEvents', 'none');

          e.cancelable && e.preventDefault();

          this.dragging = true;
          this.dir = distance < 0 ? 1 : -1;

          const { slides } = this;
          let { prevIndex } = this;
          let dis = Math.abs(distance);
          let nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
          let width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;

          while (nextIndex !== prevIndex && dis > width) {
            this.drag -= width * this.dir;

            prevIndex = nextIndex;
            dis -= width;
            nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
            width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;
          }

          this.percent = dis / width;

          const prev = slides[prevIndex];
          const next = slides[nextIndex];
          const changed = this.index !== nextIndex;
          const edge = prevIndex === nextIndex;

          let itemShown;

          [this.index, this.prevIndex].
          filter((i) => !includes([nextIndex, prevIndex], i)).
          forEach((i) => {
            trigger(slides[i], 'itemhidden', [this]);

            if (edge) {
              itemShown = true;
              this.prevIndex = prevIndex;
            }
          });

          if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {
            trigger(slides[this.index], 'itemshown', [this]);
          }

          if (changed) {
            this.prevIndex = prevIndex;
            this.index = nextIndex;

            !edge && trigger(prev, 'beforeitemhide', [this]);
            trigger(next, 'beforeitemshow', [this]);
          }

          this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);

          if (changed) {
            !edge && trigger(prev, 'itemhide', [this]);
            trigger(next, 'itemshow', [this]);
          }
        },

        end() {
          off(document, pointerMove, this.move, { passive: false });
          off(document, pointerUp + " " + pointerCancel + " input", this.end, true);

          if (this.dragging) {
            this.dragging = null;

            if (this.index === this.prevIndex) {
              this.percent = 1 - this.percent;
              this.dir *= -1;
              this._show(false, this.index, true);
              this._transitioner = null;
            } else {
              const dirChange =
              (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 ===
              this.prevPos > this.pos;
              this.index = dirChange ? this.index : this.prevIndex;

              if (dirChange) {
                this.percent = 1 - this.percent;
              }

              this.show(
              this.dir > 0 && !dirChange || this.dir < 0 && dirChange ?
              'next' :
              'previous',
              true);

            }
          }

          css(this.list, { userSelect: '', pointerEvents: '' });

          this.drag = this.percent = null;
        } } };



    function hasTextNodesOnly(el) {
      return !el.children.length && el.childNodes.length;
    }

    var SliderNav = {
      data: {
        selNav: false },


      computed: {
        nav(_ref, $el) {let { selNav } = _ref;
          return $(selNav, $el);
        },

        selNavItem(_ref2) {let { attrItem } = _ref2;
          return "[" + attrItem + "],[data-" + attrItem + "]";
        },

        navItems(_, $el) {
          return $$(this.selNavItem, $el);
        } },


      update: {
        write() {
          if (this.nav && this.length !== this.nav.children.length) {
            html(
            this.nav,
            this.slides.
            map((_, i) => "<li " + this.attrItem + "=\"" + i + "\"><a href></a></li>").
            join(''));

          }

          this.navItems.concat(this.nav).forEach((el) => el && (el.hidden = !this.maxIndex));

          this.updateNav();
        },

        events: ['resize'] },


      events: [
      {
        name: 'click',

        delegate() {
          return this.selNavItem;
        },

        handler(e) {
          e.preventDefault();
          this.show(data(e.current, this.attrItem));
        } },


      {
        name: 'itemshow',
        handler: 'updateNav' }],



      methods: {
        updateNav() {
          const i = this.getValidIndex();
          for (const el of this.navItems) {
            const cmd = data(el, this.attrItem);

            toggleClass(el, this.clsActive, toNumber(cmd) === i);
            toggleClass(
            el,
            'uk-invisible',
            this.finite && (
            cmd === 'previous' && i === 0 || cmd === 'next' && i >= this.maxIndex));

          }
        } } };

    var Slider = {
      mixins: [SliderAutoplay, SliderDrag, SliderNav, Resize],

      props: {
        clsActivated: Boolean,
        easing: String,
        index: Number,
        finite: Boolean,
        velocity: Number,
        selSlides: String },


      data: () => ({
        easing: 'ease',
        finite: false,
        velocity: 1,
        index: 0,
        prevIndex: -1,
        stack: [],
        percent: 0,
        clsActive: 'uk-active',
        clsActivated: false,
        Transitioner: false,
        transitionOptions: {} }),


      connected() {
        this.prevIndex = -1;
        this.index = this.getValidIndex(this.$props.index);
        this.stack = [];
      },

      disconnected() {
        removeClass(this.slides, this.clsActive);
      },

      computed: {
        duration(_ref, $el) {let { velocity } = _ref;
          return speedUp($el.offsetWidth / velocity);
        },

        list(_ref2, $el) {let { selList } = _ref2;
          return $(selList, $el);
        },

        maxIndex() {
          return this.length - 1;
        },

        selSlides(_ref3) {let { selList, selSlides } = _ref3;
          return selList + " " + (selSlides || '> *');
        },

        slides: {
          get() {
            return $$(this.selSlides, this.$el);
          },

          watch() {
            this.$reset();
          } },


        length() {
          return this.slides.length;
        } },


      methods: {
        show(index, force) {if (force === void 0) {force = false;}
          if (this.dragging || !this.length) {
            return;
          }

          const { stack } = this;
          const queueIndex = force ? 0 : stack.length;
          const reset = () => {
            stack.splice(queueIndex, 1);

            if (stack.length) {
              this.show(stack.shift(), true);
            }
          };

          stack[force ? 'unshift' : 'push'](index);

          if (!force && stack.length > 1) {
            if (stack.length === 2) {
              this._transitioner.forward(Math.min(this.duration, 200));
            }

            return;
          }

          const prevIndex = this.getIndex(this.index);
          const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];
          const nextIndex = this.getIndex(index, this.index);
          const next = this.slides[nextIndex];

          if (prev === next) {
            reset();
            return;
          }

          this.dir = getDirection(index, prevIndex);
          this.prevIndex = prevIndex;
          this.index = nextIndex;

          if (
          prev && !trigger(prev, 'beforeitemhide', [this]) ||
          !trigger(next, 'beforeitemshow', [this, prev]))
          {
            this.index = this.prevIndex;
            reset();
            return;
          }

          const promise = this._show(prev, next, force).then(() => {
            prev && trigger(prev, 'itemhidden', [this]);
            trigger(next, 'itemshown', [this]);

            return new Promise((resolve) => {
              fastdom.write(() => {
                stack.shift();
                if (stack.length) {
                  this.show(stack.shift(), true);
                } else {
                  this._transitioner = null;
                }
                resolve();
              });
            });
          });

          prev && trigger(prev, 'itemhide', [this]);
          trigger(next, 'itemshow', [this]);

          return promise;
        },

        getIndex(index, prev) {if (index === void 0) {index = this.index;}if (prev === void 0) {prev = this.index;}
          return clamp(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);
        },

        getValidIndex(index, prevIndex) {if (index === void 0) {index = this.index;}if (prevIndex === void 0) {prevIndex = this.prevIndex;}
          return this.getIndex(index, prevIndex);
        },

        _show(prev, next, force) {
          this._transitioner = this._getTransitioner(prev, next, this.dir, {
            easing: force ?
            next.offsetWidth < 600 ?
            'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */ :
            'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */ :
            this.easing,
            ...this.transitionOptions });


          if (!force && !prev) {
            this._translate(1);
            return Promise.resolve();
          }

          const { length } = this.stack;
          return this._transitioner[length > 1 ? 'forward' : 'show'](
          length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration,
          this.percent);

        },

        _getDistance(prev, next) {
          return this._getTransitioner(prev, prev !== next && next).getDistance();
        },

        _translate(percent, prev, next) {if (prev === void 0) {prev = this.prevIndex;}if (next === void 0) {next = this.index;}
          const transitioner = this._getTransitioner(prev !== next ? prev : false, next);
          transitioner.translate(percent);
          return transitioner;
        },

        _getTransitioner(
        prev,
        next,
        dir,
        options)
        {if (prev === void 0) {prev = this.prevIndex;}if (next === void 0) {next = this.index;}if (dir === void 0) {dir = this.dir || 1;}if (options === void 0) {options = this.transitionOptions;}
          return new this.Transitioner(
          isNumber(prev) ? this.slides[prev] : prev,
          isNumber(next) ? this.slides[next] : next,
          dir * (isRtl ? -1 : 1),
          options);

        } } };



    function getDirection(index, prevIndex) {
      return index === 'next' ? 1 : index === 'previous' ? -1 : index < prevIndex ? -1 : 1;
    }

    function speedUp(x) {
      return 0.5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)
    }

    var Slideshow = {
      mixins: [Slider],

      props: {
        animation: String },


      data: {
        animation: 'slide',
        clsActivated: 'uk-transition-active',
        Animations: Animations$2,
        Transitioner: Transitioner$1 },


      computed: {
        animation(_ref) {let { animation, Animations } = _ref;
          return { ...(Animations[animation] || Animations.slide), name: animation };
        },

        transitionOptions() {
          return { animation: this.animation };
        } },


      events: {
        beforeitemshow(_ref2) {let { target } = _ref2;
          addClass(target, this.clsActive);
        },

        itemshown(_ref3) {let { target } = _ref3;
          addClass(target, this.clsActivated);
        },

        itemhidden(_ref4) {let { target } = _ref4;
          removeClass(target, this.clsActive, this.clsActivated);
        } } };

    var LightboxPanel = {
      mixins: [Container, Modal, Togglable, Slideshow],

      functional: true,

      props: {
        delayControls: Number,
        preload: Number,
        videoAutoplay: Boolean,
        template: String },


      data: () => ({
        preload: 1,
        videoAutoplay: false,
        delayControls: 3000,
        items: [],
        cls: 'uk-open',
        clsPage: 'uk-lightbox-page',
        selList: '.uk-lightbox-items',
        attrItem: 'uk-lightbox-item',
        selClose: '.uk-close-large',
        selCaption: '.uk-lightbox-caption',
        pauseOnHover: false,
        velocity: 2,
        Animations: Animations$1,
        template: "<div class=\"uk-lightbox uk-overflow-hidden\"> <ul class=\"uk-lightbox-items\"></ul> <div class=\"uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque\"> <button class=\"uk-lightbox-toolbar-icon uk-close-large\" type=\"button\" uk-close></button> </div> <a class=\"uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade\" href uk-slidenav-previous uk-lightbox-item=\"previous\"></a> <a class=\"uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade\" href uk-slidenav-next uk-lightbox-item=\"next\"></a> <div class=\"uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque\"></div> </div>" }),










      created() {
        const $el = $(this.template);
        const list = $(this.selList, $el);
        this.items.forEach(() => append(list, '<li>'));

        this.$mount(append(this.container, $el));
      },

      computed: {
        caption(_ref, $el) {let { selCaption } = _ref;
          return $(selCaption, $el);
        } },


      events: [
      {
        name: pointerMove + " " + pointerDown + " keydown",

        handler: 'showControls' },


      {
        name: 'click',

        self: true,

        delegate() {
          return this.selSlides;
        },

        handler(e) {
          if (e.defaultPrevented) {
            return;
          }

          this.hide();
        } },


      {
        name: 'shown',

        self: true,

        handler() {
          this.showControls();
        } },


      {
        name: 'hide',

        self: true,

        handler() {
          this.hideControls();

          removeClass(this.slides, this.clsActive);
          Transition.stop(this.slides);
        } },


      {
        name: 'hidden',

        self: true,

        handler() {
          this.$destroy(true);
        } },


      {
        name: 'keyup',

        el() {
          return document;
        },

        handler(e) {
          if (!this.isToggled(this.$el) || !this.draggable) {
            return;
          }

          switch (e.keyCode) {
            case 37:
              this.show('previous');
              break;
            case 39:
              this.show('next');
              break;}

        } },


      {
        name: 'beforeitemshow',

        handler(e) {
          if (this.isToggled()) {
            return;
          }

          this.draggable = false;

          e.preventDefault();

          this.toggleElement(this.$el, true, false);

          this.animation = Animations$1['scale'];
          removeClass(e.target, this.clsActive);
          this.stack.splice(1, 0, this.index);
        } },


      {
        name: 'itemshow',

        handler() {
          html(this.caption, this.getItem().caption || '');

          for (let j = -this.preload; j <= this.preload; j++) {
            this.loadItem(this.index + j);
          }
        } },


      {
        name: 'itemshown',

        handler() {
          this.draggable = this.$props.draggable;
        } },


      {
        name: 'itemload',

        async handler(_, item) {
          const { source: src, type, alt = '', poster, attrs = {} } = item;

          this.setItem(item, '<span uk-spinner></span>');

          if (!src) {
            return;
          }

          let matches;
          const iframeAttrs = {
            frameborder: '0',
            allow: 'autoplay',
            allowfullscreen: '',
            style: 'max-width: 100%; box-sizing: border-box;',
            'uk-responsive': '',
            'uk-video': "" + this.videoAutoplay };


          // Image
          if (
          type === 'image' ||
          src.match(/\.(avif|jpe?g|jfif|a?png|gif|svg|webp)($|\?)/i))
          {
            try {
              const { width, height } = await getImage(src, attrs.srcset, attrs.size);
              this.setItem(item, createEl('img', { src, width, height, alt, ...attrs }));
            } catch (e) {
              this.setError(item);
            }

            // Video
          } else if (type === 'video' || src.match(/\.(mp4|webm|ogv)($|\?)/i)) {
            const video = createEl('video', {
              src,
              poster,
              controls: '',
              playsinline: '',
              'uk-video': "" + this.videoAutoplay,
              ...attrs });


            on(video, 'loadedmetadata', () => {
              attr(video, { width: video.videoWidth, height: video.videoHeight });
              this.setItem(item, video);
            });
            on(video, 'error', () => this.setError(item));

            // Iframe
          } else if (type === 'iframe' || src.match(/\.(html|php)($|\?)/i)) {
            this.setItem(
            item,
            createEl('iframe', {
              src,
              frameborder: '0',
              allowfullscreen: '',
              class: 'uk-lightbox-iframe',
              ...attrs }));



            // YouTube
          } else if (
          matches = src.match(
          /\/\/(?:.*?youtube(-nocookie)?\..*?[?&]v=|youtu\.be\/)([\w-]{11})[&?]?(.*)?/))

          {
            this.setItem(
            item,
            createEl('iframe', {
              src: "https://www.youtube" + (matches[1] || '') + ".com/embed/" + matches[2] + (
              matches[3] ? "?" + matches[3] : ''),

              width: 1920,
              height: 1080,
              ...iframeAttrs,
              ...attrs }));



            // Vimeo
          } else if (matches = src.match(/\/\/.*?vimeo\.[a-z]+\/(\d+)[&?]?(.*)?/)) {
            try {
              const { height, width } = await (
              await fetch("https://vimeo.com/api/oembed.json?maxwidth=1920&url=" +
              encodeURI(
              src),

              {
                credentials: 'omit' })).


              json();

              this.setItem(
              item,
              createEl('iframe', {
                src: "https://player.vimeo.com/video/" + matches[1] + (
                matches[2] ? "?" + matches[2] : ''),

                width,
                height,
                ...iframeAttrs,
                ...attrs }));


            } catch (e) {
              this.setError(item);
            }
          }
        } }],



      methods: {
        loadItem(index) {if (index === void 0) {index = this.index;}
          const item = this.getItem(index);

          if (!this.getSlide(item).childElementCount) {
            trigger(this.$el, 'itemload', [item]);
          }
        },

        getItem(index) {if (index === void 0) {index = this.index;}
          return this.items[getIndex(index, this.slides)];
        },

        setItem(item, content) {
          trigger(this.$el, 'itemloaded', [this, html(this.getSlide(item), content)]);
        },

        getSlide(item) {
          return this.slides[this.items.indexOf(item)];
        },

        setError(item) {
          this.setItem(item, '<span uk-icon="icon: bolt; ratio: 2"></span>');
        },

        showControls() {
          clearTimeout(this.controlsTimer);
          this.controlsTimer = setTimeout(this.hideControls, this.delayControls);

          addClass(this.$el, 'uk-active', 'uk-transition-active');
        },

        hideControls() {
          removeClass(this.$el, 'uk-active', 'uk-transition-active');
        } } };



    function createEl(tag, attrs) {
      const el = fragment("<" + tag + ">");
      attr(el, attrs);
      return el;
    }

    var lightbox = {
      install: install$1,

      props: { toggle: String },

      data: { toggle: 'a' },

      computed: {
        toggles: {
          get(_ref, $el) {let { toggle } = _ref;
            return $$(toggle, $el);
          },

          watch() {
            this.hide();
          } } },



      disconnected() {
        this.hide();
      },

      events: [
      {
        name: 'click',

        delegate() {
          return this.toggle + ":not(.uk-disabled)";
        },

        handler(e) {
          e.preventDefault();
          this.show(e.current);
        } }],



      methods: {
        show(index) {
          const items = uniqueBy(this.toggles.map(toItem), 'source');

          if (isElement(index)) {
            const { source } = toItem(index);
            index = findIndex(items, (_ref2) => {let { source: src } = _ref2;return source === src;});
          }

          this.panel = this.panel || this.$create('lightboxPanel', { ...this.$props, items });

          on(this.panel.$el, 'hidden', () => this.panel = false);

          return this.panel.show(index);
        },

        hide() {var _this$panel;
          return (_this$panel = this.panel) == null ? void 0 : _this$panel.hide();
        } } };



    function install$1(UIkit, Lightbox) {
      if (!UIkit.lightboxPanel) {
        UIkit.component('lightboxPanel', LightboxPanel);
      }

      assign(Lightbox.props, UIkit.component('lightboxPanel').options.props);
    }

    function toItem(el) {
      const item = {};

      for (const attr of ['href', 'caption', 'type', 'poster', 'alt', 'attrs']) {
        item[attr === 'href' ? 'source' : attr] = data(el, attr);
      }

      item.attrs = parseOptions(item.attrs);

      return item;
    }

    var notification = {
      mixins: [Container],

      functional: true,

      args: ['message', 'status'],

      data: {
        message: '',
        status: '',
        timeout: 5000,
        group: null,
        pos: 'top-center',
        clsContainer: 'uk-notification',
        clsClose: 'uk-notification-close',
        clsMsg: 'uk-notification-message' },


      install,

      computed: {
        marginProp(_ref) {let { pos } = _ref;
          return "margin" + (startsWith(pos, 'top') ? 'Top' : 'Bottom');
        },

        startProps() {
          return { opacity: 0, [this.marginProp]: -this.$el.offsetHeight };
        } },


      created() {
        const container =
        $("." + this.clsContainer + "-" + this.pos, this.container) ||
        append(
        this.container, "<div class=\"" +
        this.clsContainer + " " + this.clsContainer + "-" + this.pos + "\" style=\"display: block\"></div>");


        this.$mount(
        append(
        container, "<div class=\"" +
        this.clsMsg + (this.status ? " " + this.clsMsg + "-" + this.status : '') + "\"> <a href class=\"" +
        this.clsClose + "\" data-uk-close></a> <div>" +
        this.message + "</div> </div>"));



      },

      async connected() {
        const margin = toFloat(css(this.$el, this.marginProp));
        await Transition.start(css(this.$el, this.startProps), {
          opacity: 1,
          [this.marginProp]: margin });


        if (this.timeout) {
          this.timer = setTimeout(this.close, this.timeout);
        }
      },

      events: {
        click(e) {
          if (closest(e.target, 'a[href="#"],a[href=""]')) {
            e.preventDefault();
          }
          this.close();
        },

        [pointerEnter]() {
          if (this.timer) {
            clearTimeout(this.timer);
          }
        },

        [pointerLeave]() {
          if (this.timeout) {
            this.timer = setTimeout(this.close, this.timeout);
          }
        } },


      methods: {
        async close(immediate) {
          const removeFn = (el) => {
            const container = parent(el);

            trigger(el, 'close', [this]);
            remove$1(el);

            if (!(container != null && container.hasChildNodes())) {
              remove$1(container);
            }
          };

          if (this.timer) {
            clearTimeout(this.timer);
          }

          if (!immediate) {
            await Transition.start(this.$el, this.startProps);
          }

          removeFn(this.$el);
        } } };



    function install(UIkit) {
      UIkit.notification.closeAll = function (group, immediate) {
        apply(document.body, (el) => {
          const notification = UIkit.getComponent(el, 'notification');
          if (notification && (!group || group === notification.group)) {
            notification.close(immediate);
          }
        });
      };
    }

    const props = {
      x: transformFn,
      y: transformFn,
      rotate: transformFn,
      scale: transformFn,
      color: colorFn,
      backgroundColor: colorFn,
      borderColor: colorFn,
      blur: filterFn,
      hue: filterFn,
      fopacity: filterFn,
      grayscale: filterFn,
      invert: filterFn,
      saturate: filterFn,
      sepia: filterFn,
      opacity: cssPropFn,
      stroke: strokeFn,
      bgx: backgroundFn,
      bgy: backgroundFn };


    const { keys } = Object;

    var Parallax = {
      mixins: [Media],

      props: fillObject(keys(props), 'list'),

      data: fillObject(keys(props), undefined),

      computed: {
        props(properties, $el) {
          return keys(props).reduce((result, prop) => {
            if (!isUndefined(properties[prop])) {
              result[prop] = props[prop](prop, $el, properties[prop].slice());
            }
            return result;
          }, {});
        } },


      events: {
        load() {
          this.$emit();
        } },


      methods: {
        reset() {
          each(this.getCss(0), (_, prop) => css(this.$el, prop, ''));
        },

        getCss(percent) {
          const css = { transform: '', filter: '' };
          for (const prop in this.props) {
            this.props[prop](css, percent);
          }
          return css;
        } } };



    function transformFn(prop, el, stops) {
      const unit = getUnit(stops) || { x: 'px', y: 'px', rotate: 'deg' }[prop] || '';
      let transformFn;

      if (prop === 'x' || prop === 'y') {
        prop = "translate" + ucfirst(prop);
        transformFn = (stop) => toFloat(toFloat(stop).toFixed(unit === 'px' ? 0 : 6));
      }

      if (stops.length === 1) {
        stops.unshift(prop === 'scale' ? 1 : 0);
      }

      stops = parseStops(stops, transformFn);

      return (css, percent) => {
        css.transform += " " + prop + "(" + getValue(stops, percent) + unit + ")";
      };
    }

    function colorFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(getCssValue(el, prop, ''));
      }

      stops = parseStops(stops, (stop) => parseColor(el, stop));

      return (css, percent) => {
        const [start, end, p] = getStop(stops, percent);
        const value = start.
        map((value, i) => {
          value += p * (end[i] - value);
          return i === 3 ? toFloat(value) : parseInt(value, 10);
        }).
        join(',');
        css[prop] = "rgba(" + value + ")";
      };
    }

    function parseColor(el, color) {
      return getCssValue(el, 'color', color).
      split(/[(),]/g).
      slice(1, -1).
      concat(1).
      slice(0, 4).
      map(toFloat);
    }

    function filterFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(0);
      }

      const unit = getUnit(stops) || { blur: 'px', hue: 'deg' }[prop] || '%';
      prop = { fopacity: 'opacity', hue: 'hue-rotate' }[prop] || prop;
      stops = parseStops(stops);

      return (css, percent) => {
        const value = getValue(stops, percent);
        css.filter += " " + prop + "(" + (value + unit) + ")";
      };
    }

    function cssPropFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(getCssValue(el, prop, ''));
      }

      stops = parseStops(stops);

      return (css, percent) => {
        css[prop] = getValue(stops, percent);
      };
    }

    function strokeFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(0);
      }

      const unit = getUnit(stops);
      const length = getMaxPathLength(el);
      stops = parseStops(stops.reverse(), (stop) => {
        stop = toFloat(stop);
        return unit === '%' ? stop * length / 100 : stop;
      });

      if (!stops.some((_ref) => {let [value] = _ref;return value;})) {
        return noop;
      }

      css(el, 'strokeDasharray', length);

      return (css, percent) => {
        css.strokeDashoffset = getValue(stops, percent);
      };
    }

    function backgroundFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(0);
      }

      prop = prop.substr(-1);
      const attr = prop === 'y' ? 'height' : 'width';
      stops = parseStops(stops, (stop) => toPx(stop, attr, el));

      const bgPos = getCssValue(el, "background-position-" + prop, '');

      return getCssValue(el, 'backgroundSize', '') === 'cover' ?
      backgroundCoverFn(prop, el, stops, bgPos, attr) :
      setBackgroundPosFn(prop, stops, bgPos);
    }

    function backgroundCoverFn(prop, el, stops, bgPos, attr) {
      const dimImage = getBackgroundImageDimensions(el);

      if (!dimImage.width) {
        return noop;
      }

      const values = stops.map((_ref2) => {let [value] = _ref2;return value;});
      const min = Math.min(...values);
      const max = Math.max(...values);
      const down = values.indexOf(min) < values.indexOf(max);

      const diff = max - min;
      let pos = (down ? -diff : 0) - (down ? min : max);

      const dimEl = {
        width: el.offsetWidth,
        height: el.offsetHeight };


      const baseDim = Dimensions.cover(dimImage, dimEl);
      const span = baseDim[attr] - dimEl[attr];

      if (span < diff) {
        dimEl[attr] = baseDim[attr] + diff - span;
      } else if (span > diff) {
        const posPercentage = dimEl[attr] / toPx(bgPos, attr, el, true);

        if (posPercentage) {
          pos -= (span - diff) / posPercentage;
        }
      }

      const dim = Dimensions.cover(dimImage, dimEl);

      const fn = setBackgroundPosFn(prop, stops, pos + "px");
      return (css, percent) => {
        fn(css, percent);
        css.backgroundSize = dim.width + "px " + dim.height + "px";
        css.backgroundRepeat = 'no-repeat';
      };
    }

    function setBackgroundPosFn(prop, stops, pos) {
      return function (css, percent) {
        css["background-position-" + prop] = "calc(" + pos + " + " + getValue(stops, percent) + "px)";
      };
    }

    const dimensions = {};
    function getBackgroundImageDimensions(el) {
      const src = css(el, 'backgroundImage').replace(/^none|url\(["']?(.+?)["']?\)$/, '$1');

      if (dimensions[src]) {
        return dimensions[src];
      }

      const image = new Image();
      if (src) {
        image.src = src;

        if (!image.naturalWidth) {
          image.onload = () => {
            dimensions[src] = toDimensions(image);
            trigger(el, createEvent('load', false));
          };
          return toDimensions(image);
        }
      }

      return dimensions[src] = toDimensions(image);
    }

    function toDimensions(image) {
      return {
        width: image.naturalWidth,
        height: image.naturalHeight };

    }

    function parseStops(stops, fn) {if (fn === void 0) {fn = toFloat;}
      const result = [];
      const { length } = stops;
      let nullIndex = 0;
      for (let i = 0; i < length; i++) {
        let [value, percent] = isString(stops[i]) ? stops[i].trim().split(' ') : [stops[i]];
        value = fn(value);
        percent = percent ? toFloat(percent) / 100 : null;

        if (i === 0) {
          if (percent === null) {
            percent = 0;
          } else if (percent) {
            result.push([value, 0]);
          }
        } else if (i === length - 1) {
          if (percent === null) {
            percent = 1;
          } else if (percent !== 1) {
            result.push([value, percent]);
            percent = 1;
          }
        }

        result.push([value, percent]);

        if (percent === null) {
          nullIndex++;
        } else if (nullIndex) {
          const leftPercent = result[i - nullIndex - 1][1];
          const p = (percent - leftPercent) / (nullIndex + 1);
          for (let j = nullIndex; j > 0; j--) {
            result[i - j][1] = leftPercent + p * (nullIndex - j + 1);
          }

          nullIndex = 0;
        }
      }

      return result;
    }

    function getStop(stops, percent) {
      const index = findIndex(stops.slice(1), (_ref3) => {let [, targetPercent] = _ref3;return percent <= targetPercent;}) + 1;
      return [
      stops[index - 1][0],
      stops[index][0],
      (percent - stops[index - 1][1]) / (stops[index][1] - stops[index - 1][1])];

    }

    function getValue(stops, percent) {
      const [start, end, p] = getStop(stops, percent);
      return isNumber(start) ? start + Math.abs(start - end) * p * (start < end ? 1 : -1) : +end;
    }

    const unitRe = /^-?\d+([^\s]*)/;
    function getUnit(stops, defaultUnit) {
      for (const stop of stops) {
        const match = stop.match == null ? void 0 : stop.match(unitRe);
        if (match) {
          return match[1];
        }
      }
      return defaultUnit;
    }

    function getCssValue(el, prop, value) {
      const prev = el.style[prop];
      const val = css(css(el, prop, value), prop);
      el.style[prop] = prev;
      return val;
    }

    function fillObject(keys, value) {
      return keys.reduce((data, prop) => {
        data[prop] = value;
        return data;
      }, {});
    }

    var parallax = {
      mixins: [Parallax, Resize, Scroll],

      props: {
        target: String,
        viewport: Number, // Deprecated
        easing: Number,
        start: String,
        end: String },


      data: {
        target: false,
        viewport: 1,
        easing: 1,
        start: 0,
        end: 0 },


      computed: {
        target(_ref, $el) {let { target } = _ref;
          return getOffsetElement(target && query(target, $el) || $el);
        },

        start(_ref2) {let { start } = _ref2;
          return toPx(start, 'height', this.target, true);
        },

        end(_ref3) {let { end, viewport } = _ref3;
          return toPx(
          end || (viewport = (1 - viewport) * 100) && viewport + "vh+" + viewport + "%",
          'height',
          this.target,
          true);

        } },


      update: {
        read(_ref4, types) {let { percent } = _ref4;
          if (!types.has('scroll')) {
            percent = false;
          }

          if (!this.matchMedia) {
            return;
          }

          const prev = percent;
          percent = ease(scrolledOver(this.target, this.start, this.end), this.easing);

          return {
            percent,
            style: prev === percent ? false : this.getCss(percent) };

        },

        write(_ref5) {let { style } = _ref5;
          if (!this.matchMedia) {
            this.reset();
            return;
          }

          style && css(this.$el, style);
        },

        events: ['scroll', 'resize'] } };



    function ease(percent, easing) {
      return easing >= 0 ? Math.pow(percent, easing + 1) : 1 - Math.pow(1 - percent, -easing + 1);
    }

    // SVG elements do not inherit from HTMLElement
    function getOffsetElement(el) {
      return el ? 'offsetTop' in el ? el : getOffsetElement(parent(el)) : document.documentElement;
    }

    var SliderReactive = {
      update: {
        write() {
          if (this.stack.length || this.dragging) {
            return;
          }

          const index = this.getValidIndex(this.index);

          if (!~this.prevIndex || this.index !== index) {
            this.show(index);
          }
        },

        events: ['resize'] } };

    var SliderPreload = {
      mixins: [Lazyload],

      connected() {
        this.lazyload(this.slides, this.getAdjacentSlides);
      } };

    function Transitioner (prev, next, dir, _ref) {let { center, easing, list } = _ref;
      const deferred = new Deferred();

      const from = prev ?
      getLeft(prev, list, center) :
      getLeft(next, list, center) + dimensions$1(next).width * dir;
      const to = next ?
      getLeft(next, list, center) :
      from + dimensions$1(prev).width * dir * (isRtl ? -1 : 1);

      return {
        dir,

        show(duration, percent, linear) {if (percent === void 0) {percent = 0;}
          const timing = linear ? 'linear' : easing;
          duration -= Math.round(duration * clamp(percent, -1, 1));

          this.translate(percent);

          percent = prev ? percent : clamp(percent, 0, 1);
          triggerUpdate(this.getItemIn(), 'itemin', { percent, duration, timing, dir });
          prev &&
          triggerUpdate(this.getItemIn(true), 'itemout', {
            percent: 1 - percent,
            duration,
            timing,
            dir });


          Transition.start(
          list,
          { transform: translate(-to * (isRtl ? -1 : 1), 'px') },
          duration,
          timing).
          then(deferred.resolve, noop);

          return deferred.promise;
        },

        cancel() {
          Transition.cancel(list);
        },

        reset() {
          css(list, 'transform', '');
        },

        forward(duration, percent) {if (percent === void 0) {percent = this.percent();}
          Transition.cancel(list);
          return this.show(duration, percent, true);
        },

        translate(percent) {
          const distance = this.getDistance() * dir * (isRtl ? -1 : 1);

          css(
          list,
          'transform',
          translate(
          clamp(
          -to + (distance - distance * percent),
          -getWidth(list),
          dimensions$1(list).width) * (
          isRtl ? -1 : 1),
          'px'));



          const actives = this.getActives();
          const itemIn = this.getItemIn();
          const itemOut = this.getItemIn(true);

          percent = prev ? clamp(percent, -1, 1) : 0;

          for (const slide of children(list)) {
            const isActive = includes(actives, slide);
            const isIn = slide === itemIn;
            const isOut = slide === itemOut;
            const translateIn =
            isIn ||
            !isOut && (
            isActive ||
            dir * (isRtl ? -1 : 1) === -1 ^
            getElLeft(slide, list) > getElLeft(prev || next));

            triggerUpdate(slide, "itemtranslate" + (translateIn ? 'in' : 'out'), {
              dir,
              percent: isOut ? 1 - percent : isIn ? percent : isActive ? 1 : 0 });

          }
        },

        percent() {
          return Math.abs(
          (css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));

        },

        getDistance() {
          return Math.abs(to - from);
        },

        getItemIn(out) {if (out === void 0) {out = false;}
          let actives = this.getActives();
          let nextActives = inView(list, getLeft(next || prev, list, center));

          if (out) {
            const temp = actives;
            actives = nextActives;
            nextActives = temp;
          }

          return nextActives[findIndex(nextActives, (el) => !includes(actives, el))];
        },

        getActives() {
          return inView(list, getLeft(prev || next, list, center));
        } };

    }

    function getLeft(el, list, center) {
      const left = getElLeft(el, list);

      return center ? left - centerEl(el, list) : Math.min(left, getMax(list));
    }

    function getMax(list) {
      return Math.max(0, getWidth(list) - dimensions$1(list).width);
    }

    function getWidth(list) {
      return children(list).reduce((right, el) => dimensions$1(el).width + right, 0);
    }

    function centerEl(el, list) {
      return dimensions$1(list).width / 2 - dimensions$1(el).width / 2;
    }

    function getElLeft(el, list) {
      return (
        el &&
        (position(el).left + (isRtl ? dimensions$1(el).width - dimensions$1(list).width : 0)) * (
        isRtl ? -1 : 1) ||
        0);

    }

    function inView(list, listLeft) {
      listLeft -= 1;
      const listWidth = dimensions$1(list).width;
      const listRight = listLeft + listWidth + 2;

      return children(list).filter((slide) => {
        const slideLeft = getElLeft(slide, list);
        const slideRight = slideLeft + Math.min(dimensions$1(slide).width, listWidth);

        return slideLeft >= listLeft && slideRight <= listRight;
      });
    }

    function triggerUpdate(el, type, data) {
      trigger(el, createEvent(type, false, false, data));
    }

    var slider = {
      mixins: [Class, Slider, SliderReactive, SliderPreload],

      props: {
        center: Boolean,
        sets: Boolean },


      data: {
        center: false,
        sets: false,
        attrItem: 'uk-slider-item',
        selList: '.uk-slider-items',
        selNav: '.uk-slider-nav',
        clsContainer: 'uk-slider-container',
        Transitioner },


      computed: {
        avgWidth() {
          return getWidth(this.list) / this.length;
        },

        finite(_ref) {let { finite } = _ref;
          return (
            finite ||
            Math.ceil(getWidth(this.list)) <
            Math.trunc(dimensions$1(this.list).width + getMaxElWidth(this.list) + this.center));

        },

        maxIndex() {
          if (!this.finite || this.center && !this.sets) {
            return this.length - 1;
          }

          if (this.center) {
            return last(this.sets);
          }

          let lft = 0;
          const max = getMax(this.list);
          const index = findIndex(this.slides, (el) => {
            if (lft >= max) {
              return true;
            }

            lft += dimensions$1(el).width;
          });

          return ~index ? index : this.length - 1;
        },

        sets(_ref2) {let { sets: enabled } = _ref2;
          if (!enabled) {
            return;
          }

          let left = 0;
          const sets = [];
          const width = dimensions$1(this.list).width;
          for (let i in this.slides) {
            const slideWidth = dimensions$1(this.slides[i]).width;

            if (left + slideWidth > width) {
              left = 0;
            }

            if (this.center) {
              if (
              left < width / 2 &&
              left + slideWidth + dimensions$1(this.slides[+i + 1]).width / 2 > width / 2)
              {
                sets.push(+i);
                left = width / 2 - slideWidth / 2;
              }
            } else if (left === 0) {
              sets.push(Math.min(+i, this.maxIndex));
            }

            left += slideWidth;
          }

          if (sets.length) {
            return sets;
          }
        },

        transitionOptions() {
          return {
            center: this.center,
            list: this.list };

        } },


      connected() {
        toggleClass(this.$el, this.clsContainer, !$("." + this.clsContainer, this.$el));
      },

      update: {
        write() {
          for (const el of this.navItems) {
            const index = toNumber(data(el, this.attrItem));
            if (index !== false) {
              el.hidden =
              !this.maxIndex ||
              index > this.maxIndex ||
              this.sets && !includes(this.sets, index);
            }
          }

          if (this.length && !this.dragging && !this.stack.length) {
            this.reorder();
            this._translate(1);
          }

          this.updateActiveClasses();
        },

        events: ['resize'] },


      events: {
        beforeitemshow(e) {
          if (
          !this.dragging &&
          this.sets &&
          this.stack.length < 2 &&
          !includes(this.sets, this.index))
          {
            this.index = this.getValidIndex();
          }

          const diff = Math.abs(
          this.index -
          this.prevIndex + (
          this.dir > 0 && this.index < this.prevIndex ||
          this.dir < 0 && this.index > this.prevIndex ?
          (this.maxIndex + 1) * this.dir :
          0));


          if (!this.dragging && diff > 1) {
            for (let i = 0; i < diff; i++) {
              this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');
            }

            e.preventDefault();
            return;
          }

          const index =
          this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex;
          this.duration =
          speedUp(this.avgWidth / this.velocity) * (
          dimensions$1(this.slides[index]).width / this.avgWidth);

          this.reorder();
        },

        itemshow() {
          if (~this.prevIndex) {
            addClass(this._getTransitioner().getItemIn(), this.clsActive);
          }
        },

        itemshown() {
          this.updateActiveClasses();
        } },


      methods: {
        reorder() {
          if (this.finite) {
            css(this.slides, 'order', '');
            return;
          }

          const index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;

          this.slides.forEach((slide, i) =>
          css(
          slide,
          'order',
          this.dir > 0 && i < index ? 1 : this.dir < 0 && i >= this.index ? -1 : ''));



          if (!this.center) {
            return;
          }

          const next = this.slides[index];
          let width = dimensions$1(this.list).width / 2 - dimensions$1(next).width / 2;
          let j = 0;

          while (width > 0) {
            const slideIndex = this.getIndex(--j + index, index);
            const slide = this.slides[slideIndex];

            css(slide, 'order', slideIndex > index ? -2 : -1);
            width -= dimensions$1(slide).width;
          }
        },

        updateActiveClasses() {
          const actives = this._getTransitioner(this.index).getActives();
          const activeClasses = [
          this.clsActive,
          (!this.sets || includes(this.sets, toFloat(this.index))) && this.clsActivated ||
          ''];

          for (const slide of this.slides) {
            toggleClass(slide, activeClasses, includes(actives, slide));
          }
        },

        getValidIndex(index, prevIndex) {if (index === void 0) {index = this.index;}if (prevIndex === void 0) {prevIndex = this.prevIndex;}
          index = this.getIndex(index, prevIndex);

          if (!this.sets) {
            return index;
          }

          let prev;

          do {
            if (includes(this.sets, index)) {
              return index;
            }

            prev = index;
            index = this.getIndex(index + this.dir, prevIndex);
          } while (index !== prev);

          return index;
        },

        getAdjacentSlides() {
          const { width } = dimensions$1(this.list);
          const left = -width;
          const right = width * 2;
          const slideWidth = dimensions$1(this.slides[this.index]).width;
          const slideLeft = this.center ? width / 2 - slideWidth / 2 : 0;
          const slides = new Set();
          for (const i of [-1, 1]) {
            let currentLeft = slideLeft + (i > 0 ? slideWidth : 0);
            let j = 0;
            do {
              const slide = this.slides[this.getIndex(this.index + i + j++ * i)];
              currentLeft += dimensions$1(slide).width * i;
              slides.add(slide);
            } while (this.slides.length > j && currentLeft > left && currentLeft < right);
          }
          return Array.from(slides);
        } } };



    function getMaxElWidth(list) {
      return Math.max(0, ...children(list).map((el) => dimensions$1(el).width));
    }

    var sliderParallax = {
      mixins: [Parallax],

      data: {
        selItem: '!li' },


      beforeConnect() {
        this.item = query(this.selItem, this.$el);
      },

      disconnected() {
        this.item = null;
      },

      events: [
      {
        name: 'itemin itemout',

        self: true,

        el() {
          return this.item;
        },

        handler(_ref) {let { type, detail: { percent, duration, timing, dir } } = _ref;
          fastdom.read(() => {
            const propsFrom = this.getCss(getCurrentPercent(type, dir, percent));
            const propsTo = this.getCss(isIn(type) ? 0.5 : dir > 0 ? 1 : 0);
            fastdom.write(() => {
              css(this.$el, propsFrom);
              Transition.start(this.$el, propsTo, duration, timing).catch(noop);
            });
          });
        } },


      {
        name: 'transitioncanceled transitionend',

        self: true,

        el() {
          return this.item;
        },

        handler() {
          Transition.cancel(this.$el);
        } },


      {
        name: 'itemtranslatein itemtranslateout',

        self: true,

        el() {
          return this.item;
        },

        handler(_ref2) {let { type, detail: { percent, dir } } = _ref2;
          fastdom.read(() => {
            const props = this.getCss(getCurrentPercent(type, dir, percent));
            fastdom.write(() => css(this.$el, props));
          });
        } }] };




    function isIn(type) {
      return endsWith(type, 'in');
    }

    function getCurrentPercent(type, dir, percent) {
      percent /= 2;

      return isIn(type) ^ dir < 0 ? percent : 1 - percent;
    }

    var Animations = {
      ...Animations$2,
      fade: {
        show() {
          return [{ opacity: 0, zIndex: 0 }, { zIndex: -1 }];
        },

        percent(current) {
          return 1 - css(current, 'opacity');
        },

        translate(percent) {
          return [{ opacity: 1 - percent, zIndex: 0 }, { zIndex: -1 }];
        } },


      scale: {
        show() {
          return [{ opacity: 0, transform: scale3d(1 + 0.5), zIndex: 0 }, { zIndex: -1 }];
        },

        percent(current) {
          return 1 - css(current, 'opacity');
        },

        translate(percent) {
          return [
          { opacity: 1 - percent, transform: scale3d(1 + 0.5 * percent), zIndex: 0 },
          { zIndex: -1 }];

        } },


      pull: {
        show(dir) {
          return dir < 0 ?
          [
          { transform: translate(30), zIndex: -1 },
          { transform: translate(), zIndex: 0 }] :

          [
          { transform: translate(-100), zIndex: 0 },
          { transform: translate(), zIndex: -1 }];

        },

        percent(current, next, dir) {
          return dir < 0 ? 1 - translated(next) : translated(current);
        },

        translate(percent, dir) {
          return dir < 0 ?
          [
          { transform: translate(30 * percent), zIndex: -1 },
          { transform: translate(-100 * (1 - percent)), zIndex: 0 }] :

          [
          { transform: translate(-percent * 100), zIndex: 0 },
          { transform: translate(30 * (1 - percent)), zIndex: -1 }];

        } },


      push: {
        show(dir) {
          return dir < 0 ?
          [
          { transform: translate(100), zIndex: 0 },
          { transform: translate(), zIndex: -1 }] :

          [
          { transform: translate(-30), zIndex: -1 },
          { transform: translate(), zIndex: 0 }];

        },

        percent(current, next, dir) {
          return dir > 0 ? 1 - translated(next) : translated(current);
        },

        translate(percent, dir) {
          return dir < 0 ?
          [
          { transform: translate(percent * 100), zIndex: 0 },
          { transform: translate(-30 * (1 - percent)), zIndex: -1 }] :

          [
          { transform: translate(-30 * percent), zIndex: -1 },
          { transform: translate(100 * (1 - percent)), zIndex: 0 }];

        } } };

    var slideshow = {
      mixins: [Class, Slideshow, SliderReactive, SliderPreload],

      props: {
        ratio: String,
        minHeight: Number,
        maxHeight: Number },


      data: {
        ratio: '16:9',
        minHeight: false,
        maxHeight: false,
        selList: '.uk-slideshow-items',
        attrItem: 'uk-slideshow-item',
        selNav: '.uk-slideshow-nav',
        Animations },


      update: {
        read() {
          if (!this.list) {
            return false;
          }

          let [width, height] = this.ratio.split(':').map(Number);

          height = height * this.list.offsetWidth / width || 0;

          if (this.minHeight) {
            height = Math.max(this.minHeight, height);
          }

          if (this.maxHeight) {
            height = Math.min(this.maxHeight, height);
          }

          return { height: height - boxModelAdjust(this.list, 'height', 'content-box') };
        },

        write(_ref) {let { height } = _ref;
          height > 0 && css(this.list, 'minHeight', height);
        },

        events: ['resize'] },


      methods: {
        getAdjacentSlides() {
          return [1, -1].map((i) => this.slides[this.getIndex(this.index + i)]);
        } } };

    var sortable = {
      mixins: [Class, Animate],

      props: {
        group: String,
        threshold: Number,
        clsItem: String,
        clsPlaceholder: String,
        clsDrag: String,
        clsDragState: String,
        clsBase: String,
        clsNoDrag: String,
        clsEmpty: String,
        clsCustom: String,
        handle: String },


      data: {
        group: false,
        threshold: 5,
        clsItem: 'uk-sortable-item',
        clsPlaceholder: 'uk-sortable-placeholder',
        clsDrag: 'uk-sortable-drag',
        clsDragState: 'uk-drag',
        clsBase: 'uk-sortable',
        clsNoDrag: 'uk-sortable-nodrag',
        clsEmpty: 'uk-sortable-empty',
        clsCustom: '',
        handle: false,
        pos: {} },


      created() {
        for (const key of ['init', 'start', 'move', 'end']) {
          const fn = this[key];
          this[key] = (e) => {
            assign(this.pos, getEventPos(e));
            fn(e);
          };
        }
      },

      events: {
        name: pointerDown,
        passive: false,
        handler: 'init' },


      computed: {
        target() {
          return (this.$el.tBodies || [this.$el])[0];
        },

        items() {
          return children(this.target);
        },

        isEmpty: {
          get() {
            return isEmpty(this.items);
          },

          watch(empty) {
            toggleClass(this.target, this.clsEmpty, empty);
          },

          immediate: true },


        handles: {
          get(_ref, el) {let { handle } = _ref;
            return handle ? $$(handle, el) : this.items;
          },

          watch(handles, prev) {
            css(prev, { touchAction: '', userSelect: '' });
            css(handles, { touchAction: hasTouch ? 'none' : '', userSelect: 'none' }); // touchAction set to 'none' causes a performance drop in Chrome 80
          },

          immediate: true } },



      update: {
        write(data) {
          if (!this.drag || !parent(this.placeholder)) {
            return;
          }

          const {
            pos: { x, y },
            origin: { offsetTop, offsetLeft },
            placeholder } =
          this;

          css(this.drag, {
            top: y - offsetTop,
            left: x - offsetLeft });


          const sortable = this.getSortable(document.elementFromPoint(x, y));

          if (!sortable) {
            return;
          }

          const { items } = sortable;

          if (items.some(Transition.inProgress)) {
            return;
          }

          const target = findTarget(items, { x, y });

          if (items.length && (!target || target === placeholder)) {
            return;
          }

          const previous = this.getSortable(placeholder);
          const insertTarget = findInsertTarget(
          sortable.target,
          target,
          placeholder,
          x,
          y,
          sortable === previous && data.moved !== target);


          if (insertTarget === false) {
            return;
          }

          if (insertTarget && placeholder === insertTarget) {
            return;
          }

          if (sortable !== previous) {
            previous.remove(placeholder);
            data.moved = target;
          } else {
            delete data.moved;
          }

          sortable.insert(placeholder, insertTarget);

          this.touched.add(sortable);
        },

        events: ['move'] },


      methods: {
        init(e) {
          const { target, button, defaultPrevented } = e;
          const [placeholder] = this.items.filter((el) => within(target, el));

          if (
          !placeholder ||
          defaultPrevented ||
          button > 0 ||
          isInput(target) ||
          within(target, "." + this.clsNoDrag) ||
          this.handle && !within(target, this.handle))
          {
            return;
          }

          e.preventDefault();

          this.touched = new Set([this]);
          this.placeholder = placeholder;
          this.origin = { target, index: index(placeholder), ...this.pos };

          on(document, pointerMove, this.move);
          on(document, pointerUp, this.end);

          if (!this.threshold) {
            this.start(e);
          }
        },

        start(e) {
          this.drag = appendDrag(this.$container, this.placeholder);
          const { left, top } = this.placeholder.getBoundingClientRect();
          assign(this.origin, { offsetLeft: this.pos.x - left, offsetTop: this.pos.y - top });

          addClass(this.drag, this.clsDrag, this.clsCustom);
          addClass(this.placeholder, this.clsPlaceholder);
          addClass(this.items, this.clsItem);
          addClass(document.documentElement, this.clsDragState);

          trigger(this.$el, 'start', [this, this.placeholder]);

          trackScroll(this.pos);

          this.move(e);
        },

        move(e) {
          if (this.drag) {
            this.$emit('move');
          } else if (
          Math.abs(this.pos.x - this.origin.x) > this.threshold ||
          Math.abs(this.pos.y - this.origin.y) > this.threshold)
          {
            this.start(e);
          }
        },

        end() {
          off(document, pointerMove, this.move);
          off(document, pointerUp, this.end);

          if (!this.drag) {
            return;
          }

          untrackScroll();

          const sortable = this.getSortable(this.placeholder);

          if (this === sortable) {
            if (this.origin.index !== index(this.placeholder)) {
              trigger(this.$el, 'moved', [this, this.placeholder]);
            }
          } else {
            trigger(sortable.$el, 'added', [sortable, this.placeholder]);
            trigger(this.$el, 'removed', [this, this.placeholder]);
          }

          trigger(this.$el, 'stop', [this, this.placeholder]);

          remove$1(this.drag);
          this.drag = null;

          for (const { clsPlaceholder, clsItem } of this.touched) {
            for (const sortable of this.touched) {
              removeClass(sortable.items, clsPlaceholder, clsItem);
            }
          }
          this.touched = null;
          removeClass(document.documentElement, this.clsDragState);
        },

        insert(element, target) {
          addClass(this.items, this.clsItem);

          const insert = () => target ? before(target, element) : append(this.target, element);

          this.animate(insert);
        },

        remove(element) {
          if (!within(element, this.target)) {
            return;
          }

          this.animate(() => remove$1(element));
        },

        getSortable(element) {
          do {
            const sortable = this.$getComponent(element, 'sortable');

            if (
            sortable && (
            sortable === this || this.group !== false && sortable.group === this.group))
            {
              return sortable;
            }
          } while (element = parent(element));
        } } };



    let trackTimer;
    function trackScroll(pos) {
      let last = Date.now();
      trackTimer = setInterval(() => {
        let { x, y } = pos;
        y += scrollTop(window);

        const dist = (Date.now() - last) * 0.3;
        last = Date.now();

        scrollParents(document.elementFromPoint(x, pos.y), /auto|scroll/).
        reverse().
        some((scrollEl) => {
          let { scrollTop: scroll, scrollHeight } = scrollEl;

          const { top, bottom, height } = offset(getViewport$1(scrollEl));

          if (top < y && top + 35 > y) {
            scroll -= dist;
          } else if (bottom > y && bottom - 35 < y) {
            scroll += dist;
          } else {
            return;
          }

          if (scroll > 0 && scroll < scrollHeight - height) {
            scrollTop(scrollEl, scroll);
            return true;
          }
        });
      }, 15);
    }

    function untrackScroll() {
      clearInterval(trackTimer);
    }

    function appendDrag(container, element) {
      const clone = append(
      container,
      element.outerHTML.replace(/(^<)(?:li|tr)|(?:li|tr)(\/>$)/g, '$1div$2'));


      css(clone, 'margin', '0', 'important');
      css(clone, {
        boxSizing: 'border-box',
        width: element.offsetWidth,
        height: element.offsetHeight,
        padding: css(element, 'padding') });


      height(clone.firstElementChild, height(element.firstElementChild));

      return clone;
    }

    function findTarget(items, point) {
      return items[findIndex(items, (item) => pointInRect(point, item.getBoundingClientRect()))];
    }

    function findInsertTarget(list, target, placeholder, x, y, sameList) {
      if (!children(list).length) {
        return;
      }

      const rect = target.getBoundingClientRect();
      if (!sameList) {
        if (!isHorizontal(list, placeholder)) {
          return y < rect.top + rect.height / 2 ? target : target.nextElementSibling;
        }

        return target;
      }

      const placeholderRect = placeholder.getBoundingClientRect();
      const sameRow = linesIntersect(
      [rect.top, rect.bottom],
      [placeholderRect.top, placeholderRect.bottom]);


      const pointerPos = sameRow ? x : y;
      const lengthProp = sameRow ? 'width' : 'height';
      const startProp = sameRow ? 'left' : 'top';
      const endProp = sameRow ? 'right' : 'bottom';

      const diff =
      placeholderRect[lengthProp] < rect[lengthProp] ?
      rect[lengthProp] - placeholderRect[lengthProp] :
      0;

      if (placeholderRect[startProp] < rect[startProp]) {
        if (diff && pointerPos < rect[startProp] + diff) {
          return false;
        }

        return target.nextElementSibling;
      }

      if (diff && pointerPos > rect[endProp] - diff) {
        return false;
      }

      return target;
    }

    function isHorizontal(list, placeholder) {
      const single = children(list).length === 1;

      if (single) {
        append(list, placeholder);
      }

      const items = children(list);
      const isHorizontal = items.some((el, i) => {
        const rectA = el.getBoundingClientRect();
        return items.slice(i + 1).some((el) => {
          const rectB = el.getBoundingClientRect();
          return !linesIntersect([rectA.left, rectA.right], [rectB.left, rectB.right]);
        });
      });

      if (single) {
        remove$1(placeholder);
      }

      return isHorizontal;
    }

    function linesIntersect(lineA, lineB) {
      return lineA[1] > lineB[0] && lineB[1] > lineA[0];
    }

    var tooltip = {
      mixins: [Container, Togglable, Position],

      args: 'title',

      props: {
        delay: Number,
        title: String },


      data: {
        pos: 'top',
        title: '',
        delay: 0,
        animation: ['uk-animation-scale-up'],
        duration: 100,
        cls: 'uk-active' },


      beforeConnect() {
        this._hasTitle = hasAttr(this.$el, 'title');
        attr(this.$el, 'title', '');
        this.updateAria(false);
        makeFocusable(this.$el);
      },

      disconnected() {
        this.hide();
        attr(this.$el, 'title', this._hasTitle ? this.title : null);
      },

      methods: {
        show() {
          if (this.isToggled(this.tooltip || null) || !this.title) {
            return;
          }

          this._unbind = once(
          document, "show keydown " +
          pointerDown,
          this.hide,
          false,
          (e) =>
          e.type === pointerDown && !within(e.target, this.$el) ||
          e.type === 'keydown' && e.keyCode === 27 ||
          e.type === 'show' && e.detail[0] !== this && e.detail[0].$name === this.$name);


          clearTimeout(this.showTimer);
          this.showTimer = setTimeout(this._show, this.delay);
        },

        async hide() {
          if (matches(this.$el, 'input:focus')) {
            return;
          }

          clearTimeout(this.showTimer);

          if (!this.isToggled(this.tooltip || null)) {
            return;
          }

          await this.toggleElement(this.tooltip, false, false);
          remove$1(this.tooltip);
          this.tooltip = null;
          this._unbind();
        },

        _show() {
          this.tooltip = append(
          this.container, "<div class=\"uk-" +
          this.$options.name + "\"> <div class=\"uk-" +
          this.$options.name + "-inner\">" + this.title + "</div> </div>");



          on(this.tooltip, 'toggled', (e, toggled) => {
            this.updateAria(toggled);

            if (!toggled) {
              return;
            }

            this.positionAt(this.tooltip, this.$el);

            this.origin =
            this.getAxis() === 'y' ?
            flipPosition(this.dir) + "-" + this.align :
            this.align + "-" + flipPosition(this.dir);
          });

          this.toggleElement(this.tooltip, true);
        },

        updateAria(toggled) {
          attr(this.$el, 'aria-expanded', toggled);
        } },


      events: {
        focus: 'show',
        blur: 'hide',

        [pointerEnter + " " + pointerLeave](e) {
          if (!isTouch(e)) {
            this[e.type === pointerEnter ? 'show' : 'hide']();
          }
        },

        // Clicking a button does not give it focus on all browsers and platforms
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus
        [pointerDown](e) {
          if (isTouch(e)) {
            this.show();
          }
        } } };



    function makeFocusable(el) {
      if (!isFocusable(el)) {
        attr(el, 'tabindex', '0');
      }
    }

    var upload = {
      props: {
        allow: String,
        clsDragover: String,
        concurrent: Number,
        maxSize: Number,
        method: String,
        mime: String,
        msgInvalidMime: String,
        msgInvalidName: String,
        msgInvalidSize: String,
        multiple: Boolean,
        name: String,
        params: Object,
        type: String,
        url: String },


      data: {
        allow: false,
        clsDragover: 'uk-dragover',
        concurrent: 1,
        maxSize: 0,
        method: 'POST',
        mime: false,
        msgInvalidMime: 'Invalid File Type: %s',
        msgInvalidName: 'Invalid File Name: %s',
        msgInvalidSize: 'Invalid File Size: %s Kilobytes Max',
        multiple: false,
        name: 'files[]',
        params: {},
        type: '',
        url: '',
        abort: noop,
        beforeAll: noop,
        beforeSend: noop,
        complete: noop,
        completeAll: noop,
        error: noop,
        fail: noop,
        load: noop,
        loadEnd: noop,
        loadStart: noop,
        progress: noop },


      events: {
        change(e) {
          if (!matches(e.target, 'input[type="file"]')) {
            return;
          }

          e.preventDefault();

          if (e.target.files) {
            this.upload(e.target.files);
          }

          e.target.value = '';
        },

        drop(e) {
          stop(e);

          const transfer = e.dataTransfer;

          if (!(transfer != null && transfer.files)) {
            return;
          }

          removeClass(this.$el, this.clsDragover);

          this.upload(transfer.files);
        },

        dragenter(e) {
          stop(e);
        },

        dragover(e) {
          stop(e);
          addClass(this.$el, this.clsDragover);
        },

        dragleave(e) {
          stop(e);
          removeClass(this.$el, this.clsDragover);
        } },


      methods: {
        async upload(files) {
          files = toArray(files);

          if (!files.length) {
            return;
          }

          trigger(this.$el, 'upload', [files]);

          for (const file of files) {
            if (this.maxSize && this.maxSize * 1000 < file.size) {
              this.fail(this.msgInvalidSize.replace('%s', this.maxSize));
              return;
            }

            if (this.allow && !match(this.allow, file.name)) {
              this.fail(this.msgInvalidName.replace('%s', this.allow));
              return;
            }

            if (this.mime && !match(this.mime, file.type)) {
              this.fail(this.msgInvalidMime.replace('%s', this.mime));
              return;
            }
          }

          if (!this.multiple) {
            files = files.slice(0, 1);
          }

          this.beforeAll(this, files);

          const chunks = chunk(files, this.concurrent);
          const upload = async (files) => {
            const data = new FormData();

            files.forEach((file) => data.append(this.name, file));

            for (const key in this.params) {
              data.append(key, this.params[key]);
            }

            try {
              const xhr = await ajax(this.url, {
                data,
                method: this.method,
                responseType: this.type,
                beforeSend: (env) => {
                  const { xhr } = env;
                  xhr.upload && on(xhr.upload, 'progress', this.progress);
                  for (const type of ['loadStart', 'load', 'loadEnd', 'abort']) {
                    on(xhr, type.toLowerCase(), this[type]);
                  }

                  return this.beforeSend(env);
                } });


              this.complete(xhr);

              if (chunks.length) {
                await upload(chunks.shift());
              } else {
                this.completeAll(xhr);
              }
            } catch (e) {
              this.error(e);
            }
          };

          await upload(chunks.shift());
        } } };



    function match(pattern, path) {
      return path.match(
      new RegExp("^" +
      pattern.
      replace(/\//g, '\\/').
      replace(/\*\*/g, '(\\/[^\\/]+)*').
      replace(/\*/g, '[^\\/]+').
      replace(/((?!\\))\?/g, '$1.') + "$",
      'i'));


    }

    function chunk(files, size) {
      const chunks = [];
      for (let i = 0; i < files.length; i += size) {
        chunks.push(files.slice(i, i + size));
      }
      return chunks;
    }

    function stop(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    var components = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Countdown: countdown,
        Filter: filter,
        Lightbox: lightbox,
        LightboxPanel: LightboxPanel,
        Notification: notification,
        Parallax: parallax,
        Slider: slider,
        SliderParallax: sliderParallax,
        Slideshow: slideshow,
        SlideshowParallax: sliderParallax,
        Sortable: sortable,
        Tooltip: tooltip,
        Upload: upload
    });

    each(components, (component, name) => UIkit.component(name, component));

    return UIkit;

}));

},{}]},{},[7])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJtYWluL3NyYy90cy9ibG9ja3MudHMiLCJtYWluL3NyYy90cy9ibG9ja3MvUGFnZUJsb2NrLnRzIiwibWFpbi9zcmMvdHMvYmxvY2tzL3NpZ25pbi50cyIsIm1haW4vc3JjL3RzL2Jsb2Nrcy9zaWdudXAudHMiLCJtYWluL3NyYy90cy9saWJzLnRzIiwibWFpbi9zcmMvdHMvbGlicy91aWtpdC50cyIsIm1haW4vc3JjL3RzL21haW4udHMiLCJub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbnlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL3Vpa2l0L2Rpc3QvanMvdWlraXQtaWNvbnMuanMiLCJub2RlX21vZHVsZXMvdWlraXQvZGlzdC9qcy91aWtpdC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FDQUEsNkRBQXFDO0FBQ3JDLDZEQUFxQztBQUVyQyxrQkFBZSxHQUFHLEVBQUU7SUFDaEIsSUFBSSxnQkFBTSxFQUFFLENBQUM7SUFDYixJQUFJLGdCQUFNLEVBQUUsQ0FBQztBQUNqQixDQUFDLENBQUM7Ozs7QUNORixNQUE4QixTQUFTO0lBQ25DO1FBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUNkLE9BQU87U0FDVjtRQUVELElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNqQixDQUFDO0NBSUo7QUFYRCw0QkFXQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWEQsY0FBYztBQUNkLDZDQUErQjtBQUMvQiw4REFBZ0M7QUFFaEMsNERBQW9DO0FBRXBDLE1BQXFCLE1BQU8sU0FBUSxtQkFBUztJQUE3Qzs7UUF1QlkseUJBQW9CLEdBQUcsQ0FBQyxJQUFJLEVBQVEsRUFBRTtZQUMxQyxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksT0FBTyxFQUFFO2dCQUN4QixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDakMsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQy9CLE9BQU87YUFDVjtZQUVELE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztRQUMvQixDQUFDLENBQUE7SUFrQkwsQ0FBQztJQTdDYSxJQUFJO1FBQ1YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDcEMsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxJQUFJLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDdkQsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBRXZFLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFUyxLQUFLO1FBQ1gsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3ZCLENBQUM7SUFFTyxlQUFlLENBQUMsU0FBaUI7UUFDckMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0lBQzdDLENBQUM7SUFZTyxXQUFXO1FBQ2YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUM5QyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7WUFFdkIsSUFBQSxxQkFBSyxFQUFDLGNBQWMsRUFBRTtnQkFDbEIsTUFBTSxFQUFFLE1BQU07Z0JBQ2QsSUFBSSxFQUFFLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7YUFDbkMsQ0FBQztpQkFDRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUM7aUJBQy9CLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDWCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNuQixLQUFLLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2xDLENBQUMsQ0FBQyxDQUFDO1FBQ1gsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0NBQ0o7QUFqREQseUJBaURDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2REQsY0FBYztBQUNkLDZDQUErQjtBQUMvQiw0REFBb0M7QUFFcEMsTUFBcUIsTUFBTyxTQUFRLG1CQUFTO0lBQTdDOztRQWlCWSxxQkFBZ0IsR0FBRyxHQUFTLEVBQUU7WUFDbEMsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1lBQzVFLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxhQUFhLEVBQUUsRUFBRTtnQkFDckMsYUFBYSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7WUFDakMsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUE7UUFFTyxvQkFBZSxHQUFHLENBQUMsU0FBUyxFQUFFLEtBQWEsRUFBUSxFQUFFO1lBQ3pELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLGtCQUFrQixTQUFTLHVCQUF1QixDQUFDLENBQUM7WUFDaEcsUUFBUSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDL0IsQ0FBQyxDQUFBO1FBVU8seUJBQW9CLEdBQUcsQ0FBQyxJQUFJLEVBQVEsRUFBRTtZQUMxQyxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksT0FBTyxFQUFFO2dCQUN4QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUNuQyxPQUFPO2FBQ1Y7WUFFRCxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxTQUFTLENBQUM7UUFDckMsQ0FBQyxDQUFBO0lBa0JMLENBQUM7SUEzRGEsSUFBSTtRQUNWLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3BDLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRXZELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFUyxLQUFLO1FBQ1gsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3ZCLENBQUM7SUFjTyxnQkFBZ0IsQ0FBQyxNQUFjO1FBQ25DLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBRXhCLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUNsRCxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMzQyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFXTyxXQUFXO1FBQ2YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUM5QyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7WUFFdkIsS0FBSyxDQUFDLGNBQWMsRUFBRTtnQkFDbEIsTUFBTSxFQUFFLE1BQU07Z0JBQ2QsSUFBSSxFQUFFLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7YUFDbkMsQ0FBQztpQkFDRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUM7aUJBQy9CLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDWCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNuQixLQUFLLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2xDLENBQUMsQ0FBQyxDQUFDO1FBQ1gsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0NBQ0o7QUE5REQseUJBOERDOzs7Ozs7O0FDbEVELHlEQUFxQztBQUVyQyxrQkFBZSxHQUFTLEVBQUU7SUFDdEIsSUFBQSxlQUFTLEdBQUUsQ0FBQztBQUNoQixDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hGLGNBQWM7QUFDZCw2Q0FBK0I7QUFDL0IsNEVBQThDO0FBRTlDLGtCQUFlLEdBQUcsRUFBRTtJQUNoQixLQUFLLENBQUMsR0FBRyxDQUFDLHFCQUFLLENBQUMsQ0FBQztBQUNyQixDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNORixrREFBOEI7QUFDOUIsc0RBQXdDO0FBRXhDLE1BQU0sSUFBSSxHQUFHLEdBQVMsRUFBRTtJQUNwQixJQUFBLGNBQVEsR0FBRSxDQUFDO0lBQ1gsSUFBQSxnQkFBZ0IsR0FBRSxDQUFDO0FBQ3ZCLENBQUMsQ0FBQSxDQUFDO0FBRUYsSUFBSSxFQUFFLENBQUM7O0FDVFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJpbXBvcnQgc2lnbmluIGZyb20gJy4vYmxvY2tzL3NpZ25pbic7XHJcbmltcG9ydCBzaWdudXAgZnJvbSAnLi9ibG9ja3Mvc2lnbnVwJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0ICgpID0+IHtcclxuICAgIG5ldyBzaWduaW4oKTtcclxuICAgIG5ldyBzaWdudXAoKTtcclxufTsiLCJleHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBQYWdlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGluaXQoKTogYm9vbGVhblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHN0YXJ0KCk6IHZvaWRcclxufSIsIi8vIEB0cy1ub2NoZWNrXHJcbmltcG9ydCAqIGFzIFVJa2l0IGZyb20gJ3Vpa2l0JztcclxuaW1wb3J0IGZldGNoIGZyb20gJ2Nyb3NzLWZldGNoJztcclxuXHJcbmltcG9ydCBQYWdlQmxvY2sgZnJvbSAnLi9QYWdlQmxvY2snO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mgc2lnbmluIGV4dGVuZHMgUGFnZUJsb2NrIHtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgZm9ybURvbTtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgZm9ybUVycm9yc0RvbTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgaW5pdCgpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zaWduaW4nKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZvcm1Eb20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnNpZ25pbl9fZm9ybVwiKTtcclxuICAgICAgICB0aGlzLmZvcm1FcnJvcnNEb20gPSB0aGlzLmZvcm1Eb20ucXVlcnlTZWxlY3RvcihcIi5zaWdudXBfX2Zvcm0tZXJyb3JcIik7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGFydCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmZvcm1IYW5kbGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVGb3JtRXJyb3IoZXJyb3JUZXh0OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmZvcm1FcnJvcnNEb20uaW5uZXJIVE1MID0gZXJyb3JUZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2lnbmluUmVxdWVzdEhhbmRsZXIgPSAoZGF0YSk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybUVycm9yKGRhdGEuZXJyb3IpO1xyXG4gICAgICAgICAgICBVSWtpdC5ub3RpZmljYXRpb24oZGF0YS5lcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy8nO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZm9ybUhhbmRsZXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5mb3JtRG9tLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgZmV0Y2goJy9zaWduaW4vcG9zdCcsIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICAgICAgYm9keTogbmV3IEZvcm1EYXRhKHRoaXMuZm9ybURvbSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuc2lnbmluUmVxdWVzdEhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBVSWtpdC5ub3RpZmljYXRpb24oJ9Ce0YjQuNCx0LrQsCEnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiLy8gQHRzLW5vY2hlY2tcclxuaW1wb3J0ICogYXMgVUlraXQgZnJvbSAndWlraXQnO1xyXG5pbXBvcnQgUGFnZUJsb2NrIGZyb20gJy4vUGFnZUJsb2NrJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHNpZ251cCBleHRlbmRzIFBhZ2VCbG9jayB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZvcm1Eb207XHJcblxyXG4gICAgcHJvdGVjdGVkIGluaXQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2lnbnVwJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5mb3JtRG9tID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5zaWdudXBfX2Zvcm1cIik7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGFydCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmZvcm1IYW5kbGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjbGVhckZpZWxkRXJyb3JzID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzRG9tID0gdGhpcy5mb3JtRG9tLnF1ZXJ5U2VsZWN0b3JBbGwoYC5zaWdudXBfX2Zvcm0tZXJyb3JgKTtcclxuICAgICAgICBmaWVsZEVycm9yc0RvbS5mb3JFYWNoKChmaWVsZEVycm9yRG9tKSA9PiB7XHJcbiAgICAgICAgICAgIGZpZWxkRXJyb3JEb20uaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBwcmludEZpZWxkRXJyb3IgPSAoZmllbGROYW1lLCBlcnJvcjogc3RyaW5nKTogdm9pZCA9PiB7XHJcbiAgICAgICAgY29uc3QgZmllbGREb20gPSB0aGlzLmZvcm1Eb20ucXVlcnlTZWxlY3RvcihgLnNpZ251cF9fZmllbGQtJHtmaWVsZE5hbWV9IHAuc2lnbnVwX19mb3JtLWVycm9yYCk7XHJcbiAgICAgICAgZmllbGREb20uaW5uZXJIVE1MID0gZXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVGb3JtRXJyb3JzKGVycm9yczogb2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckZpZWxkRXJyb3JzKCk7XHJcblxyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGVycm9ycykuZm9yRWFjaCgoW2ZpZWxkTmFtZSwgZXJyb3JdKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJpbnRGaWVsZEVycm9yKGZpZWxkTmFtZSwgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2lnbmluUmVxdWVzdEhhbmRsZXIgPSAoZGF0YSk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybUVycm9ycyhkYXRhLmVycm9ycyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9zaWduaW4nO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZm9ybUhhbmRsZXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5mb3JtRG9tLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgZmV0Y2goJy9zaWdudXAvcG9zdCcsIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICAgICAgYm9keTogbmV3IEZvcm1EYXRhKHRoaXMuZm9ybURvbSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuc2lnbmluUmVxdWVzdEhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBVSWtpdC5ub3RpZmljYXRpb24oJ9Ce0YjQuNCx0LrQsCEnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHVpa2l0SW5pdCBmcm9tICcuL2xpYnMvdWlraXQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgKCk6IHZvaWQgPT4ge1xyXG4gICAgdWlraXRJbml0KCk7XHJcbn07IiwiXHJcbi8vIEB0cy1ub2NoZWNrXHJcbmltcG9ydCAqIGFzIFVJa2l0IGZyb20gJ3Vpa2l0JztcclxuaW1wb3J0IEljb25zIGZyb20gJ3Vpa2l0L2Rpc3QvanMvdWlraXQtaWNvbnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xyXG4gICAgVUlraXQudXNlKEljb25zKTtcclxufTsiLCJcclxuaW1wb3J0IGluaXRMaWJzIGZyb20gJy4vbGlicyc7XHJcbmltcG9ydCBpbml0QmxvY2tTY3JpcHRzIGZyb20gJy4vYmxvY2tzJztcclxuXHJcbmNvbnN0IG1haW4gPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpbml0TGlicygpO1xyXG4gICAgaW5pdEJsb2NrU2NyaXB0cygpO1xyXG59O1xyXG5cclxubWFpbigpOyIsInZhciBnbG9iYWwgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcztcbnZhciBfX3NlbGZfXyA9IChmdW5jdGlvbiAoKSB7XG5mdW5jdGlvbiBGKCkge1xudGhpcy5mZXRjaCA9IGZhbHNlO1xudGhpcy5ET01FeGNlcHRpb24gPSBnbG9iYWwuRE9NRXhjZXB0aW9uXG59XG5GLnByb3RvdHlwZSA9IGdsb2JhbDtcbnJldHVybiBuZXcgRigpO1xufSkoKTtcbihmdW5jdGlvbihzZWxmKSB7XG5cbnZhciBpcnJlbGV2YW50ID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snO1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0pKHt9KTtcbn0pKF9fc2VsZl9fKTtcbl9fc2VsZl9fLmZldGNoLnBvbnlmaWxsID0gdHJ1ZTtcbi8vIFJlbW92ZSBcInBvbHlmaWxsXCIgcHJvcGVydHkgYWRkZWQgYnkgd2hhdHdnLWZldGNoXG5kZWxldGUgX19zZWxmX18uZmV0Y2gucG9seWZpbGw7XG4vLyBDaG9vc2UgYmV0d2VlbiBuYXRpdmUgaW1wbGVtZW50YXRpb24gKGdsb2JhbCkgb3IgY3VzdG9tIGltcGxlbWVudGF0aW9uIChfX3NlbGZfXylcbi8vIHZhciBjdHggPSBnbG9iYWwuZmV0Y2ggPyBnbG9iYWwgOiBfX3NlbGZfXztcbnZhciBjdHggPSBfX3NlbGZfXzsgLy8gdGhpcyBsaW5lIGRpc2FibGUgc2VydmljZSB3b3JrZXIgc3VwcG9ydCB0ZW1wb3JhcmlseVxuZXhwb3J0cyA9IGN0eC5mZXRjaCAvLyBUbyBlbmFibGU6IGltcG9ydCBmZXRjaCBmcm9tICdjcm9zcy1mZXRjaCdcbmV4cG9ydHMuZGVmYXVsdCA9IGN0eC5mZXRjaCAvLyBGb3IgVHlwZVNjcmlwdCBjb25zdW1lcnMgd2l0aG91dCBlc01vZHVsZUludGVyb3AuXG5leHBvcnRzLmZldGNoID0gY3R4LmZldGNoIC8vIFRvIGVuYWJsZTogaW1wb3J0IHtmZXRjaH0gZnJvbSAnY3Jvc3MtZmV0Y2gnXG5leHBvcnRzLkhlYWRlcnMgPSBjdHguSGVhZGVyc1xuZXhwb3J0cy5SZXF1ZXN0ID0gY3R4LlJlcXVlc3RcbmV4cG9ydHMuUmVzcG9uc2UgPSBjdHguUmVzcG9uc2Vcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1xuIiwiLyohIFVJa2l0IDMuMTMuOSB8IGh0dHBzOi8vd3d3LmdldHVpa2l0LmNvbSB8IChjKSAyMDE0IC0gMjAyMiBZT090aGVtZSB8IE1JVCBMaWNlbnNlICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgndWlraXRpY29ucycsIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVUlraXRJY29ucyA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBwbHVnaW4oVUlraXQpIHtcbiAgICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgVUlraXQuaWNvbi5hZGQoe1xuICAgICAgICBcIjUwMHB4XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNOS42MjQsMTEuODY2Yy0wLjE0MSwwLjEzMiwwLjQ3OSwwLjY1OCwwLjY2MiwwLjQxOGMwLjA1MS0wLjA0NiwwLjYwNy0wLjYxLDAuNjYyLTAuNjY0YzAsMCwwLjczOCwwLjcxOSwwLjgxNCwwLjcxOSBjMC4xLDAsMC4yMDctMC4wNTUsMC4zMjItMC4xN2MwLjI3LTAuMjY5LDAuMTM1LTAuNDE2LDAuMDY2LTAuNDk1bC0wLjYzMS0wLjYxNmwwLjY1OC0wLjY2OGMwLjE0Ni0wLjE1NiwwLjAyMS0wLjMxNC0wLjEtMC40NDkgYy0wLjE4Mi0wLjE4LTAuMzU5LTAuMjI2LTAuNDcxLTAuMTI1bC0wLjY1NiwwLjY1NGwtMC42NTQtMC42NTRjLTAuMDMzLTAuMDM0LTAuMDgtMC4wNDUtMC4xMjQtMC4wNDUgYy0wLjA3OSwwLTAuMTkxLDAuMDY4LTAuMzA3LDAuMTgxYy0wLjIwMiwwLjIwMi0wLjI0NywwLjM1MS0wLjEzMywwLjQ2MmwwLjY2NSwwLjY2NUw5LjYyNCwxMS44NjZ6XFxcIi8+PHBhdGggZD1cXFwiTTExLjA2NiwyLjg4NGMtMS4wNjEsMC0yLjE4NSwwLjI0OC0zLjAxMSwwLjYwNGMtMC4wODcsMC4wMzQtMC4xNDEsMC4xMDYtMC4xNSwwLjIwNUM3Ljg5MywzLjc4NCw3LjkxOSwzLjkwOSw3Ljk4Miw0LjA2NiBjMC4wNSwwLjEzNiwwLjE4NywwLjQ3NCwwLjQ1MiwwLjM3MmMwLjg0NC0wLjMyNiwxLjc3OS0wLjUwNywyLjYzMy0wLjUwN2MwLjk2MywwLDEuOSwwLjE5MSwyLjc4MSwwLjU2NCBjMC42OTUsMC4yOTIsMS4zNTcsMC43MTksMi4wNzgsMS4zNGMwLjA1MSwwLjA0NCwwLjEwNSwwLjA2OCwwLjE2NCwwLjA2OGMwLjE0MywwLDAuMjczLTAuMTM3LDAuMzg5LTAuMjcxIGMwLjE5MS0wLjIxNCwwLjMyNC0wLjM5NSwwLjEzNS0wLjU3NWMtMC42ODYtMC42NTQtMS40MzYtMS4xMzgtMi4zNjMtMS41MzNDMTMuMjQsMy4wOTcsMTIuMTY4LDIuODg0LDExLjA2NiwyLjg4NHpcXFwiLz48cGF0aCBkPVxcXCJNMTYuNDMsMTUuNzQ3Yy0wLjA5Mi0wLjAyOC0wLjI0MiwwLjA1LTAuMzA5LDAuMTE5bDAsMGMtMC42NTIsMC42NTItMS40MiwxLjE2OS0yLjI2OCwxLjUyMSBjLTAuODc3LDAuMzcxLTEuODE0LDAuNTUxLTIuNzc5LDAuNTUxYy0wLjk2MSwwLTEuODk2LTAuMTg5LTIuNzc1LTAuNTY0Yy0wLjg0OC0wLjM2LTEuNjEyLTAuODc5LTIuMjY4LTEuNTMgYy0wLjY4Mi0wLjY4OC0xLjE5Ni0xLjQ1NS0xLjUyOS0yLjI2OGMtMC4zMjUtMC43OTktMC40NzEtMS42NDMtMC40NzEtMS42NDNjLTAuMDQ1LTAuMjQtMC4yNTgtMC4yNDktMC41NjctMC4yMDMgYy0wLjEyOCwwLjAyMS0wLjUxOSwwLjA3OS0wLjQ4MywwLjM2djAuMDFjMC4xMDUsMC42NDQsMC4yODksMS4yODQsMC41NDUsMS44OTVjMC40MTcsMC45NjksMS4wMDIsMS44NDksMS43NTYsMi42MDQgYzAuNzU3LDAuNzU0LDEuNjM2LDEuMzQsMi42MDQsMS43NTdDOC45MDEsMTguNzg1LDkuOTcsMTksMTEuMDg4LDE5YzEuMTA0LDAsMi4xODYtMC4yMTUsMy4xODgtMC42NDUgYzEuODM4LTAuODk2LDIuNjA0LTEuNzU3LDIuNjA0LTEuNzU3YzAuMTgyLTAuMjA0LDAuMjI3LTAuMzE3LTAuMS0wLjY0M0MxNi43NzksMTUuOTU2LDE2LjUyNSwxNS43NzQsMTYuNDMsMTUuNzQ3elxcXCIvPjxwYXRoIGQ9XFxcIk01LjYzMywxMy4yODdjMC4yOTMsMC43MSwwLjcyMywxLjM0MSwxLjI2MiwxLjg4MmMwLjU0LDAuNTQsMS4xNzIsMC45NzEsMS44ODIsMS4yNjRjMC43MzEsMC4zMDMsMS41MDksMC40NjEsMi4yOTgsMC40NjEgYzAuODAxLDAsMS41NzgtMC4xNTgsMi4yOTctMC40NjFjMC43MTEtMC4yOTMsMS4zNDQtMC43MjQsMS44ODMtMS4yNjRjMC41NDMtMC41NDEsMC45NzEtMS4xNzIsMS4yNjQtMS44ODIgYzAuMzE0LTAuNzIxLDAuNDYzLTEuNSwwLjQ2My0yLjI5OGMwLTAuNzktMC4xNDgtMS41NjktMC40NjMtMi4yODljLTAuMjkzLTAuNjk5LTAuNzIxLTEuMzI5LTEuMjY0LTEuODgxIGMtMC41MzktMC41NDEtMS4xNzItMC45NTktMS44NjctMS4yNjNjLTAuNzIxLTAuMzAzLTEuNS0wLjQ2MS0yLjI5OS0wLjQ2MWMtMC44MDIsMC0xLjYxMywwLjE1OS0yLjMyMiwwLjQ2MSBjLTAuNTc3LDAuMjUtMS41NDQsMC44NjctMi4xMTksMS40NTR2MC4wMTJWMi4xMDhoOC4xNkMxNS4xLDIuMTA0LDE1LjEsMS42OSwxNS4xLDEuNTUyQzE1LjEsMS40MTcsMTUuMSwxLDE0LjgwOSwxSDUuOTE1IEM1LjY3NiwxLDUuNTI3LDEuMTkyLDUuNTI3LDEuMzg0djYuODRjMCwwLjIxNCwwLjI3MywwLjM3MiwwLjUyOSwwLjQyOGMwLjUsMC4xMDUsMC42MTQtMC4wNTYsMC43MzctMC4yMjRsMCwwIGMwLjE4LTAuMjczLDAuNzc2LTAuODg0LDAuNzg3LTAuODk0YzAuOTAxLTAuOTA1LDIuMTE3LTEuNDA4LDMuNDE2LTEuNDA4YzEuMjg1LDAsMi41LDAuNTAxLDMuNDEyLDEuNDA4IGMwLjkxNCwwLjkxNCwxLjQwOCwyLjEyMiwxLjQwOCwzLjQwNWMwLDEuMjg4LTAuNTA4LDIuNDk2LTEuNDA4LDMuNDA1Yy0wLjksMC44OTYtMi4xNTIsMS40MDYtMy40MzgsMS40MDYgYy0wLjg3NywwLTEuNzExLTAuMjI5LTIuNDMzLTAuNjcxdi00LjE1OGMwLTAuNTUzLDAuMjM3LTEuMTUxLDAuNjQzLTEuNjE0YzAuNDYyLTAuNTE5LDEuMDk0LTAuNzk5LDEuNzgyLTAuNzk5IGMwLjY2NCwwLDEuMjkzLDAuMjUzLDEuNzU4LDAuNzE1YzAuNDU5LDAuNDU5LDAuNzA5LDEuMDcxLDAuNzA5LDEuNzIzYzAsMS4zODUtMS4wOTQsMi40NjgtMi40ODgsMi40NjggYy0wLjI3MywwLTAuNzY5LTAuMTIxLTAuNzgxLTAuMTI1Yy0wLjI4MS0wLjA4Ny0wLjQwNSwwLjMwNi0wLjQzOCwwLjQzNmMtMC4xNTksMC40OTYsMC4wNzksMC41ODUsMC4xMjMsMC42MDcgYzAuNDUyLDAuMTM3LDAuNzQzLDAuMTU3LDEuMTI5LDAuMTU3YzEuOTczLDAsMy41NzItMS42LDMuNTcyLTMuNTdjMC0xLjk2NC0xLjYtMy41NTItMy41NzItMy41NTJjLTAuOTcsMC0xLjg3MiwwLjM2LTIuNTQ2LDEuMDM4IGMtMC42NTYsMC42MzEtMS4wMjcsMS40ODctMS4wMjcsMi4zMjJ2My40Mzh2LTAuMDExYy0wLjM3Mi0wLjQyLTAuNzMyLTEuMDQxLTAuOTgxLTEuNjgyYy0wLjEwMi0wLjI0OC0wLjMxNS0wLjIwMi0wLjYwNy0wLjExMyBjLTAuMTM1LDAuMDM1LTAuNTE5LDAuMTU3LTAuNDQsMC40MzlDNS4zNzIsMTIuNzk5LDUuNTc3LDEzLjE2NCw1LjYzMywxMy4yODd6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYWxidW1cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjVcXFwiIHk9XFxcIjJcXFwiIHdpZHRoPVxcXCIxMFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiM1xcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjE0XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjEuNVxcXCIgeT1cXFwiNi41XFxcIiB3aWR0aD1cXFwiMTdcXFwiIGhlaWdodD1cXFwiMTFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJhcnJvdy1kb3duXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjEwLjUsMTYuMDggNS42MywxMC42NiA2LjM3LDEwIDEwLjUsMTQuNTggMTQuNjMsMTAgMTUuMzcsMTAuNjZcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCIxMC41XFxcIiB5MT1cXFwiNFxcXCIgeDI9XFxcIjEwLjVcXFwiIHkyPVxcXCIxNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImFycm93LWxlZnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTAgMTQgNSA5LjUgMTAgNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjE2XFxcIiB5MT1cXFwiOS41XFxcIiB4Mj1cXFwiNVxcXCIgeTI9XFxcIjkuNTJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJhcnJvdy1yaWdodFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIxMCA1IDE1IDkuNSAxMCAxNFxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjRcXFwiIHkxPVxcXCI5LjVcXFwiIHgyPVxcXCIxNVxcXCIgeTI9XFxcIjkuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImFycm93LXVwXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjEwLjUsNCAxNS4zNyw5LjQgMTQuNjMsMTAuMDggMTAuNSw1LjQ5IDYuMzcsMTAuMDggNS42Myw5LjRcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCIxMC41XFxcIiB5MT1cXFwiMTZcXFwiIHgyPVxcXCIxMC41XFxcIiB5Mj1cXFwiNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImJhZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNNy41LDcuNVY0QTIuNDgsMi40OCwwLDAsMSwxMCwxLjUsMi41NCwyLjU0LDAsMCwxLDEyLjUsNFY3LjVcXFwiLz48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTYuNSA3LjUgMy41IDcuNSAyLjUgMTguNSAxNy41IDE4LjUgMTYuNSA3LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJiYW5cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiNFxcXCIgeTE9XFxcIjMuNVxcXCIgeDI9XFxcIjE2XFxcIiB5Mj1cXFwiMTYuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImJlaGFuY2VcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk05LjUsMTAuNmMtMC40LTAuNS0wLjktMC45LTEuNi0xLjFjMS43LTEsMi4yLTMuMiwwLjctNC43QzcuOCw0LDYuMyw0LDUuMiw0QzMuNSw0LDEuNyw0LDAsNHYxMmMxLjcsMCwzLjQsMCw1LjIsMCBjMSwwLDIuMSwwLDMuMS0wLjVDMTAuMiwxNC42LDEwLjUsMTIuMyw5LjUsMTAuNkw5LjUsMTAuNnogTTUuNiw2LjFjMS44LDAsMS44LDIuNy0wLjEsMi43Yy0xLDAtMiwwLTIuOSwwVjYuMUg1LjZ6IE0yLjYsMTMuOHYtMy4xIGMxLjEsMCwyLjEsMCwzLjIsMGMyLjEsMCwyLjEsMy4yLDAuMSwzLjJMMi42LDEzLjh6XFxcIi8+PHBhdGggZD1cXFwiTTE5LjksMTAuOUMxOS43LDkuMiwxOC43LDcuNiwxNyw3Yy00LjItMS4zLTcuMywzLjQtNS4zLDcuMWMwLjksMS43LDIuOCwyLjMsNC43LDIuMWMxLjctMC4yLDIuOS0xLjMsMy40LTIuOWgtMi4yIGMtMC40LDEuMy0yLjQsMS41LTMuNSwwLjZjLTAuNC0wLjQtMC42LTEuMS0wLjYtMS43SDIwQzIwLDExLjcsMTkuOSwxMC45LDE5LjksMTAuOXogTTEzLjUsMTAuNmMwLTEuNiwyLjMtMi43LDMuNS0xLjQgYzAuNCwwLjQsMC41LDAuOSwwLjYsMS40SDEzLjVMMTMuNSwxMC42elxcXCIvPjxyZWN0IHg9XFxcIjEzXFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiNVxcXCIgaGVpZ2h0PVxcXCIxLjRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJiZWxsXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTcsMTUuNSBMMywxNS41IEMyLjk5LDE0LjYxIDMuNzksMTMuMzQgNC4xLDEyLjUxIEM0LjU4LDExLjMgNC43MiwxMC4zNSA1LjE5LDcuMDEgQzUuNTQsNC41MyA1Ljg5LDMuMiA3LjI4LDIuMTYgQzguMTMsMS41NiA5LjM3LDEuNSA5LjgxLDEuNSBMOS45NiwxLjUgQzkuOTYsMS41IDExLjYyLDEuNDEgMTIuNjcsMi4xNyBDMTQuMDgsMy4yIDE0LjQyLDQuNTQgMTQuNzcsNy4wMiBDMTUuMjYsMTAuMzUgMTUuNCwxMS4zMSAxNS44NywxMi41MiBDMTYuMiwxMy4zNCAxNy4wMSwxNC42MSAxNywxNS41IEwxNywxNS41IFpcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xMi4zOSwxNiBDMTIuMzksMTcuMzcgMTEuMzUsMTguNDMgOS45MSwxOC40MyBDOC40OCwxOC40MyA3LjQyLDE3LjM3IDcuNDIsMTZcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJib2xkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNSwxNS4zIEM1LjY2LDE1LjMgNS45LDE1IDUuOSwxNC41MyBMNS45LDUuNSBDNS45LDQuOTIgNS41Niw0LjcgNSw0LjcgTDUsNCBMOC45NSw0IEMxMi42LDQgMTMuNyw1LjM3IDEzLjcsNi45IEMxMy43LDcuODcgMTMuMTQsOS4xNyAxMC44Niw5LjU5IEwxMC44Niw5LjcgQzEzLjI1LDkuODYgMTQuMjksMTEuMjggMTQuMywxMi41NCBDMTQuMywxNC40NyAxMi45NCwxNiA5LDE2IEw1LDE2IEw1LDE1LjMgWiBNOSw5LjMgQzExLjE5LDkuMyAxMS44LDguNSAxMS44NSw3IEMxMS44NSw1LjY1IDExLjMsNC44IDksNC44IEw3LjY3LDQuOCBMNy42Nyw5LjMgTDksOS4zIFogTTkuMTg1LDE1LjIyIEMxMS45NywxNSAxMi4zOSwxNCAxMi40LDEyLjU4IEMxMi40LDExLjE1IDExLjM5LDEwIDksMTAgTDcuNjcsMTAgTDcuNjcsMTUgTDkuMTgsMTUgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImJvbHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk00Ljc0LDIwIEw3LjczLDEyIEwzLDEyIEwxNS40MywxIEwxMi4zMiw5IEwxNy4wMiw5IEw0Ljc0LDIwIEw0Ljc0LDIwIEw0Ljc0LDIwIFogTTkuMTgsMTEgTDcuMSwxNi4zOSBMMTQuNDcsMTAgTDEwLjg2LDEwIEwxMi45OSw0LjY3IEw1LjYxLDExIEw5LjE4LDExIEw5LjE4LDExIEw5LjE4LDExIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJib29rbWFya1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjUuNSAxLjUgMTUuNSAxLjUgMTUuNSAxNy41IDEwLjUgMTIuNSA1LjUgMTcuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNhbGVuZGFyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNIDIsMyAyLDE3IDE4LDE3IDE4LDMgMiwzIFogTSAxNywxNiAzLDE2IDMsOCAxNyw4IDE3LDE2IFogTSAxNyw3IDMsNyAzLDQgMTcsNCAxNyw3IFpcXFwiLz48cmVjdCB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIzXFxcIiB4PVxcXCI2XFxcIiB5PVxcXCIyXFxcIi8+PHJlY3Qgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiM1xcXCIgeD1cXFwiMTNcXFwiIHk9XFxcIjJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjYW1lcmFcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTAuOFxcXCIgcj1cXFwiMy44XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMSw0LjUgQzAuNyw0LjUgMC41LDQuNyAwLjUsNSBMMC41LDE3IEMwLjUsMTcuMyAwLjcsMTcuNSAxLDE3LjUgTDE5LDE3LjUgQzE5LjMsMTcuNSAxOS41LDE3LjMgMTkuNSwxNyBMMTkuNSw1IEMxOS41LDQuNyAxOS4zLDQuNSAxOSw0LjUgTDEzLjUsNC41IEwxMy41LDIuOSBDMTMuNSwyLjYgMTMuMywyLjUgMTMsMi41IEw3LDIuNSBDNi43LDIuNSA2LjUsMi42IDYuNSwyLjkgTDYuNSw0LjUgTDEsNC41IEwxLDQuNSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2FydFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBjeD1cXFwiNy4zXFxcIiBjeT1cXFwiMTcuM1xcXCIgcj1cXFwiMS40XFxcIi8+PGNpcmNsZSBjeD1cXFwiMTMuM1xcXCIgY3k9XFxcIjE3LjNcXFwiIHI9XFxcIjEuNFxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMCAyIDMuMiA0IDUuMyAxMi41IDE2IDEyLjUgMTggNi41IDggNi41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hlY2tcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBwb2ludHM9XFxcIjQsMTAgOCwxNSAxNyw0XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi1kb3VibGUtbGVmdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBwb2ludHM9XFxcIjEwIDE0IDYgMTAgMTAgNlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgcG9pbnRzPVxcXCIxNCAxNCAxMCAxMCAxNCA2XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi1kb3VibGUtcmlnaHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgcG9pbnRzPVxcXCIxMCA2IDE0IDEwIDEwIDE0XFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBwb2ludHM9XFxcIjYgNiAxMCAxMCA2IDE0XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi1kb3duXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiMTYgNyAxMCAxMyA0IDdcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjaGV2cm9uLWxlZnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgcG9pbnRzPVxcXCIxMyAxNiA3IDEwIDEzIDRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjaGV2cm9uLXJpZ2h0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiNyA0IDEzIDEwIDcgMTZcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjaGV2cm9uLXVwXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiNCAxMyAxMCA3IDE2IDEzXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2xvY2tcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48cmVjdCB4PVxcXCI5XFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI3XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEzLjAxOCwxNC4xOTcgTDkuNDQ1LDEwLjYyNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNsb3NlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wNlxcXCIgZD1cXFwiTTE2LDE2IEw0LDRcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wNlxcXCIgZD1cXFwiTTE2LDQgTDQsMTZcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjbG91ZC1kb3dubG9hZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTYuNSwxNC42MSBMMy43NSwxNC42MSBDMS45NiwxNC42MSAwLjUsMTMuMTcgMC41LDExLjM5IEMwLjUsOS43NiAxLjcyLDguNDEgMy4zLDguMiBDMy4zOCw1LjMxIDUuNzUsMyA4LjY4LDMgQzExLjE5LDMgMTMuMzEsNC43MSAxMy44OSw3LjAyIEMxNC4zOSw2LjggMTQuOTMsNi42OCAxNS41LDYuNjggQzE3LjcxLDYuNjggMTkuNSw4LjQ1IDE5LjUsMTAuNjQgQzE5LjUsMTIuODMgMTcuNzEsMTQuNiAxNS41LDE0LjYgTDEyLjUsMTQuNlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTEuNzUgMTYgOS41IDE4LjI1IDcuMjUgMTZcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk05LjUsMTggTDkuNSw5LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjbG91ZC11cGxvYWRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk02LjUsMTQuNjEgTDMuNzUsMTQuNjEgQzEuOTYsMTQuNjEgMC41LDEzLjE3IDAuNSwxMS4zOSBDMC41LDkuNzYgMS43Miw4LjQxIDMuMzEsOC4yIEMzLjM4LDUuMzEgNS43NSwzIDguNjgsMyBDMTEuMTksMyAxMy4zMSw0LjcxIDEzLjg5LDcuMDIgQzE0LjM5LDYuOCAxNC45Myw2LjY4IDE1LjUsNi42OCBDMTcuNzEsNi42OCAxOS41LDguNDUgMTkuNSwxMC42NCBDMTkuNSwxMi44MyAxNy43MSwxNC42IDE1LjUsMTQuNiBMMTIuNSwxNC42XFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI3LjI1IDExLjc1IDkuNSA5LjUgMTEuNzUgMTEuNzVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk05LjUsMTggTDkuNSw5LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjb2RlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDFcXFwiIHBvaW50cz1cXFwiMTMsNCAxOSwxMCAxMywxNlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wMVxcXCIgcG9pbnRzPVxcXCI3LDQgMSwxMCA3LDE2XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY29nXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjkuOTk3XFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjMuMzFcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xOC40ODgsMTIuMjg1IEwxNi4yMDUsMTYuMjM3IEMxNS4zMjIsMTUuNDk2IDE0LjE4NSwxNS4yODEgMTMuMzAzLDE1Ljc5MSBDMTIuNDI4LDE2LjI4OSAxMi4wNDcsMTcuMzczIDEyLjI0NiwxOC41IEw3LjczNSwxOC41IEM3LjkzOCwxNy4zNzQgNy41NTMsMTYuMjk5IDYuNjg0LDE1Ljc5MSBDNS44MDEsMTUuMjcgNC42NTUsMTUuNDkyIDMuNzczLDE2LjIzNyBMMS41LDEyLjI4NSBDMi41NzMsMTEuODcxIDMuMzE3LDEwLjk5OSAzLjMxNyw5Ljk5MSBDMy4zMDUsOC45OCAyLjU3Myw4LjEyMSAxLjUsNy43MTYgTDMuNzY1LDMuNzg0IEM0LjY0NSw0LjUxNiA1Ljc5NCw0LjczOCA2LjY4Nyw0LjIzMiBDNy41NTUsMy43MjIgNy45MzksMi42MzcgNy43MzUsMS41IEwxMi4yNjMsMS41IEMxMi4wNzIsMi42MzcgMTIuNDQxLDMuNzEgMTMuMzE0LDQuMjIgQzE0LjIwNiw0LjczIDE1LjM0Myw0LjUxNiAxNi4yMjUsMy43OTQgTDE4LjQ4Nyw3LjcxNCBDMTcuNDA0LDguMTE3IDE2LjY2MSw4Ljk4OCAxNi42NywxMC4wMDkgQzE2LjY3MiwxMS4wMTggMTcuNDE1LDExLjg4IDE4LjQ4OCwxMi4yODUgTDE4LjQ4OCwxMi4yODUgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNvbW1lbnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk02LDE4LjcxIEw2LDE0IEwxLDE0IEwxLDEgTDE5LDEgTDE5LDE0IEwxMC43MSwxNCBMNiwxOC43MSBMNiwxOC43MSBaIE0yLDEzIEw3LDEzIEw3LDE2LjI5IEwxMC4yOSwxMyBMMTgsMTMgTDE4LDIgTDIsMiBMMiwxMyBMMiwxMyBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY29tbWVudGluZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjEuNSwxLjUgMTguNSwxLjUgMTguNSwxMy41IDEwLjUsMTMuNSA2LjUsMTcuNSA2LjUsMTMuNSAxLjUsMTMuNVxcXCIvPjxjaXJjbGUgY3g9XFxcIjEwXFxcIiBjeT1cXFwiOFxcXCIgcj1cXFwiMVxcXCIvPjxjaXJjbGUgY3g9XFxcIjZcXFwiIGN5PVxcXCI4XFxcIiByPVxcXCIxXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTRcXFwiIGN5PVxcXCI4XFxcIiByPVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY29tbWVudHNcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMiAwLjUgMTkuNSAwLjUgMTkuNSAxM1xcXCIvPjxwYXRoIGQ9XFxcIk01LDE5LjcxIEw1LDE1IEwwLDE1IEwwLDIgTDE4LDIgTDE4LDE1IEw5LjcxLDE1IEw1LDE5LjcxIEw1LDE5LjcxIEw1LDE5LjcxIFogTTEsMTQgTDYsMTQgTDYsMTcuMjkgTDkuMjksMTQgTDE3LDE0IEwxNywzIEwxLDMgTDEsMTQgTDEsMTQgTDEsMTQgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNvcHlcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMy41XFxcIiB5PVxcXCIyLjVcXFwiIHdpZHRoPVxcXCIxMlxcXCIgaGVpZ2h0PVxcXCIxNlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNSAwLjUgMTcuNSAwLjUgMTcuNSAxN1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNyZWRpdC1jYXJkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjEuNVxcXCIgeT1cXFwiNC41XFxcIiB3aWR0aD1cXFwiMTdcXFwiIGhlaWdodD1cXFwiMTJcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCI3XFxcIiB3aWR0aD1cXFwiMThcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImRhdGFiYXNlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48ZWxsaXBzZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjQuNjRcXFwiIHJ4PVxcXCI3LjVcXFwiIHJ5PVxcXCIzLjE0XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTcuNSw4LjExIEMxNy41LDkuODUgMTQuMTQsMTEuMjUgMTAsMTEuMjUgQzUuODYsMTEuMjUgMi41LDkuODQgMi41LDguMTFcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNy41LDExLjI1IEMxNy41LDEyLjk5IDE0LjE0LDE0LjM5IDEwLDE0LjM5IEM1Ljg2LDE0LjM5IDIuNSwxMi45OCAyLjUsMTEuMjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNy40OSw0LjY0IEwxNy41LDE0LjM2IEMxNy41LDE2LjEgMTQuMTQsMTcuNSAxMCwxNy41IEM1Ljg2LDE3LjUgMi41LDE2LjA5IDIuNSwxNC4zNiBMMi41LDQuNjRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJkZXNrdG9wXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCI4XFxcIiB5PVxcXCIxNVxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjExXFxcIiB5PVxcXCIxNVxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjVcXFwiIHk9XFxcIjE2XFxcIiB3aWR0aD1cXFwiMTBcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMS41XFxcIiB5PVxcXCIzLjVcXFwiIHdpZHRoPVxcXCIxN1xcXCIgaGVpZ2h0PVxcXCIxMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImRpc2NvcmRcIjogXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiPjxwYXRoIGQ9XFxcIk0xNi4wNzQsNC4zNjFhMTQuMjQzLDE0LjI0MywwLDAsMC0zLjYxLTEuMTM0LDEwLjYxLDEwLjYxLDAsMCwwLS40NjMuOTYsMTMuMjE5LDEzLjIxOSwwLDAsMC00LDAsMTAuMTM4LDEwLjEzOCwwLDAsMC0uNDY4LS45NkExNC4yMDYsMTQuMjA2LDAsMCwwLDMuOTE5LDQuMzY0LDE1LjE0NiwxNS4xNDYsMCwwLDAsMS4zMjQsMTQuNWExNC40MzUsMTQuNDM1LDAsMCwwLDQuNDI4LDIuMjY5QTEwLjk4MiwxMC45ODIsMCwwLDAsNi43LDE1LjIxYTkuMjk0LDkuMjk0LDAsMCwxLTEuNDk0LS43MjdjLjEyNS0uMDkzLjI0OC0uMTkuMzY2LS4yODlhMTAuMjEyLDEwLjIxMiwwLDAsMCw4Ljg1NCwwYy4xMTkuMS4yNDIuMi4zNjYuMjg5YTkuMjc0LDkuMjc0LDAsMCwxLTEuNS43MjgsMTAuOCwxMC44LDAsMCwwLC45NDgsMS41NjIsMTQuNDE5LDE0LjQxOSwwLDAsMCw0LjQzMS0yLjI3QTE1LjEyOCwxNS4xMjgsMCwwLDAsMTYuMDc0LDQuMzYxWm0tOC45ODEsOC4xYTEuNywxLjcsMCwwLDEtMS41NzMtMS43OUExLjY4OSwxLjY4OSwwLDAsMSw3LjA5Myw4Ljg4MWExLjY3OSwxLjY3OSwwLDAsMSwxLjU3MywxLjc5MUExLjY4NywxLjY4NywwLDAsMSw3LjA5MywxMi40NjJabTUuODE0LDBhMS43LDEuNywwLDAsMS0xLjU3My0xLjc5LDEuNjg5LDEuNjg5LDAsMCwxLDEuNTczLTEuNzkxLDEuNjc5LDEuNjc5LDAsMCwxLDEuNTczLDEuNzkxQTEuNjg4LDEuNjg4LDAsMCwxLDEyLjkwNywxMi40NjJaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZG93bmxvYWRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTQsMTAgOS41LDE0LjUgNSwxMFxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjE3XFxcIiB3aWR0aD1cXFwiMTNcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjkuNVxcXCIgeTE9XFxcIjEzLjkxXFxcIiB4Mj1cXFwiOS41XFxcIiB5Mj1cXFwiM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImRyaWJiYmxlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiBkPVxcXCJNMS4zLDguOWMwLDAsNSwwLjEsOC42LTFjMS40LTAuNCwyLjYtMC45LDQtMS45IGMxLjQtMS4xLDIuNS0yLjUsMi41LTIuNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIGQ9XFxcIk0zLjksMTYuNmMwLDAsMS43LTIuOCwzLjUtNC4yIGMxLjgtMS4zLDQtMiw1LjctMi4yQzE2LDEwLDE5LDEwLjYsMTksMTAuNlxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIGQ9XFxcIk02LjksMS42YzAsMCwzLjMsNC42LDQuMiw2LjggYzAuNCwwLjksMS4zLDMuMSwxLjksNS4yYzAuNiwyLDAuOSw0LjQsMC45LDQuNFxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJldHN5XCI6IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIj48cGF0aCBkPVxcXCJNOCw0LjI2QzgsNC4wNyw4LDQsOC4zMSw0aDQuNDZjLjc5LDAsMS4yMi42NywxLjUzLDEuOTFsLjI1LDFoLjc2Yy4xNC0yLjgyLjI2LTQsLjI2LTRTMTMuNjUsMywxMi41MiwzSDYuODFMMy43NSwyLjkydi44NGwxLC4yYy43My4xMS45LjI3LDEsMSwwLDAsLjA2LDIsLjA2LDUuMTdzLS4wNiw1LjE0LS4wNiw1LjE0YzAsLjU5LS4yMy44MS0xLC45NGwtMSwuMnYuODRsMy4wNi0uMWg1LjExYzEuMTUsMCwzLjgyLjEsMy44Mi4xLDAtLjcuNDUtMy44OC41MS00LjIyaC0uNzNsLS43NiwxLjY5YTIuMjUsMi4yNSwwLDAsMS0yLjQ1LDEuNDdIOS40Yy0xLDAtMS40NC0uNC0xLjQ0LTEuMjRWMTAuNDRzMi4xNiwwLDIuODYuMDZjLjU1LDAsLjg1LjE5LDEuMDYsMWwuMjMsMUgxM0wxMi45LDkuOTQsMTMsNy40MWgtLjg1bC0uMjgsMS4xM2MtLjE2Ljc0LS4yOC44NC0xLDEtMSwuMS0yLjg5LjA5LTIuODkuMDlaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZXhwYW5kXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjEzIDIgMTggMiAxOCA3IDE3IDcgMTcgMyAxMyAzXFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCIyIDEzIDMgMTMgMyAxNyA3IDE3IDcgMTggMiAxOFxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMSw5IEwxNywzXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTMsMTcgTDksMTFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmYWNlYm9va1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTExLDEwaDIuNmwwLjQtM0gxMVY1LjNjMC0wLjksMC4yLTEuNSwxLjUtMS41SDE0VjEuMWMtMC4zLDAtMS0wLjEtMi4xLTAuMUM5LjYsMSw4LDIuNCw4LDV2Mkg1LjV2M0g4djhoM1YxMHpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmaWxlLWVkaXRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTE4LjY1LDEuNjggQzE4LjQxLDEuNDUgMTguMTA5LDEuMzMgMTcuODEsMS4zMyBDMTcuNDk5LDEuMzMgMTcuMjA5LDEuNDUgMTYuOTgsMS42OCBMOC45Miw5Ljc2IEw4LDEyLjMzIEwxMC41NSwxMS40MSBMMTguNjUxLDMuMzQgQzE5LjEyLDIuODcgMTkuMTIsMi4xNSAxOC42NSwxLjY4IEwxOC42NSwxLjY4IEwxOC42NSwxLjY4IFpcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjE2LjUgOC40ODIgMTYuNSAxOC41IDMuNSAxOC41IDMuNSAxLjUgMTQuMjExIDEuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZpbGUtcGRmXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHdpZHRoPVxcXCIxM1xcXCIgaGVpZ2h0PVxcXCIxN1xcXCIgeD1cXFwiMy41XFxcIiB5PVxcXCIxLjVcXFwiLz48cGF0aCBkPVxcXCJNMTQuNjUgMTEuNjdjLS40OC4zLTEuMzctLjE5LTEuNzktLjM3YTQuNjUgNC42NSAwIDAgMSAxLjQ5LjA2Yy4zNS4xLjM2LjI4LjMuMzF6bS02LjMuMDZsLjQzLS43OWExNC43IDE0LjcgMCAwIDAgLjc1LTEuNjQgNS40OCA1LjQ4IDAgMCAwIDEuMjUgMS41NWwuMi4xNWExNi4zNiAxNi4zNiAwIDAgMC0yLjYzLjczek05LjUgNS4zMmMuMiAwIC4zMi41LjMyLjk3YTEuOTkgMS45OSAwIDAgMS0uMjMgMS4wNCA1LjA1IDUuMDUgMCAwIDEtLjE3LTEuM3MwLS43MS4wOC0uNzF6bS0zLjkgOWE0LjM1IDQuMzUgMCAwIDEgMS4yMS0xLjQ2bC4yNC0uMjJhNC4zNSA0LjM1IDAgMCAxLTEuNDYgMS42OHptOS4yMy0zLjNhMi4wNSAyLjA1IDAgMCAwLTEuMzItLjMgMTEuMDcgMTEuMDcgMCAwIDAtMS41OC4xMSA0LjA5IDQuMDkgMCAwIDEtLjc0LS41IDUuMzkgNS4zOSAwIDAgMS0xLjMyLTIuMDYgMTAuMzcgMTAuMzcgMCAwIDAgLjI4LTIuNjIgMS44MyAxLjgzIDAgMCAwLS4wNy0uMjUuNTcuNTcgMCAwIDAtLjUyLS40SDkuNGEuNTkuNTkgMCAwIDAtLjYuMzggNi45NSA2Ljk1IDAgMCAwIC4zNyAzLjE0Yy0uMjYuNjMtMSAyLjEyLTEgMi4xMi0uMy41OC0uNTcgMS4wOC0uODIgMS41bC0uOC40NEEzLjExIDMuMTEgMCAwIDAgNSAxNC4xNmEuMzkuMzkgMCAwIDAgLjE1LjQybC4yNC4xM2MxLjE1LjU2IDIuMjgtMS43NCAyLjY2LTIuNDJhMjMuMSAyMy4xIDAgMCAxIDMuNTktLjg1IDQuNTYgNC41NiAwIDAgMCAyLjkxLjguNS41IDAgMCAwIC4zLS4yMSAxLjEgMS4xIDAgMCAwIC4xMi0uNzUuODQuODQgMCAwIDAtLjE0LS4yNXpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmaWxlLXRleHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgd2lkdGg9XFxcIjEzXFxcIiBoZWlnaHQ9XFxcIjE3XFxcIiB4PVxcXCIzLjVcXFwiIHk9XFxcIjEuNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjZcXFwiIHgyPVxcXCIxMlxcXCIgeTE9XFxcIjEyLjVcXFwiIHkyPVxcXCIxMi41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiNlxcXCIgeDI9XFxcIjE0XFxcIiB5MT1cXFwiOC41XFxcIiB5Mj1cXFwiOC41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiNlxcXCIgeDI9XFxcIjE0XFxcIiB5MT1cXFwiNi41XFxcIiB5Mj1cXFwiNi41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiNlxcXCIgeDI9XFxcIjE0XFxcIiB5MT1cXFwiMTAuNVxcXCIgeTI9XFxcIjEwLjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmaWxlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiMS41XFxcIiB3aWR0aD1cXFwiMTNcXFwiIGhlaWdodD1cXFwiMTdcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmbGlja3JcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjUuNVxcXCIgY3k9XFxcIjkuNVxcXCIgcj1cXFwiMy41XFxcIi8+PGNpcmNsZSBjeD1cXFwiMTQuNVxcXCIgY3k9XFxcIjkuNVxcXCIgcj1cXFwiMy41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZm9sZGVyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiOS41IDUuNSA4LjUgMy41IDEuNSAzLjUgMS41IDE2LjUgMTguNSAxNi41IDE4LjUgNS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZm9yd2FyZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTIuNDcsMTMuMTEgQzQuMDIsMTAuMDIgNi4yNyw3Ljg1IDkuMDQsNi42MSBDOS40OCw2LjQxIDEwLjI3LDYuMTMgMTEsNS45MSBMMTEsMiBMMTguODksOSBMMTEsMTYgTDExLDEyLjEzIEM5LjI1LDEyLjQ3IDcuNTgsMTMuMTkgNi4wMiwxNC4yNSBDMy4wMywxNi4yOCAxLjYzLDE4LjU0IDEuNjMsMTguNTQgQzEuNjMsMTguNTQgMS4zOCwxNS4yOCAyLjQ3LDEzLjExIEwyLjQ3LDEzLjExIFogTTUuMywxMy41MyBDNi45MiwxMi40IDkuMDQsMTEuNCAxMiwxMC45MiBMMTIsMTMuNjMgTDE3LjM2LDkgTDEyLDQuMjUgTDEyLDYuOCBDMTEuNzEsNi44NiAxMC44Niw3LjAyIDkuNjcsNy40OSBDNi43OSw4LjY1IDQuNTgsMTAuOTYgMy40OSwxMy4wOCBDMy4xOCwxMy43IDIuNjgsMTQuODcgMi40OSwxNiBDMy4yOCwxNS4wNSA0LjQsMTQuMTUgNS4zLDEzLjUzIEw1LjMsMTMuNTMgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZvdXJzcXVhcmVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNS4yMywyIEMxNS45NiwyIDE2LjQsMi40MSAxNi41LDIuODYgQzE2LjU3LDMuMTUgMTYuNTYsMy40NCAxNi41MSwzLjczIEMxNi40Niw0LjA0IDE0Ljg2LDExLjcyIDE0Ljc1LDEyLjAzIEMxNC41NiwxMi41NiAxNC4xNiwxMi44MiAxMy42MSwxMi44MyBDMTMuMDMsMTIuODQgMTEuMDksMTIuNTEgMTAuNjksMTMgQzEwLjM4LDEzLjM4IDcuNzksMTYuMzkgNi44MSwxNy41MyBDNi42MSwxNy43NiA2LjQsMTcuOTYgNi4wOCwxNy45OSBDNS42OCwxOC4wNCA1LjI5LDE3Ljg3IDUuMTcsMTcuNDUgQzUuMTIsMTcuMjggNS4xLDE3LjA5IDUuMSwxNi45MSBDNS4xLDEyLjQgNC44Niw3LjgxIDUuMTEsMy4zMSBDNS4xNywyLjUgNS44MSwyLjEyIDYuNTMsMiBMMTUuMjMsMiBMMTUuMjMsMiBaIE05Ljc2LDExLjQyIEM5Ljk0LDExLjE5IDEwLjE3LDExLjEgMTAuNDUsMTEuMSBMMTIuODYsMTEuMSBDMTMuMTIsMTEuMSAxMy4zMSwxMC45NCAxMy4zNiwxMC42OSBDMTMuMzcsMTAuNjQgMTMuNjIsOS40MSAxMy43NCw4LjgzIEMxMy44MSw4LjUyIDEzLjUzLDguMjggMTMuMjcsOC4yOCBDMTIuMzUsOC4yOSAxMS40Miw4LjI4IDEwLjUsOC4yOCBDOS44NCw4LjI4IDkuODMsNy42OSA5LjgyLDcuMjEgQzkuOCw2Ljg1IDEwLjEzLDYuNTUgMTAuNSw2LjU1IEMxMS41OSw2LjU2IDEyLjY3LDYuNTUgMTMuNzYsNi41NSBDMTQuMDMsNi41NSAxNC4yMyw2LjQgMTQuMjgsNi4xNCBDMTQuMzQsNS44NyAxNC42Nyw0LjI5IDE0LjY3LDQuMjkgQzE0LjY3LDQuMjkgMTQuODIsMy43NCAxNC4xOSwzLjc0IEw3LjM0LDMuNzQgQzcsMy43NSA2Ljg0LDQuMDIgNi44NCw0LjMzIEM2Ljg0LDcuNTggNi44NSwxNC45NSA2Ljg1LDE0Ljk5IEM2Ljg3LDE1IDguODksMTIuNTEgOS43NiwxMS40MiBMOS43NiwxMS40MiBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZnV0dXJlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgcG9pbnRzPVxcXCIxOSAyIDE4IDIgMTggNiAxNCA2IDE0IDcgMTkgNyAxOSAyXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE4LDYuNTQ4IEMxNi43MDksMy4yOSAxMy4zNTQsMSA5LjYsMSBDNC42LDEgMC42LDUgMC42LDEwIEMwLjYsMTUgNC42LDE5IDkuNiwxOSBDMTQuNiwxOSAxOC42LDE1IDE4LjYsMTBcXFwiLz48cmVjdCB4PVxcXCI5XFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI3XFxcIi8+PHBhdGggZD1cXFwiTTEzLjAxOCwxNC4xOTcgTDkuNDQ1LDEwLjYyNVxcXCIgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImdpdC1icmFuY2hcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgY3g9XFxcIjdcXFwiIGN5PVxcXCIzXFxcIiByPVxcXCIyXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBjeD1cXFwiMTRcXFwiIGN5PVxcXCI2XFxcIiByPVxcXCIyXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBjeD1cXFwiN1xcXCIgY3k9XFxcIjE3XFxcIiByPVxcXCIyXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjJcXFwiIGQ9XFxcIk0xNCw4IEMxNCwxMC40MSAxMi40MywxMC44NyAxMC41NiwxMS4yNSBDOS4wOSwxMS41NCA3LDEyLjA2IDcsMTUgTDcsNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImdpdC1mb3JrXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIGN4PVxcXCI1Ljc5XFxcIiBjeT1cXFwiMi43OVxcXCIgcj1cXFwiMS43OVxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgY3g9XFxcIjE0LjE5XFxcIiBjeT1cXFwiMi43OVxcXCIgcj1cXFwiMS43OVxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgY3g9XFxcIjEwLjAzXFxcIiBjeT1cXFwiMTYuNzlcXFwiIHI9XFxcIjEuNzlcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMlxcXCIgZD1cXFwiTTUuNzksNC41NyBMNS43OSw2LjU2IEM1Ljc5LDkuMTkgMTAuMDMsMTAuMjIgMTAuMDMsMTMuMzEgQzEwLjAzLDE0Ljg2IDEwLjA0LDE0LjU1IDEwLjA0LDE0LjU1IEMxMC4wNCwxNC4zNyAxMC4wNCwxNC44NiAxMC4wNCwxMy4zMSBDMTAuMDQsMTAuMjIgMTQuMiw5LjE5IDE0LjIsNi41NiBMMTQuMiw0LjU3XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ2l0aHViLWFsdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEwLDAuNSBDNC43NSwwLjUgMC41LDQuNzYgMC41LDEwLjAxIEMwLjUsMTUuMjYgNC43NSwxOS41MSAxMCwxOS41MSBDMTUuMjQsMTkuNTEgMTkuNSwxNS4yNiAxOS41LDEwLjAxIEMxOS41LDQuNzYgMTUuMjUsMC41IDEwLDAuNSBMMTAsMC41IFogTTEyLjgxLDE3LjY5IEMxMi44MSwxNy42OSAxMi44MSwxNy43IDEyLjc5LDE3LjY5IEMxMi40NywxNy43NSAxMi4zNSwxNy41OSAxMi4zNSwxNy4zNiBMMTIuMzUsMTYuMTcgQzEyLjM1LDE1LjQ1IDEyLjA5LDE0LjkyIDExLjU4LDE0LjU2IEMxMi4yLDE0LjUxIDEyLjc3LDE0LjM5IDEzLjI2LDE0LjIxIEMxMy44NywxMy45OCAxNC4zNiwxMy42OSAxNC43NCwxMy4yOSBDMTUuNDIsMTIuNTkgMTUuNzYsMTEuNTUgMTUuNzYsMTAuMTcgQzE1Ljc2LDkuMjUgMTUuNDUsOC40NiAxNC44Myw3LjggQzE1LjEsNy4wOCAxNS4wNyw2LjI5IDE0Ljc1LDUuNDQgTDE0LjUxLDUuNDIgQzE0LjM0LDUuNCAxNC4wNiw1LjQ2IDEzLjY3LDUuNjEgQzEzLjI1LDUuNzggMTIuNzksNi4wMyAxMi4zMSw2LjM1IEMxMS41NSw2LjE2IDEwLjgxLDYuMDUgMTAuMDksNi4wNSBDOS4zNiw2LjA1IDguNjEsNi4xNSA3Ljg4LDYuMzUgQzcuMjgsNS45NiA2Ljc1LDUuNjggNi4yNiw1LjU0IEM2LjA3LDUuNDcgNS45LDUuNDQgNS43OCw1LjQ0IEw1LjQyLDUuNDQgQzUuMDYsNi4yOSA1LjA0LDcuMDggNS4zMiw3LjggQzQuNyw4LjQ2IDQuNCw5LjI1IDQuNCwxMC4xNyBDNC40LDExLjk0IDQuOTYsMTMuMTYgNi4wOCwxMy44NCBDNi41MywxNC4xMyA3LjA1LDE0LjMyIDcuNjksMTQuNDMgQzguMDMsMTQuNSA4LjMyLDE0LjU0IDguNTUsMTQuNTUgQzguMDcsMTQuODkgNy44MiwxNS40MiA3LjgyLDE2LjE2IEw3LjgyLDE3LjUxIEM3LjgsMTcuNjkgNy43LDE3LjggNy41MSwxNy44IEM0LjIxLDE2Ljc0IDEuODIsMTMuNjUgMS44MiwxMC4wMSBDMS44Miw1LjUgNS40OSwxLjgzIDEwLDEuODMgQzE0LjUsMS44MyAxOC4xNyw1LjUgMTguMTcsMTAuMDEgQzE4LjE4LDEzLjUzIDE1Ljk0LDE2LjU0IDEyLjgxLDE3LjY5IEwxMi44MSwxNy42OSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ2l0aHViXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTAsMSBDNS4wMywxIDEsNS4wMyAxLDEwIEMxLDEzLjk4IDMuNTgsMTcuMzUgNy4xNiwxOC41NCBDNy42MSwxOC42MiA3Ljc3LDE4LjM0IDcuNzcsMTguMTEgQzcuNzcsMTcuOSA3Ljc2LDE3LjMzIDcuNzYsMTYuNTggQzUuMjYsMTcuMTIgNC43MywxNS4zNyA0LjczLDE1LjM3IEM0LjMyLDE0LjMzIDMuNzMsMTQuMDUgMy43MywxNC4wNSBDMi45MSwxMy41IDMuNzksMTMuNSAzLjc5LDEzLjUgQzQuNjksMTMuNTYgNS4xNywxNC40MyA1LjE3LDE0LjQzIEM1Ljk3LDE1LjggNy4yOCwxNS40MSA3Ljc5LDE1LjE4IEM3Ljg3LDE0LjYgOC4xLDE0LjIgOC4zNiwxMy45OCBDNi4zNiwxMy43NSA0LjI2LDEyLjk4IDQuMjYsOS41MyBDNC4yNiw4LjU1IDQuNjEsNy43NCA1LjE5LDcuMTEgQzUuMSw2Ljg4IDQuNzksNS45NyA1LjI4LDQuNzMgQzUuMjgsNC43MyA2LjA0LDQuNDkgNy43NSw1LjY1IEM4LjQ3LDUuNDUgOS4yNCw1LjM1IDEwLDUuMzUgQzEwLjc2LDUuMzUgMTEuNTMsNS40NSAxMi4yNSw1LjY1IEMxMy45Nyw0LjQ4IDE0LjcyLDQuNzMgMTQuNzIsNC43MyBDMTUuMjEsNS45NyAxNC45LDYuODggMTQuODEsNy4xMSBDMTUuMzksNy43NCAxNS43Myw4LjU0IDE1LjczLDkuNTMgQzE1LjczLDEyLjk5IDEzLjYzLDEzLjc1IDExLjYyLDEzLjk3IEMxMS45NCwxNC4yNSAxMi4yMywxNC44IDEyLjIzLDE1LjY0IEMxMi4yMywxNi44NCAxMi4yMiwxNy44MSAxMi4yMiwxOC4xMSBDMTIuMjIsMTguMzUgMTIuMzgsMTguNjMgMTIuODQsMTguNTQgQzE2LjQyLDE3LjM1IDE5LDEzLjk4IDE5LDEwIEMxOSw1LjAzIDE0Ljk3LDEgMTAsMSBMMTAsMSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ2l0dGVyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCIzLjVcXFwiIHk9XFxcIjFcXFwiIHdpZHRoPVxcXCIxLjUzMVxcXCIgaGVpZ2h0PVxcXCIxMS40NzFcXFwiLz48cmVjdCB4PVxcXCI3LjMyNFxcXCIgeT1cXFwiNC4wNTlcXFwiIHdpZHRoPVxcXCIxLjUyOVxcXCIgaGVpZ2h0PVxcXCIxNS4yOTRcXFwiLz48cmVjdCB4PVxcXCIxMS4xNDhcXFwiIHk9XFxcIjQuMDU5XFxcIiB3aWR0aD1cXFwiMS41MjdcXFwiIGhlaWdodD1cXFwiMTUuMjk0XFxcIi8+PHJlY3QgeD1cXFwiMTQuOTcxXFxcIiB5PVxcXCI0LjA1OVxcXCIgd2lkdGg9XFxcIjEuNTI5XFxcIiBoZWlnaHQ9XFxcIjguNDEyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ29vZ2xlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTcuODYsOS4wOSBDMTguNDYsMTIuMTIgMTcuMTQsMTYuMDUgMTMuODEsMTcuNTYgQzkuNDUsMTkuNTMgNC4xMywxNy42OCAyLjQ3LDEyLjg3IEMwLjY4LDcuNjggNC4yMiwyLjQyIDkuNSwyLjAzIEMxMS41NywxLjg4IDEzLjQyLDIuMzcgMTUuMDUsMy42NSBDMTUuMjIsMy43OCAxNS4zNywzLjkzIDE1LjYxLDQuMTQgQzE0LjksNC44MSAxNC4yMyw1LjQ1IDEzLjUsNi4xNCBDMTIuMjcsNS4wOCAxMC44NCw0LjcyIDkuMjgsNC45OCBDOC4xMiw1LjE3IDcuMTYsNS43NiA2LjM3LDYuNjMgQzQuODgsOC4yNyA0LjYyLDEwLjg2IDUuNzYsMTIuODIgQzYuOTUsMTQuODcgOS4xNywxNS44IDExLjU3LDE1LjI1IEMxMy4yNywxNC44NyAxNC43NiwxMy4zMyAxNC44OSwxMS43NSBMMTAuNTEsMTEuNzUgTDEwLjUxLDkuMDkgTDE3Ljg2LDkuMDkgTDE3Ljg2LDkuMDkgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImdyaWRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjJcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCI4XFxcIiB5PVxcXCIyXFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiMTRcXFwiIHk9XFxcIjJcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCI4XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiOFxcXCIgeT1cXFwiOFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjE0XFxcIiB5PVxcXCI4XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiMTRcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCI4XFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjE0XFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImhhcHB5XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIxM1xcXCIgY3k9XFxcIjdcXFwiIHI9XFxcIjFcXFwiLz48Y2lyY2xlIGN4PVxcXCI3XFxcIiBjeT1cXFwiN1xcXCIgcj1cXFwiMVxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOC41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTQuNiwxMS40IEMxMy45LDEzLjMgMTIuMSwxNC41IDEwLDE0LjUgQzcuOSwxNC41IDYuMSwxMy4zIDUuNCwxMS40XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaGFzaHRhZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE1LjQzMSw4IEwxNS42NjEsNyBMMTIuOTExLDcgTDEzLjgzMSwzIEwxMi45MDEsMyBMMTEuOTgsNyBMOS4yOSw3IEwxMC4yMSwzIEw5LjI4MSwzIEw4LjM2MSw3IEw1LjIzLDcgTDUsOCBMOC4xMyw4IEw3LjIxLDEyIEw0LjIzLDEyIEw0LDEzIEw2Ljk4LDEzIEw2LjA2MSwxNyBMNi45OTEsMTcgTDcuOTExLDEzIEwxMC42MDEsMTMgTDkuNjgxLDE3IEwxMC42MTEsMTcgTDExLjUzMSwxMyBMMTQuNDMxLDEzIEwxNC42NjEsMTIgTDExLjc2LDEyIEwxMi42ODEsOCBMMTUuNDMxLDggWiBNMTAuODMxLDEyIEw4LjE0MSwxMiBMOS4wNjEsOCBMMTEuNzUsOCBMMTAuODMxLDEyIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJoZWFydFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIGQ9XFxcIk0xMCw0IEMxMCw0IDguMSwyIDUuNzQsMiBDMy4zOCwyIDEsMy41NSAxLDYuNzMgQzEsOC44NCAyLjY3LDEwLjQ0IDIuNjcsMTAuNDQgTDEwLDE4IEwxNy4zMywxMC40NCBDMTcuMzMsMTAuNDQgMTksOC44NCAxOSw2LjczIEMxOSwzLjU1IDE2LjYyLDIgMTQuMjYsMiBDMTEuOSwyIDEwLDQgMTAsNCBMMTAsNCBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaGlzdG9yeVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMSAyIDIgMiAyIDYgNiA2IDYgNyAxIDcgMSAyXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTIuMSw2LjU0OCBDMy4zOTEsMy4yOSA2Ljc0NiwxIDEwLjUsMSBDMTUuNSwxIDE5LjUsNSAxOS41LDEwIEMxOS41LDE1IDE1LjUsMTkgMTAuNSwxOSBDNS41LDE5IDEuNSwxNSAxLjUsMTBcXFwiLz48cmVjdCB4PVxcXCI5XFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI3XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEzLjAxOCwxNC4xOTcgTDkuNDQ1LDEwLjYyNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImhvbWVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiMTguNjUgMTEuMzUgMTAgMi43MSAxLjM1IDExLjM1IDAuNjUgMTAuNjUgMTAgMS4yOSAxOS4zNSAxMC42NVxcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiMTUgNCAxOCA0IDE4IDcgMTcgNyAxNyA1IDE1IDVcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjMgMTEgNCAxMSA0IDE4IDcgMTggNyAxMiAxMiAxMiAxMiAxOCAxNiAxOCAxNiAxMSAxNyAxMSAxNyAxOSAxMSAxOSAxMSAxMyA4IDEzIDggMTkgMyAxOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImltYWdlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIxNi4xXFxcIiBjeT1cXFwiNi4xXFxcIiByPVxcXCIxLjFcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIi41XFxcIiB5PVxcXCIyLjVcXFwiIHdpZHRoPVxcXCIxOVxcXCIgaGVpZ2h0PVxcXCIxNVxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wMVxcXCIgcG9pbnRzPVxcXCI0LDEzIDgsOSAxMywxNFxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wMVxcXCIgcG9pbnRzPVxcXCIxMSwxMiAxMi41LDEwLjUgMTYsMTRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJpbmZvXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTIuMTMsMTEuNTkgQzExLjk3LDEyLjg0IDEwLjM1LDE0LjEyIDkuMSwxNC4xNiBDNi4xNywxNC4yIDkuODksOS40NiA4Ljc0LDguMzcgQzkuMyw4LjE2IDEwLjYyLDcuODMgMTAuNjIsOC44MSBDMTAuNjIsOS42MyAxMC4xMiwxMC41NSA5Ljg4LDExLjMyIEM4LjY2LDE1LjE2IDEyLjEzLDExLjE1IDEyLjE0LDExLjE4IEMxMi4xNiwxMS4yMSAxMi4xNiwxMS4zNSAxMi4xMywxMS41OSBDMTIuMDgsMTEuOTUgMTIuMTYsMTEuMzUgMTIuMTMsMTEuNTkgTDEyLjEzLDExLjU5IFogTTExLjU2LDUuNjcgQzExLjU2LDYuNjcgOS4zNiw3LjE1IDkuMzYsNi4wMyBDOS4zNiw1IDExLjU2LDQuNTQgMTEuNTYsNS42NyBMMTEuNTYsNS42NyBaXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImluc3RhZ3JhbVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEzLjU1LDFINi40NkMzLjQ1LDEsMSwzLjQ0LDEsNi40NHY3LjEyYzAsMywyLjQ1LDUuNDQsNS40Niw1LjQ0aDcuMDhjMy4wMiwwLDUuNDYtMi40NCw1LjQ2LTUuNDRWNi40NCBDMTkuMDEsMy40NCwxNi41NiwxLDEzLjU1LDF6IE0xNy41LDE0YzAsMS45My0xLjU3LDMuNS0zLjUsMy41SDZjLTEuOTMsMC0zLjUtMS41Ny0zLjUtMy41VjZjMC0xLjkzLDEuNTctMy41LDMuNS0zLjVoOCBjMS45MywwLDMuNSwxLjU3LDMuNSwzLjVWMTR6XFxcIi8+PGNpcmNsZSBjeD1cXFwiMTQuODdcXFwiIGN5PVxcXCI1LjI2XFxcIiByPVxcXCIxLjA5XFxcIi8+PHBhdGggZD1cXFwiTTEwLjAzLDUuNDVjLTIuNTUsMC00LjYzLDIuMDYtNC42Myw0LjZjMCwyLjU1LDIuMDcsNC42MSw0LjYzLDQuNjFjMi41NiwwLDQuNjMtMi4wNjEsNC42My00LjYxIEMxNC42NSw3LjUxLDEyLjU4LDUuNDUsMTAuMDMsNS40NUwxMC4wMyw1LjQ1TDEwLjAzLDUuNDV6IE0xMC4wOCwxM2MtMS42NiwwLTMtMS4zNC0zLTIuOTljMC0xLjY1LDEuMzQtMi45OSwzLTIuOTlzMywxLjM0LDMsMi45OSBDMTMuMDgsMTEuNjYsMTEuNzQsMTMsMTAuMDgsMTNMMTAuMDgsMTNMMTAuMDgsMTN6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaXRhbGljXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTIuNjMsNS40OCBMMTAuMTUsMTQuNTIgQzEwLDE1LjA4IDEwLjM3LDE1LjI1IDExLjkyLDE1LjMgTDExLjcyLDE2IEw2LDE2IEw2LjIsMTUuMzEgQzcuNzgsMTUuMjYgOC4xOSwxNS4wOSA4LjM0LDE0LjUzIEwxMC44Miw1LjQ5IEMxMC45Nyw0LjkyIDEwLjYzLDQuNzYgOS4wOSw0LjcxIEw5LjI4LDQgTDE1LDQgTDE0LjgxLDQuNjkgQzEzLjIzLDQuNzUgMTIuNzgsNC45MSAxMi42Myw1LjQ4IEwxMi42Myw1LjQ4IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJqb29tbGFcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk03LjgsMTMuNGwxLjctMS43TDUuOSw4Yy0wLjYtMC41LTAuNi0xLjUsMC0yYzAuNi0wLjYsMS40LTAuNiwyLDBsMS43LTEuN2MtMS0xLTIuMy0xLjMtMy42LTFDNS44LDIuMiw0LjgsMS40LDMuNywxLjQgYy0xLjMsMC0yLjMsMS0yLjMsMi4zYzAsMS4xLDAuOCwyLDEuOCwyLjNjLTAuNCwxLjMtMC4xLDIuOCwxLDMuOEw3LjgsMTMuNEw3LjgsMTMuNHpcXFwiLz48cGF0aCBkPVxcXCJNMTAuMiw0LjNjMS0xLDIuNS0xLjQsMy44LTFjMC4yLTEuMSwxLjEtMiwyLjMtMmMxLjMsMCwyLjMsMSwyLjMsMi4zYzAsMS4yLTAuOSwyLjItMiwyLjNjMC40LDEuMywwLDIuOC0xLDMuOEwxMy45LDggYzAuNi0wLjUsMC42LTEuNSwwLTJjLTAuNS0wLjYtMS41LTAuNi0yLDBMOC4yLDkuN0w2LjUsOFxcXCIvPjxwYXRoIGQ9XFxcIk0xNC4xLDE2LjhjLTEuMywwLjQtMi44LDAuMS0zLjgtMWwxLjctMS43YzAuNiwwLjYsMS41LDAuNiwyLDBjMC41LTAuNiwwLjYtMS41LDAtMmwtMy43LTMuN0wxMiw2LjdsMy43LDMuNyBjMSwxLDEuMywyLjQsMSwzLjZjMS4xLDAuMiwyLDEuMSwyLDIuM2MwLDEuMy0xLDIuMy0yLjMsMi4zQzE1LjIsMTguNiwxNC4zLDE3LjgsMTQuMSwxNi44XFxcIi8+PHBhdGggZD1cXFwiTTEzLjIsMTIuMmwtMy43LDMuN2MtMSwxLTIuNCwxLjMtMy42LDFjLTAuMiwxLTEuMiwxLjgtMi4yLDEuOGMtMS4zLDAtMi4zLTEtMi4zLTIuM2MwLTEuMSwwLjgtMiwxLjgtMi4zIGMtMC4zLTEuMywwLTIuNywxLTMuN2wxLjcsMS43Yy0wLjYsMC42LTAuNiwxLjUsMCwyYzAuNiwwLjYsMS40LDAuNiwyLDBsMy43LTMuN1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImxhcHRvcFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeT1cXFwiMTZcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIyLjVcXFwiIHk9XFxcIjQuNVxcXCIgd2lkdGg9XFxcIjE1XFxcIiBoZWlnaHQ9XFxcIjEwXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibGlmZXNhdmVyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTAsMC41IEM0Ljc2LDAuNSAwLjUsNC43NiAwLjUsMTAgQzAuNSwxNS4yNCA0Ljc2LDE5LjUgMTAsMTkuNSBDMTUuMjQsMTkuNSAxOS41LDE1LjI0IDE5LjUsMTAgQzE5LjUsNC43NiAxNS4yNCwwLjUgMTAsMC41IEwxMCwwLjUgWiBNMTAsMS41IEMxMS40OSwxLjUgMTIuODksMS44OCAxNC4xMSwyLjU2IEwxMS44NSw0LjgyIEMxMS4yNyw0LjYxIDEwLjY1LDQuNSAxMCw0LjUgQzkuMjEsNC41IDguNDcsNC42NyA3Ljc5LDQuOTYgTDUuNTgsMi43NSBDNi44NywxLjk1IDguMzgsMS41IDEwLDEuNSBMMTAsMS41IFogTTQuOTYsNy44IEM0LjY3LDguNDggNC41LDkuMjEgNC41LDEwIEM0LjUsMTAuNjUgNC42MSwxMS4yNyA0LjgzLDExLjg1IEwyLjU2LDE0LjExIEMxLjg4LDEyLjg5IDEuNSwxMS40OSAxLjUsMTAgQzEuNSw4LjM4IDEuOTUsNi44NyAyLjc1LDUuNTggTDQuOTYsNy43OSBMNC45Niw3LjggTDQuOTYsNy44IFogTTEwLDE4LjUgQzguMjUsMTguNSA2LjYyLDE3Ljk3IDUuMjcsMTcuMDYgTDcuNDYsMTQuODcgQzguMjIsMTUuMjcgOS4wOCwxNS41IDEwLDE1LjUgQzEwLjc5LDE1LjUgMTEuNTMsMTUuMzMgMTIuMjEsMTUuMDQgTDE0LjQyLDE3LjI1IEMxMy4xMywxOC4wNSAxMS42MiwxOC41IDEwLDE4LjUgTDEwLDE4LjUgWiBNMTAsMTQuNSBDNy41MiwxNC41IDUuNSwxMi40OCA1LjUsMTAgQzUuNSw3LjUyIDcuNTIsNS41IDEwLDUuNSBDMTIuNDgsNS41IDE0LjUsNy41MiAxNC41LDEwIEMxNC41LDEyLjQ4IDEyLjQ4LDE0LjUgMTAsMTQuNSBMMTAsMTQuNSBaIE0xNS4wNCwxMi4yMSBDMTUuMzMsMTEuNTMgMTUuNSwxMC43OSAxNS41LDEwIEMxNS41LDkuMDggMTUuMjcsOC4yMiAxNC44Nyw3LjQ2IEwxNy4wNiw1LjI3IEMxNy45Nyw2LjYyIDE4LjUsOC4yNSAxOC41LDEwIEMxOC41LDExLjYyIDE4LjA1LDEzLjEzIDE3LjI1LDE0LjQyIEwxNS4wNCwxMi4yMSBMMTUuMDQsMTIuMjEgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImxpbmtcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMC42MjUsMTIuMzc1IEw3LjUyNSwxNS40NzUgQzYuODI1LDE2LjE3NSA1LjkyNSwxNi4xNzUgNS4yMjUsMTUuNDc1IEw0LjUyNSwxNC43NzUgQzMuODI1LDE0LjA3NCAzLjgyNSwxMy4xNzUgNC41MjUsMTIuNDc1IEw3LjYyNSw5LjM3NVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk05LjMyNSw3LjM3NSBMMTIuNDI1LDQuMjc1IEMxMy4xMjUsMy41NzUgMTQuMDI1LDMuNTc1IDE0LjcyNCw0LjI3NSBMMTUuNDI1LDQuOTc1IEMxNi4xMjUsNS42NzUgMTYuMTI1LDYuNTc1IDE1LjQyNSw3LjI3NSBMMTIuMzI1LDEwLjM3NVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk03LjkyNSwxMS44NzUgTDExLjkyNSw3Ljk3NVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImxpbmtlZGluXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNS43NywxNy44OSBMNS43Nyw3LjE3IEwyLjIxLDcuMTcgTDIuMjEsMTcuODkgTDUuNzcsMTcuODkgTDUuNzcsMTcuODkgWiBNMy45OSw1LjcxIEM1LjIzLDUuNzEgNi4wMSw0Ljg5IDYuMDEsMy44NiBDNS45OSwyLjggNS4yNCwyIDQuMDIsMiBDMi44LDIgMiwyLjggMiwzLjg1IEMyLDQuODggMi43Nyw1LjcgMy45Nyw1LjcgTDMuOTksNS43IEwzLjk5LDUuNzEgTDMuOTksNS43MSBaXFxcIi8+PHBhdGggZD1cXFwiTTcuNzUsMTcuODkgTDExLjMxLDE3Ljg5IEwxMS4zMSwxMS45IEMxMS4zMSwxMS41OCAxMS4zMywxMS4yNiAxMS40MywxMS4wMyBDMTEuNjksMTAuMzkgMTIuMjcsOS43MyAxMy4yNiw5LjczIEMxNC41NSw5LjczIDE1LjA2LDEwLjcxIDE1LjA2LDEyLjE1IEwxNS4wNiwxNy44OSBMMTguNjIsMTcuODkgTDE4LjYyLDExLjc0IEMxOC42Miw4LjQ1IDE2Ljg2LDYuOTIgMTQuNTIsNi45MiBDMTIuNiw2LjkyIDExLjc1LDcuOTkgMTEuMjgsOC43MyBMMTEuMyw4LjczIEwxMS4zLDcuMTcgTDcuNzUsNy4xNyBDNy43OSw4LjE3IDcuNzUsMTcuODkgNy43NSwxNy44OSBMNy43NSwxNy44OSBMNy43NSwxNy44OSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibGlzdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiNlxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjEyXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCI2XFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMTJcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjZcXFwiIHk9XFxcIjE0XFxcIiB3aWR0aD1cXFwiMTJcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjRcXFwiIHdpZHRoPVxcXCIyXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiMTRcXFwiIHdpZHRoPVxcXCIyXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJsb2NhdGlvblwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDFcXFwiIGQ9XFxcIk0xMCwwLjUgQzYuNDEsMC41IDMuNSwzLjM5IDMuNSw2Ljk4IEMzLjUsMTEuODMgMTAsMTkgMTAsMTkgQzEwLDE5IDE2LjUsMTEuODMgMTYuNSw2Ljk4IEMxNi41LDMuMzkgMTMuNTksMC41IDEwLDAuNSBMMTAsMC41IFpcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiNi44XFxcIiByPVxcXCIyLjNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJsb2NrXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGhlaWdodD1cXFwiMTBcXFwiIHdpZHRoPVxcXCIxM1xcXCIgeT1cXFwiOC41XFxcIiB4PVxcXCIzLjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk02LjUsOCBMNi41LDQuODggQzYuNSwzLjAxIDguMDcsMS41IDEwLDEuNSBDMTEuOTMsMS41IDEzLjUsMy4wMSAxMy41LDQuODggTDEzLjUsOFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1haWxcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMS40LDYuNSAxMCwxMSAxOC42LDYuNVxcXCIvPjxwYXRoIGQ9XFxcIk0gMSw0IDEsMTYgMTksMTYgMTksNCAxLDQgWiBNIDE4LDE1IDIsMTUgMiw1IDE4LDUgMTgsMTUgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1lbnVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjRcXFwiIHdpZHRoPVxcXCIxNlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjE2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjE2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtaWNyb3Bob25lXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCIxMFxcXCIgeDI9XFxcIjEwXFxcIiB5MT1cXFwiMTYuNDRcXFwiIHkyPVxcXCIxOC41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiN1xcXCIgeDI9XFxcIjEzXFxcIiB5MT1cXFwiMTguNVxcXCIgeTI9XFxcIjE4LjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTMuNSA0Ljg5djUuODdhMy41IDMuNSAwIDAgMS03IDBWNC44OWEzLjUgMy41IDAgMCAxIDcgMHpcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTUuNSAxMC4zNlYxMWE1LjUgNS41IDAgMCAxLTExIDB2LS42XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibWludXMtY2lyY2xlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI5LjVcXFwiIGN5PVxcXCI5LjVcXFwiIHI9XFxcIjlcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI1XFxcIiB5MT1cXFwiOS41XFxcIiB4Mj1cXFwiMTRcXFwiIHkyPVxcXCI5LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtaW51c1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgaGVpZ2h0PVxcXCIxXFxcIiB3aWR0aD1cXFwiMThcXFwiIHk9XFxcIjlcXFwiIHg9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtb3JlLXZlcnRpY2FsXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjNcXFwiIHI9XFxcIjJcXFwiLz48Y2lyY2xlIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCIyXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxN1xcXCIgcj1cXFwiMlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1vcmVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjNcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiMlxcXCIvPjxjaXJjbGUgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjJcXFwiLz48Y2lyY2xlIGN4PVxcXCIxN1xcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCIyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibW92ZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCI0LDUgMSw1IDEsOSAyLDkgMiw2IDQsNlxcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiMSwxNiAyLDE2IDIsMTggNCwxOCA0LDE5IDEsMTlcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjE0LDE2IDE0LDE5IDExLDE5IDExLDE4IDEzLDE4IDEzLDE2XFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCI1LjVcXFwiIHk9XFxcIjEuNVxcXCIgd2lkdGg9XFxcIjEzXFxcIiBoZWlnaHQ9XFxcIjEzXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiMTFcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCI2XFxcIiB5PVxcXCIxOFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm51dFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjIuNSw1LjcgMTAsMS4zIDE3LjUsNS43IDE3LjUsMTQuMyAxMCwxOC43IDIuNSwxNC4zXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCIzLjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwYWdla2l0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjMsMSAxNywxIDE3LDE2IDEwLDE2IDEwLDEzIDE0LDEzIDE0LDQgNiw0IDYsMTYgMTAsMTYgMTAsMTkgMywxOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBhaW50LWJ1Y2tldFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEwLjIxLDEgTDAsMTEuMjEgTDguMSwxOS4zMSBMMTguMzEsOS4xIEwxMC4yMSwxIEwxMC4yMSwxIFogTTE2Ljg5LDkuMSBMMTUsMTEgTDEuNywxMSBMMTAuMjEsMi40MiBMMTYuODksOS4xIFpcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNNi40MiwyLjMzIEwxMS43LDcuNjFcXFwiLz48cGF0aCBkPVxcXCJNMTguNDksMTIgQzE4LjQ5LDEyIDIwLDE0LjA2IDIwLDE1LjM2IEMyMCwxNi4yOCAxOS4yNCwxNyAxOC40OSwxNyBMMTguNDksMTcgQzE3Ljc0LDE3IDE3LDE2LjI4IDE3LDE1LjM2IEMxNywxNC4wNiAxOC40OSwxMiAxOC40OSwxMiBMMTguNDksMTIgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBlbmNpbFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTcuMjUsNi4wMSBMNy4xMiwxNi4xIEwzLjgyLDE3LjIgTDUuMDIsMTMuOSBMMTUuMTIsMy44OCBDMTUuNzEsMy4yOSAxNi42NiwzLjI5IDE3LjI1LDMuODggQzE3LjgzLDQuNDcgMTcuODMsNS40MiAxNy4yNSw2LjAxIEwxNy4yNSw2LjAxIFpcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNS45OCw3LjI2OCBMMTMuODUxLDUuMTQ4XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGhvbmUtbGFuZHNjYXBlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNyw1LjUgQzE3LjgsNS41IDE4LjUsNi4yIDE4LjUsNyBMMTguNSwxNCBDMTguNSwxNC44IDE3LjgsMTUuNSAxNywxNS41IEwzLDE1LjUgQzIuMiwxNS41IDEuNSwxNC44IDEuNSwxNCBMMS41LDcgQzEuNSw2LjIgMi4yLDUuNSAzLDUuNSBMMTcsNS41IEwxNyw1LjUgTDE3LDUuNSBaXFxcIi8+PGNpcmNsZSBjeD1cXFwiMy44XFxcIiBjeT1cXFwiMTAuNVxcXCIgcj1cXFwiLjhcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTUuNSwxNyBDMTUuNSwxNy44IDE0LjgsMTguNSAxNCwxOC41IEw3LDE4LjUgQzYuMiwxOC41IDUuNSwxNy44IDUuNSwxNyBMNS41LDMgQzUuNSwyLjIgNi4yLDEuNSA3LDEuNSBMMTQsMS41IEMxNC44LDEuNSAxNS41LDIuMiAxNS41LDMgTDE1LjUsMTcgTDE1LjUsMTcgTDE1LjUsMTcgWlxcXCIvPjxjaXJjbGUgY3g9XFxcIjEwLjVcXFwiIGN5PVxcXCIxNi41XFxcIiByPVxcXCIuOFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBpbnRlcmVzdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEwLjIxLDEgQzUuNSwxIDMsNC4xNiAzLDcuNjEgQzMsOS4yMSAzLjg1LDExLjIgNS4yMiwxMS44NCBDNS40MywxMS45NCA1LjU0LDExLjg5IDUuNTgsMTEuNjkgQzUuNjIsMTEuNTQgNS44LDEwLjggNS44OCwxMC40NSBDNS45MSwxMC4zNCA1Ljg5LDEwLjI0IDUuOCwxMC4xNCBDNS4zNiw5LjU5IDUsOC41OCA1LDcuNjUgQzUsNS4yNCA2LjgyLDIuOTEgOS45MywyLjkxIEMxMi42MSwyLjkxIDE0LjQ5LDQuNzQgMTQuNDksNy4zNSBDMTQuNDksMTAuMyAxMywxMi4zNSAxMS4wNiwxMi4zNSBDOS45OSwxMi4zNSA5LjE5LDExLjQ3IDkuNDQsMTAuMzggQzkuNzUsOS4wOCAxMC4zNSw3LjY4IDEwLjM1LDYuNzUgQzEwLjM1LDUuOTEgOS45LDUuMjEgOC45Nyw1LjIxIEM3Ljg3LDUuMjEgNi45OSw2LjM0IDYuOTksNy44NiBDNi45OSw4LjgzIDcuMzIsOS40OCA3LjMyLDkuNDggQzcuMzIsOS40OCA2LjI0LDE0LjA2IDYuMDQsMTQuOTEgQzUuNywxNi4zNSA2LjA4LDE4LjcgNi4xMiwxOC45IEM2LjE0LDE5LjAxIDYuMjYsMTkuMDUgNi4zMywxOC45NSBDNi40NCwxOC44MSA3Ljc0LDE2Ljg1IDguMTEsMTUuNDQgQzguMjQsMTQuOTMgOC43OSwxMi44NCA4Ljc5LDEyLjg0IEM5LjE1LDEzLjUyIDEwLjE5LDE0LjA5IDExLjI5LDE0LjA5IEMxNC41OCwxNC4wOSAxNi45NiwxMS4wNiAxNi45Niw3LjMgQzE2Ljk0LDMuNyAxNCwxIDEwLjIxLDFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwbGF5LWNpcmNsZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgcG9pbnRzPVxcXCI4LjUgNyAxMy41IDEwIDguNSAxM1xcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwbGF5XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNi41LDUgMTQuNSwxMCA2LjUsMTVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwbHVzLWNpcmNsZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiOS41XFxcIiBjeT1cXFwiOS41XFxcIiByPVxcXCI5XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiOS41XFxcIiB5MT1cXFwiNVxcXCIgeDI9XFxcIjkuNVxcXCIgeTI9XFxcIjE0XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiNVxcXCIgeTE9XFxcIjkuNVxcXCIgeDI9XFxcIjE0XFxcIiB5Mj1cXFwiOS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGx1c1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiOVxcXCIgeT1cXFwiMVxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMTdcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMTdcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInByaW50XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjQuNSAxMy41IDEuNSAxMy41IDEuNSA2LjUgMTguNSA2LjUgMTguNSAxMy41IDE1LjUgMTMuNVxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTUuNSA2LjUgMTUuNSAyLjUgNC41IDIuNSA0LjUgNi41XFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB3aWR0aD1cXFwiMTFcXFwiIGhlaWdodD1cXFwiNlxcXCIgeD1cXFwiNC41XFxcIiB5PVxcXCIxMS41XFxcIi8+PHJlY3Qgd2lkdGg9XFxcIjhcXFwiIGhlaWdodD1cXFwiMVxcXCIgeD1cXFwiNlxcXCIgeT1cXFwiMTNcXFwiLz48cmVjdCB3aWR0aD1cXFwiOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIiB4PVxcXCI2XFxcIiB5PVxcXCIxNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInB1bGxcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiNi44NSw4IDkuNSwxMC42IDEyLjE1LDggMTIuODUsOC43IDkuNSwxMiA2LjE1LDguN1xcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjkuNVxcXCIgeTE9XFxcIjExXFxcIiB4Mj1cXFwiOS41XFxcIiB5Mj1cXFwiMlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNiw1LjUgMy41LDUuNSAzLjUsMTguNSAxNS41LDE4LjUgMTUuNSw1LjUgMTMsNS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicHVzaFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMi4xNSw0IDkuNSwxLjQgNi44NSw0IDYuMTUsMy4zIDkuNSwwIDEyLjg1LDMuM1xcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjkuNVxcXCIgeTE9XFxcIjEwXFxcIiB4Mj1cXFwiOS41XFxcIiB5Mj1cXFwiMVxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNiA1LjUgMy41IDUuNSAzLjUgMTguNSAxNS41IDE4LjUgMTUuNSA1LjUgMTMgNS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicXVlc3Rpb25cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48Y2lyY2xlIGN4PVxcXCIxMC40NFxcXCIgY3k9XFxcIjE0LjQyXFxcIiByPVxcXCIxLjA1XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgZD1cXFwiTTguMTcsNy43OSBDOC4xNyw0Ljc1IDEyLjcyLDQuNzMgMTIuNzIsNy43MiBDMTIuNzIsOC42NyAxMS44MSw5LjE1IDExLjIzLDkuNzUgQzEwLjc1LDEwLjI0IDEwLjUxLDEwLjczIDEwLjQ1LDExLjQgQzEwLjQ0LDExLjUzIDEwLjQzLDExLjY0IDEwLjQzLDExLjc1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicXVvdGUtcmlnaHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNy4yNyw3Ljc5IEMxNy4yNyw5LjQ1IDE2Ljk3LDEwLjQzIDE1Ljk5LDEyLjAyIEMxNC45OCwxMy42NCAxMywxNS4yMyAxMS41NiwxNS45NyBMMTEuMSwxNS4wOCBDMTIuMzQsMTQuMiAxMy4xNCwxMy41MSAxNC4wMiwxMS44MiBDMTQuMjcsMTEuMzQgMTQuNDEsMTAuOTIgMTQuNDksMTAuNTQgQzE0LjMsMTAuNTggMTQuMDksMTAuNiAxMy44OCwxMC42IEMxMi4wNiwxMC42IDEwLjU5LDkuMTIgMTAuNTksNy4zIEMxMC41OSw1LjQ4IDEyLjA2LDQgMTMuODgsNCBDMTUuMzksNCAxNi42Nyw1LjAyIDE3LjA1LDYuNDIgQzE3LjE5LDYuODIgMTcuMjcsNy4yNyAxNy4yNyw3Ljc5IEwxNy4yNyw3Ljc5IFpcXFwiLz48cGF0aCBkPVxcXCJNOC42OCw3Ljc5IEM4LjY4LDkuNDUgOC4zOCwxMC40MyA3LjQsMTIuMDIgQzYuMzksMTMuNjQgNC40MSwxNS4yMyAyLjk3LDE1Ljk3IEwyLjUxLDE1LjA4IEMzLjc1LDE0LjIgNC41NSwxMy41MSA1LjQzLDExLjgyIEM1LjY4LDExLjM0IDUuODIsMTAuOTIgNS45LDEwLjU0IEM1LjcxLDEwLjU4IDUuNSwxMC42IDUuMjksMTAuNiBDMy40NywxMC42IDIsOS4xMiAyLDcuMyBDMiw1LjQ4IDMuNDcsNCA1LjI5LDQgQzYuOCw0IDguMDgsNS4wMiA4LjQ2LDYuNDIgQzguNiw2LjgyIDguNjgsNy4yNyA4LjY4LDcuNzkgTDguNjgsNy43OSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicmVjZWl2ZXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAxXFxcIiBkPVxcXCJNNi4xODksMTMuNjExQzguMTM0LDE1LjUyNSAxMS4wOTcsMTguMjM5IDEzLjg2NywxOC4yNTdDMTYuNDcsMTguMjc1IDE4LjIsMTYuMjQxIDE4LjIsMTYuMjQxTDE0LjUwOSwxMi41NTFMMTEuNTM5LDEzLjYzOUw2LjE4OSw4LjI5TDcuMzEzLDUuMzU1TDMuNzYsMS44QzMuNzYsMS44IDEuNzMyLDMuNTM3IDEuNyw2LjA5MkMxLjY2Nyw4LjgwOSA0LjM0NywxMS43MzggNi4xODksMTMuNjExXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicmVkZGl0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTkgOS4wNWEyLjU2IDIuNTYgMCAwIDAtMi41Ni0yLjU2IDIuNTkgMi41OSAwIDAgMC0xLjg4LjgyIDEwLjYzIDEwLjYzIDAgMCAwLTQuMTQtMXYtLjA4Yy41OC0xLjYyIDEuNTgtMy44OSAyLjctNC4xLjM4LS4wOC43Ny4xMiAxLjE5LjU3YTEuMTUgMS4xNSAwIDAgMC0uMDYuMzcgMS40OCAxLjQ4IDAgMSAwIDEuNTEtMS40NSAxLjQzIDEuNDMgMCAwIDAtLjc2LjE5QTIuMjkgMi4yOSAwIDAgMCAxMi45MSAxYy0yLjExLjQzLTMuMzkgNC4zOC0zLjYzIDUuMTkgMCAwIDAgLjExLS4wNi4xMWExMC42NSAxMC42NSAwIDAgMC0zLjc1IDFBMi41NiAyLjU2IDAgMCAwIDEgOS4wNWEyLjQyIDIuNDIgMCAwIDAgLjcyIDEuNzZBNS4xOCA1LjE4IDAgMCAwIDEuMjQgMTNjMCAzLjY2IDMuOTIgNi42NCA4LjczIDYuNjRzOC43NC0zIDguNzQtNi42NGE1LjIzIDUuMjMgMCAwIDAtLjQ2LTIuMTNBMi41OCAyLjU4IDAgMCAwIDE5IDkuMDV6bS0xNi44OCAwYTEuNDQgMS40NCAwIDAgMSAyLjI3LTEuMTkgNy42OCA3LjY4IDAgMCAwLTIuMDcgMS45MSAxLjMzIDEuMzMgMCAwIDEtLjItLjcyek0xMCAxOC40Yy00LjE3IDAtNy41NS0yLjQtNy41NS01LjRTNS44MyA3LjUzIDEwIDcuNTMgMTcuNSAxMCAxNy41IDEzcy0zLjM4IDUuNC03LjUgNS40em03LjY5LTguNjFhNy42MiA3LjYyIDAgMCAwLTIuMDktMS45MSAxLjQxIDEuNDEgMCAwIDEgLjg0LS4yOCAxLjQ3IDEuNDcgMCAwIDEgMS40NCAxLjQ1IDEuMzQgMS4zNCAwIDAgMS0uMjEuNzJ6XFxcIi8+PHBhdGggZD1cXFwiTTYuNjkgMTIuNThhMS4zOSAxLjM5IDAgMSAxIDEuMzktMS4zOSAxLjM4IDEuMzggMCAwIDEtMS4zOCAxLjM5elxcXCIvPjxwYXRoIGQ9XFxcIk0xNC4yNiAxMS4yYTEuMzkgMS4zOSAwIDEgMS0xLjM5LTEuMzkgMS4zOSAxLjM5IDAgMCAxIDEuMzkgMS4zOXpcXFwiLz48cGF0aCBkPVxcXCJNMTMuMDkgMTQuODhhLjU0LjU0IDAgMCAxLS4wOS43NyA1LjMgNS4zIDAgMCAxLTMuMjYgMS4xOSA1LjYxIDUuNjEgMCAwIDEtMy40LTEuMjIuNTUuNTUgMCAxIDEgLjczLS44MyA0LjA5IDQuMDkgMCAwIDAgNS4yNSAwIC41Ni41NiAwIDAgMSAuNzcuMDl6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicmVmcmVzaFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE3LjA4LDExLjE1IEMxNy4wOSwxMS4zMSAxNy4xLDExLjQ3IDE3LjEsMTEuNjQgQzE3LjEsMTUuNTMgMTMuOTQsMTguNjkgMTAuMDUsMTguNjkgQzYuMTYsMTguNjggMywxNS41MyAzLDExLjYzIEMzLDcuNzQgNi4xNiw0LjU4IDEwLjA1LDQuNTggQzEwLjksNC41OCAxMS43MSw0LjczIDEyLjQ2LDVcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjkuOSAyIDEyLjc5IDQuODkgOS43OSA3LjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJyZXBseVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE3LjcsMTMuMTEgQzE2LjEyLDEwLjAyIDEzLjg0LDcuODUgMTEuMDIsNi42MSBDMTAuNTcsNi40MSA5Ljc1LDYuMTMgOSw1LjkxIEw5LDIgTDEsOSBMOSwxNiBMOSwxMi4xMyBDMTAuNzgsMTIuNDcgMTIuNSwxMy4xOSAxNC4wOSwxNC4yNSBDMTcuMTMsMTYuMjggMTguNTYsMTguNTQgMTguNTYsMTguNTQgQzE4LjU2LDE4LjU0IDE4LjgxLDE1LjI4IDE3LjcsMTMuMTEgTDE3LjcsMTMuMTEgWiBNMTQuODIsMTMuNTMgQzEzLjE3LDEyLjQgMTEuMDEsMTEuNCA4LDEwLjkyIEw4LDEzLjYzIEwyLjU1LDkgTDgsNC4yNSBMOCw2LjggQzguMyw2Ljg2IDkuMTYsNy4wMiAxMC4zNyw3LjQ5IEMxMy4zLDguNjUgMTUuNTQsMTAuOTYgMTYuNjUsMTMuMDggQzE2Ljk3LDEzLjcgMTcuNDgsMTQuODYgMTcuNjgsMTYgQzE2Ljg3LDE1LjA1IDE1LjczLDE0LjE1IDE0LjgyLDEzLjUzIEwxNC44MiwxMy41MyBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicnNzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIzLjEyXFxcIiBjeT1cXFwiMTYuOFxcXCIgcj1cXFwiMS44NVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xLjUsOC4yIEMxLjc4LDguMTggMi4wNiw4LjE2IDIuMzUsOC4xNiBDNy41Nyw4LjE2IDExLjgxLDEyLjM3IDExLjgxLDE3LjU3IEMxMS44MSwxNy44OSAxMS43OSwxOC4xOSAxMS43NiwxOC41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEuNSwyLjUyIEMxLjc4LDIuNTEgMi4wNiwyLjUgMi4zNSwyLjUgQzEwLjcyLDIuNSAxNy41LDkuMjQgMTcuNSwxNy41NyBDMTcuNSwxNy44OSAxNy40OSwxOC4xOSAxNy40NywxOC41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic2VhcmNoXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI5XFxcIiBjeT1cXFwiOVxcXCIgcj1cXFwiN1xcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xNCwxNCBMMTgsMTggTDE0LDE0IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzZXJ2ZXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjNcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB4PVxcXCI1XFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeD1cXFwiN1xcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjE2XFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMTZcXFwiIHk9XFxcIjEwXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCI5LjlcXFwiIGN5PVxcXCIxNy40XFxcIiByPVxcXCIxLjRcXFwiLz48cmVjdCB4PVxcXCIzXFxcIiB5PVxcXCIxMFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjVcXFwiIHk9XFxcIjEwXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeD1cXFwiOS41XFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjE3XFxcIiB3aWR0aD1cXFwiNlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMTFcXFwiIHk9XFxcIjE3XFxcIiB3aWR0aD1cXFwiNlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxLjVcXFwiIHk9XFxcIjEuNVxcXCIgd2lkdGg9XFxcIjE3XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjEuNVxcXCIgeT1cXFwiOC41XFxcIiB3aWR0aD1cXFwiMTdcXFwiIGhlaWdodD1cXFwiNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInNldHRpbmdzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48ZWxsaXBzZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCI2LjExXFxcIiBjeT1cXFwiMy41NVxcXCIgcng9XFxcIjIuMTFcXFwiIHJ5PVxcXCIyLjE1XFxcIi8+PGVsbGlwc2UgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiNi4xMVxcXCIgY3k9XFxcIjE1LjU1XFxcIiByeD1cXFwiMi4xMVxcXCIgcnk9XFxcIjIuMTVcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjEzLjE1XFxcIiBjeT1cXFwiOS41NVxcXCIgcj1cXFwiMi4xNVxcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjNcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxMFxcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjhcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjlcXFwiIHdpZHRoPVxcXCI4XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxNVxcXCIgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjE1XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMTBcXFwiIHk9XFxcIjE1XFxcIiB3aWR0aD1cXFwiOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic2hyaW5rXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjExIDQgMTIgNCAxMiA4IDE2IDggMTYgOSAxMSA5XFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCI0IDExIDkgMTEgOSAxNiA4IDE2IDggMTIgNCAxMlxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMiw4IEwxOCwyXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTIsMTggTDgsMTJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzaWduLWluXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjcgMiAxNyAyIDE3IDE3IDcgMTcgNyAxNiAxNiAxNiAxNiAzIDcgM1xcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiOS4xIDEzLjQgOC41IDEyLjggMTEuMjggMTAgNCAxMCA0IDkgMTEuMjggOSA4LjUgNi4yIDkuMSA1LjYyIDEzIDkuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInNpZ24tb3V0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjEzLjEgMTMuNCAxMi41IDEyLjggMTUuMjggMTAgOCAxMCA4IDkgMTUuMjggOSAxMi41IDYuMiAxMy4xIDUuNjIgMTcgOS41XFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCIxMyAyIDMgMiAzIDE3IDEzIDE3IDEzIDE2IDQgMTYgNCAzIDEzIDNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzb2NpYWxcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHgxPVxcXCIxMy40XFxcIiB5MT1cXFwiMTRcXFwiIHgyPVxcXCI2LjNcXFwiIHkyPVxcXCIxMC43XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjEzLjVcXFwiIHkxPVxcXCI1LjVcXFwiIHgyPVxcXCI2LjVcXFwiIHkyPVxcXCI4LjhcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxNS41XFxcIiBjeT1cXFwiNC42XFxcIiByPVxcXCIyLjNcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxNS41XFxcIiBjeT1cXFwiMTQuOFxcXCIgcj1cXFwiMi4zXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiNC41XFxcIiBjeT1cXFwiOS44XFxcIiByPVxcXCIyLjNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzb3VuZGNsb3VkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTcuMiw5LjRjLTAuNCwwLTAuOCwwLjEtMS4xMDEsMC4yYy0wLjE5OS0yLjUtMi4zOTktNC41LTUtNC41Yy0wLjYsMC0xLjIsMC4xLTEuNywwLjNDOS4yLDUuNSw5LjEsNS42LDkuMSw1LjZWMTVoOCBjMS42MDEsMCwyLjgwMS0xLjIsMi44MDEtMi44QzIwLDEwLjcsMTguNyw5LjQsMTcuMiw5LjRMMTcuMiw5LjR6XFxcIi8+PHJlY3QgeD1cXFwiNlxcXCIgeT1cXFwiNi41XFxcIiB3aWR0aD1cXFwiMS41XFxcIiBoZWlnaHQ9XFxcIjguNVxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjhcXFwiIHdpZHRoPVxcXCIxLjVcXFwiIGhlaWdodD1cXFwiN1xcXCIvPjxyZWN0IHk9XFxcIjEwXFxcIiB3aWR0aD1cXFwiMS41XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzdGFyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wMVxcXCIgcG9pbnRzPVxcXCIxMCAyIDEyLjYzIDcuMjcgMTguNSA4LjEyIDE0LjI1IDEyLjIyIDE1LjI1IDE4IDEwIDE1LjI3IDQuNzUgMTggNS43NSAxMi4yMiAxLjUgOC4xMiA3LjM3IDcuMjdcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzdHJpa2V0aHJvdWdoXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNiwxMy4wMiBMNi42NSwxMy4wMiBDNy42NCwxNS4xNiA4Ljg2LDE2LjEyIDEwLjQxLDE2LjEyIEMxMi4yMiwxNi4xMiAxMi45MiwxNC45MyAxMi45MiwxMy44OSBDMTIuOTIsMTIuNTUgMTEuOTksMTIuMDMgOS43NCwxMS4yMyBDOC4wNSwxMC42NCA2LjIzLDEwLjExIDYuMjMsNy44MyBDNi4yMyw1LjUgOC4wOSw0LjA5IDEwLjQsNC4wOSBDMTEuNDQsNC4wOSAxMi4xMyw0LjMxIDEyLjcyLDQuNTQgTDEzLjMzLDQgTDEzLjgxLDQgTDEzLjgxLDcuNTkgTDEzLjE2LDcuNTkgQzEyLjU1LDUuODggMTEuNTIsNC44OSAxMC4wNyw0Ljg5IEM4Ljg0LDQuODkgNy44OSw1LjY5IDcuODksNy4wMyBDNy44OSw4LjI5IDguODksOC43OCAxMC44OCw5LjQ1IEMxMi41NywxMC4wMyAxNC4zOCwxMC42IDE0LjM4LDEyLjkxIEMxNC4zOCwxNC43NSAxMy4yNywxNi45MyAxMC4xOCwxNi45MyBDOS4xOCwxNi45MyA4LjE3LDE2LjY5IDcuNDYsMTYuMzkgTDYuNTIsMTcgTDYsMTcgTDYsMTMuMDIgTDYsMTMuMDIgWlxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjEwXFxcIiB3aWR0aD1cXFwiMTVcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRhYmxlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMThcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjdcXFwiIHdpZHRoPVxcXCIxOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiMTFcXFwiIHdpZHRoPVxcXCIxOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiMTVcXFwiIHdpZHRoPVxcXCIxOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidGFibGV0LWxhbmRzY2FwZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMS41LDUgQzEuNSw0LjIgMi4yLDMuNSAzLDMuNSBMMTcsMy41IEMxNy44LDMuNSAxOC41LDQuMiAxOC41LDUgTDE4LjUsMTYgQzE4LjUsMTYuOCAxNy44LDE3LjUgMTcsMTcuNSBMMywxNy41IEMyLjIsMTcuNSAxLjUsMTYuOCAxLjUsMTYgTDEuNSw1IEwxLjUsNSBMMS41LDUgWlxcXCIvPjxjaXJjbGUgY3g9XFxcIjMuN1xcXCIgY3k9XFxcIjEwLjVcXFwiIHI9XFxcIi44XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidGFibGV0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk01LDE4LjUgQzQuMiwxOC41IDMuNSwxNy44IDMuNSwxNyBMMy41LDMgQzMuNSwyLjIgNC4yLDEuNSA1LDEuNSBMMTYsMS41IEMxNi44LDEuNSAxNy41LDIuMiAxNy41LDMgTDE3LjUsMTcgQzE3LjUsMTcuOCAxNi44LDE4LjUgMTYsMTguNSBMNSwxOC41IEw1LDE4LjUgTDUsMTguNSBaXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTAuNVxcXCIgY3k9XFxcIjE2LjNcXFwiIHI9XFxcIi44XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidGFnXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTcuNSwzLjcxIEwxNy41LDcuNzIgQzE3LjUsNy45NiAxNy40LDguMiAxNy4yMSw4LjM5IEw4LjM5LDE3LjIgQzcuOTksMTcuNiA3LjMzLDE3LjYgNi45MywxNy4yIEwyLjgsMTMuMDcgQzIuNCwxMi42NyAyLjQsMTIuMDEgMi44LDExLjYxIEwxMS42MSwyLjggQzExLjgxLDIuNiAxMi4wOCwyLjUgMTIuMzQsMi41IEwxNi4xOSwyLjUgQzE2LjUyLDIuNSAxNi44NiwyLjYzIDE3LjExLDIuODggQzE3LjM1LDMuMTEgMTcuNDgsMy40IDE3LjUsMy43MSBMMTcuNSwzLjcxIFpcXFwiLz48Y2lyY2xlIGN4PVxcXCIxNFxcXCIgY3k9XFxcIjZcXFwiIHI9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0aHVtYm5haWxzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiMy41XFxcIiB3aWR0aD1cXFwiNVxcXCIgaGVpZ2h0PVxcXCI1XFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxMS41XFxcIiB5PVxcXCIzLjVcXFwiIHdpZHRoPVxcXCI1XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjExLjVcXFwiIHk9XFxcIjExLjVcXFwiIHdpZHRoPVxcXCI1XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiMTEuNVxcXCIgd2lkdGg9XFxcIjVcXFwiIGhlaWdodD1cXFwiNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRpa3Rva1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE3LjI0LDZWOC44MmE2Ljc5LDYuNzksMCwwLDEtNC0xLjI4djUuODFBNS4yNiw1LjI2LDAsMSwxLDgsOC4xYTQuMzYsNC4zNiwwLDAsMSwuNzIuMDV2Mi45QTIuNTcsMi41NywwLDAsMCw3LjY0LDExYTIuNCwyLjQsMCwxLDAsMi43NywyLjM4VjJoMi44NmE0LDQsMCwwLDAsMS44NCwzLjM4QTQsNCwwLDAsMCwxNy4yNCw2WlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRyYXNoXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjYuNSAzIDYuNSAxLjUgMTMuNSAxLjUgMTMuNSAzXFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI0LjUgNCA0LjUgMTguNSAxNS41IDE4LjUgMTUuNSA0XFxcIi8+PHJlY3QgeD1cXFwiOFxcXCIgeT1cXFwiN1xcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiOVxcXCIvPjxyZWN0IHg9XFxcIjExXFxcIiB5PVxcXCI3XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI5XFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjE2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0cmlhbmdsZS1kb3duXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjUgNyAxNSA3IDEwIDEyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHJpYW5nbGUtbGVmdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMiA1IDcgMTAgMTIgMTVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0cmlhbmdsZS1yaWdodFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCI4IDUgMTMgMTAgOCAxNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRyaWFuZ2xlLXVwXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjUgMTMgMTAgOCAxNSAxM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRyaXBhZHZpc29yXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTkuMDIxLDcuODY2QzE5LjI1Niw2Ljg2MiwyMCw1Ljg1NCwyMCw1Ljg1NGgtMy4zNDZDMTQuNzgxLDQuNjQxLDEyLjUwNCw0LDkuOTgsNEM3LjM2Myw0LDQuOTk5LDQuNjUxLDMuMTM1LDUuODc2SDBcXHRjMCwwLDAuNzM4LDAuOTg3LDAuOTc2LDEuOTg4Yy0wLjYxMSwwLjgzNy0wLjk3MywxLjg1Mi0wLjk3MywyLjk2NGMwLDIuNzYzLDIuMjQ5LDUuMDA5LDUuMDExLDUuMDA5XFx0YzEuNTc2LDAsMi45NzYtMC43MzcsMy45MDEtMS44NzlsMS4wNjMsMS41OTlsMS4wNzUtMS42MTVjMC40NzUsMC42MTEsMS4xLDEuMTExLDEuODM4LDEuNDUxYzEuMjEzLDAuNTQ3LDIuNTc0LDAuNjEyLDMuODI1LDAuMTVcXHRjMi41ODktMC45NjMsMy45MTMtMy44NTIsMi45NjQtNi40MzljLTAuMTc1LTAuNDYzLTAuNC0wLjg3Ni0wLjY3NS0xLjIzOEgxOS4wMjF6IE0xNi4zOCwxNC41OTRcXHRjLTEuMDAyLDAuMzcxLTIuMDg4LDAuMzI4LTMuMDYtMC4xMTljLTAuNjg4LTAuMzE3LTEuMjUyLTAuODE3LTEuNjU3LTEuNDM4Yy0wLjE2NC0wLjI1LTAuMzEzLTAuNTItMC40MTctMC44MTFcXHRjLTAuMTI0LTAuMzI4LTAuMTg2LTAuNjY4LTAuMjE3LTEuMDE0Yy0wLjA2My0wLjY4OSwwLjAzNy0xLjM5NiwwLjMzOS0yLjA0M2MwLjQ0OC0wLjk3MSwxLjI1MS0xLjcxLDIuMjUtMi4wNzlcXHRjMi4wNzUtMC43NjUsNC4zNzUsMC4zLDUuMTQsMi4zNjZjMC43NjIsMi4wNjYtMC4zMDEsNC4zNy0yLjM2Myw1LjEzNEwxNi4zOCwxNC41OTRMMTYuMzgsMTQuNTk0eiBNOC4zMjIsMTMuMDY2XFx0Yy0wLjcyLDEuMDU5LTEuOTM1LDEuNzYtMy4zMDksMS43NmMtMi4yMDcsMC00LjAwMS0xLjc5Ny00LjAwMS0zLjk5NmMwLTIuMjAzLDEuNzk1LTQuMDAyLDQuMDAxLTQuMDAyXFx0YzIuMjA0LDAsMy45OTksMS44LDMuOTk5LDQuMDAyYzAsMC4xMzctMC4wMjQsMC4yNjEtMC4wNCwwLjM5NmMtMC4wNjcsMC42NzgtMC4yODQsMS4zMTMtMC42NDgsMS44NTN2LTAuMDEzSDguMzIyeiBNMi40NzIsMTAuNzc1XFx0YzAsMS4zNjcsMS4xMTIsMi40NzksMi40NzYsMi40NzljMS4zNjMsMCwyLjQ3Mi0xLjExLDIuNDcyLTIuNDc5YzAtMS4zNTktMS4xMS0yLjQ2OC0yLjQ3Mi0yLjQ2OFxcdEMzLjU4NCw4LjMwNiwyLjQ3Myw5LjQxNiwyLjQ3MiwxMC43NzVMMi40NzIsMTAuNzc1eiBNMTIuNTE0LDEwLjc3NWMwLDEuMzY3LDEuMTA0LDIuNDc5LDIuNDcxLDIuNDc5XFx0YzEuMzYzLDAsMi40NzQtMS4xMDgsMi40NzQtMi40NzljMC0xLjM1OS0xLjExLTIuNDY4LTIuNDc0LTIuNDY4Yy0xLjM2NCwwLTIuNDc3LDEuMTA5LTIuNDc3LDIuNDY4SDEyLjUxNHogTTMuMzI0LDEwLjc3NVxcdGMwLTAuODkzLDAuNzI2LTEuNjE4LDEuNjE0LTEuNjE4YzAuODg5LDAsMS42MjUsMC43MjcsMS42MjUsMS42MThjMCwwLjg5OC0wLjcyNSwxLjYyNy0xLjYyNSwxLjYyN1xcdGMtMC45MDEsMC0xLjYyNS0wLjcyOS0xLjYyNS0xLjYyN0gzLjMyNHogTTEzLjM1NCwxMC43NzVjMC0wLjg5MywwLjcyNi0xLjYxOCwxLjYyNy0xLjYxOGMwLjg4NiwwLDEuNjEsMC43MjcsMS42MSwxLjYxOFxcdGMwLDAuODk4LTAuNzI2LDEuNjI3LTEuNjI2LDEuNjI3cy0xLjYyNS0wLjcyOS0xLjYyNS0xLjYyN0gxMy4zNTR6IE05Ljk3Nyw0Ljg3NWMxLjc5OCwwLDMuNDI1LDAuMzI0LDQuODQ5LDAuOTY4XFx0Yy0wLjUzNSwwLjAxNS0xLjA2MSwwLjEwOC0xLjU4NiwwLjNjLTEuMjY0LDAuNDYzLTIuMjY0LDEuMzg4LTIuODE1LDIuNjA0Yy0wLjI2MiwwLjU1MS0wLjM5OCwxLjEzMy0wLjQ0OCwxLjcyXFx0QzkuNzksNy45MDUsNy42NzcsNS44NzMsNS4wNzYsNS44MkM2LjUwMSw1LjIwOCw4LjE1Myw0Ljg3NSw5Ljk0LDQuODc1SDkuOTc3elxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInR1bWJsclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTYuODg1LDguNTk4YzAsMCwwLDMuMzkzLDAsNC45OTZjMCwwLjI4MiwwLDAuNjYsMC4wOTQsMC45NDJjMC4zNzcsMS41MDksMS4xMzEsMi41NDUsMi41NDUsMy4xMSBjMS4zMTksMC40NzIsMi4zNTYsMC40NzIsMy42NzYsMGMwLjU2NS0wLjE4OCwxLjEzMi0wLjY1OSwxLjEzMi0wLjY1OWwtMC44NDktMi4yNjNjMCwwLTEuMDM2LDAuMzc4LTEuNjAzLDAuMjgzIGMtMC41NjUtMC4wOTQtMS4yMjYtMC42Ni0xLjIyNi0xLjUwOGMwLTEuNjAzLDAtNC45MDIsMC00LjkwMmgyLjgyOFY1Ljc3MWgtMi44MjhWMkg4LjIwNWMwLDAtMC4wOTQsMC42Ni0wLjE4OCwwLjk0MiBDNy44MjgsMy43OTEsNy4yNjIsNC43MzMsNi42MDMsNS4zOTRDNS44NDgsNi4xNDcsNSw2LjQzLDUsNi40M3YyLjE2OEg2Ljg4NXpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0dlwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiN1xcXCIgeT1cXFwiMTZcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIi41XFxcIiB5PVxcXCIzLjVcXFwiIHdpZHRoPVxcXCIxOVxcXCIgaGVpZ2h0PVxcXCIxMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInR3aXRjaFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTUuMjMsMSwyLDQuMjNWMTUuODVINS44OHYzLjIzTDkuMSwxNS44NWgyLjU5TDE3LjUsMTBWMVptMTEsOC40TDEzLjYyLDEySDExTDguNzgsMTQuMjRWMTJINS44OFYyLjI5SDE2LjIxWlxcXCIvPjxyZWN0IHg9XFxcIjEyLjk4XFxcIiB5PVxcXCI0LjU1XFxcIiB3aWR0aD1cXFwiMS4yOVxcXCIgaGVpZ2h0PVxcXCIzLjg4XFxcIi8+PHJlY3QgeD1cXFwiOS40M1xcXCIgeT1cXFwiNC41NVxcXCIgd2lkdGg9XFxcIjEuMjlcXFwiIGhlaWdodD1cXFwiMy44OFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInR3aXR0ZXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xOSw0Ljc0IEMxOC4zMzksNS4wMjkgMTcuNjI2LDUuMjI5IDE2Ljg4MSw1LjMyIEMxNy42NDQsNC44NiAxOC4yMjcsNC4xMzkgMTguNTAzLDMuMjggQzE3Ljc5LDMuNyAxNy4wMDEsNC4wMDkgMTYuMTU5LDQuMTcgQzE1LjQ4NSwzLjQ1IDE0LjUyNiwzIDEzLjQ2NCwzIEMxMS40MjMsMyA5Ljc3MSw0LjY2IDkuNzcxLDYuNyBDOS43NzEsNi45OSA5LjgwNCw3LjI2OSA5Ljg2OCw3LjUzOSBDNi43OTUsNy4zOCA0LjA3Niw1LjkxOSAyLjI1NCwzLjY3OSBDMS45MzYsNC4yMTkgMS43NTQsNC44NiAxLjc1NCw1LjUzOSBDMS43NTQsNi44MiAyLjQwNSw3Ljk1IDMuMzk3LDguNjEgQzIuNzksOC41ODkgMi4yMiw4LjQyOSAxLjcyMyw4LjE0OSBMMS43MjMsOC4xODkgQzEuNzIzLDkuOTc4IDIuOTk3LDExLjQ3OCA0LjY4NiwxMS44MiBDNC4zNzYsMTEuODk5IDQuMDQ5LDExLjkzOSAzLjcxMywxMS45MzkgQzMuNDc1LDExLjkzOSAzLjI0NSwxMS45MTkgMy4wMTgsMTEuODggQzMuNDksMTMuMzQ5IDQuODUyLDE0LjQxOSA2LjQ2OSwxNC40NDkgQzUuMjA1LDE1LjQyOSAzLjYxMiwxNi4wMTkgMS44ODIsMTYuMDE5IEMxLjU4MywxNi4wMTkgMS4yOSwxNi4wMDkgMSwxNS45NjkgQzIuNjM1LDE3LjAxOSA0LjU3NiwxNy42MjkgNi42NjIsMTcuNjI5IEMxMy40NTQsMTcuNjI5IDE3LjE3LDEyIDE3LjE3LDcuMTI5IEMxNy4xNyw2Ljk2OSAxNy4xNjYsNi44MDkgMTcuMTU3LDYuNjQ5IEMxNy44NzksNi4xMjkgMTguNTA0LDUuNDc4IDE5LDQuNzRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ1aWtpdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxNC40LDMuMSAxMS4zLDUuMSAxNSw3LjMgMTUsMTIuOSAxMCwxNS43IDUsMTIuOSA1LDguNSAyLDYuOCAyLDE0LjggOS45LDE5LjUgMTgsMTQuOCAxOCw1LjNcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjkuOCw0LjIgNi43LDIuNCA5LjgsMC40IDEyLjksMi4zXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidW5sb2NrXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiOC41XFxcIiB3aWR0aD1cXFwiMTNcXFwiIGhlaWdodD1cXFwiMTBcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk02LjUsOC41IEw2LjUsNC45IEM2LjUsMyA4LjEsMS41IDEwLDEuNSBDMTEuOSwxLjUgMTMuNSwzIDEzLjUsNC45XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidXBsb2FkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjUgOCA5LjUgMy41IDE0IDhcXFwiLz48cmVjdCB4PVxcXCIzXFxcIiB5PVxcXCIxN1xcXCIgd2lkdGg9XFxcIjEzXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI5LjVcXFwiIHkxPVxcXCIxNVxcXCIgeDI9XFxcIjkuNVxcXCIgeTI9XFxcIjRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ1c2VyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI5LjlcXFwiIGN5PVxcXCI2LjRcXFwiIHI9XFxcIjQuNFxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xLjUsMTkgQzIuMywxNC41IDUuOCwxMS4yIDEwLDExLjIgQzE0LjIsMTEuMiAxNy43LDE0LjYgMTguNSwxOS4yXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidXNlcnNcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjcuN1xcXCIgY3k9XFxcIjguNlxcXCIgcj1cXFwiMy41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEsMTguMSBDMS43LDE0LjYgNC40LDEyLjEgNy42LDEyLjEgQzEwLjksMTIuMSAxMy43LDE0LjggMTQuMywxOC4zXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTExLjQsNCBDMTIuOCwyLjQgMTUuNCwyLjggMTYuMyw0LjcgQzE3LjIsNi42IDE1LjcsOC45IDEzLjYsOC45IEMxNi41LDguOSAxOC44LDExLjMgMTkuMiwxNC4xXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidmlkZW8tY2FtZXJhXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTcuNSA2LjkgMTcuNSAxMy4xIDEzLjUgMTAuNCAxMy41IDE0LjUgMi41IDE0LjUgMi41IDUuNSAxMy41IDUuNSAxMy41IDkuNiAxNy41IDYuOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInZpbWVvXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMi4wNjUsNy41OUMxLjg0LDcuMzY3LDEuNjU0LDcuMDgyLDEuNDY4LDYuODM4Yy0wLjMzMi0wLjQyLTAuMTM3LTAuNDExLDAuMjc0LTAuNzcyYzEuMDI2LTAuOTEsMi4wMDQtMS44OTYsMy4xMjctMi42ODggYzEuMDE3LTAuNzEzLDIuMzY1LTEuMTczLDMuMjg2LTAuMDM5YzAuODQ5LDEuMDQ1LDAuODY5LDIuNjI5LDEuMDg0LDMuODkxYzAuMjE1LDEuMzA5LDAuNDIxLDIuNjQ4LDAuODgsMy45MDEgYzAuMTI3LDAuMzUyLDAuMzcsMS4wMTgsMC44MSwxLjA3NGMwLjU2NywwLjA3OCwxLjE0NS0wLjkxNywxLjQwOC0xLjI4OWMwLjY4NC0wLjk4NywxLjYxMS0yLjMxNywxLjQ5NC0zLjU4NyBjLTAuMTE1LTEuMzQ5LTEuNTcyLTEuMDk1LTIuNDgyLTAuNzczYzAuMTQ2LTEuNTE0LDEuNTU1LTMuMjE2LDIuOTEyLTMuNzkyYzEuNDM5LTAuNTk3LDMuNTc5LTAuNTg3LDQuMzAyLDEuMDM2IGMwLjc3MiwxLjc1OSwwLjA3OCwzLjgwMi0wLjc2Myw1LjM5NmMtMC45MTgsMS43MzEtMi4xLDMuMzMzLTMuMzYzLDQuODI5Yy0xLjExNCwxLjMyOS0yLjQzMiwyLjc4Ny00LjA5MywzLjQyMiBjLTEuODk3LDAuNzIzLTMuMDIxLTAuNjg2LTMuNjY3LTIuMzE4Yy0wLjcwNS0xLjc3Ny0xLjA1Ni0zLjc3MS0xLjU2NS01LjYyMUM0Ljg5OCw4LjcyNiw0LjY0NCw3LjgzNiw0LjEzNiw3LjE5MSBDMy40NzMsNi4zNTgsMi43Miw3LjE0MSwyLjA2NSw3LjU5QzEuOTc3LDcuNTAyLDIuMTE1LDcuNTUxLDIuMDY1LDcuNTlMMi4wNjUsNy41OXpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ3YXJuaW5nXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjE0XFxcIiByPVxcXCIxXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOVxcXCIvPjxwYXRoIGQ9XFxcIk0xMC45Nyw3LjcyIEMxMC44NSw5LjU0IDEwLjU2LDExLjI5IDEwLjU2LDExLjI5IEMxMC41MSwxMS44NyAxMC4yNywxMiA5Ljk5LDEyIEM5LjY5LDEyIDkuNDksMTEuODcgOS40MywxMS4yOSBDOS40MywxMS4yOSA5LjE2LDkuNTQgOS4wMyw3LjcyIEM4Ljk2LDYuNTQgOS4wMyw2IDkuMDMsNiBDOS4wMyw1LjQ1IDkuNDYsNS4wMiA5Ljk5LDUgQzEwLjUzLDUuMDEgMTAuOTcsNS40NCAxMC45Nyw2IEMxMC45Nyw2IDExLjA0LDYuNTQgMTAuOTcsNy43MiBMMTAuOTcsNy43MiBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwid2hhdHNhcHBcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNi43LDMuM2MtMS44LTEuOC00LjEtMi44LTYuNy0yLjhjLTUuMiwwLTkuNCw0LjItOS40LDkuNGMwLDEuNywwLjQsMy4zLDEuMyw0LjdsLTEuMyw0LjlsNS0xLjNjMS40LDAuOCwyLjksMS4yLDQuNSwxLjIgbDAsMGwwLDBjNS4yLDAsOS40LTQuMiw5LjQtOS40QzE5LjUsNy40LDE4LjUsNSwxNi43LDMuMyBNMTAuMSwxNy43TDEwLjEsMTcuN2MtMS40LDAtMi44LTAuNC00LTEuMWwtMC4zLTAuMmwtMywwLjhsMC44LTIuOSBsLTAuMi0wLjNjLTAuOC0xLjItMS4yLTIuNy0xLjItNC4yYzAtNC4zLDMuNS03LjgsNy44LTcuOGMyLjEsMCw0LjEsMC44LDUuNSwyLjNjMS41LDEuNSwyLjMsMy40LDIuMyw1LjUgQzE3LjksMTQuMiwxNC40LDE3LjcsMTAuMSwxNy43IE0xNC40LDExLjljLTAuMi0wLjEtMS40LTAuNy0xLjYtMC44Yy0wLjItMC4xLTAuNC0wLjEtMC41LDAuMWMtMC4yLDAuMi0wLjYsMC44LTAuOCwwLjkgYy0wLjEsMC4yLTAuMywwLjItMC41LDAuMWMtMC4yLTAuMS0xLTAuNC0xLjktMS4yYy0wLjctMC42LTEuMi0xLjQtMS4zLTEuNmMtMC4xLTAuMiwwLTAuNCwwLjEtMC41QzgsOC44LDguMSw4LjcsOC4yLDguNSBjMC4xLTAuMSwwLjItMC4yLDAuMi0wLjRjMC4xLTAuMiwwLTAuMywwLTAuNEM4LjQsNy42LDcuOSw2LjUsNy43LDZDNy41LDUuNSw3LjMsNS42LDcuMiw1LjZjLTAuMSwwLTAuMywwLTAuNCwwIGMtMC4yLDAtMC40LDAuMS0wLjYsMC4zYy0wLjIsMC4yLTAuOCwwLjgtMC44LDJjMCwxLjIsMC44LDIuMywxLDIuNGMwLjEsMC4yLDEuNywyLjUsNCwzLjVjMC42LDAuMiwxLDAuNCwxLjMsMC41IGMwLjYsMC4yLDEuMSwwLjIsMS41LDAuMWMwLjUtMC4xLDEuNC0wLjYsMS42LTEuMWMwLjItMC41LDAuMi0xLDAuMS0xLjFDMTQuOCwxMi4xLDE0LjYsMTIsMTQuNCwxMS45XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwid29yZHByZXNzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTAsMC41Yy01LjIsMC05LjUsNC4zLTkuNSw5LjVzNC4zLDkuNSw5LjUsOS41YzUuMiwwLDkuNS00LjMsOS41LTkuNVMxNS4yLDAuNSwxMCwwLjVMMTAsMC41TDEwLDAuNXogTTE1LjYsMy45aC0wLjEgYy0wLjgsMC0xLjQsMC43LTEuNCwxLjVjMCwwLjcsMC40LDEuMywwLjgsMS45YzAuMywwLjYsMC43LDEuMywwLjcsMi4zYzAsMC43LTAuMywxLjUtMC42LDIuN0wxNC4xLDE1bC0zLTguOSBjMC41LDAsMC45LTAuMSwwLjktMC4xQzEyLjUsNiwxMi41LDUuMywxMiw1LjRjMCwwLTEuMywwLjEtMi4yLDAuMUM5LDUuNSw3LjcsNS40LDcuNyw1LjRDNy4yLDUuMyw3LjIsNiw3LjYsNmMwLDAsMC40LDAuMSwwLjksMC4xIGwxLjMsMy41TDgsMTVMNSw2LjFDNS41LDYuMSw1LjksNiw1LjksNkM2LjQsNiw2LjMsNS4zLDUuOSw1LjRjMCwwLTEuMywwLjEtMi4yLDAuMWMtMC4yLDAtMC4zLDAtMC41LDBjMS41LTIuMiw0LTMuNyw2LjktMy43IEMxMi4yLDEuNywxNC4xLDIuNiwxNS42LDMuOUwxNS42LDMuOUwxNS42LDMuOXogTTIuNSw2LjZsMy45LDEwLjhjLTIuNy0xLjMtNC42LTQuMi00LjYtNy40QzEuOCw4LjgsMiw3LjYsMi41LDYuNkwyLjUsNi42TDIuNSw2LjYgeiBNMTAuMiwxMC43bDIuNSw2LjljMCwwLDAsMC4xLDAuMSwwLjFDMTEuOSwxOCwxMSwxOC4yLDEwLDE4LjJjLTAuOCwwLTEuNi0wLjEtMi4zLTAuM0wxMC4yLDEwLjdMMTAuMiwxMC43TDEwLjIsMTAuN3ogTTE0LjIsMTcuMSBsMi41LTcuM2MwLjUtMS4yLDAuNi0yLjEsMC42LTIuOWMwLTAuMywwLTAuNi0wLjEtMC44YzAuNiwxLjIsMSwyLjUsMSw0QzE4LjMsMTMsMTYuNiwxNS43LDE0LjIsMTcuMUwxNC4yLDE3LjFMMTQuMiwxNy4xelxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIndvcmxkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xLDEwLjUgTDE5LDEwLjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0yLjM1LDE1LjUgTDE3LjY1LDE1LjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0yLjM1LDUuNSBMMTcuNTIzLDUuNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTEwLDE5LjQ2IEw5Ljk4LDE5LjQ2IEM3LjMxLDE3LjMzIDUuNjEsMTQuMTQxIDUuNjEsMTAuNTggQzUuNjEsNy4wMiA3LjMzLDMuODMgMTAsMS43IEMxMC4wMSwxLjcgOS45OSwxLjcgMTAsMS43IEwxMCwxLjcgQzEyLjY3LDMuODMgMTQuNCw3LjAyIDE0LjQsMTAuNTggQzE0LjQsMTQuMTQxIDEyLjY3LDE3LjMzIDEwLDE5LjQ2IEwxMCwxOS40NiBMMTAsMTkuNDYgTDEwLDE5LjQ2IFpcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTAuNVxcXCIgcj1cXFwiOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInhpbmdcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk00LjQsNC41NiBDNC4yNCw0LjU2IDQuMTEsNC42MSA0LjA1LDQuNzIgQzMuOTgsNC44MyAzLjk5LDQuOTcgNC4wNyw1LjEyIEw1LjgyLDguMTYgTDUuODIsOC4xNyBMMy4wNiwxMy4wNCBDMi45OSwxMy4xOCAyLjk5LDEzLjMzIDMuMDYsMTMuNDQgQzMuMTIsMTMuNTUgMy4yNCwxMy42MiAzLjQsMTMuNjIgTDYsMTMuNjIgQzYuMzksMTMuNjIgNi41NywxMy4zNiA2LjcxLDEzLjEyIEM2LjcxLDEzLjEyIDkuNDEsOC4zNSA5LjUxLDguMTYgQzkuNDksOC4xNCA3LjcyLDUuMDQgNy43Miw1LjA0IEM3LjU4LDQuODEgNy4zOSw0LjU2IDYuOTksNC41NiBMNC40LDQuNTYgTDQuNCw0LjU2IFpcXFwiLz48cGF0aCBkPVxcXCJNMTUuMywxIEMxNC45MSwxIDE0Ljc0LDEuMjUgMTQuNiwxLjUgQzE0LjYsMS41IDkuMDEsMTEuNDIgOC44MiwxMS43NCBDOC44MywxMS43NiAxMi41MSwxOC41MSAxMi41MSwxOC41MSBDMTIuNjQsMTguNzQgMTIuODQsMTkgMTMuMjMsMTkgTDE1LjgyLDE5IEMxNS45OCwxOSAxNi4xLDE4Ljk0IDE2LjE2LDE4LjgzIEMxNi4yMywxOC43MiAxNi4yMywxOC41NyAxNi4xNiwxOC40MyBMMTIuNSwxMS43NCBMMTIuNSwxMS43MiBMMTguMjUsMS41NiBDMTguMzIsMS40MiAxOC4zMiwxLjI3IDE4LjI1LDEuMTYgQzE4LjIxLDEuMDYgMTguMDgsMSAxNy45MywxIEwxNS4zLDEgTDE1LjMsMSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwieWVscFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE3LjE3NSwxNC45NzFjLTAuMTEyLDAuNzctMS42ODYsMi43NjctMi40MDYsMy4wNTRjLTAuMjQ2LDAuMS0wLjQ4NywwLjA3Ni0wLjY3NS0wLjA2OVxcdGMtMC4xMjItMC4wOTYtMi40NDYtMy44NTktMi40NDYtMy44NTljLTAuMTk0LTAuMjkzLTAuMTU3LTAuNjgyLDAuMDgzLTAuOTc4YzAuMjM0LTAuMjg0LDAuNTgxLTAuMzkzLDAuODgxLTAuMjc2XFx0YzAuMDE2LDAuMDEsNC4yMSwxLjM5NCw0LjMzMiwxLjQ4MmMwLjE3OCwwLjE0OCwwLjI2MywwLjM3OSwwLjIyNSwwLjY0NkwxNy4xNzUsMTQuOTcxTDE3LjE3NSwxNC45NzF6IE0xMS40NjQsMTAuNzg5XFx0Yy0wLjIwMy0wLjMwNy0wLjE5OS0wLjY2NiwwLjAwOS0wLjkxNmMwLDAsMi42MjUtMy41NzQsMi43NDUtMy42NTdjMC4yMDMtMC4xMzUsMC40NTItMC4xNDEsMC42OS0wLjAyNVxcdGMwLjY5MSwwLjMzNSwyLjA4NSwyLjQwNSwyLjE2NywzLjE5OXYwLjAyN2MwLjAyNCwwLjI3MS0wLjA4MiwwLjQ5MS0wLjI3MywwLjYyM2MtMC4xMzIsMC4wODMtNC40MywxLjE1NS00LjQzLDEuMTU1XFx0Yy0wLjMyMiwwLjA5Ni0wLjY4LTAuMDYtMC44ODItMC4zODFMMTEuNDY0LDEwLjc4OXogTTkuNDc1LDkuNTYzQzkuMzIsOS42MDksOC44NDgsOS43NTcsOC4yNjksOC44MTdjMCwwLTMuOTE2LTYuMTYtNC4wMDctNi4zNTFcXHRjLTAuMDU3LTAuMjEyLDAuMDExLTAuNDU1LDAuMjAyLTAuNjVDNS4wNDcsMS4yMTEsOC4yMSwwLjMyNyw5LjAzNywwLjUyOWMwLjI3LDAuMDY5LDAuNDU3LDAuMjM4LDAuNTIyLDAuNDc5XFx0YzAuMDQ3LDAuMjY2LDAuNDMzLDUuOTgyLDAuNDg4LDcuMjY0QzEwLjA5OCw5LjM2OCw5LjYyOSw5LjUxNyw5LjQ3NSw5LjU2M3ogTTkuOTI3LDE5LjA2NmMtMC4wODMsMC4yMjUtMC4yNzMsMC4zNzMtMC41NCwwLjQyMVxcdGMtMC43NjIsMC4xMy0zLjE1LTAuNzUxLTMuNjQ3LTEuMzQyYy0wLjA5Ni0wLjEzMS0wLjE1NS0wLjI2Mi0wLjE2Ny0wLjM5NGMtMC4wMTEtMC4wOTUsMC0wLjE4OSwwLjAzNi0wLjI3MlxcdGMwLjA2MS0wLjE1NSwyLjkxNy0zLjUzOCwyLjkxNy0zLjUzOGMwLjIxNC0wLjI3MiwwLjU5NS0wLjM1NSwwLjk1Mi0wLjIxM2MwLjM0NSwwLjEzLDAuNTYsMC40MjgsMC41MzYsMC43NDlcXHRDMTAuMDE0LDE0LjQ3OSw5Ljk3NywxOC45MjMsOS45MjcsMTkuMDY2eiBNMy40OTUsMTMuOTEyYy0wLjIzNS0wLjAwOS0wLjQ0NC0wLjE0OC0wLjU2OC0wLjM4MmMtMC4wODktMC4xNy0wLjE1MS0wLjQ1My0wLjE5LTAuNzk0XFx0QzIuNjMsMTEuNzAxLDIuNzYxLDEwLjE0NCwzLjA3LDkuNjQ4YzAuMTQ1LTAuMjI2LDAuMzU3LTAuMzQ1LDAuNTkyLTAuMzM2YzAuMTU0LDAsNC4yNTUsMS42NjcsNC4yNTUsMS42NjdcXHRjMC4zMjEsMC4xMTgsMC41MjEsMC40NTMsMC41LDAuODMzYy0wLjAyMywwLjM3LTAuMjM2LDAuNjU1LTAuNTUxLDAuNzM4TDMuNDk1LDEzLjkxMnpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ5b3V0dWJlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTUsNC4xYzEsMC4xLDIuMywwLDMsMC44YzAuOCwwLjgsMC45LDIuMSwwLjksMy4xQzE5LDkuMiwxOSwxMC45LDE5LDEyYy0wLjEsMS4xLDAsMi40LTAuNSwzLjRjLTAuNSwxLjEtMS40LDEuNS0yLjUsMS42IGMtMS4yLDAuMS04LjYsMC4xLTExLDBjLTEuMS0wLjEtMi40LTAuMS0zLjItMWMtMC43LTAuOC0wLjctMi0wLjgtM0MxLDExLjgsMSwxMC4xLDEsOC45YzAtMS4xLDAtMi40LDAuNS0zLjRDMiw0LjUsMyw0LjMsNC4xLDQuMiBDNS4zLDQuMSwxMi42LDQsMTUsNC4xeiBNOCw3LjV2Nmw1LjUtM0w4LDcuNXpcXFwiLz48L3N2Zz5cIiB9KTtcblxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVUlraXQpIHtcbiAgICAgIHdpbmRvdy5VSWtpdC51c2UocGx1Z2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luO1xuXG59KSk7XG4iLCIvKiEgVUlraXQgMy4xMy45IHwgaHR0cHM6Ly93d3cuZ2V0dWlraXQuY29tIHwgKGMpIDIwMTQgLSAyMDIyIFlPT3RoZW1lIHwgTUlUIExpY2Vuc2UgKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCd1aWtpdCcsIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVUlraXQgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSwgdG9TdHJpbmcgfSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCBoeXBoZW5hdGVSZSA9IC9cXEIoW0EtWl0pL2c7XG5cbiAgICBjb25zdCBoeXBoZW5hdGUgPSBtZW1vaXplKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJlLCAnLSQxJykudG9Mb3dlckNhc2UoKSk7XG5cbiAgICBjb25zdCBjYW1lbGl6ZVJlID0gLy0oXFx3KS9nO1xuXG4gICAgY29uc3QgY2FtZWxpemUgPSBtZW1vaXplKChzdHIpID0+IHN0ci5yZXBsYWNlKGNhbWVsaXplUmUsIHRvVXBwZXIpKTtcblxuICAgIGNvbnN0IHVjZmlyc3QgPSBtZW1vaXplKChzdHIpID0+XG4gICAgc3RyLmxlbmd0aCA/IHRvVXBwZXIobnVsbCwgc3RyLmNoYXJBdCgwKSkgKyBzdHIuc2xpY2UoMSkgOiAnJyk7XG5cblxuICAgIGZ1bmN0aW9uIHRvVXBwZXIoXywgYykge1xuICAgICAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoKSB7XG4gICAgICByZXR1cm4gc3RyID09IG51bGwgPyB2b2lkIDAgOiBzdHIuc3RhcnRzV2l0aCA9PSBudWxsID8gdm9pZCAwIDogc3RyLnN0YXJ0c1dpdGgoc2VhcmNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCkge1xuICAgICAgcmV0dXJuIHN0ciA9PSBudWxsID8gdm9pZCAwIDogc3RyLmVuZHNXaXRoID09IG51bGwgPyB2b2lkIDAgOiBzdHIuZW5kc1dpdGgoc2VhcmNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhvYmosIHNlYXJjaCkge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqLmluY2x1ZGVzID09IG51bGwgPyB2b2lkIDAgOiBvYmouaW5jbHVkZXMoc2VhcmNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyB2b2lkIDAgOiBhcnJheS5maW5kSW5kZXggPT0gbnVsbCA/IHZvaWQgMCA6IGFycmF5LmZpbmRJbmRleChwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgaXNBcnJheSwgZnJvbTogdG9BcnJheSB9ID0gQXJyYXk7XG4gICAgY29uc3QgeyBhc3NpZ24gfSA9IE9iamVjdDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgb2JqID09PSBvYmoud2luZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnQob2JqKSB7XG4gICAgICByZXR1cm4gbm9kZVR5cGUob2JqKSA9PT0gOTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc05vZGUob2JqKSB7XG4gICAgICByZXR1cm4gbm9kZVR5cGUob2JqKSA+PSAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgICAgIHJldHVybiBub2RlVHlwZShvYmopID09PSAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vZGVUeXBlKG9iaikge1xuICAgICAgcmV0dXJuICFpc1dpbmRvdyhvYmopICYmIGlzT2JqZWN0KG9iaikgJiYgb2JqLm5vZGVUeXBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1lcmljKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNOYU4odmFsdWUgLSBwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICAgIHJldHVybiAhKGlzQXJyYXkob2JqKSA/IG9iai5sZW5ndGggOiBpc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggOiBmYWxzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQm9vbGVhbih2YWx1ZSkgP1xuICAgICAgdmFsdWUgOlxuICAgICAgdmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJzEnIHx8IHZhbHVlID09PSAnJyA/XG4gICAgICB0cnVlIDpcbiAgICAgIHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAnMCcgP1xuICAgICAgZmFsc2UgOlxuICAgICAgdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGNvbnN0IG51bWJlciA9IE51bWJlcih2YWx1ZSk7XG4gICAgICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhbHNlIDogbnVtYmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm9kZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KVswXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vZGVzKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ICYmIChpc05vZGUoZWxlbWVudCkgPyBbZWxlbWVudF0gOiBBcnJheS5mcm9tKGVsZW1lbnQpLmZpbHRlcihpc05vZGUpKSB8fCBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b1dpbmRvdyhlbGVtZW50KSB7dmFyIF9lbGVtZW50O1xuICAgICAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBpc0RvY3VtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IChfZWxlbWVudCA9IGVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudC5vd25lckRvY3VtZW50O1xuXG4gICAgICByZXR1cm4gKGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTXModGltZSkge1xuICAgICAgcmV0dXJuIHRpbWUgPyBlbmRzV2l0aCh0aW1lLCAnbXMnKSA/IHRvRmxvYXQodGltZSkgOiB0b0Zsb2F0KHRpbWUpICogMTAwMCA6IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZhbHVlID09PSBvdGhlciB8fFxuICAgICAgICBpc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgICAgaXNPYmplY3Qob3RoZXIpICYmXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IE9iamVjdC5rZXlzKG90aGVyKS5sZW5ndGggJiZcbiAgICAgICAgZWFjaCh2YWx1ZSwgKHZhbCwga2V5KSA9PiB2YWwgPT09IG90aGVyW2tleV0pKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN3YXAodmFsdWUsIGEsIGIpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoYSArIFwifFwiICsgYiwgJ2cnKSwgKG1hdGNoKSA9PiBtYXRjaCA9PT0gYSA/IGIgOiBhKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWFjaChvYmosIGNiKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGZhbHNlID09PSBjYihvYmpba2V5XSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEJ5JDEoYXJyYXksIHByb3ApIHtcbiAgICAgIHJldHVybiBhcnJheS5cbiAgICAgIHNsaWNlKCkuXG4gICAgICBzb3J0KChfcmVmLCBfcmVmMikgPT4ge2xldCB7IFtwcm9wXTogcHJvcEEgPSAwIH0gPSBfcmVmO2xldCB7IFtwcm9wXTogcHJvcEIgPSAwIH0gPSBfcmVmMjtyZXR1cm4gKFxuICAgICAgICAgIHByb3BBID4gcHJvcEIgPyAxIDogcHJvcEIgPiBwcm9wQSA/IC0xIDogMCk7fSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmlxdWVCeShhcnJheSwgcHJvcCkge1xuICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoKF9yZWYzKSA9PiB7bGV0IHsgW3Byb3BdOiBjaGVjayB9ID0gX3JlZjM7cmV0dXJuIHNlZW4uaGFzKGNoZWNrKSA/IGZhbHNlIDogc2Vlbi5hZGQoY2hlY2spO30pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbWluLCBtYXgpIHtpZiAobWluID09PSB2b2lkIDApIHttaW4gPSAwO31pZiAobWF4ID09PSB2b2lkIDApIHttYXggPSAxO31cbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh0b051bWJlcihudW1iZXIpIHx8IDAsIG1pbiksIG1heCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RSZWN0KCkge2ZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZWN0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtyZWN0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTt9XG4gICAgICByZXR1cm4gW1xuICAgICAgWydib3R0b20nLCAndG9wJ10sXG4gICAgICBbJ3JpZ2h0JywgJ2xlZnQnXV0uXG4gICAgICBldmVyeShcbiAgICAgIChfcmVmNCkgPT4ge2xldCBbbWluUHJvcCwgbWF4UHJvcF0gPSBfcmVmNDtyZXR1cm4gKFxuICAgICAgICAgIE1hdGgubWluKC4uLnJlY3RzLm1hcCgoX3JlZjUpID0+IHtsZXQgeyBbbWluUHJvcF06IG1pbiB9ID0gX3JlZjU7cmV0dXJuIG1pbjt9KSkgLVxuICAgICAgICAgIE1hdGgubWF4KC4uLnJlY3RzLm1hcCgoX3JlZjYpID0+IHtsZXQgeyBbbWF4UHJvcF06IG1heCB9ID0gX3JlZjY7cmV0dXJuIG1heDt9KSkgPlxuICAgICAgICAgIDApO30pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRJblJlY3QocG9pbnQsIHJlY3QpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvaW50LnggPD0gcmVjdC5yaWdodCAmJlxuICAgICAgICBwb2ludC54ID49IHJlY3QubGVmdCAmJlxuICAgICAgICBwb2ludC55IDw9IHJlY3QuYm90dG9tICYmXG4gICAgICAgIHBvaW50LnkgPj0gcmVjdC50b3ApO1xuXG4gICAgfVxuXG4gICAgY29uc3QgRGltZW5zaW9ucyA9IHtcbiAgICAgIHJhdGlvKGRpbWVuc2lvbnMsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFQcm9wID0gcHJvcCA9PT0gJ3dpZHRoJyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFthUHJvcF06IGRpbWVuc2lvbnNbcHJvcF0gP1xuICAgICAgICAgIE1hdGgucm91bmQodmFsdWUgKiBkaW1lbnNpb25zW2FQcm9wXSAvIGRpbWVuc2lvbnNbcHJvcF0pIDpcbiAgICAgICAgICBkaW1lbnNpb25zW2FQcm9wXSxcbiAgICAgICAgICBbcHJvcF06IHZhbHVlIH07XG5cbiAgICAgIH0sXG5cbiAgICAgIGNvbnRhaW4oZGltZW5zaW9ucywgbWF4RGltZW5zaW9ucykge1xuICAgICAgICBkaW1lbnNpb25zID0geyAuLi5kaW1lbnNpb25zIH07XG5cbiAgICAgICAgZWFjaChcbiAgICAgICAgZGltZW5zaW9ucyxcbiAgICAgICAgKF8sIHByb3ApID0+XG4gICAgICAgIGRpbWVuc2lvbnMgPVxuICAgICAgICBkaW1lbnNpb25zW3Byb3BdID4gbWF4RGltZW5zaW9uc1twcm9wXSA/XG4gICAgICAgIHRoaXMucmF0aW8oZGltZW5zaW9ucywgcHJvcCwgbWF4RGltZW5zaW9uc1twcm9wXSkgOlxuICAgICAgICBkaW1lbnNpb25zKTtcblxuXG4gICAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuICAgICAgfSxcblxuICAgICAgY292ZXIoZGltZW5zaW9ucywgbWF4RGltZW5zaW9ucykge1xuICAgICAgICBkaW1lbnNpb25zID0gdGhpcy5jb250YWluKGRpbWVuc2lvbnMsIG1heERpbWVuc2lvbnMpO1xuXG4gICAgICAgIGVhY2goXG4gICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgIChfLCBwcm9wKSA9PlxuICAgICAgICBkaW1lbnNpb25zID1cbiAgICAgICAgZGltZW5zaW9uc1twcm9wXSA8IG1heERpbWVuc2lvbnNbcHJvcF0gP1xuICAgICAgICB0aGlzLnJhdGlvKGRpbWVuc2lvbnMsIHByb3AsIG1heERpbWVuc2lvbnNbcHJvcF0pIDpcbiAgICAgICAgZGltZW5zaW9ucyk7XG5cblxuICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICAgIH0gfTtcblxuXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoaSwgZWxlbWVudHMsIGN1cnJlbnQsIGZpbml0ZSkge2lmIChjdXJyZW50ID09PSB2b2lkIDApIHtjdXJyZW50ID0gMDt9aWYgKGZpbml0ZSA9PT0gdm9pZCAwKSB7ZmluaXRlID0gZmFsc2U7fVxuICAgICAgZWxlbWVudHMgPSB0b05vZGVzKGVsZW1lbnRzKTtcblxuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IGVsZW1lbnRzO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGkgPSBpc051bWVyaWMoaSkgP1xuICAgICAgdG9OdW1iZXIoaSkgOlxuICAgICAgaSA9PT0gJ25leHQnID9cbiAgICAgIGN1cnJlbnQgKyAxIDpcbiAgICAgIGkgPT09ICdwcmV2aW91cycgP1xuICAgICAgY3VycmVudCAtIDEgOlxuICAgICAgZWxlbWVudHMuaW5kZXhPZih0b05vZGUoaSkpO1xuXG4gICAgICBpZiAoZmluaXRlKSB7XG4gICAgICAgIHJldHVybiBjbGFtcChpLCAwLCBsZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgaSAlPSBsZW5ndGg7XG5cbiAgICAgIHJldHVybiBpIDwgMCA/IGkgKyBsZW5ndGggOiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiAoa2V5KSA9PiBjYWNoZVtrZXldIHx8IChjYWNoZVtrZXldID0gZm4oa2V5KSk7XG4gICAgfVxuXG4gICAgY2xhc3MgRGVmZXJyZWQge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgIH19XG5cbiAgICBmdW5jdGlvbiBhdHRyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZSkge1xuICAgICAgICAgIGF0dHIoZWxlbWVudCwga2V5LCBuYW1lW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge3ZhciBfdG9Ob2RlO1xuICAgICAgICByZXR1cm4gKF90b05vZGUgPSB0b05vZGUoZWxlbWVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfdG9Ob2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgdG9Ob2RlcyhlbGVtZW50KSkge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKGVsLCBhdHRyKGVsLCBuYW1lKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBdHRyKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQpID0+IGVsZW1lbnQuaGFzQXR0cmlidXRlKG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVBdHRyKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gdG9Ob2RlcyhlbGVtZW50KTtcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIG5hbWUuc3BsaXQoJyAnKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF0YShlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBbYXR0cmlidXRlLCBcImRhdGEtXCIgKyBhdHRyaWJ1dGVdKSB7XG4gICAgICAgIGlmIChoYXNBdHRyKGVsZW1lbnQsIG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHIoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2b2lkRWxlbWVudHMgPSB7XG4gICAgICBhcmVhOiB0cnVlLFxuICAgICAgYmFzZTogdHJ1ZSxcbiAgICAgIGJyOiB0cnVlLFxuICAgICAgY29sOiB0cnVlLFxuICAgICAgZW1iZWQ6IHRydWUsXG4gICAgICBocjogdHJ1ZSxcbiAgICAgIGltZzogdHJ1ZSxcbiAgICAgIGlucHV0OiB0cnVlLFxuICAgICAga2V5Z2VuOiB0cnVlLFxuICAgICAgbGluazogdHJ1ZSxcbiAgICAgIG1lbnVpdGVtOiB0cnVlLFxuICAgICAgbWV0YTogdHJ1ZSxcbiAgICAgIHBhcmFtOiB0cnVlLFxuICAgICAgc291cmNlOiB0cnVlLFxuICAgICAgdHJhY2s6IHRydWUsXG4gICAgICB3YnI6IHRydWUgfTtcblxuICAgIGZ1bmN0aW9uIGlzVm9pZEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZSgoZWxlbWVudCkgPT4gdm9pZEVsZW1lbnRzW2VsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWaXNpYmxlKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoXG4gICAgICAoZWxlbWVudCkgPT4gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcblxuICAgIH1cblxuICAgIGNvbnN0IHNlbElucHV0ID0gJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYSxidXR0b24nO1xuICAgIGZ1bmN0aW9uIGlzSW5wdXQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZSgoZWxlbWVudCkgPT4gbWF0Y2hlcyhlbGVtZW50LCBzZWxJbnB1dCkpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbEZvY3VzYWJsZSA9IHNlbElucHV0ICsgXCIsYVtocmVmXSxbdGFiaW5kZXhdXCI7XG4gICAgZnVuY3Rpb24gaXNGb2N1c2FibGUoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG1hdGNoZXMoZWxlbWVudCwgc2VsRm9jdXNhYmxlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJlbnQoZWxlbWVudCkge3ZhciBfdG9Ob2RlO1xuICAgICAgcmV0dXJuIChfdG9Ob2RlID0gdG9Ob2RlKGVsZW1lbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RvTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlciQxKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5maWx0ZXIoKGVsZW1lbnQpID0+IG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKChlbGVtZW50KSA9PiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc3RhcnRzV2l0aChzZWxlY3RvciwgJz4nKSkge1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNFbGVtZW50KGVsZW1lbnQpID9cbiAgICAgIGVsZW1lbnQuY2xvc2VzdChzZWxlY3RvcikgOlxuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5cbiAgICAgIG1hcCgoZWxlbWVudCkgPT4gY2xvc2VzdChlbGVtZW50LCBzZWxlY3RvcikpLlxuICAgICAgZmlsdGVyKEJvb2xlYW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhpbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKHNlbGVjdG9yKSA/XG4gICAgICBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB8fCAhIWNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIDpcbiAgICAgIGVsZW1lbnQgPT09IHNlbGVjdG9yIHx8IHRvTm9kZShzZWxlY3RvcikuY29udGFpbnModG9Ob2RlKGVsZW1lbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgICB3aGlsZSAoZWxlbWVudCA9IHBhcmVudChlbGVtZW50KSkge1xuICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGVsZW1lbnQgPSB0b05vZGUoZWxlbWVudCk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGVsZW1lbnQgPyB0b05vZGVzKGVsZW1lbnQuY2hpbGRyZW4pIDogW107XG4gICAgICByZXR1cm4gc2VsZWN0b3IgPyBmaWx0ZXIkMShjaGlsZHJlbiwgc2VsZWN0b3IpIDogY2hpbGRyZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZXgoZWxlbWVudCwgcmVmKSB7XG4gICAgICByZXR1cm4gcmVmID8gdG9Ob2RlcyhlbGVtZW50KS5pbmRleE9mKHRvTm9kZShyZWYpKSA6IGNoaWxkcmVuKHBhcmVudChlbGVtZW50KSkuaW5kZXhPZihlbGVtZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWVyeShzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGZpbmQoc2VsZWN0b3IsIGdldENvbnRleHQoc2VsZWN0b3IsIGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWVyeUFsbChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGZpbmRBbGwoc2VsZWN0b3IsIGdldENvbnRleHQoc2VsZWN0b3IsIGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlKF9xdWVyeShzZWxlY3RvciwgY29udGV4dCwgJ3F1ZXJ5U2VsZWN0b3InKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZEFsbChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoX3F1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0LCAncXVlcnlTZWxlY3RvckFsbCcpKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0U2VsZWN0b3JSZSA9IC8oXnxbXlxcXFxdLClcXHMqWyE+K34tXS87XG4gICAgY29uc3QgaXNDb250ZXh0U2VsZWN0b3IgPSBtZW1vaXplKChzZWxlY3RvcikgPT4gc2VsZWN0b3IubWF0Y2goY29udGV4dFNlbGVjdG9yUmUpKTtcblxuICAgIGZ1bmN0aW9uIGdldENvbnRleHQoc2VsZWN0b3IsIGNvbnRleHQpIHtpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7Y29udGV4dCA9IGRvY3VtZW50O31cbiAgICAgIHJldHVybiBpc1N0cmluZyhzZWxlY3RvcikgJiYgaXNDb250ZXh0U2VsZWN0b3Ioc2VsZWN0b3IpIHx8IGlzRG9jdW1lbnQoY29udGV4dCkgP1xuICAgICAgY29udGV4dCA6XG4gICAgICBjb250ZXh0Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dFNhbml0aXplUmUgPSAvKFshPit+LV0pKD89XFxzK1shPit+LV18XFxzKiQpL2c7XG4gICAgY29uc3Qgc2FuYXRpemUgPSBtZW1vaXplKChzZWxlY3RvcikgPT4gc2VsZWN0b3IucmVwbGFjZShjb250ZXh0U2FuaXRpemVSZSwgJyQxIConKSk7XG5cbiAgICBmdW5jdGlvbiBfcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQsIHF1ZXJ5Rm4pIHtpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7Y29udGV4dCA9IGRvY3VtZW50O31cbiAgICAgIGlmICghc2VsZWN0b3IgfHwgIWlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdG9yID0gc2FuYXRpemUoc2VsZWN0b3IpO1xuXG4gICAgICBpZiAoaXNDb250ZXh0U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHNlbGVjdG9yID0gJyc7XG4gICAgICAgIGZvciAobGV0IHNlbCBvZiBzcGxpdCkge1xuICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0O1xuXG4gICAgICAgICAgaWYgKHNlbFswXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvcnMgPSBzZWwuc3Vic3RyKDEpLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgY3R4ID0gY2xvc2VzdChwYXJlbnQoY29udGV4dCksIHNlbGVjdG9yc1swXSk7XG4gICAgICAgICAgICBzZWwgPSBzZWxlY3RvcnMuc2xpY2UoMSkuam9pbignICcpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghc2VsLmxlbmd0aCAmJiBzcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsWzBdID09PSAnLScpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHNlbC5zdWJzdHIoMSkudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gKGN0eCB8fCBjb250ZXh0KS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgY3R4ID0gbWF0Y2hlcyhwcmV2LCBzZWwuc3Vic3RyKDEpKSA/IHByZXYgOiBudWxsO1xuICAgICAgICAgICAgc2VsID0gc2VsZWN0b3JzLnNsaWNlKDEpLmpvaW4oJyAnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBzZWxlY3RvciArPSBcIlwiICsgKHNlbGVjdG9yID8gJywnIDogJycpICsgZG9tUGF0aChjdHgpICsgXCIgXCIgKyBzZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dCA9IGRvY3VtZW50O1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29udGV4dFtxdWVyeUZuXShzZWxlY3Rvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdG9yUmUgPSAvLio/W15cXFxcXSg/Oix8JCkvZztcblxuICAgIGNvbnN0IHNwbGl0U2VsZWN0b3IgPSBtZW1vaXplKChzZWxlY3RvcikgPT5cbiAgICBzZWxlY3Rvci5tYXRjaChzZWxlY3RvclJlKS5tYXAoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5yZXBsYWNlKC8sJC8sICcnKS50cmltKCkpKTtcblxuXG4gICAgZnVuY3Rpb24gZG9tUGF0aChlbGVtZW50KSB7XG4gICAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb25zdCBpZCA9IGF0dHIoZWxlbWVudCwgJ2lkJyk7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIG5hbWVzLnVuc2hpZnQoXCIjXCIgKyBlc2NhcGUoaWQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgeyB0YWdOYW1lIH0gPSBlbGVtZW50O1xuICAgICAgICAgIGlmICh0YWdOYW1lICE9PSAnSFRNTCcpIHtcbiAgICAgICAgICAgIHRhZ05hbWUgKz0gXCI6bnRoLWNoaWxkKFwiICsgKGluZGV4KGVsZW1lbnQpICsgMSkgKyBcIilcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFtZXMudW5zaGlmdCh0YWdOYW1lKTtcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZXMuam9pbignID4gJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlKGNzcykge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNzcykgPyBDU1MuZXNjYXBlKGNzcykgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbigpIHtmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHthcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO31cbiAgICAgIGxldCBbdGFyZ2V0cywgdHlwZXMsIHNlbGVjdG9yLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSA9IGZhbHNlXSA9IGdldEFyZ3MoYXJncyk7XG5cbiAgICAgIGlmIChsaXN0ZW5lci5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxpc3RlbmVyID0gZGV0YWlsKGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZUNhcHR1cmUgIT0gbnVsbCAmJiB1c2VDYXB0dXJlLnNlbGYpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBzZWxmRmlsdGVyKGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGxpc3RlbmVyID0gZGVsZWdhdGUoc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgpID0+IG9mZih0YXJnZXRzLCB0eXBlcywgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZigpIHtmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHthcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07fVxuICAgICAgbGV0IFt0YXJnZXRzLCB0eXBlcywsIGxpc3RlbmVyLCB1c2VDYXB0dXJlID0gZmFsc2VdID0gZ2V0QXJncyhhcmdzKTtcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25jZSgpIHtmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHthcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107fVxuICAgICAgY29uc3QgW2VsZW1lbnQsIHR5cGVzLCBzZWxlY3RvciwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZSwgY29uZGl0aW9uXSA9IGdldEFyZ3MoYXJncyk7XG4gICAgICBjb25zdCBvZmYgPSBvbihcbiAgICAgIGVsZW1lbnQsXG4gICAgICB0eXBlcyxcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gIWNvbmRpdGlvbiB8fCBjb25kaXRpb24oZSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBvZmYoKTtcbiAgICAgICAgICBsaXN0ZW5lcihlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlQ2FwdHVyZSk7XG5cblxuICAgICAgcmV0dXJuIG9mZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyKHRhcmdldHMsIGV2ZW50LCBkZXRhaWwpIHtcbiAgICAgIHJldHVybiB0b0V2ZW50VGFyZ2V0cyh0YXJnZXRzKS5ldmVyeSgodGFyZ2V0KSA9PlxuICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoZXZlbnQsIHRydWUsIHRydWUsIGRldGFpbCkpKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCkge2lmIChidWJibGVzID09PSB2b2lkIDApIHtidWJibGVzID0gdHJ1ZTt9aWYgKGNhbmNlbGFibGUgPT09IHZvaWQgMCkge2NhbmNlbGFibGUgPSBmYWxzZTt9XG4gICAgICBpZiAoaXNTdHJpbmcoZSkpIHtcbiAgICAgICAgZSA9IG5ldyBDdXN0b21FdmVudChlLCB7IGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXJncyhhcmdzKSB7XG4gICAgICAvLyBFdmVudCB0YXJnZXRzXG4gICAgICBhcmdzWzBdID0gdG9FdmVudFRhcmdldHMoYXJnc1swXSk7XG5cbiAgICAgIC8vIEV2ZW50IHR5cGVzXG4gICAgICBpZiAoaXNTdHJpbmcoYXJnc1sxXSkpIHtcbiAgICAgICAgYXJnc1sxXSA9IGFyZ3NbMV0uc3BsaXQoJyAnKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVsZWdhdGU/XG4gICAgICBpZiAoaXNGdW5jdGlvbihhcmdzWzJdKSkge1xuICAgICAgICBhcmdzLnNwbGljZSgyLCAwLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGVnYXRlKHNlbGVjdG9yLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPVxuICAgICAgICBzZWxlY3RvclswXSA9PT0gJz4nID9cbiAgICAgICAgZmluZEFsbChzZWxlY3RvciwgZS5jdXJyZW50VGFyZ2V0KS5cbiAgICAgICAgcmV2ZXJzZSgpLlxuICAgICAgICBmaWx0ZXIoKGVsZW1lbnQpID0+IHdpdGhpbihlLnRhcmdldCwgZWxlbWVudCkpWzBdIDpcbiAgICAgICAgY2xvc2VzdChlLnRhcmdldCwgc2VsZWN0b3IpO1xuXG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgZS5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGFpbChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIChlKSA9PiBpc0FycmF5KGUuZGV0YWlsKSA/IGxpc3RlbmVyKGUsIC4uLmUuZGV0YWlsKSA6IGxpc3RlbmVyKGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGZGaWx0ZXIobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fCBlLnRhcmdldCA9PT0gZS5jdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmNhbGwobnVsbCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFdmVudFRhcmdldCh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0YXJnZXQgJiYgJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0V2ZW50VGFyZ2V0KHRhcmdldCkge1xuICAgICAgcmV0dXJuIGlzRXZlbnRUYXJnZXQodGFyZ2V0KSA/IHRhcmdldCA6IHRvTm9kZSh0YXJnZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRXZlbnRUYXJnZXRzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodGFyZ2V0KSA/XG4gICAgICB0YXJnZXQubWFwKHRvRXZlbnRUYXJnZXQpLmZpbHRlcihCb29sZWFuKSA6XG4gICAgICBpc1N0cmluZyh0YXJnZXQpID9cbiAgICAgIGZpbmRBbGwodGFyZ2V0KSA6XG4gICAgICBpc0V2ZW50VGFyZ2V0KHRhcmdldCkgP1xuICAgICAgW3RhcmdldF0gOlxuICAgICAgdG9Ob2Rlcyh0YXJnZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVG91Y2goZSkge1xuICAgICAgcmV0dXJuIGUucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgfHwgISFlLnRvdWNoZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRQb3MoZSkge3ZhciBfZSR0b3VjaGVzLCBfZSRjaGFuZ2VkVG91Y2hlcztcbiAgICAgIGNvbnN0IHsgY2xpZW50WDogeCwgY2xpZW50WTogeSB9ID0gKChfZSR0b3VjaGVzID0gZS50b3VjaGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2UkdG91Y2hlc1swXSkgfHwgKChfZSRjaGFuZ2VkVG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXMpID09IG51bGwgPyB2b2lkIDAgOiBfZSRjaGFuZ2VkVG91Y2hlc1swXSkgfHwgZTtcblxuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFqYXgodXJsLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBlbnYgPSB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICB4aHI6IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBiZWZvcmVTZW5kOiBub29wLFxuICAgICAgICByZXNwb25zZVR5cGU6ICcnLFxuICAgICAgICAuLi5vcHRpb25zIH07XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS5cbiAgICAgIHRoZW4oKCkgPT4gZW52LmJlZm9yZVNlbmQoZW52KSkuXG4gICAgICB0aGVuKCgpID0+IHNlbmQodXJsLCBlbnYpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZW5kKHVybCwgZW52KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB7IHhociB9ID0gZW52O1xuXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBlbnYpIHtcbiAgICAgICAgICBpZiAocHJvcCBpbiB4aHIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHhocltwcm9wXSA9IGVudltwcm9wXTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHhoci5vcGVuKGVudi5tZXRob2QudG9VcHBlckNhc2UoKSwgdXJsKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBlbnYuaGVhZGVycykge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgZW52LmhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBvbih4aHIsICdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAwIHx8IHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAgICAgICByZXNvbHZlKHhocik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIGFzc2lnbihFcnJvcih4aHIuc3RhdHVzVGV4dCksIHtcbiAgICAgICAgICAgICAgeGhyLFxuICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMgfSkpO1xuXG5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9uKHhociwgJ2Vycm9yJywgKCkgPT4gcmVqZWN0KGFzc2lnbihFcnJvcignTmV0d29yayBFcnJvcicpLCB7IHhociB9KSkpO1xuICAgICAgICBvbih4aHIsICd0aW1lb3V0JywgKCkgPT4gcmVqZWN0KGFzc2lnbihFcnJvcignTmV0d29yayBUaW1lb3V0JyksIHsgeGhyIH0pKSk7XG5cbiAgICAgICAgeGhyLnNlbmQoZW52LmRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW1hZ2Uoc3JjLCBzcmNzZXQsIHNpemVzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzaXplcyAmJiAoaW1nLnNpemVzID0gc2l6ZXMpO1xuICAgICAgICBzcmNzZXQgJiYgKGltZy5zcmNzZXQgPSBzcmNzZXQpO1xuICAgICAgICBpbWcuc3JjID0gc3JjO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3NzTnVtYmVyID0ge1xuICAgICAgJ2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQnOiB0cnVlLFxuICAgICAgJ2NvbHVtbi1jb3VudCc6IHRydWUsXG4gICAgICAnZmlsbC1vcGFjaXR5JzogdHJ1ZSxcbiAgICAgICdmbGV4LWdyb3cnOiB0cnVlLFxuICAgICAgJ2ZsZXgtc2hyaW5rJzogdHJ1ZSxcbiAgICAgICdmb250LXdlaWdodCc6IHRydWUsXG4gICAgICAnbGluZS1oZWlnaHQnOiB0cnVlLFxuICAgICAgb3BhY2l0eTogdHJ1ZSxcbiAgICAgIG9yZGVyOiB0cnVlLFxuICAgICAgb3JwaGFuczogdHJ1ZSxcbiAgICAgICdzdHJva2UtZGFzaGFycmF5JzogdHJ1ZSxcbiAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6IHRydWUsXG4gICAgICB3aWRvd3M6IHRydWUsXG4gICAgICAnei1pbmRleCc6IHRydWUsXG4gICAgICB6b29tOiB0cnVlIH07XG5cblxuICAgIGZ1bmN0aW9uIGNzcyhlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5KSB7aWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHtwcmlvcml0eSA9ICcnO31cbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gdG9Ob2RlcyhlbGVtZW50KTtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBpZiAoaXNTdHJpbmcocHJvcGVydHkpKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBwcm9wTmFtZShwcm9wZXJ0eSk7XG5cbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgaXNOdW1lcmljKHZhbHVlKSAmJiAhY3NzTnVtYmVyW3Byb3BlcnR5XSA/XG4gICAgICAgICAgICB2YWx1ZSArIFwicHhcIiA6XG4gICAgICAgICAgICB2YWx1ZSB8fCBpc051bWJlcih2YWx1ZSkgP1xuICAgICAgICAgICAgdmFsdWUgOlxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBwcmlvcml0eSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcHJvcHNbcHJvcF0gPSBjc3MoZWxlbWVudCwgcHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9wcztcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBwcmlvcml0eSA9IHZhbHVlO1xuICAgICAgICAgIGVhY2gocHJvcGVydHksICh2YWx1ZSwgcHJvcGVydHkpID0+IGNzcyhlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50c1swXTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wZXJ0eVJlID0gL15cXHMqKFtcIiddKT8oLio/KVxcMVxccyokLztcbiAgICBmdW5jdGlvbiBnZXRDc3NWYXIobmFtZSwgZWxlbWVudCkge2lmIChlbGVtZW50ID09PSB2b2lkIDApIHtlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O31cbiAgICAgIHJldHVybiBjc3MoZWxlbWVudCwgXCItLXVrLVwiICsgbmFtZSkucmVwbGFjZShwcm9wZXJ0eVJlLCAnJDInKTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2RvbS1jc3NzdHlsZWRlY2xhcmF0aW9uLXNldHByb3BlcnR5XG4gICAgY29uc3QgcHJvcE5hbWUgPSBtZW1vaXplKChuYW1lKSA9PiB2ZW5kb3JQcm9wTmFtZShuYW1lKSk7XG5cbiAgICBjb25zdCBjc3NQcmVmaXhlcyA9IFsnd2Via2l0JywgJ21veiddO1xuXG4gICAgZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUobmFtZSkge1xuICAgICAgaWYgKG5hbWVbMF0gPT09ICctJykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cblxuICAgICAgbmFtZSA9IGh5cGhlbmF0ZShuYW1lKTtcblxuICAgICAgY29uc3QgeyBzdHlsZSB9ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICBpZiAobmFtZSBpbiBzdHlsZSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBjc3NQcmVmaXhlcy5sZW5ndGgsXG4gICAgICBwcmVmaXhlZE5hbWU7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcHJlZml4ZWROYW1lID0gXCItXCIgKyBjc3NQcmVmaXhlc1tpXSArIFwiLVwiICsgbmFtZTtcbiAgICAgICAgaWYgKHByZWZpeGVkTmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXhlZE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50KSB7Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge2FyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO31cbiAgICAgIGFwcGx5JDEoZWxlbWVudCwgYXJncywgJ2FkZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQpIHtmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge2FyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07fVxuICAgICAgYXBwbHkkMShlbGVtZW50LCBhcmdzLCAncmVtb3ZlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhlbGVtZW50LCBjbHMpIHtcbiAgICAgIGF0dHIoZWxlbWVudCwgJ2NsYXNzJywgKHZhbHVlKSA9PiAodmFsdWUgfHwgJycpLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxiXCIgKyBjbHMgKyBcIlxcXFxiXCIsICdnJyksICcnKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUNsYXNzKGVsZW1lbnQpIHtcbiAgICAgIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0pICYmIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSk7XG4gICAgICAoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKSAmJiBhZGRDbGFzcyhlbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNscykge1xuICAgICAgW2Nsc10gPSBnZXRDbGFzc2VzKGNscyk7XG4gICAgICByZXR1cm4gISFjbHMgJiYgdG9Ob2RlcyhlbGVtZW50KS5zb21lKChub2RlKSA9PiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbHMsIGZvcmNlKSB7XG4gICAgICBjb25zdCBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhjbHMpO1xuXG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKGZvcmNlKSkge1xuICAgICAgICBmb3JjZSA9ICEhZm9yY2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0b05vZGVzKGVsZW1lbnQpKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2xzIG9mIGNsYXNzZXMpIHtcbiAgICAgICAgICBub2RlLmNsYXNzTGlzdC50b2dnbGUoY2xzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseSQxKGVsZW1lbnQsIGFyZ3MsIGZuKSB7XG4gICAgICBhcmdzID0gYXJncy5yZWR1Y2UoKGFyZ3MsIGFyZykgPT4gYXJncy5jb25jYXQoZ2V0Q2xhc3NlcyhhcmcpKSwgW10pO1xuXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdG9Ob2RlcyhlbGVtZW50KSkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdFtmbl0oLi4uYXJncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2xhc3NlcyhzdHIpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5zcGxpdCgvXFxzfCwvKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbihlbGVtZW50LCBwcm9wcywgZHVyYXRpb24sIHRpbWluZykge2lmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7ZHVyYXRpb24gPSA0MDA7fWlmICh0aW1pbmcgPT09IHZvaWQgMCkge3RpbWluZyA9ICdsaW5lYXInO31cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKFxuICAgICAgKGVsZW1lbnQpID0+XG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3NzKGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGNzcyhlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRyaWdnZXIoZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnKSwgZHVyYXRpb24pO1xuXG4gICAgICAgIG9uY2UoXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgICd0cmFuc2l0aW9uZW5kIHRyYW5zaXRpb25jYW5jZWxlZCcsXG4gICAgICAgIChfcmVmKSA9PiB7bGV0IHsgdHlwZSB9ID0gX3JlZjtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsICd1ay10cmFuc2l0aW9uJyk7XG4gICAgICAgICAgY3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogJycsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAnJyB9KTtcblxuICAgICAgICAgIHR5cGUgPT09ICd0cmFuc2l0aW9uY2FuY2VsZWQnID8gcmVqZWN0KCkgOiByZXNvbHZlKGVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICB7IHNlbGY6IHRydWUgfSk7XG5cblxuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCAndWstdHJhbnNpdGlvbicpO1xuICAgICAgICBjc3MoZWxlbWVudCwge1xuICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMocHJvcHMpLm1hcChwcm9wTmFtZSkuam9pbignLCcpLFxuICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogZHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiB0aW1pbmcsXG4gICAgICAgICAgLi4ucHJvcHMgfSk7XG5cbiAgICAgIH0pKSk7XG5cblxuICAgIH1cblxuICAgIGNvbnN0IFRyYW5zaXRpb24gPSB7XG4gICAgICBzdGFydDogdHJhbnNpdGlvbixcblxuICAgICAgc3RvcChlbGVtZW50KSB7XG4gICAgICAgIHRyaWdnZXIoZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfSxcblxuICAgICAgY2FuY2VsKGVsZW1lbnQpIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAndHJhbnNpdGlvbmNhbmNlbGVkJyk7XG4gICAgICB9LFxuXG4gICAgICBpblByb2dyZXNzKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGhhc0NsYXNzKGVsZW1lbnQsICd1ay10cmFuc2l0aW9uJyk7XG4gICAgICB9IH07XG5cblxuICAgIGNvbnN0IGFuaW1hdGlvblByZWZpeCA9ICd1ay1hbmltYXRpb24tJztcblxuICAgIGZ1bmN0aW9uIGFuaW1hdGUkMShlbGVtZW50LCBhbmltYXRpb24sIGR1cmF0aW9uLCBvcmlnaW4sIG91dCkge2lmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7ZHVyYXRpb24gPSAyMDA7fVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5tYXAoXG4gICAgICAoZWxlbWVudCkgPT5cbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAnYW5pbWF0aW9uY2FuY2VsZWQnKTtcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRyaWdnZXIoZWxlbWVudCwgJ2FuaW1hdGlvbmVuZCcpLCBkdXJhdGlvbik7XG5cbiAgICAgICAgb25jZShcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgJ2FuaW1hdGlvbmVuZCBhbmltYXRpb25jYW5jZWxlZCcsXG4gICAgICAgIChfcmVmMikgPT4ge2xldCB7IHR5cGUgfSA9IF9yZWYyO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgICAgICB0eXBlID09PSAnYW5pbWF0aW9uY2FuY2VsZWQnID8gcmVqZWN0KCkgOiByZXNvbHZlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgY3NzKGVsZW1lbnQsICdhbmltYXRpb25EdXJhdGlvbicsICcnKTtcbiAgICAgICAgICByZW1vdmVDbGFzc2VzKGVsZW1lbnQsIGFuaW1hdGlvblByZWZpeCArIFwiXFxcXFMqXCIpO1xuICAgICAgICB9LFxuICAgICAgICB7IHNlbGY6IHRydWUgfSk7XG5cblxuICAgICAgICBjc3MoZWxlbWVudCwgJ2FuaW1hdGlvbkR1cmF0aW9uJywgZHVyYXRpb24gKyBcIm1zXCIpO1xuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBhbmltYXRpb24sIGFuaW1hdGlvblByZWZpeCArIChvdXQgPyAnbGVhdmUnIDogJ2VudGVyJykpO1xuXG4gICAgICAgIGlmIChzdGFydHNXaXRoKGFuaW1hdGlvbiwgYW5pbWF0aW9uUHJlZml4KSkge1xuICAgICAgICAgIG9yaWdpbiAmJiBhZGRDbGFzcyhlbGVtZW50LCBcInVrLXRyYW5zZm9ybS1vcmlnaW4tXCIgKyBvcmlnaW4pO1xuICAgICAgICAgIG91dCAmJiBhZGRDbGFzcyhlbGVtZW50LCBhbmltYXRpb25QcmVmaXggKyBcInJldmVyc2VcIik7XG4gICAgICAgIH1cbiAgICAgIH0pKSk7XG5cblxuICAgIH1cblxuICAgIGNvbnN0IGluUHJvZ3Jlc3MgPSBuZXcgUmVnRXhwKGFuaW1hdGlvblByZWZpeCArIFwiKGVudGVyfGxlYXZlKVwiKTtcbiAgICBjb25zdCBBbmltYXRpb24gPSB7XG4gICAgICBpbjogYW5pbWF0ZSQxLFxuXG4gICAgICBvdXQoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRlJDEoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luLCB0cnVlKTtcbiAgICAgIH0sXG5cbiAgICAgIGluUHJvZ3Jlc3MoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaW5Qcm9ncmVzcy50ZXN0KGF0dHIoZWxlbWVudCwgJ2NsYXNzJykpO1xuICAgICAgfSxcblxuICAgICAgY2FuY2VsKGVsZW1lbnQpIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAnYW5pbWF0aW9uY2FuY2VsZWQnKTtcbiAgICAgIH0gfTtcblxuICAgIGNvbnN0IGRpcnMkMSA9IHtcbiAgICAgIHdpZHRoOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgIGhlaWdodDogWyd0b3AnLCAnYm90dG9tJ10gfTtcblxuXG4gICAgZnVuY3Rpb24gZGltZW5zaW9ucyQxKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBpc0VsZW1lbnQoZWxlbWVudCkgP1xuICAgICAgdG9Ob2RlKGVsZW1lbnQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDpcbiAgICAgIHsgaGVpZ2h0OiBoZWlnaHQoZWxlbWVudCksIHdpZHRoOiB3aWR0aChlbGVtZW50KSwgdG9wOiAwLCBsZWZ0OiAwIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgICAgIGJvdHRvbTogcmVjdC50b3AgKyByZWN0LmhlaWdodCxcbiAgICAgICAgcmlnaHQ6IHJlY3QubGVmdCArIHJlY3Qud2lkdGggfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldChlbGVtZW50LCBjb29yZGluYXRlcykge1xuICAgICAgY29uc3QgY3VycmVudE9mZnNldCA9IGRpbWVuc2lvbnMkMShlbGVtZW50KTtcblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxZLCBzY3JvbGxYIH0gPSB0b1dpbmRvdyhlbGVtZW50KTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0QnkgPSB7IGhlaWdodDogc2Nyb2xsWSwgd2lkdGg6IHNjcm9sbFggfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGRpciBpbiBkaXJzJDEpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgZGlycyQxW2Rpcl0pIHtcbiAgICAgICAgICAgIGN1cnJlbnRPZmZzZXRbcHJvcF0gKz0gb2Zmc2V0QnlbZGlyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY3VycmVudE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcG9zID0gY3NzKGVsZW1lbnQsICdwb3NpdGlvbicpO1xuXG4gICAgICBlYWNoKGNzcyhlbGVtZW50LCBbJ2xlZnQnLCAndG9wJ10pLCAodmFsdWUsIHByb3ApID0+XG4gICAgICBjc3MoXG4gICAgICBlbGVtZW50LFxuICAgICAgcHJvcCxcbiAgICAgIGNvb3JkaW5hdGVzW3Byb3BdIC1cbiAgICAgIGN1cnJlbnRPZmZzZXRbcHJvcF0gK1xuICAgICAgdG9GbG9hdChwb3MgPT09ICdhYnNvbHV0ZScgJiYgdmFsdWUgPT09ICdhdXRvJyA/IHBvc2l0aW9uKGVsZW1lbnQpW3Byb3BdIDogdmFsdWUpKSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGxldCB7IHRvcCwgbGVmdCB9ID0gb2Zmc2V0KGVsZW1lbnQpO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIG93bmVyRG9jdW1lbnQ6IHsgYm9keSwgZG9jdW1lbnRFbGVtZW50IH0sXG4gICAgICAgIG9mZnNldFBhcmVudCB9ID1cbiAgICAgIHRvTm9kZShlbGVtZW50KTtcbiAgICAgIGxldCBwYXJlbnQgPSBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICB3aGlsZSAoXG4gICAgICBwYXJlbnQgJiYgKFxuICAgICAgcGFyZW50ID09PSBib2R5IHx8IHBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50KSAmJlxuICAgICAgY3NzKHBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKVxuICAgICAge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWxlbWVudChwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE9mZnNldCA9IG9mZnNldChwYXJlbnQpO1xuICAgICAgICB0b3AgLT0gcGFyZW50T2Zmc2V0LnRvcCArIHRvRmxvYXQoY3NzKHBhcmVudCwgJ2JvcmRlclRvcFdpZHRoJykpO1xuICAgICAgICBsZWZ0IC09IHBhcmVudE9mZnNldC5sZWZ0ICsgdG9GbG9hdChjc3MocGFyZW50LCAnYm9yZGVyTGVmdFdpZHRoJykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcCAtIHRvRmxvYXQoY3NzKGVsZW1lbnQsICdtYXJnaW5Ub3AnKSksXG4gICAgICAgIGxlZnQ6IGxlZnQgLSB0b0Zsb2F0KGNzcyhlbGVtZW50LCAnbWFyZ2luTGVmdCcpKSB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0UG9zaXRpb24oZWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gWzAsIDBdO1xuXG4gICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG9mZnNldFswXSArPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgb2Zmc2V0WzFdICs9IGVsZW1lbnQub2Zmc2V0TGVmdDtcblxuICAgICAgICBpZiAoY3NzKGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgY29uc3Qgd2luID0gdG9XaW5kb3coZWxlbWVudCk7XG4gICAgICAgICAgb2Zmc2V0WzBdICs9IHdpbi5zY3JvbGxZO1xuICAgICAgICAgIG9mZnNldFsxXSArPSB3aW4uc2Nyb2xsWDtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQpO1xuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGNvbnN0IGhlaWdodCA9IGRpbWVuc2lvbignaGVpZ2h0Jyk7XG4gICAgY29uc3Qgd2lkdGggPSBkaW1lbnNpb24oJ3dpZHRoJyk7XG5cbiAgICBmdW5jdGlvbiBkaW1lbnNpb24ocHJvcCkge1xuICAgICAgY29uc3QgcHJvcE5hbWUgPSB1Y2ZpcnN0KHByb3ApO1xuICAgICAgcmV0dXJuIChlbGVtZW50LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFtcImlubmVyXCIgKyBwcm9wTmFtZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRG9jdW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGVsZW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGRvY1tcIm9mZnNldFwiICsgcHJvcE5hbWVdLCBkb2NbXCJzY3JvbGxcIiArIHByb3BOYW1lXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcblxuICAgICAgICAgIHZhbHVlID0gY3NzKGVsZW1lbnQsIHByb3ApO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICdhdXRvJyA/IGVsZW1lbnRbXCJvZmZzZXRcIiArIHByb3BOYW1lXSA6IHRvRmxvYXQodmFsdWUpIHx8IDA7XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgLSBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3NzKFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICAhdmFsdWUgJiYgdmFsdWUgIT09IDAgPyAnJyA6ICt2YWx1ZSArIGJveE1vZGVsQWRqdXN0KGVsZW1lbnQsIHByb3ApICsgJ3B4Jyk7XG5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wLCBzaXppbmcpIHtpZiAoc2l6aW5nID09PSB2b2lkIDApIHtzaXppbmcgPSAnYm9yZGVyLWJveCc7fVxuICAgICAgcmV0dXJuIGNzcyhlbGVtZW50LCAnYm94U2l6aW5nJykgPT09IHNpemluZyA/XG4gICAgICBkaXJzJDFbcHJvcF0uXG4gICAgICBtYXAodWNmaXJzdCkuXG4gICAgICByZWR1Y2UoXG4gICAgICAodmFsdWUsIHByb3ApID0+XG4gICAgICB2YWx1ZSArXG4gICAgICB0b0Zsb2F0KGNzcyhlbGVtZW50LCBcInBhZGRpbmdcIiArIHByb3ApKSArXG4gICAgICB0b0Zsb2F0KGNzcyhlbGVtZW50LCBcImJvcmRlclwiICsgcHJvcCArIFwiV2lkdGhcIikpLFxuICAgICAgMCkgOlxuXG4gICAgICAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsaXBQb3NpdGlvbihwb3MpIHtcbiAgICAgIGZvciAoY29uc3QgZGlyIGluIGRpcnMkMSkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gZGlycyQxW2Rpcl0pIHtcbiAgICAgICAgICBpZiAoZGlycyQxW2Rpcl1baV0gPT09IHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIGRpcnMkMVtkaXJdWzEgLSBpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9QeCh2YWx1ZSwgcHJvcGVydHksIGVsZW1lbnQsIG9mZnNldERpbSkge2lmIChwcm9wZXJ0eSA9PT0gdm9pZCAwKSB7cHJvcGVydHkgPSAnd2lkdGgnO31pZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7ZWxlbWVudCA9IHdpbmRvdzt9aWYgKG9mZnNldERpbSA9PT0gdm9pZCAwKSB7b2Zmc2V0RGltID0gZmFsc2U7fVxuICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRvRmxvYXQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VDYWxjKHZhbHVlKS5yZWR1Y2UoKHJlc3VsdCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdW5pdCA9IHBhcnNlVW5pdCh2YWx1ZSk7XG4gICAgICAgIGlmICh1bml0KSB7XG4gICAgICAgICAgdmFsdWUgPSBwZXJjZW50KFxuICAgICAgICAgIHVuaXQgPT09ICd2aCcgP1xuICAgICAgICAgIGhlaWdodCh0b1dpbmRvdyhlbGVtZW50KSkgOlxuICAgICAgICAgIHVuaXQgPT09ICd2dycgP1xuICAgICAgICAgIHdpZHRoKHRvV2luZG93KGVsZW1lbnQpKSA6XG4gICAgICAgICAgb2Zmc2V0RGltID9cbiAgICAgICAgICBlbGVtZW50W1wib2Zmc2V0XCIgKyB1Y2ZpcnN0KHByb3BlcnR5KV0gOlxuICAgICAgICAgIGRpbWVuc2lvbnMkMShlbGVtZW50KVtwcm9wZXJ0eV0sXG4gICAgICAgICAgdmFsdWUpO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgdG9GbG9hdCh2YWx1ZSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWxjUmUgPSAvLT9cXGQrKD86XFwuXFxkKyk/KD86dlt3aF18JXxweCk/L2c7XG4gICAgY29uc3QgcGFyc2VDYWxjID0gbWVtb2l6ZSgoY2FsYykgPT4gY2FsYy50b1N0cmluZygpLnJlcGxhY2UoL1xccy9nLCAnJykubWF0Y2goY2FsY1JlKSB8fCBbXSk7XG4gICAgY29uc3QgdW5pdFJlJDEgPSAvKD86dltod118JSkkLztcbiAgICBjb25zdCBwYXJzZVVuaXQgPSBtZW1vaXplKChzdHIpID0+IChzdHIubWF0Y2godW5pdFJlJDEpIHx8IFtdKVswXSk7XG5cbiAgICBmdW5jdGlvbiBwZXJjZW50KGJhc2UsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZSAqIHRvRmxvYXQodmFsdWUpIC8gMTAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWR5KGZuKSB7XG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb25jZShkb2N1bWVudCwgJ0RPTUNvbnRlbnRMb2FkZWQnLCBmbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNUYWcoZWxlbWVudCwgdGFnTmFtZSkge3ZhciBfZWxlbWVudCR0YWdOYW1lO1xuICAgICAgcmV0dXJuIChlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiAoX2VsZW1lbnQkdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JHRhZ05hbWUudG9Mb3dlckNhc2UoKSkgPT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbXB0eShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gcmVwbGFjZUNoaWxkcmVuKGVsZW1lbnQsICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodG1sKHBhcmVudCwgaHRtbCkge1xuICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGh0bWwpID8gJChwYXJlbnQpLmlubmVySFRNTCA6IHJlcGxhY2VDaGlsZHJlbihwYXJlbnQsIGh0bWwpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcGxhY2VDaGlsZHJlbiA9IGFwcGx5Rm4oJ3JlcGxhY2VDaGlsZHJlbicpO1xuICAgIGNvbnN0IHByZXBlbmQgPSBhcHBseUZuKCdwcmVwZW5kJyk7XG4gICAgY29uc3QgYXBwZW5kID0gYXBwbHlGbignYXBwZW5kJyk7XG4gICAgY29uc3QgYmVmb3JlID0gYXBwbHlGbignYmVmb3JlJyk7XG4gICAgY29uc3QgYWZ0ZXIgPSBhcHBseUZuKCdhZnRlcicpO1xuXG4gICAgZnVuY3Rpb24gYXBwbHlGbihmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZWYsIGVsZW1lbnQpIHt2YXIgXyQ7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdG9Ob2Rlcyhpc1N0cmluZyhlbGVtZW50KSA/IGZyYWdtZW50KGVsZW1lbnQpIDogZWxlbWVudCk7XG4gICAgICAgIChfJCA9ICQocmVmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF8kW2ZuXSguLi5ub2Rlcyk7XG4gICAgICAgIHJldHVybiB1bndyYXBTaW5nbGUobm9kZXMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUkMShlbGVtZW50KSB7XG4gICAgICB0b05vZGVzKGVsZW1lbnQpLmZvckVhY2goKGVsZW1lbnQpID0+IGVsZW1lbnQucmVtb3ZlKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBBbGwoZWxlbWVudCwgc3RydWN0dXJlKSB7XG4gICAgICBzdHJ1Y3R1cmUgPSB0b05vZGUoYmVmb3JlKGVsZW1lbnQsIHN0cnVjdHVyZSkpO1xuXG4gICAgICB3aGlsZSAoc3RydWN0dXJlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgc3RydWN0dXJlID0gc3RydWN0dXJlLmZpcnN0Q2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZChzdHJ1Y3R1cmUsIGVsZW1lbnQpO1xuXG4gICAgICByZXR1cm4gc3RydWN0dXJlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBJbm5lcihlbGVtZW50LCBzdHJ1Y3R1cmUpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKFxuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5tYXAoKGVsZW1lbnQpID0+XG4gICAgICBlbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSA/XG4gICAgICB3cmFwQWxsKHRvTm9kZXMoZWxlbWVudC5jaGlsZE5vZGVzKSwgc3RydWN0dXJlKSA6XG4gICAgICBhcHBlbmQoZWxlbWVudCwgc3RydWN0dXJlKSkpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bndyYXAoZWxlbWVudCkge1xuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5cbiAgICAgIG1hcChwYXJlbnQpLlxuICAgICAgZmlsdGVyKCh2YWx1ZSwgaW5kZXgsIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4KS5cbiAgICAgIGZvckVhY2goKHBhcmVudCkgPT4gcGFyZW50LnJlcGxhY2VXaXRoKC4uLnBhcmVudC5jaGlsZE5vZGVzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZnJhZ21lbnRSZSA9IC9eXFxzKjwoXFx3K3whKVtePl0qPi87XG4gICAgY29uc3Qgc2luZ2xlVGFnUmUgPSAvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPik/JC87XG5cbiAgICBmdW5jdGlvbiBmcmFnbWVudChodG1sKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gc2luZ2xlVGFnUmUuZXhlYyhodG1sKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG1hdGNoZXNbMV0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGlmIChmcmFnbWVudFJlLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgaHRtbC50cmltKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gaHRtbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZShjb250YWluZXIuY2hpbGROb2Rlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW53cmFwU2luZ2xlKG5vZGVzKSB7XG4gICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMSA/IG5vZGVzIDogbm9kZXNbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkobm9kZSwgZm4pIHtcbiAgICAgIGlmICghaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm4obm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgYXBwbHkobm9kZSwgZm4pO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gaXNIdG1sKHNlbGVjdG9yKSA/IHRvTm9kZShmcmFnbWVudChzZWxlY3RvcikpIDogZmluZChzZWxlY3RvciwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBpc0h0bWwoc2VsZWN0b3IpID8gdG9Ob2RlcyhmcmFnbWVudChzZWxlY3RvcikpIDogZmluZEFsbChzZWxlY3RvciwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIdG1sKHN0cikge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKHN0cikgJiYgc3RhcnRzV2l0aChzdHIudHJpbSgpLCAnPCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgIGNvbnN0IGlzUnRsID0gaW5Ccm93c2VyICYmIGF0dHIoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnZGlyJykgPT09ICdydGwnO1xuXG4gICAgY29uc3QgaGFzVG91Y2ggPSBpbkJyb3dzZXIgJiYgJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuICAgIGNvbnN0IGhhc1BvaW50ZXJFdmVudHMgPSBpbkJyb3dzZXIgJiYgd2luZG93LlBvaW50ZXJFdmVudDtcblxuICAgIGNvbnN0IHBvaW50ZXJEb3duID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVyZG93bicgOiBoYXNUb3VjaCA/ICd0b3VjaHN0YXJ0JyA6ICdtb3VzZWRvd24nO1xuICAgIGNvbnN0IHBvaW50ZXJNb3ZlID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVybW92ZScgOiBoYXNUb3VjaCA/ICd0b3VjaG1vdmUnIDogJ21vdXNlbW92ZSc7XG4gICAgY29uc3QgcG9pbnRlclVwID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVydXAnIDogaGFzVG91Y2ggPyAndG91Y2hlbmQnIDogJ21vdXNldXAnO1xuICAgIGNvbnN0IHBvaW50ZXJFbnRlciA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcmVudGVyJyA6IGhhc1RvdWNoID8gJycgOiAnbW91c2VlbnRlcic7XG4gICAgY29uc3QgcG9pbnRlckxlYXZlID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVybGVhdmUnIDogaGFzVG91Y2ggPyAnJyA6ICdtb3VzZWxlYXZlJztcbiAgICBjb25zdCBwb2ludGVyQ2FuY2VsID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVyY2FuY2VsJyA6ICd0b3VjaGNhbmNlbCc7XG5cbiAgICAvKlxuICAgICAgICBCYXNlZCBvbjpcbiAgICAgICAgQ29weXJpZ2h0IChjKSAyMDE2IFdpbHNvbiBQYWdlIHdpbHNvbnBhZ2VAbWUuY29tXG4gICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS93aWxzb25wYWdlL2Zhc3Rkb21cbiAgICAqL1xuXG4gICAgY29uc3QgZmFzdGRvbSA9IHtcbiAgICAgIHJlYWRzOiBbXSxcbiAgICAgIHdyaXRlczogW10sXG5cbiAgICAgIHJlYWQodGFzaykge1xuICAgICAgICB0aGlzLnJlYWRzLnB1c2godGFzayk7XG4gICAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICB9LFxuXG4gICAgICB3cml0ZSh0YXNrKSB7XG4gICAgICAgIHRoaXMud3JpdGVzLnB1c2godGFzayk7XG4gICAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICB9LFxuXG4gICAgICBjbGVhcih0YXNrKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLnJlYWRzLCB0YXNrKTtcbiAgICAgICAgcmVtb3ZlKHRoaXMud3JpdGVzLCB0YXNrKTtcbiAgICAgIH0sXG5cbiAgICAgIGZsdXNoIH07XG5cblxuICAgIGZ1bmN0aW9uIGZsdXNoKHJlY3Vyc2lvbikge1xuICAgICAgcnVuVGFza3MoZmFzdGRvbS5yZWFkcyk7XG4gICAgICBydW5UYXNrcyhmYXN0ZG9tLndyaXRlcy5zcGxpY2UoMCkpO1xuXG4gICAgICBmYXN0ZG9tLnNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZmFzdGRvbS5yZWFkcy5sZW5ndGggfHwgZmFzdGRvbS53cml0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHNjaGVkdWxlRmx1c2gocmVjdXJzaW9uICsgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gNDtcbiAgICBmdW5jdGlvbiBzY2hlZHVsZUZsdXNoKHJlY3Vyc2lvbikge1xuICAgICAgaWYgKGZhc3Rkb20uc2NoZWR1bGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmFzdGRvbS5zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgaWYgKHJlY3Vyc2lvbiAmJiByZWN1cnNpb24gPCBSRUNVUlNJT05fTElNSVQpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBmbHVzaChyZWN1cnNpb24pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBmbHVzaCgxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuVGFza3ModGFza3MpIHtcbiAgICAgIGxldCB0YXNrO1xuICAgICAgd2hpbGUgKHRhc2sgPSB0YXNrcy5zaGlmdCgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGFzaygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaXRlbSkge1xuICAgICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgICAgcmV0dXJuIH5pbmRleCAmJiBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE1vdXNlVHJhY2tlcigpIHt9XG5cbiAgICBNb3VzZVRyYWNrZXIucHJvdG90eXBlID0ge1xuICAgICAgcG9zaXRpb25zOiBbXSxcblxuICAgICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBbXTtcblxuICAgICAgICBsZXQgcG9zaXRpb247XG4gICAgICAgIHRoaXMudW5iaW5kID0gb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCAoZSkgPT4gcG9zaXRpb24gPSBnZXRFdmVudFBvcyhlKSk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25zLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MCk7XG4gICAgICB9LFxuXG4gICAgICBjYW5jZWwoKSB7dmFyIF90aGlzJHVuYmluZDtcbiAgICAgICAgKF90aGlzJHVuYmluZCA9IHRoaXMudW5iaW5kKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdW5iaW5kLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgIH0sXG5cbiAgICAgIG1vdmVzVG8odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IHA7XG5cbiAgICAgICAgY29uc3QgW3ByZXZQb3NpdGlvbl0gPSB0aGlzLnBvc2l0aW9ucztcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBsYXN0KHRoaXMucG9zaXRpb25zKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IFtwcmV2UG9zaXRpb24sIHBvc2l0aW9uXTtcblxuICAgICAgICBpZiAocG9pbnRJblJlY3QocG9zaXRpb24sIHApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGlhZ29uYWxzID0gW1xuICAgICAgICBbXG4gICAgICAgIHsgeDogbGVmdCwgeTogdG9wIH0sXG4gICAgICAgIHsgeDogcmlnaHQsIHk6IGJvdHRvbSB9XSxcblxuICAgICAgICBbXG4gICAgICAgIHsgeDogbGVmdCwgeTogYm90dG9tIH0sXG4gICAgICAgIHsgeDogcmlnaHQsIHk6IHRvcCB9XV07XG5cblxuXG4gICAgICAgIHJldHVybiBkaWFnb25hbHMuc29tZSgoZGlhZ29uYWwpID0+IHtcbiAgICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3QocGF0aCwgZGlhZ29uYWwpO1xuICAgICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24gJiYgcG9pbnRJblJlY3QoaW50ZXJzZWN0aW9uLCBwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IH07XG5cblxuICAgIC8vIEluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9nZW9tZXRyeS9wb2ludGxpbmVwbGFuZS9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoX3JlZiwgX3JlZjIpIHtsZXQgW3sgeDogeDEsIHk6IHkxIH0sIHsgeDogeDIsIHk6IHkyIH1dID0gX3JlZjtsZXQgW3sgeDogeDMsIHk6IHkzIH0sIHsgeDogeDQsIHk6IHk0IH1dID0gX3JlZjI7XG4gICAgICBjb25zdCBkZW5vbWluYXRvciA9ICh5NCAtIHkzKSAqICh4MiAtIHgxKSAtICh4NCAtIHgzKSAqICh5MiAtIHkxKTtcblxuICAgICAgLy8gTGluZXMgYXJlIHBhcmFsbGVsXG4gICAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1YSA9ICgoeDQgLSB4MykgKiAoeTEgLSB5MykgLSAoeTQgLSB5MykgKiAoeDEgLSB4MykpIC8gZGVub21pbmF0b3I7XG5cbiAgICAgIGlmICh1YSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIGludGVyc2VjdGlvblxuICAgICAgcmV0dXJuIHsgeDogeDEgKyB1YSAqICh4MiAtIHgxKSwgeTogeTEgKyB1YSAqICh5MiAtIHkxKSB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ic2VydmVJbnRlcnNlY3Rpb24odGFyZ2V0cywgY2IsIG9wdGlvbnMsIGludGVyc2VjdGluZykge2lmIChpbnRlcnNlY3RpbmcgPT09IHZvaWQgMCkge2ludGVyc2VjdGluZyA9IHRydWU7fVxuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICBpbnRlcnNlY3RpbmcgP1xuICAgICAgKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgIGlmIChlbnRyaWVzLnNvbWUoKGVudHJ5KSA9PiBlbnRyeS5pc0ludGVyc2VjdGluZykpIHtcbiAgICAgICAgICBjYihlbnRyaWVzLCBvYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgIH0gOlxuICAgICAgY2IsXG4gICAgICBvcHRpb25zKTtcblxuICAgICAgZm9yIChjb25zdCBlbCBvZiB0b05vZGVzKHRhcmdldHMpKSB7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzUmVzaXplT2JzZXJ2ZXIgPSBpbkJyb3dzZXIgJiYgd2luZG93LlJlc2l6ZU9ic2VydmVyO1xuICAgIGZ1bmN0aW9uIG9ic2VydmVSZXNpemUodGFyZ2V0cywgY2IsIG9wdGlvbnMpIHtpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7b3B0aW9ucyA9IHsgYm94OiAnYm9yZGVyLWJveCcgfTt9XG4gICAgICBpZiAoaGFzUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmUoUmVzaXplT2JzZXJ2ZXIsIHRhcmdldHMsIGNiLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmFsbGJhY2sgU2FmYXJpIDwgMTMuMVxuICAgICAgaW5pdFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICBsaXN0ZW5lcnMuYWRkKGNiKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgICAgfSB9O1xuXG4gICAgfVxuXG4gICAgbGV0IGxpc3RlbmVycztcbiAgICBmdW5jdGlvbiBpbml0UmVzaXplTGlzdGVuZXIoKSB7XG4gICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuXG4gICAgICAvLyB0aHJvdHRsZSAncmVzaXplJ1xuICAgICAgbGV0IHBlbmRpbmdSZXNpemU7XG4gICAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChwZW5kaW5nUmVzaXplKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdSZXNpemUgPSB0cnVlO1xuICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4gcGVuZGluZ1Jlc2l6ZSA9IGZhbHNlKTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBvbih3aW5kb3csICdsb2FkIHJlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBvbihkb2N1bWVudCwgJ2xvYWRlZG1ldGFkYXRhIGxvYWQnLCBoYW5kbGVSZXNpemUsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ic2VydmVNdXRhdGlvbih0YXJnZXRzLCBjYiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9ic2VydmUoTXV0YXRpb25PYnNlcnZlciwgdGFyZ2V0cywgY2IsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ic2VydmUoT2JzZXJ2ZXIsIHRhcmdldHMsIGNiLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBPYnNlcnZlcihjYik7XG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIHRvTm9kZXModGFyZ2V0cykpIHtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJhdHMgPSB7fTtcblxuICAgIHN0cmF0cy5ldmVudHMgPVxuICAgIHN0cmF0cy5jcmVhdGVkID1cbiAgICBzdHJhdHMuYmVmb3JlQ29ubmVjdCA9XG4gICAgc3RyYXRzLmNvbm5lY3RlZCA9XG4gICAgc3RyYXRzLmJlZm9yZURpc2Nvbm5lY3QgPVxuICAgIHN0cmF0cy5kaXNjb25uZWN0ZWQgPVxuICAgIHN0cmF0cy5kZXN0cm95ID1cbiAgICBjb25jYXRTdHJhdDtcblxuICAgIC8vIGFyZ3Mgc3RyYXRlZ3lcbiAgICBzdHJhdHMuYXJncyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWwgIT09IGZhbHNlICYmIGNvbmNhdFN0cmF0KGNoaWxkVmFsIHx8IHBhcmVudFZhbCk7XG4gICAgfTtcblxuICAgIC8vIHVwZGF0ZSBzdHJhdGVneVxuICAgIHN0cmF0cy51cGRhdGUgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHNvcnRCeSQxKFxuICAgICAgY29uY2F0U3RyYXQocGFyZW50VmFsLCBpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IHsgcmVhZDogY2hpbGRWYWwgfSA6IGNoaWxkVmFsKSxcbiAgICAgICdvcmRlcicpO1xuXG4gICAgfTtcblxuICAgIC8vIHByb3BlcnR5IHN0cmF0ZWd5XG4gICAgc3RyYXRzLnByb3BzID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgIGlmIChpc0FycmF5KGNoaWxkVmFsKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBjaGlsZFZhbCkge1xuICAgICAgICAgIHZhbHVlW2tleV0gPSBTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRWYWwgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmF0cy5tZXRob2RzKHBhcmVudFZhbCwgY2hpbGRWYWwpO1xuICAgIH07XG5cbiAgICAvLyBleHRlbmQgc3RyYXRlZ3lcbiAgICBzdHJhdHMuY29tcHV0ZWQgPSBzdHJhdHMubWV0aG9kcyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWwgPyBwYXJlbnRWYWwgPyB7IC4uLnBhcmVudFZhbCwgLi4uY2hpbGRWYWwgfSA6IGNoaWxkVmFsIDogcGFyZW50VmFsO1xuICAgIH07XG5cbiAgICAvLyBkYXRhIHN0cmF0ZWd5XG4gICAgc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgICAgIGlmICghdm0pIHtcbiAgICAgICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodm0pIHtcbiAgICAgICAgICByZXR1cm4gbWVyZ2VGbkRhdGEocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VGbkRhdGEocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZuRGF0YShwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICAgICAgcmV0dXJuIHN0cmF0cy5jb21wdXRlZChcbiAgICAgIGlzRnVuY3Rpb24ocGFyZW50VmFsKSA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSkgOiBwYXJlbnRWYWwsXG4gICAgICBpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKSA6IGNoaWxkVmFsKTtcblxuICAgIH1cblxuICAgIC8vIGNvbmNhdCBzdHJhdGVneVxuICAgIGZ1bmN0aW9uIGNvbmNhdFN0cmF0KHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgIHBhcmVudFZhbCA9IHBhcmVudFZhbCAmJiAhaXNBcnJheShwYXJlbnRWYWwpID8gW3BhcmVudFZhbF0gOiBwYXJlbnRWYWw7XG5cbiAgICAgIHJldHVybiBjaGlsZFZhbCA/XG4gICAgICBwYXJlbnRWYWwgP1xuICAgICAgcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbCkgOlxuICAgICAgaXNBcnJheShjaGlsZFZhbCkgP1xuICAgICAgY2hpbGRWYWwgOlxuICAgICAgW2NoaWxkVmFsXSA6XG4gICAgICBwYXJlbnRWYWw7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBzdHJhdGVneVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gaXNVbmRlZmluZWQoY2hpbGRWYWwpID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQsIHZtKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge307XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgICBmb3IgKGNvbnN0IG1peGluIG9mIGNoaWxkLm1peGlucykge1xuICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyZW50KSB7XG4gICAgICAgIG1lcmdlS2V5KGtleSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNoaWxkKSB7XG4gICAgICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgICAgIG1lcmdlS2V5KGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWVyZ2VLZXkoa2V5KSB7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IChzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQpKHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRpb25zLCBhcmdzKSB7aWYgKGFyZ3MgPT09IHZvaWQgMCkge2FyZ3MgPSBbXTt9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucyA/XG4gICAgICAgIHN0YXJ0c1dpdGgob3B0aW9ucywgJ3snKSA/XG4gICAgICAgIEpTT04ucGFyc2Uob3B0aW9ucykgOlxuICAgICAgICBhcmdzLmxlbmd0aCAmJiAhaW5jbHVkZXMob3B0aW9ucywgJzonKSA/XG4gICAgICAgIHsgW2FyZ3NbMF1dOiBvcHRpb25zIH0gOlxuICAgICAgICBvcHRpb25zLnNwbGl0KCc7JykucmVkdWNlKChvcHRpb25zLCBvcHRpb24pID0+IHtcbiAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBvcHRpb24uc3BsaXQoLzooLiopLyk7XG4gICAgICAgICAgaWYgKGtleSAmJiAhaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBvcHRpb25zW2tleS50cmltKCldID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfSwge30pIDpcbiAgICAgICAge307XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwbGF5KGVsKSB7XG4gICAgICBpZiAoaXNJRnJhbWUoZWwpKSB7XG4gICAgICAgIGNhbGwoZWwsIHsgZnVuYzogJ3BsYXlWaWRlbycsIG1ldGhvZDogJ3BsYXknIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNIVE1MNShlbCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlbC5wbGF5KCkuY2F0Y2gobm9vcCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXVzZShlbCkge1xuICAgICAgaWYgKGlzSUZyYW1lKGVsKSkge1xuICAgICAgICBjYWxsKGVsLCB7IGZ1bmM6ICdwYXVzZVZpZGVvJywgbWV0aG9kOiAncGF1c2UnIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNIVE1MNShlbCkpIHtcbiAgICAgICAgZWwucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdXRlKGVsKSB7XG4gICAgICBpZiAoaXNJRnJhbWUoZWwpKSB7XG4gICAgICAgIGNhbGwoZWwsIHsgZnVuYzogJ211dGUnLCBtZXRob2Q6ICdzZXRWb2x1bWUnLCB2YWx1ZTogMCB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSFRNTDUoZWwpKSB7XG4gICAgICAgIGVsLm11dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZpZGVvKGVsKSB7XG4gICAgICByZXR1cm4gaXNIVE1MNShlbCkgfHwgaXNJRnJhbWUoZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSFRNTDUoZWwpIHtcbiAgICAgIHJldHVybiBpc1RhZyhlbCwgJ3ZpZGVvJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJRnJhbWUoZWwpIHtcbiAgICAgIHJldHVybiBpc1RhZyhlbCwgJ2lmcmFtZScpICYmIChpc1lvdXR1YmUoZWwpIHx8IGlzVmltZW8oZWwpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1lvdXR1YmUoZWwpIHtcbiAgICAgIHJldHVybiAhIWVsLnNyYy5tYXRjaChcbiAgICAgIC9cXC9cXC8uKj95b3V0dWJlKC1ub2Nvb2tpZSk/XFwuW2Etel0rXFwvKHdhdGNoXFw/dj1bXiZcXHNdK3xlbWJlZCl8eW91dHVcXC5iZVxcLy4qLyk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZpbWVvKGVsKSB7XG4gICAgICByZXR1cm4gISFlbC5zcmMubWF0Y2goL3ZpbWVvXFwuY29tXFwvdmlkZW9cXC8uKi8pO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNhbGwoZWwsIGNtZCkge1xuICAgICAgYXdhaXQgZW5hYmxlQXBpKGVsKTtcbiAgICAgIHBvc3QoZWwsIGNtZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zdChlbCwgY21kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbC5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHsgZXZlbnQ6ICdjb21tYW5kJywgLi4uY21kIH0pLCAnKicpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBub29wXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGVLZXkgPSAnX3VrUGxheWVyJztcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgZnVuY3Rpb24gZW5hYmxlQXBpKGVsKSB7XG4gICAgICBpZiAoZWxbc3RhdGVLZXldKSB7XG4gICAgICAgIHJldHVybiBlbFtzdGF0ZUtleV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHlvdXR1YmUgPSBpc1lvdXR1YmUoZWwpO1xuICAgICAgY29uc3QgdmltZW8gPSBpc1ZpbWVvKGVsKTtcblxuICAgICAgY29uc3QgaWQgPSArK2NvdW50ZXI7XG4gICAgICBsZXQgcG9sbGVyO1xuXG4gICAgICByZXR1cm4gZWxbc3RhdGVLZXldID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgeW91dHViZSAmJlxuICAgICAgICBvbmNlKGVsLCAnbG9hZCcsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHBvc3QoZWwsIHsgZXZlbnQ6ICdsaXN0ZW5pbmcnLCBpZCB9KTtcbiAgICAgICAgICBwb2xsZXIgPSBzZXRJbnRlcnZhbChsaXN0ZW5lciwgMTAwKTtcbiAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvbmNlKHdpbmRvdywgJ21lc3NhZ2UnLCByZXNvbHZlLCBmYWxzZSwgKF9yZWYpID0+IHtsZXQgeyBkYXRhIH0gPSBfcmVmO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGRhdGEgJiYgKFxuICAgICAgICAgICAgICB5b3V0dWJlICYmIGRhdGEuaWQgPT09IGlkICYmIGRhdGEuZXZlbnQgPT09ICdvblJlYWR5JyB8fFxuICAgICAgICAgICAgICB2aW1lbyAmJiBOdW1iZXIoZGF0YS5wbGF5ZXJfaWQpID09PSBpZCkpO1xuXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWwuc3JjID0gXCJcIiArIGVsLnNyYyArIChpbmNsdWRlcyhlbC5zcmMsICc/JykgPyAnJicgOiAnPycpICsgKFxuICAgICAgICB5b3V0dWJlID8gJ2VuYWJsZWpzYXBpPTEnIDogXCJhcGk9MSZwbGF5ZXJfaWQ9XCIgKyBpZCk7XG5cbiAgICAgIH0pLnRoZW4oKCkgPT4gY2xlYXJJbnRlcnZhbChwb2xsZXIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0luVmlldyhlbGVtZW50LCBvZmZzZXRUb3AsIG9mZnNldExlZnQpIHtpZiAob2Zmc2V0VG9wID09PSB2b2lkIDApIHtvZmZzZXRUb3AgPSAwO31pZiAob2Zmc2V0TGVmdCA9PT0gdm9pZCAwKSB7b2Zmc2V0TGVmdCA9IDA7fVxuICAgICAgaWYgKCFpc1Zpc2libGUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0UmVjdChcbiAgICAgIC4uLnNjcm9sbFBhcmVudHMoZWxlbWVudCkuXG4gICAgICBtYXAoKHBhcmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCB9ID0gb2Zmc2V0KGdldFZpZXdwb3J0JDEocGFyZW50KSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IHRvcCAtIG9mZnNldFRvcCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0IC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICBib3R0b206IGJvdHRvbSArIG9mZnNldFRvcCxcbiAgICAgICAgICByaWdodDogcmlnaHQgKyBvZmZzZXRMZWZ0IH07XG5cbiAgICAgIH0pLlxuICAgICAgY29uY2F0KG9mZnNldChlbGVtZW50KSkpO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsVG9wKGVsZW1lbnQsIHRvcCkge1xuICAgICAgaWYgKGlzV2luZG93KGVsZW1lbnQpIHx8IGlzRG9jdW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudCA9IGdldFNjcm9sbGluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNVbmRlZmluZWQodG9wKSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhlbGVtZW50LCBfdGVtcCkge2xldCB7IG9mZnNldDogb2Zmc2V0QnkgPSAwIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBpc1Zpc2libGUoZWxlbWVudCkgPyBzY3JvbGxQYXJlbnRzKGVsZW1lbnQpIDogW107XG4gICAgICByZXR1cm4gcGFyZW50cy5yZWR1Y2UoXG4gICAgICAoZm4sIHNjcm9sbEVsZW1lbnQsIGkpID0+IHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCwgb2Zmc2V0SGVpZ2h0IH0gPSBzY3JvbGxFbGVtZW50O1xuICAgICAgICBjb25zdCBtYXhTY3JvbGwgPSBzY3JvbGxIZWlnaHQgLSBnZXRWaWV3cG9ydENsaWVudEhlaWdodChzY3JvbGxFbGVtZW50KTtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQ6IGVsSGVpZ2h0LCB0b3A6IGVsVG9wIH0gPSBvZmZzZXQocGFyZW50c1tpIC0gMV0gfHwgZWxlbWVudCk7XG5cbiAgICAgICAgbGV0IHRvcCA9IE1hdGguY2VpbChcbiAgICAgICAgZWxUb3AgLSBvZmZzZXQoZ2V0Vmlld3BvcnQkMShzY3JvbGxFbGVtZW50KSkudG9wIC0gb2Zmc2V0QnkgKyBzY3JvbGxUb3ApO1xuXG5cbiAgICAgICAgaWYgKG9mZnNldEJ5ID4gMCAmJiBvZmZzZXRIZWlnaHQgPCBlbEhlaWdodCArIG9mZnNldEJ5KSB7XG4gICAgICAgICAgdG9wICs9IG9mZnNldEJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldEJ5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgPiBtYXhTY3JvbGwpIHtcbiAgICAgICAgICBvZmZzZXRCeSAtPSB0b3AgLSBtYXhTY3JvbGw7XG4gICAgICAgICAgdG9wID0gbWF4U2Nyb2xsO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcCA8IDApIHtcbiAgICAgICAgICBvZmZzZXRCeSAtPSB0b3A7XG4gICAgICAgICAgdG9wID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKSA9PiBzY3JvbGxUbyhzY3JvbGxFbGVtZW50LCB0b3AgLSBzY3JvbGxUb3ApLnRoZW4oZm4pO1xuICAgICAgfSxcbiAgICAgICgpID0+IFByb21pc2UucmVzb2x2ZSgpKSgpO1xuXG5cbiAgICAgIGZ1bmN0aW9uIHNjcm9sbFRvKGVsZW1lbnQsIHRvcCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBjb25zdCBzY3JvbGwgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGdldER1cmF0aW9uKE1hdGguYWJzKHRvcCkpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgIChmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IGVhc2UoY2xhbXAoKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbikpO1xuXG4gICAgICAgICAgICBzY3JvbGxUb3AoZWxlbWVudCwgc2Nyb2xsICsgdG9wICogcGVyY2VudCk7XG5cbiAgICAgICAgICAgIC8vIHNjcm9sbCBtb3JlIGlmIHdlIGhhdmUgbm90IHJlYWNoZWQgb3VyIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMSkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldER1cmF0aW9uKGRpc3QpIHtcbiAgICAgICAgcmV0dXJuIDQwICogTWF0aC5wb3coZGlzdCwgMC4zNzUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlYXNlKGspIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxlZE92ZXIoZWxlbWVudCwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge2lmIChzdGFydE9mZnNldCA9PT0gdm9pZCAwKSB7c3RhcnRPZmZzZXQgPSAwO31pZiAoZW5kT2Zmc2V0ID09PSB2b2lkIDApIHtlbmRPZmZzZXQgPSAwO31cbiAgICAgIGlmICghaXNWaXNpYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbc2Nyb2xsRWxlbWVudF0gPSBzY3JvbGxQYXJlbnRzKGVsZW1lbnQsIC9hdXRvfHNjcm9sbC8sIHRydWUpO1xuICAgICAgY29uc3QgeyBzY3JvbGxIZWlnaHQsIHNjcm9sbFRvcCB9ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gZ2V0Vmlld3BvcnRDbGllbnRIZWlnaHQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICBjb25zdCBtYXhTY3JvbGwgPSBzY3JvbGxIZWlnaHQgLSB2aWV3cG9ydEhlaWdodDtcbiAgICAgIGNvbnN0IGVsZW1lbnRPZmZzZXRUb3AgPSBvZmZzZXRQb3NpdGlvbihlbGVtZW50KVswXSAtIG9mZnNldFBvc2l0aW9uKHNjcm9sbEVsZW1lbnQpWzBdO1xuXG4gICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIGVsZW1lbnRPZmZzZXRUb3AgLSB2aWV3cG9ydEhlaWdodCArIHN0YXJ0T2Zmc2V0KTtcbiAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKG1heFNjcm9sbCwgZWxlbWVudE9mZnNldFRvcCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gZW5kT2Zmc2V0KTtcblxuICAgICAgcmV0dXJuIGNsYW1wKChzY3JvbGxUb3AgLSBzdGFydCkgLyAoZW5kIC0gc3RhcnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxQYXJlbnRzKGVsZW1lbnQsIG92ZXJmbG93UmUsIHNjcm9sbGFibGUpIHtpZiAob3ZlcmZsb3dSZSA9PT0gdm9pZCAwKSB7b3ZlcmZsb3dSZSA9IC9hdXRvfHNjcm9sbHxoaWRkZW4vO31pZiAoc2Nyb2xsYWJsZSA9PT0gdm9pZCAwKSB7c2Nyb2xsYWJsZSA9IGZhbHNlO31cbiAgICAgIGNvbnN0IHNjcm9sbEVsID0gZ2V0U2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgbGV0IGFuY2VzdG9ycyA9IHBhcmVudHMoZWxlbWVudCkucmV2ZXJzZSgpO1xuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLnNsaWNlKGFuY2VzdG9ycy5pbmRleE9mKHNjcm9sbEVsKSArIDEpO1xuXG4gICAgICBjb25zdCBmaXhlZEluZGV4ID0gZmluZEluZGV4KGFuY2VzdG9ycywgKGVsKSA9PiBjc3MoZWwsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKTtcbiAgICAgIGlmICh+Zml4ZWRJbmRleCkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuc2xpY2UoZml4ZWRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbc2Nyb2xsRWxdLlxuICAgICAgY29uY2F0KFxuICAgICAgYW5jZXN0b3JzLmZpbHRlcihcbiAgICAgIChwYXJlbnQpID0+XG4gICAgICBvdmVyZmxvd1JlLnRlc3QoY3NzKHBhcmVudCwgJ292ZXJmbG93JykpICYmIChcbiAgICAgICFzY3JvbGxhYmxlIHx8IHBhcmVudC5zY3JvbGxIZWlnaHQgPiBnZXRWaWV3cG9ydENsaWVudEhlaWdodChwYXJlbnQpKSkpLlxuXG5cbiAgICAgIHJldmVyc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydCQxKHNjcm9sbEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBzY3JvbGxFbGVtZW50ID09PSBnZXRTY3JvbGxpbmdFbGVtZW50KHNjcm9sbEVsZW1lbnQpID8gd2luZG93IDogc2Nyb2xsRWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBpT1MgMTIgcmV0dXJucyA8Ym9keT4gYXMgc2Nyb2xsaW5nRWxlbWVudFxuICAgIGZ1bmN0aW9uIGdldFZpZXdwb3J0Q2xpZW50SGVpZ2h0KHNjcm9sbEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICBzY3JvbGxFbGVtZW50ID09PSBnZXRTY3JvbGxpbmdFbGVtZW50KHNjcm9sbEVsZW1lbnQpID9cbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6XG4gICAgICBzY3JvbGxFbGVtZW50KS5cbiAgICAgIGNsaWVudEhlaWdodDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHRvV2luZG93KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGRpcnMgPSB7XG4gICAgICB3aWR0aDogWyd4JywgJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgIGhlaWdodDogWyd5JywgJ3RvcCcsICdib3R0b20nXSB9O1xuXG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbkF0KFxuICAgIGVsZW1lbnQsXG4gICAgdGFyZ2V0LFxuICAgIGVsQXR0YWNoLFxuICAgIHRhcmdldEF0dGFjaCxcbiAgICBlbE9mZnNldCxcbiAgICB0YXJnZXRPZmZzZXQsXG4gICAgZmxpcCxcbiAgICBib3VuZGFyeSlcbiAgICB7XG4gICAgICBlbEF0dGFjaCA9IGdldFBvcyhlbEF0dGFjaCk7XG4gICAgICB0YXJnZXRBdHRhY2ggPSBnZXRQb3ModGFyZ2V0QXR0YWNoKTtcblxuICAgICAgY29uc3QgZmxpcHBlZCA9IHsgZWxlbWVudDogZWxBdHRhY2gsIHRhcmdldDogdGFyZ2V0QXR0YWNoIH07XG5cbiAgICAgIGlmICghZWxlbWVudCB8fCAhdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmbGlwcGVkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkaW0gPSBvZmZzZXQoZWxlbWVudCk7XG4gICAgICBjb25zdCB0YXJnZXREaW0gPSBvZmZzZXQodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGFyZ2V0RGltO1xuXG4gICAgICBtb3ZlVG8ocG9zaXRpb24sIGVsQXR0YWNoLCBkaW0sIC0xKTtcbiAgICAgIG1vdmVUbyhwb3NpdGlvbiwgdGFyZ2V0QXR0YWNoLCB0YXJnZXREaW0sIDEpO1xuXG4gICAgICBlbE9mZnNldCA9IGdldE9mZnNldHMoZWxPZmZzZXQsIGRpbS53aWR0aCwgZGltLmhlaWdodCk7XG4gICAgICB0YXJnZXRPZmZzZXQgPSBnZXRPZmZzZXRzKHRhcmdldE9mZnNldCwgdGFyZ2V0RGltLndpZHRoLCB0YXJnZXREaW0uaGVpZ2h0KTtcblxuICAgICAgZWxPZmZzZXRbJ3gnXSArPSB0YXJnZXRPZmZzZXRbJ3gnXTtcbiAgICAgIGVsT2Zmc2V0Wyd5J10gKz0gdGFyZ2V0T2Zmc2V0Wyd5J107XG5cbiAgICAgIHBvc2l0aW9uLmxlZnQgKz0gZWxPZmZzZXRbJ3gnXTtcbiAgICAgIHBvc2l0aW9uLnRvcCArPSBlbE9mZnNldFsneSddO1xuXG4gICAgICBpZiAoZmxpcCkge1xuICAgICAgICBsZXQgYm91bmRhcmllcyA9IHNjcm9sbFBhcmVudHMoZWxlbWVudCkubWFwKGdldFZpZXdwb3J0JDEpO1xuXG4gICAgICAgIGlmIChib3VuZGFyeSAmJiAhaW5jbHVkZXMoYm91bmRhcmllcywgYm91bmRhcnkpKSB7XG4gICAgICAgICAgYm91bmRhcmllcy51bnNoaWZ0KGJvdW5kYXJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvdW5kYXJpZXMgPSBib3VuZGFyaWVzLm1hcCgoZWwpID0+IG9mZnNldChlbCkpO1xuXG4gICAgICAgIGVhY2goZGlycywgKF9yZWYsIHByb3ApID0+IHtsZXQgW2RpciwgYWxpZ24sIGFsaWduRmxpcF0gPSBfcmVmO1xuICAgICAgICAgIGlmICghKGZsaXAgPT09IHRydWUgfHwgaW5jbHVkZXMoZmxpcCwgZGlyKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3VuZGFyaWVzLnNvbWUoKGJvdW5kYXJ5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtT2Zmc2V0ID1cbiAgICAgICAgICAgIGVsQXR0YWNoW2Rpcl0gPT09IGFsaWduID9cbiAgICAgICAgICAgIC1kaW1bcHJvcF0gOlxuICAgICAgICAgICAgZWxBdHRhY2hbZGlyXSA9PT0gYWxpZ25GbGlwID9cbiAgICAgICAgICAgIGRpbVtwcm9wXSA6XG4gICAgICAgICAgICAwO1xuXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRPZmZzZXQgPVxuICAgICAgICAgICAgdGFyZ2V0QXR0YWNoW2Rpcl0gPT09IGFsaWduID9cbiAgICAgICAgICAgIHRhcmdldERpbVtwcm9wXSA6XG4gICAgICAgICAgICB0YXJnZXRBdHRhY2hbZGlyXSA9PT0gYWxpZ25GbGlwID9cbiAgICAgICAgICAgIC10YXJnZXREaW1bcHJvcF0gOlxuICAgICAgICAgICAgMDtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcG9zaXRpb25bYWxpZ25dIDwgYm91bmRhcnlbYWxpZ25dIHx8XG4gICAgICAgICAgICBwb3NpdGlvblthbGlnbl0gKyBkaW1bcHJvcF0gPiBib3VuZGFyeVthbGlnbkZsaXBdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjZW50ZXJPZmZzZXQgPSBkaW1bcHJvcF0gLyAyO1xuICAgICAgICAgICAgICBjb25zdCBjZW50ZXJUYXJnZXRPZmZzZXQgPVxuICAgICAgICAgICAgICB0YXJnZXRBdHRhY2hbZGlyXSA9PT0gJ2NlbnRlcicgPyAtdGFyZ2V0RGltW3Byb3BdIC8gMiA6IDA7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBlbEF0dGFjaFtkaXJdID09PSAnY2VudGVyJyAmJiAoXG4gICAgICAgICAgICAgICAgYXBwbHkoY2VudGVyT2Zmc2V0LCBjZW50ZXJUYXJnZXRPZmZzZXQpIHx8XG4gICAgICAgICAgICAgICAgYXBwbHkoLWNlbnRlck9mZnNldCwgLWNlbnRlclRhcmdldE9mZnNldCkpIHx8XG4gICAgICAgICAgICAgICAgYXBwbHkoZWxlbU9mZnNldCwgdGFyZ2V0T2Zmc2V0KSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYXBwbHkoZWxlbU9mZnNldCwgdGFyZ2V0T2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9IHRvRmxvYXQoXG4gICAgICAgICAgICAgIChwb3NpdGlvblthbGlnbl0gKyBlbGVtT2Zmc2V0ICsgdGFyZ2V0T2Zmc2V0IC0gZWxPZmZzZXRbZGlyXSAqIDIpLnRvRml4ZWQoNCkpO1xuXG5cbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbCA+PSBib3VuZGFyeVthbGlnbl0gJiYgbmV3VmFsICsgZGltW3Byb3BdIDw9IGJvdW5kYXJ5W2FsaWduRmxpcF0pIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblthbGlnbl0gPSBuZXdWYWw7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIFsnZWxlbWVudCcsICd0YXJnZXQnXSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1PZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxpcHBlZFtlbF1bZGlyXSA9XG4gICAgICAgICAgICAgICAgICAgIGZsaXBwZWRbZWxdW2Rpcl0gPT09IGRpcnNbcHJvcF1bMV0gP1xuICAgICAgICAgICAgICAgICAgICBkaXJzW3Byb3BdWzJdIDpcbiAgICAgICAgICAgICAgICAgICAgZGlyc1twcm9wXVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0KGVsZW1lbnQsIHBvc2l0aW9uKTtcblxuICAgICAgcmV0dXJuIGZsaXBwZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZVRvKHBvc2l0aW9uLCBhdHRhY2gsIGRpbSwgZmFjdG9yKSB7XG4gICAgICBlYWNoKGRpcnMsIChfcmVmMiwgcHJvcCkgPT4ge2xldCBbZGlyLCBhbGlnbiwgYWxpZ25GbGlwXSA9IF9yZWYyO1xuICAgICAgICBpZiAoYXR0YWNoW2Rpcl0gPT09IGFsaWduRmxpcCkge1xuICAgICAgICAgIHBvc2l0aW9uW2FsaWduXSArPSBkaW1bcHJvcF0gKiBmYWN0b3I7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0YWNoW2Rpcl0gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgcG9zaXRpb25bYWxpZ25dICs9IGRpbVtwcm9wXSAqIGZhY3RvciAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBvcyhwb3MpIHtcbiAgICAgIGNvbnN0IHggPSAvbGVmdHxjZW50ZXJ8cmlnaHQvO1xuICAgICAgY29uc3QgeSA9IC90b3B8Y2VudGVyfGJvdHRvbS87XG5cbiAgICAgIHBvcyA9IChwb3MgfHwgJycpLnNwbGl0KCcgJyk7XG5cbiAgICAgIGlmIChwb3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBvcyA9IHgudGVzdChwb3NbMF0pID9cbiAgICAgICAgcG9zLmNvbmNhdCgnY2VudGVyJykgOlxuICAgICAgICB5LnRlc3QocG9zWzBdKSA/XG4gICAgICAgIFsnY2VudGVyJ10uY29uY2F0KHBvcykgOlxuICAgICAgICBbJ2NlbnRlcicsICdjZW50ZXInXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeC50ZXN0KHBvc1swXSkgPyBwb3NbMF0gOiAnY2VudGVyJyxcbiAgICAgICAgeTogeS50ZXN0KHBvc1sxXSkgPyBwb3NbMV0gOiAnY2VudGVyJyB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0cyhvZmZzZXRzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBjb25zdCBbeCwgeV0gPSAob2Zmc2V0cyB8fCAnJykuc3BsaXQoJyAnKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCA/IHRvRmxvYXQoeCkgKiAoZW5kc1dpdGgoeCwgJyUnKSA/IHdpZHRoIC8gMTAwIDogMSkgOiAwLFxuICAgICAgICB5OiB5ID8gdG9GbG9hdCh5KSAqIChlbmRzV2l0aCh5LCAnJScpID8gaGVpZ2h0IC8gMTAwIDogMSkgOiAwIH07XG5cbiAgICB9XG5cbiAgICB2YXIgdXRpbCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBhamF4OiBhamF4LFxuICAgICAgICBnZXRJbWFnZTogZ2V0SW1hZ2UsXG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICAgIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gICAgICAgIGFuaW1hdGU6IGFuaW1hdGUkMSxcbiAgICAgICAgQW5pbWF0aW9uOiBBbmltYXRpb24sXG4gICAgICAgIGF0dHI6IGF0dHIsXG4gICAgICAgIGhhc0F0dHI6IGhhc0F0dHIsXG4gICAgICAgIHJlbW92ZUF0dHI6IHJlbW92ZUF0dHIsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICAgICAgICByZW1vdmVDbGFzc2VzOiByZW1vdmVDbGFzc2VzLFxuICAgICAgICByZXBsYWNlQ2xhc3M6IHJlcGxhY2VDbGFzcyxcbiAgICAgICAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxuICAgICAgICB0b2dnbGVDbGFzczogdG9nZ2xlQ2xhc3MsXG4gICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMkMSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgb2Zmc2V0UG9zaXRpb246IG9mZnNldFBvc2l0aW9uLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBib3hNb2RlbEFkanVzdDogYm94TW9kZWxBZGp1c3QsXG4gICAgICAgIGZsaXBQb3NpdGlvbjogZmxpcFBvc2l0aW9uLFxuICAgICAgICB0b1B4OiB0b1B4LFxuICAgICAgICByZWFkeTogcmVhZHksXG4gICAgICAgIGlzVGFnOiBpc1RhZyxcbiAgICAgICAgZW1wdHk6IGVtcHR5LFxuICAgICAgICBodG1sOiBodG1sLFxuICAgICAgICByZXBsYWNlQ2hpbGRyZW46IHJlcGxhY2VDaGlsZHJlbixcbiAgICAgICAgcHJlcGVuZDogcHJlcGVuZCxcbiAgICAgICAgYXBwZW5kOiBhcHBlbmQsXG4gICAgICAgIGJlZm9yZTogYmVmb3JlLFxuICAgICAgICBhZnRlcjogYWZ0ZXIsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlJDEsXG4gICAgICAgIHdyYXBBbGw6IHdyYXBBbGwsXG4gICAgICAgIHdyYXBJbm5lcjogd3JhcElubmVyLFxuICAgICAgICB1bndyYXA6IHVud3JhcCxcbiAgICAgICAgZnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgICAgICBhcHBseTogYXBwbHksXG4gICAgICAgICQ6ICQsXG4gICAgICAgICQkOiAkJCxcbiAgICAgICAgaW5Ccm93c2VyOiBpbkJyb3dzZXIsXG4gICAgICAgIGlzUnRsOiBpc1J0bCxcbiAgICAgICAgaGFzVG91Y2g6IGhhc1RvdWNoLFxuICAgICAgICBwb2ludGVyRG93bjogcG9pbnRlckRvd24sXG4gICAgICAgIHBvaW50ZXJNb3ZlOiBwb2ludGVyTW92ZSxcbiAgICAgICAgcG9pbnRlclVwOiBwb2ludGVyVXAsXG4gICAgICAgIHBvaW50ZXJFbnRlcjogcG9pbnRlckVudGVyLFxuICAgICAgICBwb2ludGVyTGVhdmU6IHBvaW50ZXJMZWF2ZSxcbiAgICAgICAgcG9pbnRlckNhbmNlbDogcG9pbnRlckNhbmNlbCxcbiAgICAgICAgb246IG9uLFxuICAgICAgICBvZmY6IG9mZixcbiAgICAgICAgb25jZTogb25jZSxcbiAgICAgICAgdHJpZ2dlcjogdHJpZ2dlcixcbiAgICAgICAgY3JlYXRlRXZlbnQ6IGNyZWF0ZUV2ZW50LFxuICAgICAgICB0b0V2ZW50VGFyZ2V0czogdG9FdmVudFRhcmdldHMsXG4gICAgICAgIGlzVG91Y2g6IGlzVG91Y2gsXG4gICAgICAgIGdldEV2ZW50UG9zOiBnZXRFdmVudFBvcyxcbiAgICAgICAgZmFzdGRvbTogZmFzdGRvbSxcbiAgICAgICAgaXNWb2lkRWxlbWVudDogaXNWb2lkRWxlbWVudCxcbiAgICAgICAgaXNWaXNpYmxlOiBpc1Zpc2libGUsXG4gICAgICAgIHNlbElucHV0OiBzZWxJbnB1dCxcbiAgICAgICAgaXNJbnB1dDogaXNJbnB1dCxcbiAgICAgICAgc2VsRm9jdXNhYmxlOiBzZWxGb2N1c2FibGUsXG4gICAgICAgIGlzRm9jdXNhYmxlOiBpc0ZvY3VzYWJsZSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyJDEsXG4gICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gICAgICAgIHdpdGhpbjogd2l0aGluLFxuICAgICAgICBwYXJlbnRzOiBwYXJlbnRzLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgaGFzT3duOiBoYXNPd24sXG4gICAgICAgIGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuICAgICAgICBjYW1lbGl6ZTogY2FtZWxpemUsXG4gICAgICAgIHVjZmlyc3Q6IHVjZmlyc3QsXG4gICAgICAgIHN0YXJ0c1dpdGg6IHN0YXJ0c1dpdGgsXG4gICAgICAgIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgICAgICAgaW5jbHVkZXM6IGluY2x1ZGVzLFxuICAgICAgICBmaW5kSW5kZXg6IGZpbmRJbmRleCxcbiAgICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgICAgdG9BcnJheTogdG9BcnJheSxcbiAgICAgICAgYXNzaWduOiBhc3NpZ24sXG4gICAgICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICAgICAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgICAgICAgaXNXaW5kb3c6IGlzV2luZG93LFxuICAgICAgICBpc0RvY3VtZW50OiBpc0RvY3VtZW50LFxuICAgICAgICBpc05vZGU6IGlzTm9kZSxcbiAgICAgICAgaXNFbGVtZW50OiBpc0VsZW1lbnQsXG4gICAgICAgIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICAgICAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgICAgIGlzTnVtYmVyOiBpc051bWJlcixcbiAgICAgICAgaXNOdW1lcmljOiBpc051bWVyaWMsXG4gICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgICAgIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgICAgICAgdG9Cb29sZWFuOiB0b0Jvb2xlYW4sXG4gICAgICAgIHRvTnVtYmVyOiB0b051bWJlcixcbiAgICAgICAgdG9GbG9hdDogdG9GbG9hdCxcbiAgICAgICAgdG9Ob2RlOiB0b05vZGUsXG4gICAgICAgIHRvTm9kZXM6IHRvTm9kZXMsXG4gICAgICAgIHRvV2luZG93OiB0b1dpbmRvdyxcbiAgICAgICAgdG9NczogdG9NcyxcbiAgICAgICAgaXNFcXVhbDogaXNFcXVhbCxcbiAgICAgICAgc3dhcDogc3dhcCxcbiAgICAgICAgbGFzdDogbGFzdCxcbiAgICAgICAgZWFjaDogZWFjaCxcbiAgICAgICAgc29ydEJ5OiBzb3J0QnkkMSxcbiAgICAgICAgdW5pcXVlQnk6IHVuaXF1ZUJ5LFxuICAgICAgICBjbGFtcDogY2xhbXAsXG4gICAgICAgIG5vb3A6IG5vb3AsXG4gICAgICAgIGludGVyc2VjdFJlY3Q6IGludGVyc2VjdFJlY3QsXG4gICAgICAgIHBvaW50SW5SZWN0OiBwb2ludEluUmVjdCxcbiAgICAgICAgRGltZW5zaW9uczogRGltZW5zaW9ucyxcbiAgICAgICAgZ2V0SW5kZXg6IGdldEluZGV4LFxuICAgICAgICBtZW1vaXplOiBtZW1vaXplLFxuICAgICAgICBEZWZlcnJlZDogRGVmZXJyZWQsXG4gICAgICAgIE1vdXNlVHJhY2tlcjogTW91c2VUcmFja2VyLFxuICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uOiBvYnNlcnZlSW50ZXJzZWN0aW9uLFxuICAgICAgICBvYnNlcnZlUmVzaXplOiBvYnNlcnZlUmVzaXplLFxuICAgICAgICBvYnNlcnZlTXV0YXRpb246IG9ic2VydmVNdXRhdGlvbixcbiAgICAgICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgICAgIHBhcnNlT3B0aW9uczogcGFyc2VPcHRpb25zLFxuICAgICAgICBwbGF5OiBwbGF5LFxuICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgIG11dGU6IG11dGUsXG4gICAgICAgIGlzVmlkZW86IGlzVmlkZW8sXG4gICAgICAgIHBvc2l0aW9uQXQ6IHBvc2l0aW9uQXQsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgcXVlcnlBbGw6IHF1ZXJ5QWxsLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBmaW5kQWxsOiBmaW5kQWxsLFxuICAgICAgICBlc2NhcGU6IGVzY2FwZSxcbiAgICAgICAgY3NzOiBjc3MsXG4gICAgICAgIGdldENzc1ZhcjogZ2V0Q3NzVmFyLFxuICAgICAgICBwcm9wTmFtZTogcHJvcE5hbWUsXG4gICAgICAgIGlzSW5WaWV3OiBpc0luVmlldyxcbiAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3AsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBzY3JvbGxJbnRvVmlldyxcbiAgICAgICAgc2Nyb2xsZWRPdmVyOiBzY3JvbGxlZE92ZXIsXG4gICAgICAgIHNjcm9sbFBhcmVudHM6IHNjcm9sbFBhcmVudHMsXG4gICAgICAgIGdldFZpZXdwb3J0OiBnZXRWaWV3cG9ydCQxLFxuICAgICAgICBnZXRWaWV3cG9ydENsaWVudEhlaWdodDogZ2V0Vmlld3BvcnRDbGllbnRIZWlnaHQsXG4gICAgICAgIGdldFNjcm9sbGluZ0VsZW1lbnQ6IGdldFNjcm9sbGluZ0VsZW1lbnRcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdsb2JhbEFQSSAoVUlraXQpIHtcbiAgICAgIGNvbnN0IERBVEEgPSBVSWtpdC5kYXRhO1xuXG4gICAgICBVSWtpdC51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGx1Z2luLmNhbGwobnVsbCwgdGhpcyk7XG4gICAgICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgVUlraXQubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4sIGNvbXBvbmVudCkge1xuICAgICAgICBjb21wb25lbnQgPSAoaXNTdHJpbmcoY29tcG9uZW50KSA/IFVJa2l0LmNvbXBvbmVudChjb21wb25lbnQpIDogY29tcG9uZW50KSB8fCB0aGlzO1xuICAgICAgICBjb21wb25lbnQub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhjb21wb25lbnQub3B0aW9ucywgbWl4aW4pO1xuICAgICAgfTtcblxuICAgICAgVUlraXQuZXh0ZW5kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgY29uc3QgU3VwZXIgPSB0aGlzO1xuICAgICAgICBjb25zdCBTdWIgPSBmdW5jdGlvbiBVSWtpdENvbXBvbmVudChvcHRpb25zKSB7XG4gICAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgICAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgICAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICBTdWIuc3VwZXIgPSBTdXBlcjtcbiAgICAgICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcblxuICAgICAgICByZXR1cm4gU3ViO1xuICAgICAgfTtcblxuICAgICAgVUlraXQudXBkYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGUpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQgPyB0b05vZGUoZWxlbWVudCkgOiBkb2N1bWVudC5ib2R5O1xuXG4gICAgICAgIGZvciAoY29uc3QgcGFyZW50RWwgb2YgcGFyZW50cyhlbGVtZW50KS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICB1cGRhdGUocGFyZW50RWxbREFUQV0sIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwbHkoZWxlbWVudCwgKGVsZW1lbnQpID0+IHVwZGF0ZShlbGVtZW50W0RBVEFdLCBlKSk7XG4gICAgICB9O1xuXG4gICAgICBsZXQgY29udGFpbmVyO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJa2l0LCAnY29udGFpbmVyJywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldChlbGVtZW50KSB7XG4gICAgICAgICAgY29udGFpbmVyID0gJChlbGVtZW50KTtcbiAgICAgICAgfSB9KTtcblxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoZGF0YSwgZSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhW25hbWVdLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGRhdGFbbmFtZV0uX2NhbGxVcGRhdGUoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaG9va3NBUEkgKFVJa2l0KSB7XG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHt2YXIgX3RoaXMkJG9wdGlvbnMkaG9vaztcbiAgICAgICAgKF90aGlzJCRvcHRpb25zJGhvb2sgPSB0aGlzLiRvcHRpb25zW2hvb2tdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkJG9wdGlvbnMkaG9vay5mb3JFYWNoKChoYW5kbGVyKSA9PiBoYW5kbGVyLmNhbGwodGhpcykpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9jYWxsQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLl9jb21wdXRlZCA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2luaXRQcm9wcygpO1xuXG4gICAgICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb25uZWN0Jyk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xuICAgICAgICB0aGlzLl9pbml0T2JzZXJ2ZXJzKCk7XG5cbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLl9jYWxsVXBkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxEaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZURpc2Nvbm5lY3QnKTtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdE9ic2VydmVycygpO1xuICAgICAgICB0aGlzLl91bmJpbmRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2Rpc2Nvbm5lY3RlZCcpO1xuXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBkZWxldGUgdGhpcy5fd2F0Y2g7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxVcGRhdGUgPSBmdW5jdGlvbiAoZSkge2lmIChlID09PSB2b2lkIDApIHtlID0gJ3VwZGF0ZSc7fVxuICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlID09PSAndXBkYXRlJyB8fCBlID09PSAncmVzaXplJykge1xuICAgICAgICAgIHRoaXMuX2NhbGxXYXRjaGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuJG9wdGlvbnMudXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl91cGRhdGVzKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICBydW5VcGRhdGVzLmNhbGwodGhpcywgdGhpcy5fdXBkYXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdXBkYXRlcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuYWRkKGUudHlwZSB8fCBlKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fY2FsbFdhdGNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93YXRjaCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGluaXRpYWwgPSAhaGFzT3duKHRoaXMsICdfd2F0Y2gnKTtcblxuICAgICAgICB0aGlzLl93YXRjaCA9IGZhc3Rkb20ucmVhZCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgcnVuV2F0Y2hlcy5jYWxsKHRoaXMsIGluaXRpYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl93YXRjaCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gcnVuVXBkYXRlcyh0eXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVhZCwgd3JpdGUsIGV2ZW50cyA9IFtdIH0gb2YgdGhpcy4kb3B0aW9ucy51cGRhdGUpIHtcbiAgICAgICAgICBpZiAoIXR5cGVzLmhhcygndXBkYXRlJykgJiYgIWV2ZW50cy5zb21lKCh0eXBlKSA9PiB0eXBlcy5oYXModHlwZSkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgIGlmIChyZWFkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWFkLmNhbGwodGhpcywgdGhpcy5fZGF0YSwgdHlwZXMpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0ICYmIGlzUGxhaW5PYmplY3QocmVzdWx0KSkge1xuICAgICAgICAgICAgICBhc3NpZ24odGhpcy5fZGF0YSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod3JpdGUgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiB3cml0ZS5jYWxsKHRoaXMsIHRoaXMuX2RhdGEsIHR5cGVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJ1bldhdGNoZXMoaW5pdGlhbCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJG9wdGlvbnM6IHsgY29tcHV0ZWQgfSB9ID1cbiAgICAgICAgdGhpcztcbiAgICAgICAgY29uc3QgdmFsdWVzID0geyAuLi4oaW5pdGlhbCA/IHt9IDogdGhpcy5fY29tcHV0ZWQpIH07XG4gICAgICAgIHRoaXMuX2NvbXB1dGVkID0ge307XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb25zdCB7IHdhdGNoLCBpbW1lZGlhdGUgfSA9IGNvbXB1dGVkW2tleV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIHdhdGNoICYmIChcbiAgICAgICAgICBpbml0aWFsICYmIGltbWVkaWF0ZSB8fFxuICAgICAgICAgIGhhc093bih2YWx1ZXMsIGtleSkgJiYgIWlzRXF1YWwodmFsdWVzW2tleV0sIHRoaXNba2V5XSkpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdhdGNoLmNhbGwodGhpcywgdGhpc1trZXldLCB2YWx1ZXNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhdGVBUEkgKFVJa2l0KSB7XG4gICAgICBsZXQgdWlkID0gMDtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuZGF0YSA9IG5vcm1hbGl6ZURhdGEob3B0aW9ucywgdGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcblxuICAgICAgICB0aGlzLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucywgb3B0aW9ucywgdGhpcyk7XG4gICAgICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcHJvcHMgPSB7fTtcblxuICAgICAgICB0aGlzLl91aWQgPSB1aWQrKztcbiAgICAgICAgdGhpcy5faW5pdERhdGEoKTtcbiAgICAgICAgdGhpcy5faW5pdE1ldGhvZHMoKTtcbiAgICAgICAgdGhpcy5faW5pdENvbXB1dGVkcygpO1xuICAgICAgICB0aGlzLl9jYWxsSG9vaygnY3JlYXRlZCcpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICAgICAgdGhpcy4kbW91bnQob3B0aW9ucy5lbCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5faW5pdERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSA9IHt9IH0gPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICB0aGlzLiRwcm9wc1trZXldID0gdGhpc1trZXldID0gZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRNZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB7IG1ldGhvZHMgfSA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBtZXRob2RzW2tleV0uYmluZCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5faW5pdENvbXB1dGVkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgeyBjb21wdXRlZCB9ID0gdGhpcy4kb3B0aW9ucztcblxuICAgICAgICB0aGlzLl9jb21wdXRlZCA9IHt9O1xuXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZWdpc3RlckNvbXB1dGVkKHRoaXMsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICBsZXQga2V5O1xuXG4gICAgICAgIHByb3BzID0gcHJvcHMgfHwgZ2V0UHJvcHMkMSh0aGlzLiRvcHRpb25zLCB0aGlzLiRuYW1lKTtcblxuICAgICAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQocHJvcHNba2V5XSkpIHtcbiAgICAgICAgICAgIHRoaXMuJHByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGUgPSBbdGhpcy4kb3B0aW9ucy5jb21wdXRlZCwgdGhpcy4kb3B0aW9ucy5tZXRob2RzXTtcbiAgICAgICAgZm9yIChrZXkgaW4gdGhpcy4kcHJvcHMpIHtcbiAgICAgICAgICBpZiAoa2V5IGluIHByb3BzICYmIG5vdEluKGV4Y2x1ZGUsIGtleSkpIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHRoaXMuJHByb3BzW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuJG9wdGlvbnMuZXZlbnRzIHx8IFtdKSB7XG4gICAgICAgICAgaWYgKGhhc093bihldmVudCwgJ2hhbmRsZXInKSkge1xuICAgICAgICAgICAgcmVnaXN0ZXJFdmVudCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyRXZlbnQodGhpcywgZXZlbnRba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fdW5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgodW5iaW5kKSA9PiB1bmJpbmQoKSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRPYnNlcnZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycyA9IFtpbml0UHJvcHNPYnNlcnZlcih0aGlzKV07XG5cbiAgICAgICAgaWYgKHRoaXMuJG9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoaW5pdENoaWxkTGlzdE9ic2VydmVyKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLnJlZ2lzdGVyT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9kaXNjb25uZWN0T2JzZXJ2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBvYnNlcnZlci5kaXNjb25uZWN0KCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcm9wcyQxKG9wdHMsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGRhdGEkMSA9IHt9O1xuICAgICAgY29uc3QgeyBhcmdzID0gW10sIHByb3BzID0ge30sIGVsIH0gPSBvcHRzO1xuXG4gICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHJldHVybiBkYXRhJDE7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgbGV0IHZhbHVlID0gZGF0YShlbCwgcHJvcCk7XG5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBwcm9wc1trZXldID09PSBCb29sZWFuICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiBjb2VyY2UocHJvcHNba2V5XSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChwcm9wID09PSAndGFyZ2V0JyAmJiAoIXZhbHVlIHx8IHN0YXJ0c1dpdGgodmFsdWUsICdfJykpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhJDFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRpb25zID0gcGFyc2VPcHRpb25zKGRhdGEoZWwsIG5hbWUpLCBhcmdzKTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm9wID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkYXRhJDFbcHJvcF0gPSBjb2VyY2UocHJvcHNbcHJvcF0sIG9wdGlvbnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGEkMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdpc3RlckNvbXB1dGVkKGNvbXBvbmVudCwga2V5LCBjYikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBvbmVudCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IHsgX2NvbXB1dGVkLCAkcHJvcHMsICRlbCB9ID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgaWYgKCFoYXNPd24oX2NvbXB1dGVkLCBrZXkpKSB7XG4gICAgICAgICAgICBfY29tcHV0ZWRba2V5XSA9IChjYi5nZXQgfHwgY2IpLmNhbGwoY29tcG9uZW50LCAkcHJvcHMsICRlbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9jb21wdXRlZFtrZXldO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgX2NvbXB1dGVkIH0gPSBjb21wb25lbnQ7XG5cbiAgICAgICAgICBfY29tcHV0ZWRba2V5XSA9IGNiLnNldCA/IGNiLnNldC5jYWxsKGNvbXBvbmVudCwgdmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoX2NvbXB1dGVkW2tleV0pKSB7XG4gICAgICAgICAgICBkZWxldGUgX2NvbXB1dGVkW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9IH0pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFdmVudChjb21wb25lbnQsIGV2ZW50LCBrZXkpIHtcbiAgICAgIGlmICghaXNQbGFpbk9iamVjdChldmVudCkpIHtcbiAgICAgICAgZXZlbnQgPSB7IG5hbWU6IGtleSwgaGFuZGxlcjogZXZlbnQgfTtcbiAgICAgIH1cblxuICAgICAgbGV0IHsgbmFtZSwgZWwsIGhhbmRsZXIsIGNhcHR1cmUsIHBhc3NpdmUsIGRlbGVnYXRlLCBmaWx0ZXIsIHNlbGYgfSA9IGV2ZW50O1xuICAgICAgZWwgPSBpc0Z1bmN0aW9uKGVsKSA/IGVsLmNhbGwoY29tcG9uZW50KSA6IGVsIHx8IGNvbXBvbmVudC4kZWw7XG5cbiAgICAgIGlmIChpc0FycmF5KGVsKSkge1xuICAgICAgICBlbC5mb3JFYWNoKChlbCkgPT4gcmVnaXN0ZXJFdmVudChjb21wb25lbnQsIHsgLi4uZXZlbnQsIGVsIH0sIGtleSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZWwgfHwgZmlsdGVyICYmICFmaWx0ZXIuY2FsbChjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50Ll9ldmVudHMucHVzaChcbiAgICAgIG9uKFxuICAgICAgZWwsXG4gICAgICBuYW1lLFxuICAgICAgZGVsZWdhdGUgPyBpc1N0cmluZyhkZWxlZ2F0ZSkgPyBkZWxlZ2F0ZSA6IGRlbGVnYXRlLmNhbGwoY29tcG9uZW50KSA6IG51bGwsXG4gICAgICBpc1N0cmluZyhoYW5kbGVyKSA/IGNvbXBvbmVudFtoYW5kbGVyXSA6IGhhbmRsZXIuYmluZChjb21wb25lbnQpLFxuICAgICAgeyBwYXNzaXZlLCBjYXB0dXJlLCBzZWxmIH0pKTtcblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90SW4ob3B0aW9ucywga2V5KSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5ldmVyeSgoYXJyKSA9PiAhYXJyIHx8ICFoYXNPd24oYXJyLCBrZXkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2VyY2UodHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlID09PSBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiB0b0Jvb2xlYW4odmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgIHJldHVybiB0b0xpc3QodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZSA/IHR5cGUodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9MaXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgP1xuICAgICAgdmFsdWUgOlxuICAgICAgaXNTdHJpbmcodmFsdWUpID9cbiAgICAgIHZhbHVlLlxuICAgICAgc3BsaXQoLywoPyFbXihdKlxcKSkvKS5cbiAgICAgIG1hcCgodmFsdWUpID0+IGlzTnVtZXJpYyh2YWx1ZSkgPyB0b051bWJlcih2YWx1ZSkgOiB0b0Jvb2xlYW4odmFsdWUudHJpbSgpKSkgOlxuICAgICAgW3ZhbHVlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVEYXRhKF9yZWYsIF9yZWYyKSB7bGV0IHsgZGF0YSA9IHt9IH0gPSBfcmVmO2xldCB7IGFyZ3MgPSBbXSwgcHJvcHMgPSB7fSB9ID0gX3JlZjI7XG4gICAgICBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhID0gZGF0YS5zbGljZSgwLCBhcmdzLmxlbmd0aCkucmVkdWNlKChkYXRhLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGFzc2lnbihkYXRhLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFbYXJnc1tpbmRleF1dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzW2tleV0pIHtcbiAgICAgICAgICBkYXRhW2tleV0gPSBjb2VyY2UocHJvcHNba2V5XSwgZGF0YVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0Q2hpbGRMaXN0T2JzZXJ2ZXIoY29tcG9uZW50KSB7XG4gICAgICBjb25zdCB7IGVsIH0gPSBjb21wb25lbnQuJG9wdGlvbnM7XG5cbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gY29tcG9uZW50LiRlbWl0KCkpO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWUgfSk7XG5cblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRQcm9wc09ic2VydmVyKGNvbXBvbmVudCkge1xuICAgICAgY29uc3QgeyAkbmFtZSwgJG9wdGlvbnMsICRwcm9wcyB9ID0gY29tcG9uZW50O1xuICAgICAgY29uc3QgeyBhdHRycywgcHJvcHMsIGVsIH0gPSAkb3B0aW9ucztcblxuICAgICAgaWYgKCFwcm9wcyB8fCBhdHRycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gaXNBcnJheShhdHRycykgPyBhdHRycyA6IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICAgIGNvbnN0IGZpbHRlciA9IGF0dHJpYnV0ZXMubWFwKChrZXkpID0+IGh5cGhlbmF0ZShrZXkpKS5jb25jYXQoJG5hbWUpO1xuXG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChyZWNvcmRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRQcm9wcyQxKCRvcHRpb25zLCAkbmFtZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgcmVjb3Jkcy5zb21lKChfcmVmMykgPT4ge2xldCB7IGF0dHJpYnV0ZU5hbWUgfSA9IF9yZWYzO1xuICAgICAgICAgIGNvbnN0IHByb3AgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoJ2RhdGEtJywgJycpO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcHJvcCA9PT0gJG5hbWUgPyBhdHRyaWJ1dGVzIDogW2NhbWVsaXplKHByb3ApLCBjYW1lbGl6ZShhdHRyaWJ1dGVOYW1lKV0pLlxuICAgICAgICAgIHNvbWUoKHByb3ApID0+ICFpc1VuZGVmaW5lZChkYXRhW3Byb3BdKSAmJiBkYXRhW3Byb3BdICE9PSAkcHJvcHNbcHJvcF0pO1xuICAgICAgICB9KSlcbiAgICAgICAge1xuICAgICAgICAgIGNvbXBvbmVudC4kcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBmaWx0ZXIuY29uY2F0KGZpbHRlci5tYXAoKGtleSkgPT4gXCJkYXRhLVwiICsga2V5KSkgfSk7XG5cblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbmNlQVBJIChVSWtpdCkge1xuICAgICAgY29uc3QgREFUQSA9IFVJa2l0LmRhdGE7XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kY3JlYXRlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgZWxlbWVudCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gVUlraXRbY29tcG9uZW50XShlbGVtZW50LCBkYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lIH0gPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgICAgIGlmICghZWxbREFUQV0pIHtcbiAgICAgICAgICBlbFtEQVRBXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsW0RBVEFdW25hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxbREFUQV1bbmFtZV0gPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJGVsID0gdGhpcy4kb3B0aW9ucy5lbCA9IHRoaXMuJG9wdGlvbnMuZWwgfHwgZWw7XG5cbiAgICAgICAgaWYgKHdpdGhpbihlbCwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5fY2FsbENvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJHJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYWxsRGlzY29ubmVjdGVkKCk7XG4gICAgICAgIHRoaXMuX2NhbGxDb25uZWN0ZWQoKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmVFbCkge2lmIChyZW1vdmVFbCA9PT0gdm9pZCAwKSB7cmVtb3ZlRWwgPSBmYWxzZTt9XG4gICAgICAgIGNvbnN0IHsgZWwsIG5hbWUgfSA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgdGhpcy5fY2FsbERpc2Nvbm5lY3RlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2Rlc3Ryb3knKTtcblxuICAgICAgICBpZiAoIShlbCAhPSBudWxsICYmIGVsW0RBVEFdKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBlbFtEQVRBXVtuYW1lXTtcblxuICAgICAgICBpZiAoIWlzRW1wdHkoZWxbREFUQV0pKSB7XG4gICAgICAgICAgZGVsZXRlIGVsW0RBVEFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbW92ZUVsKSB7XG4gICAgICAgICAgcmVtb3ZlJDEodGhpcy4kZWwpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9jYWxsVXBkYXRlKGUpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLiR1cGRhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgZSkge2lmIChlbGVtZW50ID09PSB2b2lkIDApIHtlbGVtZW50ID0gdGhpcy4kZWw7fVxuICAgICAgICBVSWtpdC51cGRhdGUoZWxlbWVudCwgZSk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJGdldENvbXBvbmVudCA9IFVJa2l0LmdldENvbXBvbmVudDtcblxuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IG1lbW9pemUoKG5hbWUpID0+IFVJa2l0LnByZWZpeCArIGh5cGhlbmF0ZShuYW1lKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhVSWtpdC5wcm90b3R5cGUsIHtcbiAgICAgICAgJGNvbnRhaW5lcjogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihVSWtpdCwgJ2NvbnRhaW5lcicpLFxuXG4gICAgICAgICRuYW1lOiB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudE5hbWUodGhpcy4kb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgICB9IH0gfSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBvbmVudEFQSSAoVUlraXQpIHtcbiAgICAgIGNvbnN0IERBVEEgPSBVSWtpdC5kYXRhO1xuXG4gICAgICBjb25zdCBjb21wb25lbnRzID0ge307XG5cbiAgICAgIFVJa2l0LmNvbXBvbmVudCA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGlkID0gaHlwaGVuYXRlKG5hbWUpO1xuXG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZShpZCk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoY29tcG9uZW50c1tuYW1lXSkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHNbbmFtZV0gPSBVSWtpdC5leHRlbmQoY29tcG9uZW50c1tuYW1lXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBVSWtpdFtuYW1lXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBkYXRhKSB7XG4gICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gVUlraXQuY29tcG9uZW50KG5hbWUpO1xuXG4gICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwgP1xuICAgICAgICAgIG5ldyBjb21wb25lbnQoeyBkYXRhOiBpc1BsYWluT2JqZWN0KGVsZW1lbnQpID8gZWxlbWVudCA6IFsuLi5hcmd1bWVudHNdIH0pIDpcbiAgICAgICAgICBlbGVtZW50ID9cbiAgICAgICAgICAkJChlbGVtZW50KS5tYXAoaW5pdClbMF0gOlxuICAgICAgICAgIGluaXQoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGluaXQoZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBVSWtpdC5nZXRDb21wb25lbnQoZWxlbWVudCwgbmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgY29tcG9uZW50KHsgZWw6IGVsZW1lbnQsIGRhdGEgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9wdCA9IGlzUGxhaW5PYmplY3Qob3B0aW9ucykgPyB7IC4uLm9wdGlvbnMgfSA6IG9wdGlvbnMub3B0aW9ucztcblxuICAgICAgICBvcHQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgb3B0Lmluc3RhbGwgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdC5pbnN0YWxsKFVJa2l0LCBvcHQsIG5hbWUpO1xuXG4gICAgICAgIGlmIChVSWtpdC5faW5pdGlhbGl6ZWQgJiYgIW9wdC5mdW5jdGlvbmFsKSB7XG4gICAgICAgICAgZmFzdGRvbS5yZWFkKCgpID0+IFVJa2l0W25hbWVdKFwiW3VrLVwiICsgaWQgKyBcIl0sW2RhdGEtdWstXCIgKyBpZCArIFwiXVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50c1tuYW1lXSA9IGlzUGxhaW5PYmplY3Qob3B0aW9ucykgPyBvcHQgOiBvcHRpb25zO1xuICAgICAgfTtcblxuICAgICAgVUlraXQuZ2V0Q29tcG9uZW50cyA9IChlbGVtZW50KSA9PiAoZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudFtEQVRBXSkgfHwge307XG4gICAgICBVSWtpdC5nZXRDb21wb25lbnQgPSAoZWxlbWVudCwgbmFtZSkgPT4gVUlraXQuZ2V0Q29tcG9uZW50cyhlbGVtZW50KVtuYW1lXTtcblxuICAgICAgVUlraXQuY29ubmVjdCA9IChub2RlKSA9PiB7XG4gICAgICAgIGlmIChub2RlW0RBVEFdKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG5vZGVbREFUQV0pIHtcbiAgICAgICAgICAgIG5vZGVbREFUQV1bbmFtZV0uX2NhbGxDb25uZWN0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBub2RlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShhdHRyaWJ1dGUubmFtZSk7XG5cbiAgICAgICAgICBpZiAobmFtZSAmJiBuYW1lIGluIGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIFVJa2l0W25hbWVdKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQuZGlzY29ubmVjdCA9IChub2RlKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBub2RlW0RBVEFdKSB7XG4gICAgICAgICAgbm9kZVtEQVRBXVtuYW1lXS5fY2FsbERpc2Nvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGdldENvbXBvbmVudE5hbWUgPSBtZW1vaXplKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgIHJldHVybiBzdGFydHNXaXRoKGF0dHJpYnV0ZSwgJ3VrLScpIHx8IHN0YXJ0c1dpdGgoYXR0cmlidXRlLCAnZGF0YS11ay0nKSA/XG4gICAgICBjYW1lbGl6ZShhdHRyaWJ1dGUucmVwbGFjZSgnZGF0YS11ay0nLCAnJykucmVwbGFjZSgndWstJywgJycpKSA6XG4gICAgICBmYWxzZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IFVJa2l0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIFVJa2l0LnV0aWwgPSB1dGlsO1xuICAgIFVJa2l0LmRhdGEgPSAnX191aWtpdF9fJztcbiAgICBVSWtpdC5wcmVmaXggPSAndWstJztcbiAgICBVSWtpdC5vcHRpb25zID0ge307XG4gICAgVUlraXQudmVyc2lvbiA9ICczLjEzLjknO1xuXG4gICAgZ2xvYmFsQVBJKFVJa2l0KTtcbiAgICBob29rc0FQSShVSWtpdCk7XG4gICAgc3RhdGVBUEkoVUlraXQpO1xuICAgIGNvbXBvbmVudEFQSShVSWtpdCk7XG4gICAgaW5zdGFuY2VBUEkoVUlraXQpO1xuXG4gICAgZnVuY3Rpb24gQ29yZSAoKSB7XG4gICAgICBpZiAoIWluQnJvd3Nlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBzdGFydGVkID0gMDtcbiAgICAgIG9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICAnYW5pbWF0aW9uc3RhcnQnLFxuICAgICAgKF9yZWYpID0+IHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY7XG4gICAgICAgIGlmICgoY3NzKHRhcmdldCwgJ2FuaW1hdGlvbk5hbWUnKSB8fCAnJykubWF0Y2goL151ay0uKihsZWZ0fHJpZ2h0KS8pKSB7XG4gICAgICAgICAgc3RhcnRlZCsrO1xuICAgICAgICAgIGNzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdvdmVyZmxvd1gnLCAnaGlkZGVuJyk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoISAtLXN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgY3NzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ292ZXJmbG93WCcsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0b01zKGNzcyh0YXJnZXQsICdhbmltYXRpb25EdXJhdGlvbicpKSArIDEwMCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cnVlKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJvb3QgKFVJa2l0KSB7XG4gICAgICBjb25zdCB7IGNvbm5lY3QsIGRpc2Nvbm5lY3QgfSA9IFVJa2l0O1xuXG4gICAgICBpZiAoIWluQnJvd3NlciB8fCAhd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmYXN0ZG9tLnJlYWQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgIGFwcGx5KGRvY3VtZW50LmJvZHksIGNvbm5lY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMpID0+IHJlY29yZHMuZm9yRWFjaChhcHBseUNoaWxkTGlzdE11dGF0aW9uKSkub2JzZXJ2ZShcbiAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgc3VidHJlZTogdHJ1ZSB9KTtcblxuXG5cbiAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMpID0+IHJlY29yZHMuZm9yRWFjaChhcHBseUF0dHJpYnV0ZU11dGF0aW9uKSkub2JzZXJ2ZShcbiAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgIHN1YnRyZWU6IHRydWUgfSk7XG5cblxuXG4gICAgICAgIFVJa2l0Ll9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gYXBwbHlDaGlsZExpc3RNdXRhdGlvbihfcmVmKSB7bGV0IHsgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzIH0gPSBfcmVmO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYWRkZWROb2Rlcykge1xuICAgICAgICAgIGFwcGx5KG5vZGUsIGNvbm5lY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHJlbW92ZWROb2Rlcykge1xuICAgICAgICAgIGFwcGx5KG5vZGUsIGRpc2Nvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlTXV0YXRpb24oX3JlZjIpIHt2YXIgX1VJa2l0JGdldENvbXBvbmVudDtsZXQgeyB0YXJnZXQsIGF0dHJpYnV0ZU5hbWUgfSA9IF9yZWYyO1xuICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShhdHRyaWJ1dGVOYW1lKTtcblxuICAgICAgICBpZiAoIW5hbWUgfHwgIShuYW1lIGluIFVJa2l0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNBdHRyKHRhcmdldCwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICBVSWtpdFtuYW1lXSh0YXJnZXQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIChfVUlraXQkZ2V0Q29tcG9uZW50ID0gVUlraXQuZ2V0Q29tcG9uZW50KHRhcmdldCwgbmFtZSkpID09IG51bGwgPyB2b2lkIDAgOiBfVUlraXQkZ2V0Q29tcG9uZW50LiRkZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIENsYXNzID0ge1xuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICAhaGFzQ2xhc3ModGhpcy4kZWwsIHRoaXMuJG5hbWUpICYmIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLiRuYW1lKTtcbiAgICAgIH0gfTtcblxuICAgIHZhciBMYXp5bG9hZCA9IHtcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgbGF6eWxvYWQob2JzZXJ2ZVRhcmdldHMsIHRhcmdldHMpIHtpZiAob2JzZXJ2ZVRhcmdldHMgPT09IHZvaWQgMCkge29ic2VydmVUYXJnZXRzID0gdGhpcy4kZWw7fWlmICh0YXJnZXRzID09PSB2b2lkIDApIHt0YXJnZXRzID0gdGhpcy4kZWw7fVxuICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYnNlcnZlcihcbiAgICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKG9ic2VydmVUYXJnZXRzLCAoZW50cmllcywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdG9Ob2Rlcyhpc0Z1bmN0aW9uKHRhcmdldHMpID8gdGFyZ2V0cygpIDogdGFyZ2V0cykpIHtcbiAgICAgICAgICAgICAgJCQoJ1tsb2FkaW5nPVwibGF6eVwiXScsIGVsKS5mb3JFYWNoKChlbCkgPT4gcmVtb3ZlQXR0cihlbCwgJ2xvYWRpbmcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGVudHJpZXMuXG4gICAgICAgICAgICBmaWx0ZXIoKF9yZWYpID0+IHtsZXQgeyBpc0ludGVyc2VjdGluZyB9ID0gX3JlZjtyZXR1cm4gaXNJbnRlcnNlY3Rpbmc7fSkuXG4gICAgICAgICAgICBtYXAoKF9yZWYyKSA9PiB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmMjtyZXR1cm4gdGFyZ2V0O30pKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIFRvZ2dsYWJsZSA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsczogQm9vbGVhbixcbiAgICAgICAgYW5pbWF0aW9uOiAnbGlzdCcsXG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIsXG4gICAgICAgIG9yaWdpbjogU3RyaW5nLFxuICAgICAgICB0cmFuc2l0aW9uOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNsczogZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvbjogW2ZhbHNlXSxcbiAgICAgICAgZHVyYXRpb246IDIwMCxcbiAgICAgICAgb3JpZ2luOiBmYWxzZSxcbiAgICAgICAgdHJhbnNpdGlvbjogJ2xpbmVhcicsXG4gICAgICAgIGNsc0VudGVyOiAndWstdG9nZ2xhYmUtZW50ZXInLFxuICAgICAgICBjbHNMZWF2ZTogJ3VrLXRvZ2dsYWJlLWxlYXZlJyxcblxuICAgICAgICBpbml0UHJvcHM6IHtcbiAgICAgICAgICBvdmVyZmxvdzogJycsXG4gICAgICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgICAgICBwYWRkaW5nVG9wOiAnJyxcbiAgICAgICAgICBwYWRkaW5nQm90dG9tOiAnJyxcbiAgICAgICAgICBtYXJnaW5Ub3A6ICcnLFxuICAgICAgICAgIG1hcmdpbkJvdHRvbTogJycgfSxcblxuXG4gICAgICAgIGhpZGVQcm9wczoge1xuICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgcGFkZGluZ1RvcDogMCxcbiAgICAgICAgICBwYWRkaW5nQm90dG9tOiAwLFxuICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICBtYXJnaW5Cb3R0b206IDAgfSB9LFxuXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaGFzQW5pbWF0aW9uKF9yZWYpIHtsZXQgeyBhbmltYXRpb24gfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICEhYW5pbWF0aW9uWzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc1RyYW5zaXRpb24oX3JlZjIpIHtsZXQgeyBhbmltYXRpb24gfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhc0FuaW1hdGlvbiAmJiBhbmltYXRpb25bMF0gPT09IHRydWU7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHRvZ2dsZUVsZW1lbnQodGFyZ2V0cywgdG9nZ2xlLCBhbmltYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PlxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgIHRvTm9kZXModGFyZ2V0cykubWFwKChlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hvdyA9IGlzQm9vbGVhbih0b2dnbGUpID8gdG9nZ2xlIDogIXRoaXMuaXNUb2dnbGVkKGVsKTtcblxuICAgICAgICAgICAgaWYgKCF0cmlnZ2VyKGVsLCBcImJlZm9yZVwiICsgKHNob3cgPyAnc2hvdycgOiAnaGlkZScpLCBbdGhpc10pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gKFxuICAgICAgICAgICAgaXNGdW5jdGlvbihhbmltYXRlKSA/XG4gICAgICAgICAgICBhbmltYXRlIDpcbiAgICAgICAgICAgIGFuaW1hdGUgPT09IGZhbHNlIHx8ICF0aGlzLmhhc0FuaW1hdGlvbiA/XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUgOlxuICAgICAgICAgICAgdGhpcy5oYXNUcmFuc2l0aW9uID9cbiAgICAgICAgICAgIHRvZ2dsZUhlaWdodCh0aGlzKSA6XG4gICAgICAgICAgICB0b2dnbGVBbmltYXRpb24odGhpcykpKFxuICAgICAgICAgICAgZWwsIHNob3cpO1xuXG4gICAgICAgICAgICBjb25zdCBjbHMgPSBzaG93ID8gdGhpcy5jbHNFbnRlciA6IHRoaXMuY2xzTGVhdmU7XG5cbiAgICAgICAgICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuXG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCBzaG93ID8gJ3Nob3cnIDogJ2hpZGUnLCBbdGhpc10pO1xuXG4gICAgICAgICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbiAgICAgICAgICAgICAgdHJpZ2dlcihlbCwgc2hvdyA/ICdzaG93bicgOiAnaGlkZGVuJywgW3RoaXNdKTtcbiAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlKGVsKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlID9cbiAgICAgICAgICAgIHByb21pc2UudGhlbihkb25lLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KSkuXG4gICAgICAgICAgdGhlbihyZXNvbHZlLCBub29wKSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBpc1RvZ2dsZWQoZWwpIHtpZiAoZWwgPT09IHZvaWQgMCkge2VsID0gdGhpcy4kZWw7fVxuICAgICAgICAgIFtlbF0gPSB0b05vZGVzKGVsKTtcbiAgICAgICAgICByZXR1cm4gaGFzQ2xhc3MoZWwsIHRoaXMuY2xzRW50ZXIpID9cbiAgICAgICAgICB0cnVlIDpcbiAgICAgICAgICBoYXNDbGFzcyhlbCwgdGhpcy5jbHNMZWF2ZSkgP1xuICAgICAgICAgIGZhbHNlIDpcbiAgICAgICAgICB0aGlzLmNscyA/XG4gICAgICAgICAgaGFzQ2xhc3MoZWwsIHRoaXMuY2xzLnNwbGl0KCcgJylbMF0pIDpcbiAgICAgICAgICBpc1Zpc2libGUoZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF90b2dnbGUoZWwsIHRvZ2dsZWQpIHtcbiAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9nZ2xlZCA9IEJvb2xlYW4odG9nZ2xlZCk7XG5cbiAgICAgICAgICBsZXQgY2hhbmdlZDtcbiAgICAgICAgICBpZiAodGhpcy5jbHMpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSBpbmNsdWRlcyh0aGlzLmNscywgJyAnKSB8fCB0b2dnbGVkICE9PSBoYXNDbGFzcyhlbCwgdGhpcy5jbHMpO1xuICAgICAgICAgICAgY2hhbmdlZCAmJiB0b2dnbGVDbGFzcyhlbCwgdGhpcy5jbHMsIGluY2x1ZGVzKHRoaXMuY2xzLCAnICcpID8gdW5kZWZpbmVkIDogdG9nZ2xlZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0b2dnbGVkID09PSBlbC5oaWRkZW47XG4gICAgICAgICAgICBjaGFuZ2VkICYmIChlbC5oaWRkZW4gPSAhdG9nZ2xlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJCQoJ1thdXRvZm9jdXNdJywgZWwpLnNvbWUoKGVsKSA9PiBpc1Zpc2libGUoZWwpID8gZWwuZm9jdXMoKSB8fCB0cnVlIDogZWwuYmx1cigpKTtcblxuICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAndG9nZ2xlZCcsIFt0b2dnbGVkLCB0aGlzXSk7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGUoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlSGVpZ2h0KF9yZWYzKSB7bGV0IHsgaXNUb2dnbGVkLCBkdXJhdGlvbiwgaW5pdFByb3BzLCBoaWRlUHJvcHMsIHRyYW5zaXRpb24sIF90b2dnbGUgfSA9IF9yZWYzO1xuICAgICAgcmV0dXJuIChlbCwgc2hvdykgPT4ge1xuICAgICAgICBjb25zdCBpblByb2dyZXNzID0gVHJhbnNpdGlvbi5pblByb2dyZXNzKGVsKTtcbiAgICAgICAgY29uc3QgaW5uZXIgPSBlbC5oYXNDaGlsZE5vZGVzKCkgP1xuICAgICAgICB0b0Zsb2F0KGNzcyhlbC5maXJzdEVsZW1lbnRDaGlsZCwgJ21hcmdpblRvcCcpKSArXG4gICAgICAgIHRvRmxvYXQoY3NzKGVsLmxhc3RFbGVtZW50Q2hpbGQsICdtYXJnaW5Cb3R0b20nKSkgOlxuICAgICAgICAwO1xuICAgICAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gaXNWaXNpYmxlKGVsKSA/IGhlaWdodChlbCkgKyAoaW5Qcm9ncmVzcyA/IDAgOiBpbm5lcikgOiAwO1xuXG4gICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKGVsKTtcblxuICAgICAgICBpZiAoIWlzVG9nZ2xlZChlbCkpIHtcbiAgICAgICAgICBfdG9nZ2xlKGVsLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlaWdodChlbCwgJycpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjaGlsZCBjb21wb25lbnRzIGZpcnN0XG4gICAgICAgIGZhc3Rkb20uZmx1c2goKTtcblxuICAgICAgICBjb25zdCBlbmRIZWlnaHQgPSBoZWlnaHQoZWwpICsgKGluUHJvZ3Jlc3MgPyAwIDogaW5uZXIpO1xuICAgICAgICBoZWlnaHQoZWwsIGN1cnJlbnRIZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIHNob3cgP1xuICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KFxuICAgICAgICBlbCxcbiAgICAgICAgeyAuLi5pbml0UHJvcHMsIG92ZXJmbG93OiAnaGlkZGVuJywgaGVpZ2h0OiBlbmRIZWlnaHQgfSxcbiAgICAgICAgTWF0aC5yb3VuZChkdXJhdGlvbiAqICgxIC0gY3VycmVudEhlaWdodCAvIGVuZEhlaWdodCkpLFxuICAgICAgICB0cmFuc2l0aW9uKSA6XG5cbiAgICAgICAgVHJhbnNpdGlvbi5zdGFydChcbiAgICAgICAgZWwsXG4gICAgICAgIGhpZGVQcm9wcyxcbiAgICAgICAgTWF0aC5yb3VuZChkdXJhdGlvbiAqIChjdXJyZW50SGVpZ2h0IC8gZW5kSGVpZ2h0KSksXG4gICAgICAgIHRyYW5zaXRpb24pLlxuICAgICAgICB0aGVuKCgpID0+IF90b2dnbGUoZWwsIGZhbHNlKSkpLlxuICAgICAgICB0aGVuKCgpID0+IGNzcyhlbCwgaW5pdFByb3BzKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZUFuaW1hdGlvbihjbXApIHtcbiAgICAgIHJldHVybiAoZWwsIHNob3cpID0+IHtcbiAgICAgICAgQW5pbWF0aW9uLmNhbmNlbChlbCk7XG5cbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24sIGR1cmF0aW9uLCBfdG9nZ2xlIH0gPSBjbXA7XG5cbiAgICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgICBfdG9nZ2xlKGVsLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gQW5pbWF0aW9uLmluKGVsLCBhbmltYXRpb25bMF0sIGR1cmF0aW9uLCBjbXAub3JpZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBbmltYXRpb24ub3V0KGVsLCBhbmltYXRpb25bMV0gfHwgYW5pbWF0aW9uWzBdLCBkdXJhdGlvbiwgY21wLm9yaWdpbikudGhlbigoKSA9PlxuICAgICAgICBfdG9nZ2xlKGVsLCBmYWxzZSkpO1xuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBBY2NvcmRpb24gPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgTGF6eWxvYWQsIFRvZ2dsYWJsZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRhcmdldHM6IFN0cmluZyxcbiAgICAgICAgYWN0aXZlOiBudWxsLFxuICAgICAgICBjb2xsYXBzaWJsZTogQm9vbGVhbixcbiAgICAgICAgbXVsdGlwbGU6IEJvb2xlYW4sXG4gICAgICAgIHRvZ2dsZTogU3RyaW5nLFxuICAgICAgICBjb250ZW50OiBTdHJpbmcsXG4gICAgICAgIHRyYW5zaXRpb246IFN0cmluZyxcbiAgICAgICAgb2Zmc2V0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhcmdldHM6ICc+IConLFxuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICBhbmltYXRpb246IFt0cnVlXSxcbiAgICAgICAgY29sbGFwc2libGU6IHRydWUsXG4gICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgY2xzT3BlbjogJ3VrLW9wZW4nLFxuICAgICAgICB0b2dnbGU6ICc+IC51ay1hY2NvcmRpb24tdGl0bGUnLFxuICAgICAgICBjb250ZW50OiAnPiAudWstYWNjb3JkaW9uLWNvbnRlbnQnLFxuICAgICAgICB0cmFuc2l0aW9uOiAnZWFzZScsXG4gICAgICAgIG9mZnNldDogMCB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgZ2V0KF9yZWYsICRlbCkge2xldCB7IHRhcmdldHMgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gJCQodGFyZ2V0cywgJGVsKS5maWx0ZXIoKGVsKSA9PiAkKHRoaXMuY29udGVudCwgZWwpKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goaXRlbXMsIHByZXYpIHtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGVsKSA9PiBoaWRlKCQodGhpcy5jb250ZW50LCBlbCksICFoYXNDbGFzcyhlbCwgdGhpcy5jbHNPcGVuKSkpO1xuXG4gICAgICAgICAgICBpZiAocHJldiB8fCBoYXNDbGFzcyhpdGVtcywgdGhpcy5jbHNPcGVuKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSAhPT0gZmFsc2UgJiYgaXRlbXNbTnVtYmVyKHRoaXMuYWN0aXZlKV0gfHxcbiAgICAgICAgICAgICF0aGlzLmNvbGxhcHNpYmxlICYmIGl0ZW1zWzBdO1xuXG4gICAgICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGFjdGl2ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIHRvZ2dsZXMoX3JlZjIpIHtsZXQgeyB0b2dnbGUgfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLm1hcCgoaXRlbSkgPT4gJCh0b2dnbGUsIGl0ZW0pKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5sYXp5bG9hZCgpO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0cyArIFwiIFwiICsgdGhpcy4kcHJvcHMudG9nZ2xlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnRvZ2dsZShpbmRleCh0aGlzLnRvZ2dsZXMsIGUuY3VycmVudCkpO1xuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGUoaXRlbSwgYW5pbWF0ZSkge1xuICAgICAgICAgIGxldCBpdGVtcyA9IFt0aGlzLml0ZW1zW2dldEluZGV4KGl0ZW0sIHRoaXMuaXRlbXMpXV07XG4gICAgICAgICAgY29uc3QgYWN0aXZlSXRlbXMgPSBmaWx0ZXIkMSh0aGlzLml0ZW1zLCBcIi5cIiArIHRoaXMuY2xzT3Blbik7XG5cbiAgICAgICAgICBpZiAoIXRoaXMubXVsdGlwbGUgJiYgIWluY2x1ZGVzKGFjdGl2ZUl0ZW1zLCBpdGVtc1swXSkpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KGFjdGl2ZUl0ZW1zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXMuY29sbGFwc2libGUgJiZcbiAgICAgICAgICBhY3RpdmVJdGVtcy5sZW5ndGggPCAyICYmXG4gICAgICAgICAgIWZpbHRlciQxKGl0ZW1zLCBcIjpub3QoLlwiICsgdGhpcy5jbHNPcGVuICsgXCIpXCIpLmxlbmd0aClcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBpdGVtcykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVFbGVtZW50KGVsLCAhaGFzQ2xhc3MoZWwsIHRoaXMuY2xzT3BlbiksIGFzeW5jIChlbCwgc2hvdykgPT4ge1xuICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcy5jbHNPcGVuLCBzaG93KTtcbiAgICAgICAgICAgICAgYXR0cigkKHRoaXMuJHByb3BzLnRvZ2dsZSwgZWwpLCAnYXJpYS1leHBhbmRlZCcsIHNob3cpO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSAkKFwiXCIgKyAoZWwuX3dyYXBwZXIgPyAnPiAqICcgOiAnJykgKyB0aGlzLmNvbnRlbnQsIGVsKTtcblxuICAgICAgICAgICAgICBpZiAoYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIXRoaXMuaGFzVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIGhpZGUoY29udGVudCwgIXNob3cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghZWwuX3dyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBlbC5fd3JhcHBlciA9IHdyYXBBbGwoY29udGVudCwgXCI8ZGl2XCIgKyAoc2hvdyA/ICcgaGlkZGVuJyA6ICcnKSArIFwiPlwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhpZGUoY29udGVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICBhd2FpdCB0b2dnbGVIZWlnaHQodGhpcykoZWwuX3dyYXBwZXIsIHNob3cpO1xuICAgICAgICAgICAgICBoaWRlKGNvbnRlbnQsICFzaG93KTtcblxuICAgICAgICAgICAgICBkZWxldGUgZWwuX3dyYXBwZXI7XG4gICAgICAgICAgICAgIHVud3JhcChjb250ZW50KTtcblxuICAgICAgICAgICAgICBpZiAoc2hvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvZ2dsZSA9ICQodGhpcy4kcHJvcHMudG9nZ2xlLCBlbCk7XG4gICAgICAgICAgICAgICAgZmFzdGRvbS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNJblZpZXcodG9nZ2xlKSkge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldyh0b2dnbGUsIHsgb2Zmc2V0OiB0aGlzLm9mZnNldCB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBoaWRlKGVsLCBoaWRlKSB7XG4gICAgICBlbCAmJiAoZWwuaGlkZGVuID0gaGlkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsZXJ0ID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIFRvZ2dsYWJsZV0sXG5cbiAgICAgIGFyZ3M6ICdhbmltYXRpb24nLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbG9zZTogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBhbmltYXRpb246IFt0cnVlXSxcbiAgICAgICAgc2VsQ2xvc2U6ICcudWstYWxlcnQtY2xvc2UnLFxuICAgICAgICBkdXJhdGlvbjogMTUwLFxuICAgICAgICBoaWRlUHJvcHM6IHsgb3BhY2l0eTogMCwgLi4uVG9nZ2xhYmxlLmRhdGEuaGlkZVByb3BzIH0gfSxcblxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxDbG9zZTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwpO1xuICAgICAgICAgIHRoaXMuJGRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIFZpZGVvID0ge1xuICAgICAgYXJnczogJ2F1dG9wbGF5JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYXV0b211dGU6IEJvb2xlYW4sXG4gICAgICAgIGF1dG9wbGF5OiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBhdXRvbXV0ZTogZmFsc2UsXG4gICAgICAgIGF1dG9wbGF5OiB0cnVlIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMuYXV0b3BsYXkgPT09ICdpbnZpZXcnO1xuXG4gICAgICAgIGlmICh0aGlzLmluVmlldyAmJiAhaGFzQXR0cih0aGlzLiRlbCwgJ3ByZWxvYWQnKSkge1xuICAgICAgICAgIHRoaXMuJGVsLnByZWxvYWQgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hdXRvbXV0ZSkge1xuICAgICAgICAgIG11dGUodGhpcy4kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKG9ic2VydmVJbnRlcnNlY3Rpb24odGhpcy4kZWwsICgpID0+IHRoaXMuJGVtaXQoKSwge30sIGZhbHNlKSk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAoIWlzVmlkZW8odGhpcy4kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpc2libGU6IGlzVmlzaWJsZSh0aGlzLiRlbCkgJiYgY3NzKHRoaXMuJGVsLCAndmlzaWJpbGl0eScpICE9PSAnaGlkZGVuJyxcbiAgICAgICAgICAgIGluVmlldzogdGhpcy5pblZpZXcgJiYgaXNJblZpZXcodGhpcy4kZWwpIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmKSB7bGV0IHsgdmlzaWJsZSwgaW5WaWV3IH0gPSBfcmVmO1xuICAgICAgICAgIGlmICghdmlzaWJsZSB8fCB0aGlzLmluVmlldyAmJiAhaW5WaWV3KSB7XG4gICAgICAgICAgICBwYXVzZSh0aGlzLiRlbCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF1dG9wbGF5ID09PSB0cnVlIHx8IHRoaXMuaW5WaWV3ICYmIGluVmlldykge1xuICAgICAgICAgICAgcGxheSh0aGlzLiRlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBSZXNpemUgPSB7XG4gICAgICBjb25uZWN0ZWQoKSB7dmFyIF90aGlzJCRvcHRpb25zJHJlc2l6ZTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICBvYnNlcnZlUmVzaXplKCgoX3RoaXMkJG9wdGlvbnMkcmVzaXplID0gdGhpcy4kb3B0aW9ucy5yZXNpemVUYXJnZXRzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkJG9wdGlvbnMkcmVzaXplLmNhbGwodGhpcykpIHx8IHRoaXMuJGVsLCAoKSA9PlxuICAgICAgICB0aGlzLiRlbWl0KCdyZXNpemUnKSkpO1xuXG5cbiAgICAgIH0gfTtcblxuICAgIHZhciBjb3ZlciA9IHtcbiAgICAgIG1peGluczogW1Jlc2l6ZSwgVmlkZW9dLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB3aWR0aDogTnVtYmVyLFxuICAgICAgICBoZWlnaHQ6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYXV0b211dGU6IHRydWUgfSxcblxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgJ2xvYWQgbG9hZGVkbWV0YWRhdGEnKCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgcmVzaXplVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLiRlbCwgcGFyZW50KHRoaXMuJGVsKV07XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuJGVsO1xuICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0SGVpZ2h0OiBoZWlnaHQsIG9mZnNldFdpZHRoOiB3aWR0aCB9ID1cbiAgICAgICAgICBnZXRQb3NpdGlvbmVkUGFyZW50KGVsKSB8fCBwYXJlbnQoZWwpO1xuICAgICAgICAgIGNvbnN0IGRpbSA9IERpbWVuc2lvbnMuY292ZXIoXG4gICAgICAgICAge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggfHwgZWwubmF0dXJhbFdpZHRoIHx8IGVsLnZpZGVvV2lkdGggfHwgZWwuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0IHx8IGVsLm5hdHVyYWxIZWlnaHQgfHwgZWwudmlkZW9IZWlnaHQgfHwgZWwuY2xpZW50SGVpZ2h0IH0sXG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGggKyAod2lkdGggJSAyID8gMSA6IDApLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyAoaGVpZ2h0ICUgMiA/IDEgOiAwKSB9KTtcblxuXG5cbiAgICAgICAgICBpZiAoIWRpbS53aWR0aCB8fCAhZGltLmhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkaW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZikge2xldCB7IGhlaWdodCwgd2lkdGggfSA9IF9yZWY7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCB7IGhlaWdodCwgd2lkdGggfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbmVkUGFyZW50KGVsKSB7XG4gICAgICB3aGlsZSAoZWwgPSBwYXJlbnQoZWwpKSB7XG4gICAgICAgIGlmIChjc3MoZWwsICdwb3NpdGlvbicpICE9PSAnc3RhdGljJykge1xuICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBDb250YWluZXIgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBjb250YWluZXI6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbnRhaW5lcjogdHJ1ZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvbnRhaW5lcihfcmVmKSB7bGV0IHsgY29udGFpbmVyIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBjb250YWluZXIgPT09IHRydWUgJiYgdGhpcy4kY29udGFpbmVyIHx8IGNvbnRhaW5lciAmJiAkKGNvbnRhaW5lcik7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIFBvc2l0aW9uID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcG9zOiBTdHJpbmcsXG4gICAgICAgIG9mZnNldDogbnVsbCxcbiAgICAgICAgZmxpcDogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcG9zOiBcImJvdHRvbS1cIiArIChpc1J0bCA/ICdyaWdodCcgOiAnbGVmdCcpLFxuICAgICAgICBmbGlwOiB0cnVlLFxuICAgICAgICBvZmZzZXQ6IGZhbHNlIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuJHByb3BzLnBvcy5zcGxpdCgnLScpLmNvbmNhdCgnY2VudGVyJykuc2xpY2UoMCwgMik7XG4gICAgICAgIHRoaXMuZGlyID0gdGhpcy5wb3NbMF07XG4gICAgICAgIHRoaXMuYWxpZ24gPSB0aGlzLnBvc1sxXTtcbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgcG9zaXRpb25BdChlbGVtZW50LCB0YXJnZXQsIGJvdW5kYXJ5KSB7XG4gICAgICAgICAgY29uc3QgYXhpcyA9IHRoaXMuZ2V0QXhpcygpO1xuICAgICAgICAgIGNvbnN0IGRpciA9IHRoaXMucG9zWzBdO1xuICAgICAgICAgIGNvbnN0IGFsaWduID0gdGhpcy5wb3NbMV07XG5cbiAgICAgICAgICBsZXQgeyBvZmZzZXQ6IG9mZnNldCQxIH0gPSB0aGlzO1xuICAgICAgICAgIGlmICghaXNOdW1lcmljKG9mZnNldCQxKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9ICQob2Zmc2V0JDEpO1xuICAgICAgICAgICAgb2Zmc2V0JDEgPSBub2RlID9cbiAgICAgICAgICAgIG9mZnNldChub2RlKVtheGlzID09PSAneCcgPyAnbGVmdCcgOiAndG9wJ10gLVxuICAgICAgICAgICAgb2Zmc2V0KHRhcmdldClbYXhpcyA9PT0gJ3gnID8gJ3JpZ2h0JyA6ICdib3R0b20nXSA6XG4gICAgICAgICAgICAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQkMSA9IHRvUHgob2Zmc2V0JDEpICsgdG9QeChnZXRDc3NWYXIoJ3Bvc2l0aW9uLW9mZnNldCcsIGVsZW1lbnQpKTtcblxuICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9zaXRpb25BdChcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBheGlzID09PSAneCcgPyBmbGlwUG9zaXRpb24oZGlyKSArIFwiIFwiICsgYWxpZ24gOiBhbGlnbiArIFwiIFwiICsgZmxpcFBvc2l0aW9uKGRpciksXG4gICAgICAgICAgYXhpcyA9PT0gJ3gnID8gZGlyICsgXCIgXCIgKyBhbGlnbiA6IGFsaWduICsgXCIgXCIgKyBkaXIsXG4gICAgICAgICAgYXhpcyA9PT0gJ3gnID8gXCJcIiArIChcbiAgICAgICAgICBkaXIgPT09ICdsZWZ0JyA/IC1vZmZzZXQkMSA6IG9mZnNldCQxKSA6IFwiIFwiICsgKFxuICAgICAgICAgIGRpciA9PT0gJ3RvcCcgPyAtb2Zmc2V0JDEgOiBvZmZzZXQkMSksXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0aGlzLmZsaXAsXG4gICAgICAgICAgYm91bmRhcnkpLlxuICAgICAgICAgIHRhcmdldDtcblxuICAgICAgICAgIHRoaXMuZGlyID0gYXhpcyA9PT0gJ3gnID8geCA6IHk7XG4gICAgICAgICAgdGhpcy5hbGlnbiA9IGF4aXMgPT09ICd4JyA/IHkgOiB4O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEF4aXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGlyID09PSAndG9wJyB8fCB0aGlzLmRpciA9PT0gJ2JvdHRvbScgPyAneScgOiAneCc7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgbGV0IGFjdGl2ZSQxO1xuXG4gICAgdmFyIGRyb3AgPSB7XG4gICAgICBtaXhpbnM6IFtDb250YWluZXIsIExhenlsb2FkLCBQb3NpdGlvbiwgVG9nZ2xhYmxlXSxcblxuICAgICAgYXJnczogJ3BvcycsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG1vZGU6ICdsaXN0JyxcbiAgICAgICAgdG9nZ2xlOiBCb29sZWFuLFxuICAgICAgICBib3VuZGFyeTogQm9vbGVhbixcbiAgICAgICAgYm91bmRhcnlBbGlnbjogQm9vbGVhbixcbiAgICAgICAgZGVsYXlTaG93OiBOdW1iZXIsXG4gICAgICAgIGRlbGF5SGlkZTogTnVtYmVyLFxuICAgICAgICBjbHNEcm9wOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1vZGU6IFsnY2xpY2snLCAnaG92ZXInXSxcbiAgICAgICAgdG9nZ2xlOiAnLSAqJyxcbiAgICAgICAgYm91bmRhcnk6IHRydWUsXG4gICAgICAgIGJvdW5kYXJ5QWxpZ246IGZhbHNlLFxuICAgICAgICBkZWxheVNob3c6IDAsXG4gICAgICAgIGRlbGF5SGlkZTogODAwLFxuICAgICAgICBjbHNEcm9wOiBmYWxzZSxcbiAgICAgICAgYW5pbWF0aW9uOiBbJ3VrLWFuaW1hdGlvbi1mYWRlJ10sXG4gICAgICAgIGNsczogJ3VrLW9wZW4nLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlIH0sXG5cblxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy50cmFja2VyID0gbmV3IE1vdXNlVHJhY2tlcigpO1xuICAgICAgfSxcblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbHNEcm9wID0gdGhpcy4kcHJvcHMuY2xzRHJvcCB8fCBcInVrLVwiICsgdGhpcy4kb3B0aW9ucy5uYW1lO1xuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcm9wKTtcblxuICAgICAgICBpZiAodGhpcy50b2dnbGUgJiYgIXRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLiRjcmVhdGUoJ3RvZ2dsZScsIHF1ZXJ5KHRoaXMudG9nZ2xlLCB0aGlzLiRlbCksIHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy4kZWwsXG4gICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUgfSkuXG4gICAgICAgICAgJGVsO1xuICAgICAgICAgIGF0dHIodGhpcy50YXJnZXQsICdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5sYXp5bG9hZCh0aGlzLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgIGFjdGl2ZSQxID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiLlwiICsgdGhpcy5jbHNEcm9wICsgXCItY2xvc2VcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gJ2FbaHJlZl49XCIjXCJdJztcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF9yZWYpIHtsZXQgeyBkZWZhdWx0UHJldmVudGVkLCBjdXJyZW50OiB7IGhhc2ggfSB9ID0gX3JlZjtcbiAgICAgICAgICBpZiAoIWRlZmF1bHRQcmV2ZW50ZWQgJiYgaGFzaCAmJiAhd2l0aGluKGhhc2gsIHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdiZWZvcmVzY3JvbGwnLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKGUsIHRvZ2dsZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3codG9nZ2xlID09IG51bGwgPyB2b2lkIDAgOiB0b2dnbGUuJGVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG9nZ2xlc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKGUsIHRvZ2dsZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3codG9nZ2xlID09IG51bGwgPyB2b2lkIDAgOiB0b2dnbGUuJGVsKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZWhpZGUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmICghbWF0Y2hlcyh0aGlzLiRlbCwgJzpmb2N1cyw6aG92ZXInKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyRW50ZXIgKyBcIiBmb2N1c2luXCIsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdob3ZlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICghaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogcG9pbnRlckxlYXZlICsgXCIgZm9jdXNvdXRcIixcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ2hvdmVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKCFpc1RvdWNoKGUpICYmIGUucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG9nZ2xlZCcsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKGUsIHRvZ2dsZWQpIHtcbiAgICAgICAgICBpZiAoIXRvZ2dsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG4gICAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGFjdGl2ZSQxID0gdGhpcztcblxuICAgICAgICAgIHRoaXMudHJhY2tlci5pbml0KCk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgW1xuICAgICAgICAgIG9uKFxuICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgIHBvaW50ZXJEb3duLFxuICAgICAgICAgIChfcmVmMikgPT4ge2xldCB7IHRhcmdldCB9ID0gX3JlZjI7cmV0dXJuIChcbiAgICAgICAgICAgICAgIXdpdGhpbih0YXJnZXQsIHRoaXMuJGVsKSAmJlxuICAgICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgICAgcG9pbnRlclVwICsgXCIgXCIgKyBwb2ludGVyQ2FuY2VsICsgXCIgc2Nyb2xsXCIsXG4gICAgICAgICAgICAgIChfcmVmMykgPT4ge2xldCB7IGRlZmF1bHRQcmV2ZW50ZWQsIHR5cGUsIHRhcmdldDogbmV3VGFyZ2V0IH0gPSBfcmVmMztcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIWRlZmF1bHRQcmV2ZW50ZWQgJiZcbiAgICAgICAgICAgICAgICB0eXBlID09PSBwb2ludGVyVXAgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXQgPT09IG5ld1RhcmdldCAmJlxuICAgICAgICAgICAgICAgICEodGhpcy50YXJnZXQgJiYgd2l0aGluKHRhcmdldCwgdGhpcy50YXJnZXQpKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHJ1ZSkpO30pLFxuXG5cblxuICAgICAgICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG9uKHdpbmRvdywgJ3Jlc2l6ZScsICgpID0+IHRoaXMuJGVtaXQoKSksXG4gICAgICAgICAgb24oXG4gICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgJ3Njcm9sbCcsXG4gICAgICAgICAgKF9yZWY0KSA9PiB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmNDtyZXR1cm4gdGFyZ2V0LmNvbnRhaW5zKHRoaXMuJGVsKSAmJiB0aGlzLiRlbWl0KCk7fSxcbiAgICAgICAgICB0cnVlKV0pXG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBvbmNlKHRoaXMuJGVsLCAnaGlkZScsIGhhbmRsZXIsIHsgc2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdiZWZvcmVoaWRlJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZScsXG5cbiAgICAgICAgaGFuZGxlcihfcmVmNSkge2xldCB7IHRhcmdldCB9ID0gX3JlZjU7XG4gICAgICAgICAgaWYgKHRoaXMuJGVsICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIGFjdGl2ZSQxID1cbiAgICAgICAgICAgIGFjdGl2ZSQxID09PSBudWxsICYmIHdpdGhpbih0YXJnZXQsIHRoaXMuJGVsKSAmJiB0aGlzLmlzVG9nZ2xlZCgpID9cbiAgICAgICAgICAgIHRoaXMgOlxuICAgICAgICAgICAgYWN0aXZlJDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWN0aXZlJDEgPSB0aGlzLmlzQWN0aXZlKCkgPyBudWxsIDogYWN0aXZlJDE7XG4gICAgICAgICAgdGhpcy50cmFja2VyLmNhbmNlbCgpO1xuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHdyaXRlKCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpICYmICFoYXNDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNFbnRlcikpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3codGFyZ2V0LCBkZWxheSkge2lmICh0YXJnZXQgPT09IHZvaWQgMCkge3RhcmdldCA9IHRoaXMudGFyZ2V0O31pZiAoZGVsYXkgPT09IHZvaWQgMCkge2RlbGF5ID0gdHJ1ZTt9XG4gICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKCkgJiYgdGFyZ2V0ICYmIHRoaXMudGFyZ2V0ICYmIHRhcmdldCAhPT0gdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFjdGl2ZSQxKSB7XG4gICAgICAgICAgICBpZiAoZGVsYXkgJiYgYWN0aXZlJDEuaXNEZWxheWluZykge1xuICAgICAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gbWF0Y2hlcyh0YXJnZXQsICc6aG92ZXInKSAmJiB0aGlzLnNob3coKSwgMTApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBwcmV2O1xuICAgICAgICAgICAgd2hpbGUgKGFjdGl2ZSQxICYmIHByZXYgIT09IGFjdGl2ZSQxICYmICF3aXRoaW4odGhpcy4kZWwsIGFjdGl2ZSQxLiRlbCkpIHtcbiAgICAgICAgICAgICAgcHJldiA9IGFjdGl2ZSQxO1xuICAgICAgICAgICAgICBhY3RpdmUkMS5oaWRlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIgJiYgcGFyZW50KHRoaXMuJGVsKSAhPT0gdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZCh0aGlzLmNvbnRhaW5lciwgdGhpcy4kZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2hvd1RpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAoKSA9PiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIHRydWUpLFxuICAgICAgICAgIGRlbGF5ICYmIHRoaXMuZGVsYXlTaG93IHx8IDApO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZShkZWxheSkge2lmIChkZWxheSA9PT0gdm9pZCAwKSB7ZGVsYXkgPSB0cnVlO31cbiAgICAgICAgICBjb25zdCBoaWRlID0gKCkgPT4gdGhpcy50b2dnbGVFbGVtZW50KHRoaXMuJGVsLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuXG4gICAgICAgICAgdGhpcy5pc0RlbGF5aW5nID0gZ2V0UG9zaXRpb25lZEVsZW1lbnRzKHRoaXMuJGVsKS5zb21lKChlbCkgPT5cbiAgICAgICAgICB0aGlzLnRyYWNrZXIubW92ZXNUbyhlbCkpO1xuXG5cbiAgICAgICAgICBpZiAoZGVsYXkgJiYgdGhpcy5pc0RlbGF5aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVUaW1lciA9IHNldFRpbWVvdXQodGhpcy5oaWRlLCA1MCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZWxheSAmJiB0aGlzLmRlbGF5SGlkZSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlVGltZXIgPSBzZXRUaW1lb3V0KGhpZGUsIHRoaXMuZGVsYXlIaWRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclRpbWVycygpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zaG93VGltZXIpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7XG4gICAgICAgICAgdGhpcy5zaG93VGltZXIgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaGlkZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmlzRGVsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlJDEgPT09IHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpb24oKSB7XG4gICAgICAgICAgY29uc3QgYm91bmRhcnkgPSBxdWVyeSh0aGlzLmJvdW5kYXJ5LCB0aGlzLiRlbCkgfHwgd2luZG93O1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0Ryb3AgKyBcIi1zdGFja1wiKTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcm9wICsgXCItYm91bmRhcnlcIiwgdGhpcy5ib3VuZGFyeUFsaWduKTtcblxuICAgICAgICAgIGNvbnN0IGJvdW5kYXJ5T2Zmc2V0ID0gb2Zmc2V0KGJvdW5kYXJ5KTtcbiAgICAgICAgICBjb25zdCB0YXJnZXRPZmZzZXQgPSBvZmZzZXQodGhpcy50YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IGFsaWduVG8gPSB0aGlzLmJvdW5kYXJ5QWxpZ24gPyBib3VuZGFyeU9mZnNldCA6IHRhcmdldE9mZnNldDtcblxuICAgICAgICAgIGlmICh0aGlzLnBvc1sxXSA9PT0gJ2p1c3RpZnknKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gdGhpcy5nZXRBeGlzKCkgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgcHJvcCwgYWxpZ25Ub1twcm9wXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0aGlzLiRlbC5vZmZzZXRXaWR0aCA+XG4gICAgICAgICAgTWF0aC5tYXgoYm91bmRhcnlPZmZzZXQucmlnaHQgLSBhbGlnblRvLmxlZnQsIGFsaWduVG8ucmlnaHQgLSBib3VuZGFyeU9mZnNldC5sZWZ0KSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcm9wICsgXCItc3RhY2tcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wb3NpdGlvbkF0KHRoaXMuJGVsLCB0aGlzLmJvdW5kYXJ5QWxpZ24gPyBib3VuZGFyeSA6IHRoaXMudGFyZ2V0LCBib3VuZGFyeSk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uZWRFbGVtZW50cyhlbCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBhcHBseShlbCwgKGVsKSA9PiBjc3MoZWwsICdwb3NpdGlvbicpICE9PSAnc3RhdGljJyAmJiByZXN1bHQucHVzaChlbCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgZm9ybUN1c3RvbSA9IHtcbiAgICAgIG1peGluczogW0NsYXNzXSxcblxuICAgICAgYXJnczogJ3RhcmdldCcsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRhcmdldDogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGlucHV0KF8sICRlbCkge1xuICAgICAgICAgIHJldHVybiAkKHNlbElucHV0LCAkZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0Lm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgfSxcblxuICAgICAgICB0YXJnZXQoX3JlZiwgJGVsKSB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0YXJnZXQgJiYgKFxuICAgICAgICAgICAgdGFyZ2V0ID09PSB0cnVlICYmIHBhcmVudCh0aGlzLmlucHV0KSA9PT0gJGVsICYmIHRoaXMuaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nIHx8XG4gICAgICAgICAgICAkKHRhcmdldCwgJGVsKSkpO1xuXG4gICAgICAgIH0gfSxcblxuXG4gICAgICB1cGRhdGUoKSB7dmFyIF9pbnB1dCRmaWxlcztcbiAgICAgICAgY29uc3QgeyB0YXJnZXQsIGlucHV0IH0gPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9wdGlvbjtcbiAgICAgICAgY29uc3QgcHJvcCA9IGlzSW5wdXQodGFyZ2V0KSA/ICd2YWx1ZScgOiAndGV4dENvbnRlbnQnO1xuICAgICAgICBjb25zdCBwcmV2ID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChfaW5wdXQkZmlsZXMgPSBpbnB1dC5maWxlcykgIT0gbnVsbCAmJiBfaW5wdXQkZmlsZXNbMF0gP1xuICAgICAgICBpbnB1dC5maWxlc1swXS5uYW1lIDpcbiAgICAgICAgbWF0Y2hlcyhpbnB1dCwgJ3NlbGVjdCcpICYmIChcbiAgICAgICAgb3B0aW9uID0gJCQoJ29wdGlvbicsIGlucHV0KS5maWx0ZXIoKGVsKSA9PiBlbC5zZWxlY3RlZClbMF0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgPyBvcHRpb24udGV4dENvbnRlbnQgOlxuICAgICAgICBpbnB1dC52YWx1ZTtcblxuICAgICAgICBpZiAocHJldiAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjaGFuZ2UnLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAncmVzZXQnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiBjbG9zZXN0KHRoaXMuJGVsLCAnZm9ybScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9IH1dIH07XG5cbiAgICB2YXIgTWFyZ2luID0ge1xuICAgICAgbWl4aW5zOiBbUmVzaXplXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbWFyZ2luOiBTdHJpbmcsXG4gICAgICAgIGZpcnN0Q29sdW1uOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBtYXJnaW46ICd1ay1tYXJnaW4tc21hbGwtdG9wJyxcbiAgICAgICAgZmlyc3RDb2x1bW46ICd1ay1maXJzdC1jb2x1bW4nIH0sXG5cblxuICAgICAgcmVzaXplVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLiRlbCwgdGhpcy4kZWwuY2hpbGRyZW5dO1xuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoXG4gICAgICAgIG9ic2VydmVNdXRhdGlvbih0aGlzLiRlbCwgKCkgPT4gdGhpcy4kcmVzZXQoKSwge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSB9KSk7XG5cblxuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgY29uc3Qgcm93cyA9IGdldFJvd3ModGhpcy4kZWwuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvd3MsXG4gICAgICAgICAgICBjb2x1bW5zOiBnZXRDb2x1bW5zKHJvd3MpIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmKSB7bGV0IHsgY29sdW1ucywgcm93cyB9ID0gX3JlZjtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiByb3cpIHtcbiAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY29sdW1uLCB0aGlzLm1hcmdpbiwgcm93c1swXSAhPT0gcm93KTtcbiAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY29sdW1uLCB0aGlzLmZpcnN0Q29sdW1uLCAhIX5jb2x1bW5zWzBdLmluZGV4T2YoY29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0Um93cyhpdGVtcykge1xuICAgICAgcmV0dXJuIHNvcnRCeShpdGVtcywgJ3RvcCcsICdib3R0b20nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb2x1bW5zKHJvd3MpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBjb25zdCBzb3J0ZWQgPSBzb3J0Qnkocm93LCAnbGVmdCcsICdyaWdodCcpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNvcnRlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbHVtbnNbal0gPSBjb2x1bW5zW2pdID8gY29sdW1uc1tqXS5jb25jYXQoc29ydGVkW2pdKSA6IHNvcnRlZFtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNSdGwgPyBjb2x1bW5zLnJldmVyc2UoKSA6IGNvbHVtbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEJ5KGl0ZW1zLCBzdGFydFByb3AsIGVuZFByb3ApIHtcbiAgICAgIGNvbnN0IHNvcnRlZCA9IFtbXV07XG5cbiAgICAgIGZvciAoY29uc3QgZWwgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKCFpc1Zpc2libGUoZWwpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGltID0gZ2V0T2Zmc2V0KGVsKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gc29ydGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudCA9IHNvcnRlZFtpXTtcblxuICAgICAgICAgIGlmICghY3VycmVudFswXSkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBzdGFydERpbTtcbiAgICAgICAgICBpZiAoY3VycmVudFswXS5vZmZzZXRQYXJlbnQgPT09IGVsLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgc3RhcnREaW0gPSBnZXRPZmZzZXQoY3VycmVudFswXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpbSA9IGdldE9mZnNldChlbCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFydERpbSA9IGdldE9mZnNldChjdXJyZW50WzBdLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGltW3N0YXJ0UHJvcF0gPj0gc3RhcnREaW1bZW5kUHJvcF0gLSAxICYmIGRpbVtzdGFydFByb3BdICE9PSBzdGFydERpbVtzdGFydFByb3BdKSB7XG4gICAgICAgICAgICBzb3J0ZWQucHVzaChbZWxdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaW1bZW5kUHJvcF0gLSAxID4gc3RhcnREaW1bc3RhcnRQcm9wXSB8fCBkaW1bc3RhcnRQcm9wXSA9PT0gc3RhcnREaW1bc3RhcnRQcm9wXSkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBzb3J0ZWQudW5zaGlmdChbZWxdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc29ydGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9mZnNldChlbGVtZW50LCBvZmZzZXQpIHtpZiAob2Zmc2V0ID09PSB2b2lkIDApIHtvZmZzZXQgPSBmYWxzZTt9XG4gICAgICBsZXQgeyBvZmZzZXRUb3AsIG9mZnNldExlZnQsIG9mZnNldEhlaWdodCwgb2Zmc2V0V2lkdGggfSA9IGVsZW1lbnQ7XG5cbiAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgW29mZnNldFRvcCwgb2Zmc2V0TGVmdF0gPSBvZmZzZXRQb3NpdGlvbihlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgIGxlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgIGJvdHRvbTogb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0LFxuICAgICAgICByaWdodDogb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoIH07XG5cbiAgICB9XG5cbiAgICB2YXIgU2Nyb2xsID0ge1xuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICByZWdpc3RlclNjcm9sbExpc3RlbmVyKHRoaXMuX3VpZCwgKCkgPT4gdGhpcy4kZW1pdCgnc2Nyb2xsJykpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB1bnJlZ2lzdGVyU2Nyb2xsTGlzdGVuZXIodGhpcy5fdWlkKTtcbiAgICAgIH0gfTtcblxuXG4gICAgY29uc3Qgc2Nyb2xsTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCB1bmJpbmRTY3JvbGxMaXN0ZW5lcjtcbiAgICBmdW5jdGlvbiByZWdpc3RlclNjcm9sbExpc3RlbmVyKGlkLCBsaXN0ZW5lcikge1xuICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgPVxuICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgfHxcbiAgICAgIG9uKHdpbmRvdywgJ3Njcm9sbCcsICgpID0+IHNjcm9sbExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSksIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSB9KTtcblxuXG4gICAgICBzY3JvbGxMaXN0ZW5lcnMuc2V0KGlkLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5yZWdpc3RlclNjcm9sbExpc3RlbmVyKGlkKSB7XG4gICAgICBzY3JvbGxMaXN0ZW5lcnMuZGVsZXRlKGlkKTtcbiAgICAgIGlmICh1bmJpbmRTY3JvbGxMaXN0ZW5lciAmJiAhc2Nyb2xsTGlzdGVuZXJzLnNpemUpIHtcbiAgICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBncmlkID0ge1xuICAgICAgZXh0ZW5kczogTWFyZ2luLFxuXG4gICAgICBtaXhpbnM6IFtDbGFzcywgU2Nyb2xsXSxcblxuICAgICAgbmFtZTogJ2dyaWQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtYXNvbnJ5OiBCb29sZWFuLFxuICAgICAgICBwYXJhbGxheDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBtYXJnaW46ICd1ay1ncmlkLW1hcmdpbicsXG4gICAgICAgIGNsc1N0YWNrOiAndWstZ3JpZC1zdGFjaycsXG4gICAgICAgIG1hc29ucnk6IGZhbHNlLFxuICAgICAgICBwYXJhbGxheDogMCB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5tYXNvbnJ5ICYmIGFkZENsYXNzKHRoaXMuJGVsLCAndWstZmxleC10b3AgdWstZmxleC13cmFwLXRvcCcpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiBbXG4gICAgICB7XG4gICAgICAgIHdyaXRlKF9yZWYpIHtsZXQgeyBjb2x1bW5zIH0gPSBfcmVmO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc1N0YWNrLCBjb2x1bW5zLmxlbmd0aCA8IDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgcmVhZChkYXRhKSB7XG4gICAgICAgICAgbGV0IHsgY29sdW1ucywgcm93cyB9ID0gZGF0YTtcblxuICAgICAgICAgIC8vIEZpbHRlciBjb21wb25lbnQgbWFrZXMgZWxlbWVudHMgcG9zaXRpb25lZCBhYnNvbHV0ZVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAhY29sdW1ucy5sZW5ndGggfHxcbiAgICAgICAgICAhdGhpcy5tYXNvbnJ5ICYmICF0aGlzLnBhcmFsbGF4IHx8XG4gICAgICAgICAgcG9zaXRpb25lZEFic29sdXRlKHRoaXMuJGVsKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXRhLnRyYW5zbGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdHJhbnNsYXRlcyA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbih0aGlzLiRlbCk7XG4gICAgICAgICAgY29uc3QgY29sdW1uSGVpZ2h0cyA9IGdldENvbHVtbkhlaWdodHMoY29sdW1ucyk7XG4gICAgICAgICAgY29uc3QgbWFyZ2luID0gZ2V0TWFyZ2luVG9wKG5vZGVzLCB0aGlzLm1hcmdpbikgKiAocm93cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICBjb25zdCBlbEhlaWdodCA9IE1hdGgubWF4KC4uLmNvbHVtbkhlaWdodHMpICsgbWFyZ2luO1xuXG4gICAgICAgICAgaWYgKHRoaXMubWFzb25yeSkge1xuICAgICAgICAgICAgY29sdW1ucyA9IGNvbHVtbnMubWFwKChjb2x1bW4pID0+IHNvcnRCeSQxKGNvbHVtbiwgJ29mZnNldFRvcCcpKTtcbiAgICAgICAgICAgIHRyYW5zbGF0ZXMgPSBnZXRUcmFuc2xhdGVzKHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBwYWRkaW5nID0gTWF0aC5hYnModGhpcy5wYXJhbGxheCk7XG4gICAgICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgICAgIHBhZGRpbmcgPSBjb2x1bW5IZWlnaHRzLnJlZHVjZShcbiAgICAgICAgICAgIChuZXdQYWRkaW5nLCBoZ3QsIGkpID0+XG4gICAgICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAgIG5ld1BhZGRpbmcsXG4gICAgICAgICAgICBoZ3QgKyBtYXJnaW4gKyAoaSAlIDIgPyBwYWRkaW5nIDogcGFkZGluZyAvIDgpIC0gZWxIZWlnaHQpLFxuXG4gICAgICAgICAgICAwKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IHBhZGRpbmcsIGNvbHVtbnMsIHRyYW5zbGF0ZXMsIGhlaWdodDogdHJhbnNsYXRlcyA/IGVsSGVpZ2h0IDogJycgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMikge2xldCB7IGhlaWdodCwgcGFkZGluZyB9ID0gX3JlZjI7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAncGFkZGluZ0JvdHRvbScsIHBhZGRpbmcgfHwgJycpO1xuICAgICAgICAgIGhlaWdodCAhPT0gZmFsc2UgJiYgY3NzKHRoaXMuJGVsLCAnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMucGFyYWxsYXggJiYgcG9zaXRpb25lZEFic29sdXRlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY3JvbGxlZDogdGhpcy5wYXJhbGxheCA/XG4gICAgICAgICAgICBzY3JvbGxlZE92ZXIodGhpcy4kZWwpICogTWF0aC5hYnModGhpcy5wYXJhbGxheCkgOlxuICAgICAgICAgICAgZmFsc2UgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYzKSB7bGV0IHsgY29sdW1ucywgc2Nyb2xsZWQsIHRyYW5zbGF0ZXMgfSA9IF9yZWYzO1xuICAgICAgICAgIGlmIChzY3JvbGxlZCA9PT0gZmFsc2UgJiYgIXRyYW5zbGF0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbiwgaSkgPT5cbiAgICAgICAgICBjb2x1bW4uZm9yRWFjaCgoZWwsIGopID0+XG4gICAgICAgICAgY3NzKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICAgICFzY3JvbGxlZCAmJiAhdHJhbnNsYXRlcyA/XG4gICAgICAgICAgJycgOiBcInRyYW5zbGF0ZVkoXCIgKyAoXG5cbiAgICAgICAgICAodHJhbnNsYXRlcyAmJiAtdHJhbnNsYXRlc1tpXVtqXSkgKyAoXG4gICAgICAgICAgc2Nyb2xsZWQgPyBpICUgMiA/IHNjcm9sbGVkIDogc2Nyb2xsZWQgLyA4IDogMCkpICsgXCJweClcIikpKTtcblxuXG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydzY3JvbGwnLCAncmVzaXplJ10gfV0gfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uZWRBYnNvbHV0ZShlbCkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuKGVsKS5zb21lKChlbCkgPT4gY3NzKGVsLCAncG9zaXRpb24nKSA9PT0gJ2Fic29sdXRlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNsYXRlcyhyb3dzLCBjb2x1bW5zKSB7XG4gICAgICBjb25zdCByb3dIZWlnaHRzID0gcm93cy5tYXAoKHJvdykgPT4gTWF0aC5tYXgoLi4ucm93Lm1hcCgoZWwpID0+IGVsLm9mZnNldEhlaWdodCkpKTtcblxuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKChlbGVtZW50cykgPT4ge1xuICAgICAgICBsZXQgcHJldiA9IDA7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5tYXAoXG4gICAgICAgIChlbGVtZW50LCByb3cpID0+XG4gICAgICAgIHByZXYgKz0gcm93ID8gcm93SGVpZ2h0c1tyb3cgLSAxXSAtIGVsZW1lbnRzW3JvdyAtIDFdLm9mZnNldEhlaWdodCA6IDApO1xuXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXJnaW5Ub3Aobm9kZXMsIGNscykge1xuICAgICAgY29uc3QgW25vZGVdID0gbm9kZXMuZmlsdGVyKChlbCkgPT4gaGFzQ2xhc3MoZWwsIGNscykpO1xuXG4gICAgICByZXR1cm4gdG9GbG9hdChub2RlID8gY3NzKG5vZGUsICdtYXJnaW5Ub3AnKSA6IGNzcyhub2Rlc1swXSwgJ3BhZGRpbmdMZWZ0JykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbHVtbkhlaWdodHMoY29sdW1ucykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKChjb2x1bW4pID0+IGNvbHVtbi5yZWR1Y2UoKHN1bSwgZWwpID0+IHN1bSArIGVsLm9mZnNldEhlaWdodCwgMCkpO1xuICAgIH1cblxuICAgIHZhciBoZWlnaHRNYXRjaCA9IHtcbiAgICAgIG1peGluczogW1Jlc2l6ZV0sXG5cbiAgICAgIGFyZ3M6ICd0YXJnZXQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICAgICAgcm93OiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXQ6ICc+IConLFxuICAgICAgICByb3c6IHRydWUgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgIGdldChfcmVmLCAkZWwpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gJCQodGFyZ2V0LCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIHRoaXMuJHJlc2V0KCk7XG4gICAgICAgICAgfSB9IH0sXG5cblxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuJGVsLCB0aGlzLmVsZW1lbnRzXTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3dzOiAodGhpcy5yb3cgPyBnZXRSb3dzKHRoaXMuZWxlbWVudHMpIDogW3RoaXMuZWxlbWVudHNdKS5tYXAobWF0Y2gkMSkgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYyKSB7bGV0IHsgcm93cyB9ID0gX3JlZjI7XG4gICAgICAgICAgZm9yIChjb25zdCB7IGhlaWdodHMsIGVsZW1lbnRzIH0gb2Ygcm93cykge1xuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWwsIGkpID0+IGNzcyhlbCwgJ21pbkhlaWdodCcsIGhlaWdodHNbaV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBtYXRjaCQxKGVsZW1lbnRzKSB7XG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4geyBoZWlnaHRzOiBbJyddLCBlbGVtZW50cyB9O1xuICAgICAgfVxuXG4gICAgICBjc3MoZWxlbWVudHMsICdtaW5IZWlnaHQnLCAnJyk7XG4gICAgICBsZXQgaGVpZ2h0cyA9IGVsZW1lbnRzLm1hcChnZXRIZWlnaHQpO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4uaGVpZ2h0cyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodHM6IGVsZW1lbnRzLm1hcCgoZWwsIGkpID0+IGhlaWdodHNbaV0udG9GaXhlZCgyKSA9PT0gbWF4LnRvRml4ZWQoMikgPyAnJyA6IG1heCksXG4gICAgICAgIGVsZW1lbnRzIH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIZWlnaHQoZWxlbWVudCkge1xuICAgICAgbGV0IHN0eWxlID0gZmFsc2U7XG4gICAgICBpZiAoIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICBzdHlsZSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgY3NzKGVsZW1lbnQsICdkaXNwbGF5JywgJ2Jsb2NrJywgJ2ltcG9ydGFudCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoZWlnaHQgPSBkaW1lbnNpb25zJDEoZWxlbWVudCkuaGVpZ2h0IC0gYm94TW9kZWxBZGp1c3QoZWxlbWVudCwgJ2hlaWdodCcsICdjb250ZW50LWJveCcpO1xuXG4gICAgICBpZiAoc3R5bGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGNzcyhlbGVtZW50LCAnZGlzcGxheScsIHN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgaGVpZ2h0Vmlld3BvcnQgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgUmVzaXplXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZXhwYW5kOiBCb29sZWFuLFxuICAgICAgICBvZmZzZXRUb3A6IEJvb2xlYW4sXG4gICAgICAgIG9mZnNldEJvdHRvbTogQm9vbGVhbixcbiAgICAgICAgbWluSGVpZ2h0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGV4cGFuZDogZmFsc2UsXG4gICAgICAgIG9mZnNldFRvcDogZmFsc2UsXG4gICAgICAgIG9mZnNldEJvdHRvbTogZmFsc2UsXG4gICAgICAgIG1pbkhlaWdodDogMCB9LFxuXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBvZmZzZXRUb3AgY2hhbmdlXG4gICAgICAgIHJldHVybiBbdGhpcy4kZWwsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudF07XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZChfcmVmKSB7bGV0IHsgbWluSGVpZ2h0OiBwcmV2IH0gPSBfcmVmO1xuICAgICAgICAgIGlmICghaXNWaXNpYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBtaW5IZWlnaHQgPSAnJztcbiAgICAgICAgICBjb25zdCBib3ggPSBib3hNb2RlbEFkanVzdCh0aGlzLiRlbCwgJ2hlaWdodCcsICdjb250ZW50LWJveCcpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZXhwYW5kKSB7XG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBNYXRoLm1heChcbiAgICAgICAgICAgIGhlaWdodCh3aW5kb3cpIC0gKFxuICAgICAgICAgICAgZGltZW5zaW9ucyQxKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuaGVpZ2h0IC1cbiAgICAgICAgICAgIGRpbWVuc2lvbnMkMSh0aGlzLiRlbCkuaGVpZ2h0KSAtXG4gICAgICAgICAgICBib3gsXG4gICAgICAgICAgICAwKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvbiBtb2JpbGUgZGV2aWNlcyAoaU9TIGFuZCBBbmRyb2lkKSB3aW5kb3cuaW5uZXJIZWlnaHQgIT09IDEwMHZoXG4gICAgICAgICAgICBtaW5IZWlnaHQgPSAnY2FsYygxMDB2aCc7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldFRvcCkge1xuICAgICAgICAgICAgICBjb25zdCB7IHRvcCB9ID0gb2Zmc2V0KHRoaXMuJGVsKTtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IHRvcCA+IDAgJiYgdG9wIDwgaGVpZ2h0KHdpbmRvdykgLyAyID8gXCIgLSBcIiArIHRvcCArIFwicHhcIiA6ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vZmZzZXRCb3R0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IFwiIC0gXCIgKyBkaW1lbnNpb25zJDEodGhpcy4kZWwubmV4dEVsZW1lbnRTaWJsaW5nKS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTnVtZXJpYyh0aGlzLm9mZnNldEJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IFwiIC0gXCIgKyB0aGlzLm9mZnNldEJvdHRvbSArIFwidmhcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vZmZzZXRCb3R0b20gJiYgZW5kc1dpdGgodGhpcy5vZmZzZXRCb3R0b20sICdweCcpKSB7XG4gICAgICAgICAgICAgIG1pbkhlaWdodCArPSBcIiAtIFwiICsgdG9GbG9hdCh0aGlzLm9mZnNldEJvdHRvbSkgKyBcInB4XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHRoaXMub2Zmc2V0Qm90dG9tKSkge1xuICAgICAgICAgICAgICBtaW5IZWlnaHQgKz0gXCIgLSBcIiArIGRpbWVuc2lvbnMkMShxdWVyeSh0aGlzLm9mZnNldEJvdHRvbSwgdGhpcy4kZWwpKS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkhlaWdodCArPSAoYm94ID8gXCIgLSBcIiArIGJveCArIFwicHhcIiA6ICcnKSArIFwiKVwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IG1pbkhlaWdodCwgcHJldiB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYyKSB7bGV0IHsgbWluSGVpZ2h0IH0gPSBfcmVmMjtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsIHsgbWluSGVpZ2h0IH0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMubWluSGVpZ2h0ICYmIHRvRmxvYXQoY3NzKHRoaXMuJGVsLCAnbWluSGVpZ2h0JykpIDwgdGhpcy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ21pbkhlaWdodCcsIHRoaXMubWluSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuICAgIHZhciBTVkcgPSB7XG4gICAgICBhcmdzOiAnc3JjJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaWQ6IEJvb2xlYW4sXG4gICAgICAgIGljb246IFN0cmluZyxcbiAgICAgICAgc3JjOiBTdHJpbmcsXG4gICAgICAgIHN0eWxlOiBTdHJpbmcsXG4gICAgICAgIHdpZHRoOiBOdW1iZXIsXG4gICAgICAgIGhlaWdodDogTnVtYmVyLFxuICAgICAgICByYXRpbzogTnVtYmVyLFxuICAgICAgICBjbGFzczogU3RyaW5nLFxuICAgICAgICBzdHJva2VBbmltYXRpb246IEJvb2xlYW4sXG4gICAgICAgIGZvY3VzYWJsZTogQm9vbGVhbiwgLy8gSUUgMTFcbiAgICAgICAgYXR0cmlidXRlczogJ2xpc3QnIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICByYXRpbzogMSxcbiAgICAgICAgaW5jbHVkZTogWydzdHlsZScsICdjbGFzcycsICdmb2N1c2FibGUnXSxcbiAgICAgICAgY2xhc3M6ICcnLFxuICAgICAgICBzdHJva2VBbmltYXRpb246IGZhbHNlIH0sXG5cblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbGFzcyArPSAnIHVrLXN2Zyc7XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pY29uICYmIGluY2x1ZGVzKHRoaXMuc3JjLCAnIycpKSB7XG4gICAgICAgICAgW3RoaXMuc3JjLCB0aGlzLmljb25dID0gdGhpcy5zcmMuc3BsaXQoJyMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ZnID0gdGhpcy5nZXRTdmcoKS50aGVuKChlbCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2ZyA9IGluc2VydFNWRyhlbCwgdGhpcy4kZWwpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdmdFbCAmJiBzdmcgIT09IHRoaXMuc3ZnRWwpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlJDEodGhpcy5zdmdFbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlBdHRyaWJ1dGVzKHN2ZywgZWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdmdFbCA9IHN2ZztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG5vb3ApO1xuXG4gICAgICAgIGlmICh0aGlzLnN0cm9rZUFuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuc3ZnLnRoZW4oKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIGFwcGx5QW5pbWF0aW9uKGVsKTtcbiAgICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKGVsLCAocmVjb3Jkcywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhcHBseUFuaW1hdGlvbihlbCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN2Zy50aGVuKChzdmcpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzVm9pZEVsZW1lbnQodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmUkMShzdmcpO1xuICAgICAgICAgIHRoaXMuc3ZnRWwgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN2ZyA9IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGdldFN2ZygpIHtcbiAgICAgICAgICBpZiAoaXNUYWcodGhpcy4kZWwsICdpbWcnKSAmJiAhdGhpcy4kZWwuY29tcGxldGUgJiYgdGhpcy4kZWwubG9hZGluZyA9PT0gJ2xhenknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICAgICAgICBvbmNlKHRoaXMuJGVsLCAnbG9hZCcsICgpID0+IHJlc29sdmUodGhpcy5nZXRTdmcoKSkpKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwYXJzZVNWRyhhd2FpdCBsb2FkU1ZHKHRoaXMuc3JjKSwgdGhpcy5pY29uKSB8fCBQcm9taXNlLnJlamVjdCgnU1ZHIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhcHBseUF0dHJpYnV0ZXMoZWwsIHJlZikge1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB0aGlzLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5pbmNsdWRlLCBwcm9wKSAmJiBwcm9wIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgYXR0cihlbCwgcHJvcCwgdGhpc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBbcHJvcCwgdmFsdWVdID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0uc3BsaXQoJzonLCAyKTtcbiAgICAgICAgICAgIGF0dHIoZWwsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHJlbW92ZUF0dHIoZWwsICdpZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByb3BzID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbiAgICAgICAgICBsZXQgZGltZW5zaW9ucyA9IHByb3BzLm1hcCgocHJvcCkgPT4gdGhpc1twcm9wXSk7XG5cbiAgICAgICAgICBpZiAoIWRpbWVuc2lvbnMuc29tZSgodmFsKSA9PiB2YWwpKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gcHJvcHMubWFwKChwcm9wKSA9PiBhdHRyKHJlZiwgcHJvcCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHZpZXdCb3ggPSBhdHRyKHJlZiwgJ3ZpZXdCb3gnKTtcbiAgICAgICAgICBpZiAodmlld0JveCAmJiAhZGltZW5zaW9ucy5zb21lKCh2YWwpID0+IHZhbCkpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB2aWV3Qm94LnNwbGl0KCcgJykuc2xpY2UoMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGltZW5zaW9ucy5mb3JFYWNoKCh2YWwsIGkpID0+IGF0dHIoZWwsIHByb3BzW2ldLCB0b0Zsb2F0KHZhbCkgKiB0aGlzLnJhdGlvIHx8IG51bGwpKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgY29uc3QgbG9hZFNWRyA9IG1lbW9pemUoYXN5bmMgKHNyYykgPT4ge1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBpZiAoc3RhcnRzV2l0aChzcmMsICdkYXRhOicpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzcmMuc3BsaXQoJywnKVsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChhd2FpdCBmZXRjaChzcmMpKS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTVkcoc3ZnLCBpY29uKSB7dmFyIF9zdmc7XG4gICAgICBpZiAoaWNvbiAmJiBpbmNsdWRlcyhzdmcsICc8c3ltYm9sJykpIHtcbiAgICAgICAgc3ZnID0gcGFyc2VTeW1ib2xzKHN2ZywgaWNvbikgfHwgc3ZnO1xuICAgICAgfVxuXG4gICAgICBzdmcgPSAkKHN2Zy5zdWJzdHIoc3ZnLmluZGV4T2YoJzxzdmcnKSkpO1xuICAgICAgcmV0dXJuICgoX3N2ZyA9IHN2ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdmcuaGFzQ2hpbGROb2RlcygpKSAmJiBzdmc7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ltYm9sUmUgPSAvPHN5bWJvbChbXl0qP2lkPShbJ1wiXSkoLis/KVxcMlteXSo/PFxcLylzeW1ib2w+L2c7XG4gICAgY29uc3Qgc3ltYm9scyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTeW1ib2xzKHN2ZywgaWNvbikge1xuICAgICAgaWYgKCFzeW1ib2xzW3N2Z10pIHtcbiAgICAgICAgc3ltYm9sc1tzdmddID0ge307XG5cbiAgICAgICAgc3ltYm9sUmUubGFzdEluZGV4ID0gMDtcblxuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHN5bWJvbFJlLmV4ZWMoc3ZnKSkge1xuICAgICAgICAgIHN5bWJvbHNbc3ZnXVttYXRjaFszXV0gPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlwiICsgbWF0Y2hbMV0gKyBcInN2Zz5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3ltYm9sc1tzdmddW2ljb25dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uKGVsKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBnZXRNYXhQYXRoTGVuZ3RoKGVsKTtcblxuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS11ay1hbmltYXRpb24tc3Ryb2tlJywgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXhQYXRoTGVuZ3RoKGVsKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKFxuICAgICAgTWF0aC5tYXgoXG4gICAgICAwLFxuICAgICAgLi4uJCQoJ1tzdHJva2VdJywgZWwpLm1hcCgoc3Ryb2tlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHN0cm9rZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0pKSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydFNWRyhlbCwgcm9vdCkge1xuICAgICAgaWYgKGlzVm9pZEVsZW1lbnQocm9vdCkgfHwgaXNUYWcocm9vdCwgJ2NhbnZhcycpKSB7XG4gICAgICAgIHJvb3QuaGlkZGVuID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBuZXh0ID0gcm9vdC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIHJldHVybiBlcXVhbHMoZWwsIG5leHQpID8gbmV4dCA6IGFmdGVyKHJvb3QsIGVsKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGFzdCA9IHJvb3QubGFzdEVsZW1lbnRDaGlsZDtcbiAgICAgIHJldHVybiBlcXVhbHMoZWwsIGxhc3QpID8gbGFzdCA6IGFwcGVuZChyb290LCBlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1YWxzKGVsLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGlzVGFnKGVsLCAnc3ZnJykgJiYgaXNUYWcob3RoZXIsICdzdmcnKSAmJiBpbm5lckhUTUwoZWwpID09PSBpbm5lckhUTUwob3RoZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlubmVySFRNTChlbCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgIGVsLmlubmVySFRNTCB8fFxuICAgICAgbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhlbCkucmVwbGFjZSgvPHN2Zy4qPz4oLio/KTxcXC9zdmc+L2csICckMScpKS5cbiAgICAgIHJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgfVxuXG4gICAgdmFyIGNsb3NlSWNvbiA9IFwiPHN2ZyB3aWR0aD1cXFwiMTRcXFwiIGhlaWdodD1cXFwiMTRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAxNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiMVxcXCIgeTE9XFxcIjFcXFwiIHgyPVxcXCIxM1xcXCIgeTI9XFxcIjEzXFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjEzXFxcIiB5MT1cXFwiMVxcXCIgeDI9XFxcIjFcXFwiIHkyPVxcXCIxM1xcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIGNsb3NlTGFyZ2UgPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgeDE9XFxcIjFcXFwiIHkxPVxcXCIxXFxcIiB4Mj1cXFwiMTlcXFwiIHkyPVxcXCIxOVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIHgxPVxcXCIxOVxcXCIgeTE9XFxcIjFcXFwiIHgyPVxcXCIxXFxcIiB5Mj1cXFwiMTlcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBtYXJrZXIgPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiOVxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMTFcXFwiLz48cmVjdCB4PVxcXCI0XFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMTFcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG5hdmJhclRvZ2dsZUljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHk9XFxcIjE1XFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG92ZXJsYXlJY29uID0gXCI8c3ZnIHdpZHRoPVxcXCI0MFxcXCIgaGVpZ2h0PVxcXCI0MFxcXCIgdmlld0JveD1cXFwiMCAwIDQwIDQwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjE5XFxcIiB5PVxcXCIwXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI0MFxcXCIvPjxyZWN0IHg9XFxcIjBcXFwiIHk9XFxcIjE5XFxcIiB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHBhZ2luYXRpb25OZXh0ID0gXCI8c3ZnIHdpZHRoPVxcXCI3XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiB2aWV3Qm94PVxcXCIwIDAgNyAxMlxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgcG9pbnRzPVxcXCIxIDEgNiA2IDEgMTFcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBwYWdpbmF0aW9uUHJldmlvdXMgPSBcIjxzdmcgd2lkdGg9XFxcIjdcXFwiIGhlaWdodD1cXFwiMTJcXFwiIHZpZXdCb3g9XFxcIjAgMCA3IDEyXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBwb2ludHM9XFxcIjYgMSAxIDYgNiAxMVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNlYXJjaEljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiOVxcXCIgY3k9XFxcIjlcXFwiIHI9XFxcIjdcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTQsMTQgTDE4LDE4IEwxNCwxNCBaXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2VhcmNoTGFyZ2UgPSBcIjxzdmcgd2lkdGg9XFxcIjQwXFxcIiBoZWlnaHQ9XFxcIjQwXFxcIiB2aWV3Qm94PVxcXCIwIDAgNDAgNDBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS44XFxcIiBjeD1cXFwiMTcuNVxcXCIgY3k9XFxcIjE3LjVcXFwiIHI9XFxcIjE2LjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS44XFxcIiB4MT1cXFwiMzhcXFwiIHkxPVxcXCIzOVxcXCIgeDI9XFxcIjI5XFxcIiB5Mj1cXFwiMzBcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzZWFyY2hOYXZiYXIgPSBcIjxzdmcgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiMTAuNVxcXCIgY3k9XFxcIjEwLjVcXFwiIHI9XFxcIjkuNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHgxPVxcXCIyM1xcXCIgeTE9XFxcIjIzXFxcIiB4Mj1cXFwiMTdcXFwiIHkyPVxcXCIxN1xcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNsaWRlbmF2TmV4dCA9IFwiPHN2ZyB3aWR0aD1cXFwiMTRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgcG9pbnRzPVxcXCIxLjIyNSwyMyAxMi43NzUsMTIgMS4yMjUsMSBcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzbGlkZW5hdk5leHRMYXJnZSA9IFwiPHN2ZyB3aWR0aD1cXFwiMjVcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNSA0MFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjJcXFwiIHBvaW50cz1cXFwiNC4wMDIsMzguNTQ3IDIyLjUyNywyMC4wMjQgNCwxLjUgXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2xpZGVuYXZQcmV2aW91cyA9IFwiPHN2ZyB3aWR0aD1cXFwiMTRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgcG9pbnRzPVxcXCIxMi43NzUsMSAxLjIyNSwxMiAxMi43NzUsMjMgXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2xpZGVuYXZQcmV2aW91c0xhcmdlID0gXCI8c3ZnIHdpZHRoPVxcXCIyNVxcXCIgaGVpZ2h0PVxcXCI0MFxcXCIgdmlld0JveD1cXFwiMCAwIDI1IDQwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMlxcXCIgcG9pbnRzPVxcXCIyMC41MjcsMS41IDIsMjAuMDI0IDIwLjUyNSwzOC41NDcgXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc3Bpbm5lciA9IFwiPHN2ZyB3aWR0aD1cXFwiMzBcXFwiIGhlaWdodD1cXFwiMzBcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMCAzMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjE1XFxcIiBjeT1cXFwiMTVcXFwiIHI9XFxcIjE0XFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgdG90b3AgPSBcIjxzdmcgd2lkdGg9XFxcIjE4XFxcIiBoZWlnaHQ9XFxcIjEwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTggMTBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIHBvaW50cz1cXFwiMSA5IDkgMSAxNyA5IFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgY29uc3QgaWNvbnMgPSB7XG4gICAgICBzcGlubmVyLFxuICAgICAgdG90b3AsXG4gICAgICBtYXJrZXIsXG4gICAgICAnY2xvc2UtaWNvbic6IGNsb3NlSWNvbixcbiAgICAgICdjbG9zZS1sYXJnZSc6IGNsb3NlTGFyZ2UsXG4gICAgICAnbmF2YmFyLXRvZ2dsZS1pY29uJzogbmF2YmFyVG9nZ2xlSWNvbixcbiAgICAgICdvdmVybGF5LWljb24nOiBvdmVybGF5SWNvbixcbiAgICAgICdwYWdpbmF0aW9uLW5leHQnOiBwYWdpbmF0aW9uTmV4dCxcbiAgICAgICdwYWdpbmF0aW9uLXByZXZpb3VzJzogcGFnaW5hdGlvblByZXZpb3VzLFxuICAgICAgJ3NlYXJjaC1pY29uJzogc2VhcmNoSWNvbixcbiAgICAgICdzZWFyY2gtbGFyZ2UnOiBzZWFyY2hMYXJnZSxcbiAgICAgICdzZWFyY2gtbmF2YmFyJzogc2VhcmNoTmF2YmFyLFxuICAgICAgJ3NsaWRlbmF2LW5leHQnOiBzbGlkZW5hdk5leHQsXG4gICAgICAnc2xpZGVuYXYtbmV4dC1sYXJnZSc6IHNsaWRlbmF2TmV4dExhcmdlLFxuICAgICAgJ3NsaWRlbmF2LXByZXZpb3VzJzogc2xpZGVuYXZQcmV2aW91cyxcbiAgICAgICdzbGlkZW5hdi1wcmV2aW91cy1sYXJnZSc6IHNsaWRlbmF2UHJldmlvdXNMYXJnZSB9O1xuXG5cbiAgICBjb25zdCBJY29uID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCQzLFxuXG4gICAgICBleHRlbmRzOiBTVkcsXG5cbiAgICAgIGFyZ3M6ICdpY29uJyxcblxuICAgICAgcHJvcHM6IFsnaWNvbiddLFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGluY2x1ZGU6IFsnZm9jdXNhYmxlJ10gfSxcblxuXG4gICAgICBpc0ljb246IHRydWUsXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCAndWstaWNvbicpO1xuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBnZXRTdmcoKSB7XG4gICAgICAgICAgY29uc3QgaWNvbiA9IGdldEljb24odGhpcy5pY29uKTtcblxuICAgICAgICAgIGlmICghaWNvbikge1xuICAgICAgICAgICAgdGhyb3cgJ0ljb24gbm90IGZvdW5kLic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgIH0gfSB9O1xuXG4gICAgY29uc3QgSWNvbkNvbXBvbmVudCA9IHtcbiAgICAgIGFyZ3M6IGZhbHNlLFxuXG4gICAgICBleHRlbmRzOiBJY29uLFxuXG4gICAgICBkYXRhOiAodm0pID0+ICh7XG4gICAgICAgIGljb246IGh5cGhlbmF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zLm5hbWUpIH0pLFxuXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLiRuYW1lKTtcbiAgICAgIH0gfTtcblxuXG4gICAgY29uc3QgU2xpZGVuYXYgPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLXNsaWRlbmF2Jyk7XG4gICAgICAgIGNvbnN0IGljb24gPSB0aGlzLiRwcm9wcy5pY29uO1xuICAgICAgICB0aGlzLmljb24gPSBoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLXNsaWRlbmF2LWxhcmdlJykgPyBpY29uICsgXCItbGFyZ2VcIiA6IGljb247XG4gICAgICB9IH07XG5cblxuICAgIGNvbnN0IFNlYXJjaCA9IHtcbiAgICAgIGV4dGVuZHM6IEljb25Db21wb25lbnQsXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuaWNvbiA9XG4gICAgICAgIGhhc0NsYXNzKHRoaXMuJGVsLCAndWstc2VhcmNoLWljb24nKSAmJiBwYXJlbnRzKHRoaXMuJGVsLCAnLnVrLXNlYXJjaC1sYXJnZScpLmxlbmd0aCA/XG4gICAgICAgICdzZWFyY2gtbGFyZ2UnIDpcbiAgICAgICAgcGFyZW50cyh0aGlzLiRlbCwgJy51ay1zZWFyY2gtbmF2YmFyJykubGVuZ3RoID9cbiAgICAgICAgJ3NlYXJjaC1uYXZiYXInIDpcbiAgICAgICAgdGhpcy4kcHJvcHMuaWNvbjtcbiAgICAgIH0gfTtcblxuXG4gICAgY29uc3QgQ2xvc2UgPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLmljb24gPSBcImNsb3NlLVwiICsgKGhhc0NsYXNzKHRoaXMuJGVsLCAndWstY2xvc2UtbGFyZ2UnKSA/ICdsYXJnZScgOiAnaWNvbicpO1xuICAgICAgfSB9O1xuXG5cbiAgICBjb25zdCBTcGlubmVyID0ge1xuICAgICAgZXh0ZW5kczogSWNvbkNvbXBvbmVudCxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBnZXRTdmcoKSB7XG4gICAgICAgICAgY29uc3QgaWNvbiA9IGF3YWl0IEljb24ubWV0aG9kcy5nZXRTdmcuY2FsbCh0aGlzKTtcblxuICAgICAgICAgIGlmICh0aGlzLnJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICBjc3MoJCgnY2lyY2xlJywgaWNvbiksICdzdHJva2VXaWR0aCcsIDEgLyB0aGlzLnJhdGlvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaWNvbjtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgY29uc3QgcGFyc2VkID0ge307XG4gICAgZnVuY3Rpb24gaW5zdGFsbCQzKFVJa2l0KSB7XG4gICAgICBVSWtpdC5pY29uLmFkZCA9IChuYW1lLCBzdmcpID0+IHtcbiAgICAgICAgY29uc3QgYWRkZWQgPSBpc1N0cmluZyhuYW1lKSA/IHsgW25hbWVdOiBzdmcgfSA6IG5hbWU7XG4gICAgICAgIGVhY2goYWRkZWQsIChzdmcsIG5hbWUpID0+IHtcbiAgICAgICAgICBpY29uc1tuYW1lXSA9IHN2ZztcbiAgICAgICAgICBkZWxldGUgcGFyc2VkW25hbWVdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoVUlraXQuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgYXBwbHkoZG9jdW1lbnQuYm9keSwgKGVsKSA9PlxuICAgICAgICAgIGVhY2goVUlraXQuZ2V0Q29tcG9uZW50cyhlbCksIChjbXApID0+IHtcbiAgICAgICAgICAgIGNtcC4kb3B0aW9ucy5pc0ljb24gJiYgY21wLmljb24gaW4gYWRkZWQgJiYgY21wLiRyZXNldCgpO1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEljb24oaWNvbikge1xuICAgICAgaWYgKCFpY29uc1tpY29uXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJzZWRbaWNvbl0pIHtcbiAgICAgICAgcGFyc2VkW2ljb25dID0gJCgoaWNvbnNbYXBwbHlSdGwoaWNvbildIHx8IGljb25zW2ljb25dKS50cmltKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VkW2ljb25dLmNsb25lTm9kZSh0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVJ0bChpY29uKSB7XG4gICAgICByZXR1cm4gaXNSdGwgPyBzd2FwKHN3YXAoaWNvbiwgJ2xlZnQnLCAncmlnaHQnKSwgJ3ByZXZpb3VzJywgJ25leHQnKSA6IGljb247XG4gICAgfVxuXG4gICAgY29uc3QgbmF0aXZlTGF6eUxvYWQgPSBpbkJyb3dzZXIgJiYgJ2xvYWRpbmcnIGluIEhUTUxJbWFnZUVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgdmFyIGltZyA9IHtcbiAgICAgIGFyZ3M6ICdkYXRhU3JjJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZGF0YVNyYzogU3RyaW5nLFxuICAgICAgICBzb3VyY2VzOiBTdHJpbmcsXG4gICAgICAgIG9mZnNldFRvcDogU3RyaW5nLFxuICAgICAgICBvZmZzZXRMZWZ0OiBTdHJpbmcsXG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICBsb2FkaW5nOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRhdGFTcmM6ICcnLFxuICAgICAgICBzb3VyY2VzOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0VG9wOiAnNTB2aCcsXG4gICAgICAgIG9mZnNldExlZnQ6ICc1MHZ3JyxcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgbG9hZGluZzogJ2xhenknIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5sb2FkaW5nICE9PSAnbGF6eScpIHtcbiAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXQgPSBbdGhpcy4kZWwsIC4uLnF1ZXJ5QWxsKHRoaXMuJHByb3BzLnRhcmdldCwgdGhpcy4kZWwpXTtcblxuICAgICAgICBpZiAobmF0aXZlTGF6eUxvYWQgJiYgaXNJbWcodGhpcy4kZWwpKSB7XG4gICAgICAgICAgdGhpcy4kZWwubG9hZGluZyA9ICdsYXp5JztcbiAgICAgICAgICBzZXRTcmNBdHRycyh0aGlzLiRlbCk7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVuc3VyZVNyY0F0dHJpYnV0ZSh0aGlzLiRlbCk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvb3RNYXJnaW46IHRvUHgodGhpcy5vZmZzZXRUb3AsICdoZWlnaHQnKSArIFwicHggXCIgKyB0b1B4KFxuICAgICAgICAgIHRoaXMub2Zmc2V0TGVmdCxcbiAgICAgICAgICAnd2lkdGgnKSArIFwicHhcIiB9KSk7XG5cblxuXG5cbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEuaW1hZ2UpIHtcbiAgICAgICAgICB0aGlzLl9kYXRhLmltYWdlLm9ubG9hZCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGxvYWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2RhdGEuaW1hZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmltYWdlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGltYWdlID0gaXNJbWcodGhpcy4kZWwpID9cbiAgICAgICAgICB0aGlzLiRlbCA6XG4gICAgICAgICAgZ2V0SW1hZ2VGcm9tRWxlbWVudCh0aGlzLiRlbCwgdGhpcy5kYXRhU3JjLCB0aGlzLnNvdXJjZXMpO1xuXG4gICAgICAgICAgcmVtb3ZlQXR0cihpbWFnZSwgJ2xvYWRpbmcnKTtcbiAgICAgICAgICBzZXRTcmNBdHRycyh0aGlzLiRlbCwgaW1hZ2UuY3VycmVudFNyYyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gc2V0U3JjQXR0cnMoZWwsIHNyYykge1xuICAgICAgaWYgKGlzSW1nKGVsKSkge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gcGFyZW50KGVsKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBpc1BpY3R1cmUocGFyZW50Tm9kZSkgPyBjaGlsZHJlbihwYXJlbnROb2RlKSA6IFtlbF07XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiBzZXRTb3VyY2VQcm9wcyhlbCwgZWwpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9ICFpbmNsdWRlcyhlbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UsIHNyYyk7XG4gICAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgICBjc3MoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnLCBcInVybChcIiArIGVzY2FwZShzcmMpICsgXCIpXCIpO1xuICAgICAgICAgIHRyaWdnZXIoZWwsIGNyZWF0ZUV2ZW50KCdsb2FkJywgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNyY1Byb3BzID0gWydkYXRhLXNyYycsICdkYXRhLXNyY3NldCcsICdzaXplcyddO1xuICAgIGZ1bmN0aW9uIHNldFNvdXJjZVByb3BzKHNvdXJjZUVsLCB0YXJnZXRFbCkge1xuICAgICAgc3JjUHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGEoc291cmNlRWwsIHByb3ApO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBhdHRyKHRhcmdldEVsLCBwcm9wLnJlcGxhY2UoL14oZGF0YS0pKy8sICcnKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbWFnZUZyb21FbGVtZW50KGVsLCBzcmMsIHNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICB3cmFwSW5QaWN0dXJlKGltZywgc291cmNlcyk7XG4gICAgICBzZXRTb3VyY2VQcm9wcyhlbCwgaW1nKTtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHNldFNyY0F0dHJzKGVsLCBpbWcuY3VycmVudFNyYyk7XG4gICAgICB9O1xuICAgICAgYXR0cihpbWcsICdzcmMnLCBzcmMpO1xuICAgICAgcmV0dXJuIGltZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwSW5QaWN0dXJlKGltZywgc291cmNlcykge1xuICAgICAgc291cmNlcyA9IHBhcnNlU291cmNlcyhzb3VyY2VzKTtcblxuICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBpY3R1cmUgPSBmcmFnbWVudCgnPHBpY3R1cmU+Jyk7XG4gICAgICAgIGZvciAoY29uc3QgYXR0cnMgb2Ygc291cmNlcykge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGZyYWdtZW50KCc8c291cmNlPicpO1xuICAgICAgICAgIGF0dHIoc291cmNlLCBhdHRycyk7XG4gICAgICAgICAgYXBwZW5kKHBpY3R1cmUsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKHBpY3R1cmUsIGltZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTb3VyY2VzKHNvdXJjZXMpIHtcbiAgICAgIGlmICghc291cmNlcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydHNXaXRoKHNvdXJjZXMsICdbJykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzb3VyY2VzID0gSlNPTi5wYXJzZShzb3VyY2VzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlcyA9IHBhcnNlT3B0aW9ucyhzb3VyY2VzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0FycmF5KHNvdXJjZXMpKSB7XG4gICAgICAgIHNvdXJjZXMgPSBbc291cmNlc107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3VyY2VzLmZpbHRlcigoc291cmNlKSA9PiAhaXNFbXB0eShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbnN1cmVTcmNBdHRyaWJ1dGUoZWwpIHtcbiAgICAgIGlmIChpc0ltZyhlbCkgJiYgIWhhc0F0dHIoZWwsICdzcmMnKSkge1xuICAgICAgICBhdHRyKGVsLCAnc3JjJywgJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjwvc3ZnPicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUGljdHVyZShlbCkge1xuICAgICAgcmV0dXJuIGlzVGFnKGVsLCAncGljdHVyZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW1nKGVsKSB7XG4gICAgICByZXR1cm4gaXNUYWcoZWwsICdpbWcnKTtcbiAgICB9XG5cbiAgICB2YXIgTWVkaWEgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBtZWRpYTogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWVkaWE6IGZhbHNlIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBjb25zdCBtZWRpYSA9IHRvTWVkaWEodGhpcy5tZWRpYSk7XG4gICAgICAgIHRoaXMubWVkaWFPYmogPSB3aW5kb3cubWF0Y2hNZWRpYShtZWRpYSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5tYXRjaE1lZGlhID0gdGhpcy5tZWRpYU9iai5tYXRjaGVzO1xuICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsIGNyZWF0ZUV2ZW50KCdtZWRpYWNoYW5nZScsIGZhbHNlLCB0cnVlLCBbdGhpcy5tZWRpYU9ial0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vZmZNZWRpYU9iaiA9IG9uKHRoaXMubWVkaWFPYmosICdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlcigpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge3ZhciBfdGhpcyRvZmZNZWRpYU9iajtcbiAgICAgICAgKF90aGlzJG9mZk1lZGlhT2JqID0gdGhpcy5vZmZNZWRpYU9iaikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9mZk1lZGlhT2JqLmNhbGwodGhpcyk7XG4gICAgICB9IH07XG5cblxuICAgIGZ1bmN0aW9uIHRvTWVkaWEodmFsdWUpIHtcbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGgodmFsdWUsICdAJykpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gXCJicmVha3BvaW50LVwiICsgdmFsdWUuc3Vic3RyKDEpO1xuICAgICAgICAgIHZhbHVlID0gdG9GbG9hdChnZXRDc3NWYXIobmFtZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUgJiYgaXNOdW1lcmljKHZhbHVlKSA/IFwiKG1pbi13aWR0aDogXCIgKyB2YWx1ZSArIFwicHgpXCIgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgbGVhZGVyID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIE1lZGlhLCBSZXNpemVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBmaWxsOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGZpbGw6ICcnLFxuICAgICAgICBjbHNXcmFwcGVyOiAndWstbGVhZGVyLWZpbGwnLFxuICAgICAgICBjbHNIaWRlOiAndWstbGVhZGVyLWhpZGUnLFxuICAgICAgICBhdHRyRmlsbDogJ2RhdGEtZmlsbCcgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBmaWxsKF9yZWYpIHtsZXQgeyBmaWxsIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBmaWxsIHx8IGdldENzc1ZhcignbGVhZGVyLWZpbGwtY29udGVudCcpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBbdGhpcy53cmFwcGVyXSA9IHdyYXBJbm5lcih0aGlzLiRlbCwgXCI8c3BhbiBjbGFzcz1cXFwiXCIgKyB0aGlzLmNsc1dyYXBwZXIgKyBcIlxcXCI+XCIpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB1bndyYXAodGhpcy53cmFwcGVyLmNoaWxkTm9kZXMpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLnRydW5jKHRoaXMuJGVsLm9mZnNldFdpZHRoIC8gMik7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBmaWxsOiB0aGlzLmZpbGwsXG4gICAgICAgICAgICBoaWRlOiAhdGhpcy5tYXRjaE1lZGlhIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMikge2xldCB7IHdpZHRoLCBmaWxsLCBoaWRlIH0gPSBfcmVmMjtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLndyYXBwZXIsIHRoaXMuY2xzSGlkZSwgaGlkZSk7XG4gICAgICAgICAgYXR0cih0aGlzLndyYXBwZXIsIHRoaXMuYXR0ckZpbGwsIG5ldyBBcnJheSh3aWR0aCkuam9pbihmaWxsKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuICAgIGNvbnN0IGFjdGl2ZSA9IFtdO1xuXG4gICAgdmFyIE1vZGFsID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIENvbnRhaW5lciwgVG9nZ2xhYmxlXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc2VsUGFuZWw6IFN0cmluZyxcbiAgICAgICAgc2VsQ2xvc2U6IFN0cmluZyxcbiAgICAgICAgZXNjQ2xvc2U6IEJvb2xlYW4sXG4gICAgICAgIGJnQ2xvc2U6IEJvb2xlYW4sXG4gICAgICAgIHN0YWNrOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjbHM6ICd1ay1vcGVuJyxcbiAgICAgICAgZXNjQ2xvc2U6IHRydWUsXG4gICAgICAgIGJnQ2xvc2U6IHRydWUsXG4gICAgICAgIG92ZXJsYXk6IHRydWUsXG4gICAgICAgIHN0YWNrOiBmYWxzZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHBhbmVsKF9yZWYsICRlbCkge2xldCB7IHNlbFBhbmVsIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAkKHNlbFBhbmVsLCAkZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zaXRpb25FbGVtZW50KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhbmVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJnQ2xvc2UoX3JlZjIpIHtsZXQgeyBiZ0Nsb3NlIH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gYmdDbG9zZSAmJiB0aGlzLnBhbmVsO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgYmVmb3JlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzKGFjdGl2ZSwgdGhpcykpIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbENsb3NlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKCkgPT09IGluY2x1ZGVzKGFjdGl2ZSwgdGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3Jlc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoaW5jbHVkZXMoYWN0aXZlLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5zdGFjayAmJiBhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChhY3RpdmUubWFwKChtb2RhbCkgPT4gbW9kYWwuaGlkZSgpKSkudGhlbih0aGlzLnNob3cpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgY29uc3QgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICBpZiAod2lkdGgod2luZG93KSA+IGRvY0VsLmNsaWVudFdpZHRoICYmIHRoaXMub3ZlcmxheSkge1xuICAgICAgICAgICAgY3NzKGRvY3VtZW50LmJvZHksICdvdmVyZmxvd1knLCAnc2Nyb2xsJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ3pJbmRleCcsIHRvRmxvYXQoY3NzKHRoaXMuJGVsLCAnekluZGV4JykpICsgYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkQ2xhc3MoZG9jRWwsIHRoaXMuY2xzUGFnZSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5iZ0Nsb3NlKSB7XG4gICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgICAnaGlkZScsXG4gICAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlckRvd24sIChfcmVmMykgPT4ge2xldCB7IHRhcmdldCB9ID0gX3JlZjM7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGFzdChhY3RpdmUpICE9PSB0aGlzIHx8XG4gICAgICAgICAgICAgIHRoaXMub3ZlcmxheSAmJiAhd2l0aGluKHRhcmdldCwgdGhpcy4kZWwpIHx8XG4gICAgICAgICAgICAgIHdpdGhpbih0YXJnZXQsIHRoaXMucGFuZWwpKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb25jZShcbiAgICAgICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgICAgIHBvaW50ZXJVcCArIFwiIFwiICsgcG9pbnRlckNhbmNlbCArIFwiIHNjcm9sbFwiLFxuICAgICAgICAgICAgICAoX3JlZjQpID0+IHtsZXQgeyBkZWZhdWx0UHJldmVudGVkLCB0eXBlLCB0YXJnZXQ6IG5ld1RhcmdldCB9ID0gX3JlZjQ7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFkZWZhdWx0UHJldmVudGVkICYmXG4gICAgICAgICAgICAgICAgdHlwZSA9PT0gcG9pbnRlclVwICYmXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID09PSBuZXdUYXJnZXQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0cnVlKTtcblxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7IHNlbGY6IHRydWUgfSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5lc2NDbG9zZSkge1xuICAgICAgICAgICAgb25jZShcbiAgICAgICAgICAgIHRoaXMuJGVsLFxuICAgICAgICAgICAgJ2hpZGUnLFxuICAgICAgICAgICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcgJiYgbGFzdChhY3RpdmUpID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeyBzZWxmOiB0cnVlIH0pO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvd24nLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBpZiAoIWlzRm9jdXNhYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgYXR0cih0aGlzLiRlbCwgJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEkKCc6Zm9jdXMnLCB0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZGVuJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKGluY2x1ZGVzKGFjdGl2ZSwgdGhpcykpIHtcbiAgICAgICAgICAgIGFjdGl2ZS5zcGxpY2UoYWN0aXZlLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgY3NzKGRvY3VtZW50LmJvZHksICdvdmVyZmxvd1knLCAnJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAnekluZGV4JywgJycpO1xuXG4gICAgICAgICAgaWYgKCFhY3RpdmUuc29tZSgobW9kYWwpID0+IG1vZGFsLmNsc1BhZ2UgPT09IHRoaXMuY2xzUGFnZSkpIHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy5jbHNQYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc1RvZ2dsZWQoKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIgJiYgcGFyZW50KHRoaXMuJGVsKSAhPT0gdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZCh0aGlzLmNvbnRhaW5lciwgdGhpcy4kZWwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PlxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuc2hvdygpLnRoZW4ocmVzb2x2ZSkpKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIHRydWUsIGFuaW1hdGUodGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGFuaW1hdGUodGhpcykpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBhbmltYXRlKF9yZWY1KSB7bGV0IHsgdHJhbnNpdGlvbkVsZW1lbnQsIF90b2dnbGUgfSA9IF9yZWY1O1xuICAgICAgcmV0dXJuIChlbCwgc2hvdykgPT5cbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICBvbmNlKGVsLCAnc2hvdyBoaWRlJywgKCkgPT4ge1xuICAgICAgICBlbC5fcmVqZWN0ICYmIGVsLl9yZWplY3QoKTtcbiAgICAgICAgZWwuX3JlamVjdCA9IHJlamVjdDtcblxuICAgICAgICBfdG9nZ2xlKGVsLCBzaG93KTtcblxuICAgICAgICBjb25zdCBvZmYgPSBvbmNlKFxuICAgICAgICB0cmFuc2l0aW9uRWxlbWVudCxcbiAgICAgICAgJ3RyYW5zaXRpb25zdGFydCcsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBvbmNlKHRyYW5zaXRpb25FbGVtZW50LCAndHJhbnNpdGlvbmVuZCB0cmFuc2l0aW9uY2FuY2VsJywgcmVzb2x2ZSwge1xuICAgICAgICAgICAgc2VsZjogdHJ1ZSB9KTtcblxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0sXG4gICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuXG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgb2ZmKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCB0b01zKGNzcyh0cmFuc2l0aW9uRWxlbWVudCwgJ3RyYW5zaXRpb25EdXJhdGlvbicpKSk7XG4gICAgICB9KSkuXG4gICAgICB0aGVuKCgpID0+IGRlbGV0ZSBlbC5fcmVqZWN0KTtcbiAgICB9XG5cbiAgICB2YXIgbW9kYWwgPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsJDIsXG5cbiAgICAgIG1peGluczogW01vZGFsXSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBjbHNQYWdlOiAndWstbW9kYWwtcGFnZScsXG4gICAgICAgIHNlbFBhbmVsOiAnLnVrLW1vZGFsLWRpYWxvZycsXG4gICAgICAgIHNlbENsb3NlOlxuICAgICAgICAnLnVrLW1vZGFsLWNsb3NlLCAudWstbW9kYWwtY2xvc2UtZGVmYXVsdCwgLnVrLW1vZGFsLWNsb3NlLW91dHNpZGUsIC51ay1tb2RhbC1jbG9zZS1mdWxsJyB9LFxuXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChoYXNDbGFzcyh0aGlzLnBhbmVsLCAndWstbWFyZ2luLWF1dG8tdmVydGljYWwnKSkge1xuICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsICd1ay1mbGV4Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoZWlnaHQodGhpcy4kZWwpOyAvLyBmb3JjZSByZWZsb3dcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGRlbicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsICd1ay1mbGV4Jyk7XG4gICAgICAgIH0gfV0gfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwkMihfcmVmKSB7bGV0IHsgbW9kYWwgfSA9IF9yZWY7XG4gICAgICBtb2RhbC5kaWFsb2cgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkaWFsb2cgPSBtb2RhbChcIjxkaXYgY2xhc3M9XFxcInVrLW1vZGFsXFxcIj4gPGRpdiBjbGFzcz1cXFwidWstbW9kYWwtZGlhbG9nXFxcIj5cIiArXG5cbiAgICAgICAgY29udGVudCArIFwiPC9kaXY+IDwvZGl2PlwiLFxuXG4gICAgICAgIG9wdGlvbnMpO1xuXG5cbiAgICAgICAgZGlhbG9nLnNob3coKTtcblxuICAgICAgICBvbihcbiAgICAgICAgZGlhbG9nLiRlbCxcbiAgICAgICAgJ2hpZGRlbicsXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICBkaWFsb2cuJGRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuXG4gICAgICAgIHJldHVybiBkaWFsb2c7XG4gICAgICB9O1xuXG4gICAgICBtb2RhbC5hbGVydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcGVuRGlhbG9nKFxuICAgICAgICAoX3JlZjIpID0+IHtsZXQgeyBsYWJlbHMgfSA9IF9yZWYyO3JldHVybiBcIjxkaXYgY2xhc3M9XFxcInVrLW1vZGFsLWJvZHlcXFwiPlwiICsgKFxuICAgICAgICAgIGlzU3RyaW5nKG1lc3NhZ2UpID8gbWVzc2FnZSA6IGh0bWwobWVzc2FnZSkpICsgXCI8L2Rpdj4gPGRpdiBjbGFzcz1cXFwidWstbW9kYWwtZm9vdGVyIHVrLXRleHQtcmlnaHRcXFwiPiA8YnV0dG9uIGNsYXNzPVxcXCJ1ay1idXR0b24gdWstYnV0dG9uLXByaW1hcnkgdWstbW9kYWwtY2xvc2VcXFwiIGF1dG9mb2N1cz5cIiArXG5cblxuXG4gICAgICAgICAgbGFiZWxzLm9rICsgXCI8L2J1dHRvbj4gPC9kaXY+XCI7fSxcblxuXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIChkZWZlcnJlZCkgPT4gZGVmZXJyZWQucmVzb2x2ZSgpKTtcblxuICAgICAgfTtcblxuICAgICAgbW9kYWwuY29uZmlybSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcGVuRGlhbG9nKFxuICAgICAgICAoX3JlZjMpID0+IHtsZXQgeyBsYWJlbHMgfSA9IF9yZWYzO3JldHVybiBcIjxmb3JtPiA8ZGl2IGNsYXNzPVxcXCJ1ay1tb2RhbC1ib2R5XFxcIj5cIiArIChcbiAgICAgICAgICBpc1N0cmluZyhtZXNzYWdlKSA/IG1lc3NhZ2UgOiBodG1sKG1lc3NhZ2UpKSArIFwiPC9kaXY+IDxkaXYgY2xhc3M9XFxcInVrLW1vZGFsLWZvb3RlciB1ay10ZXh0LXJpZ2h0XFxcIj4gPGJ1dHRvbiBjbGFzcz1cXFwidWstYnV0dG9uIHVrLWJ1dHRvbi1kZWZhdWx0IHVrLW1vZGFsLWNsb3NlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPlwiICtcblxuXG4gICAgICAgICAgbGFiZWxzLmNhbmNlbCArIFwiPC9idXR0b24+IDxidXR0b24gY2xhc3M9XFxcInVrLWJ1dHRvbiB1ay1idXR0b24tcHJpbWFyeVxcXCIgYXV0b2ZvY3VzPlwiICtcblxuICAgICAgICAgIGxhYmVscy5vayArIFwiPC9idXR0b24+IDwvZGl2PiA8L2Zvcm0+XCI7fSxcblxuXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIChkZWZlcnJlZCkgPT4gZGVmZXJyZWQucmVqZWN0KCkpO1xuXG4gICAgICB9O1xuXG4gICAgICBtb2RhbC5wcm9tcHQgPSBmdW5jdGlvbiAobWVzc2FnZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wZW5EaWFsb2coXG4gICAgICAgIChfcmVmNCkgPT4ge2xldCB7IGxhYmVscyB9ID0gX3JlZjQ7cmV0dXJuIFwiPGZvcm0gY2xhc3M9XFxcInVrLWZvcm0tc3RhY2tlZFxcXCI+IDxkaXYgY2xhc3M9XFxcInVrLW1vZGFsLWJvZHlcXFwiPiA8bGFiZWw+XCIgKyAoXG5cbiAgICAgICAgICBpc1N0cmluZyhtZXNzYWdlKSA/IG1lc3NhZ2UgOiBodG1sKG1lc3NhZ2UpKSArIFwiPC9sYWJlbD4gPGlucHV0IGNsYXNzPVxcXCJ1ay1pbnB1dFxcXCIgdmFsdWU9XFxcIlwiICsgKFxuICAgICAgICAgIHZhbHVlIHx8ICcnKSArIFwiXFxcIiBhdXRvZm9jdXM+IDwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJ1ay1tb2RhbC1mb290ZXIgdWstdGV4dC1yaWdodFxcXCI+IDxidXR0b24gY2xhc3M9XFxcInVrLWJ1dHRvbiB1ay1idXR0b24tZGVmYXVsdCB1ay1tb2RhbC1jbG9zZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5cIiArXG5cblxuXG4gICAgICAgICAgbGFiZWxzLmNhbmNlbCArIFwiPC9idXR0b24+IDxidXR0b24gY2xhc3M9XFxcInVrLWJ1dHRvbiB1ay1idXR0b24tcHJpbWFyeVxcXCI+XCIgK1xuXG4gICAgICAgICAgbGFiZWxzLm9rICsgXCI8L2J1dHRvbj4gPC9kaXY+IDwvZm9ybT5cIjt9LFxuXG5cbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKGRlZmVycmVkKSA9PiBkZWZlcnJlZC5yZXNvbHZlKG51bGwpLFxuICAgICAgICAoZGlhbG9nKSA9PiAkKCdpbnB1dCcsIGRpYWxvZy4kZWwpLnZhbHVlKTtcblxuICAgICAgfTtcblxuICAgICAgbW9kYWwubGFiZWxzID0ge1xuICAgICAgICBvazogJ09rJyxcbiAgICAgICAgY2FuY2VsOiAnQ2FuY2VsJyB9O1xuXG5cbiAgICAgIGZ1bmN0aW9uIG9wZW5EaWFsb2codG1wbCwgb3B0aW9ucywgaGlkZUZuLCBzdWJtaXRGbikge1xuICAgICAgICBvcHRpb25zID0geyBiZ0Nsb3NlOiBmYWxzZSwgZXNjQ2xvc2U6IHRydWUsIGxhYmVsczogbW9kYWwubGFiZWxzLCAuLi5vcHRpb25zIH07XG5cbiAgICAgICAgY29uc3QgZGlhbG9nID0gbW9kYWwuZGlhbG9nKHRtcGwob3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuXG4gICAgICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgICAgIG9uKGRpYWxvZy4kZWwsICdzdWJtaXQnLCAnZm9ybScsIChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc3VibWl0Rm4gPT0gbnVsbCA/IHZvaWQgMCA6IHN1Ym1pdEZuKGRpYWxvZykpO1xuICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICBkaWFsb2cuaGlkZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvbihkaWFsb2cuJGVsLCAnaGlkZScsICgpID0+ICFyZXNvbHZlZCAmJiBoaWRlRm4oZGVmZXJyZWQpKTtcblxuICAgICAgICBkZWZlcnJlZC5wcm9taXNlLmRpYWxvZyA9IGRpYWxvZztcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmF2ID0ge1xuICAgICAgZXh0ZW5kczogQWNjb3JkaW9uLFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhcmdldHM6ICc+IC51ay1wYXJlbnQnLFxuICAgICAgICB0b2dnbGU6ICc+IGEnLFxuICAgICAgICBjb250ZW50OiAnPiB1bCcgfSB9O1xuXG4gICAgY29uc3QgbmF2SXRlbSA9ICcudWstbmF2YmFyLW5hdiA+IGxpID4gYSwgLnVrLW5hdmJhci1pdGVtLCAudWstbmF2YmFyLXRvZ2dsZSc7XG5cbiAgICB2YXIgbmF2YmFyID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIENvbnRhaW5lcl0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRyb3Bkb3duOiBTdHJpbmcsXG4gICAgICAgIG1vZGU6ICdsaXN0JyxcbiAgICAgICAgYWxpZ246IFN0cmluZyxcbiAgICAgICAgb2Zmc2V0OiBOdW1iZXIsXG4gICAgICAgIGJvdW5kYXJ5OiBCb29sZWFuLFxuICAgICAgICBib3VuZGFyeUFsaWduOiBCb29sZWFuLFxuICAgICAgICBjbHNEcm9wOiBTdHJpbmcsXG4gICAgICAgIGRlbGF5U2hvdzogTnVtYmVyLFxuICAgICAgICBkZWxheUhpZGU6IE51bWJlcixcbiAgICAgICAgZHJvcGJhcjogQm9vbGVhbixcbiAgICAgICAgZHJvcGJhckFuY2hvcjogQm9vbGVhbixcbiAgICAgICAgZHVyYXRpb246IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZHJvcGRvd246IG5hdkl0ZW0sXG4gICAgICAgIGFsaWduOiBpc1J0bCA/ICdyaWdodCcgOiAnbGVmdCcsXG4gICAgICAgIGNsc0Ryb3A6ICd1ay1uYXZiYXItZHJvcGRvd24nLFxuICAgICAgICBtb2RlOiB1bmRlZmluZWQsXG4gICAgICAgIG9mZnNldDogdW5kZWZpbmVkLFxuICAgICAgICBkZWxheVNob3c6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVsYXlIaWRlOiB1bmRlZmluZWQsXG4gICAgICAgIGJvdW5kYXJ5QWxpZ246IHVuZGVmaW5lZCxcbiAgICAgICAgZmxpcDogJ3gnLFxuICAgICAgICBib3VuZGFyeTogdHJ1ZSxcbiAgICAgICAgZHJvcGJhcjogZmFsc2UsXG4gICAgICAgIGRyb3BiYXJBbmNob3I6IGZhbHNlLFxuICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYm91bmRhcnkoX3JlZiwgJGVsKSB7bGV0IHsgYm91bmRhcnkgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIGJvdW5kYXJ5ID09PSB0cnVlID8gJGVsIDogYm91bmRhcnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJvcGJhckFuY2hvcihfcmVmMiwgJGVsKSB7bGV0IHsgZHJvcGJhckFuY2hvciB9ID0gX3JlZjI7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5KGRyb3BiYXJBbmNob3IsICRlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zKF9yZWYzKSB7bGV0IHsgYWxpZ24gfSA9IF9yZWYzO1xuICAgICAgICAgIHJldHVybiBcImJvdHRvbS1cIiArIGFsaWduO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyb3BiYXI6IHtcbiAgICAgICAgICBnZXQoX3JlZjQpIHtsZXQgeyBkcm9wYmFyIH0gPSBfcmVmNDtcbiAgICAgICAgICAgIGlmICghZHJvcGJhcikge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHJvcGJhciA9XG4gICAgICAgICAgICB0aGlzLl9kcm9wYmFyIHx8XG4gICAgICAgICAgICBxdWVyeShkcm9wYmFyLCB0aGlzLiRlbCkgfHxcbiAgICAgICAgICAgICQoJysgLnVrLW5hdmJhci1kcm9wYmFyJywgdGhpcy4kZWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gZHJvcGJhciA/IGRyb3BiYXIgOiB0aGlzLl9kcm9wYmFyID0gJCgnPGRpdj48L2Rpdj4nKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goZHJvcGJhcikge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZHJvcGJhciwgJ3VrLW5hdmJhci1kcm9wYmFyJyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgZHJvcENvbnRhaW5lcihfLCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIgfHwgJGVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyb3Bkb3duczoge1xuICAgICAgICAgIGdldChfcmVmNSwgJGVsKSB7bGV0IHsgY2xzRHJvcCB9ID0gX3JlZjU7XG4gICAgICAgICAgICBjb25zdCBkcm9wZG93bnMgPSAkJChcIi5cIiArIGNsc0Ryb3AsICRlbCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRyb3BDb250YWluZXIgIT09ICRlbCkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mICQkKFwiLlwiICsgY2xzRHJvcCwgdGhpcy5kcm9wQ29udGFpbmVyKSkge3ZhciBfdGhpcyRnZXREcm9wZG93bjtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoX3RoaXMkZ2V0RHJvcGRvd24gPSB0aGlzLmdldERyb3Bkb3duKGVsKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGdldERyb3Bkb3duLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVzKGRyb3Bkb3ducywgZWwpICYmIHRhcmdldCAmJiB3aXRoaW4odGFyZ2V0LCB0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgICAgICAgIGRyb3Bkb3ducy5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRyb3Bkb3ducztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goZHJvcGRvd25zKSB7XG4gICAgICAgICAgICB0aGlzLiRjcmVhdGUoXG4gICAgICAgICAgICAnZHJvcCcsXG4gICAgICAgICAgICBkcm9wZG93bnMuZmlsdGVyKChlbCkgPT4gIXRoaXMuZ2V0RHJvcGRvd24oZWwpKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4udGhpcy4kcHJvcHMsXG4gICAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLmJvdW5kYXJ5LFxuICAgICAgICAgICAgICBwb3M6IHRoaXMucG9zLFxuICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuZHJvcGJhciB8fCB0aGlzLm9mZnNldCB9KTtcblxuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgdG9nZ2xlcyhfcmVmNiwgJGVsKSB7bGV0IHsgZHJvcGRvd24gfSA9IF9yZWY2O1xuICAgICAgICAgIHJldHVybiAkJChkcm9wZG93biwgJGVsKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5kcm9wYmFyICYmIHJlbW92ZSQxKHRoaXMuZHJvcGJhcik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9kcm9wYmFyO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdtb3VzZW92ZXIgZm9jdXNpbicsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd247XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmNykge2xldCB7IGN1cnJlbnQgfSA9IF9yZWY3O1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGFjdGl2ZSAmJlxuICAgICAgICAgIGluY2x1ZGVzKGFjdGl2ZS5tb2RlLCAnaG92ZXInKSAmJlxuICAgICAgICAgIGFjdGl2ZS50YXJnZXQgJiZcbiAgICAgICAgICAhd2l0aGluKGFjdGl2ZS50YXJnZXQsIGN1cnJlbnQpICYmXG4gICAgICAgICAgIWFjdGl2ZS5pc0RlbGF5aW5nKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjdGl2ZS5oaWRlKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdrZXlkb3duJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBjb25zdCB7IGN1cnJlbnQsIGtleUNvZGUgfSA9IGU7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcblxuICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuRE9XTiAmJiBoYXNBdHRyKGN1cnJlbnQsICdhcmlhLWV4cGFuZGVkJykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKCFhY3RpdmUgfHwgYWN0aXZlLnRhcmdldCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgICBjdXJyZW50LmNsaWNrKCk7XG4gICAgICAgICAgICAgIG9uY2UodGhpcy5kcm9wQ29udGFpbmVyLCAnc2hvdycsIChfcmVmOCkgPT4ge2xldCB7IHRhcmdldCB9ID0gX3JlZjg7cmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIGZvY3VzRmlyc3RGb2N1c2FibGVFbGVtZW50KHRhcmdldCkpO30pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudChhY3RpdmUuJGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVOYXZJdGVtTmF2aWdhdGlvbihlLCB0aGlzLnRvZ2dsZXMsIGFjdGl2ZSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdrZXlkb3duJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiBcIi5cIiArIHRoaXMuY2xzRHJvcDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBjb25zdCB7IGN1cnJlbnQsIGtleUNvZGUgfSA9IGU7XG5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzKHRoaXMuZHJvcGRvd25zLCBjdXJyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG4gICAgICAgICAgY29uc3QgZWxlbWVudHMgPSAkJChzZWxGb2N1c2FibGUsIGN1cnJlbnQpO1xuICAgICAgICAgIGNvbnN0IGkgPSBmaW5kSW5kZXgoZWxlbWVudHMsIChlbCkgPT4gbWF0Y2hlcyhlbCwgJzpmb2N1cycpKTtcblxuICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuVVApIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICBlbGVtZW50c1tpIC0gMV0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLkRPV04pIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChpIDwgZWxlbWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBlbGVtZW50c1tpICsgMV0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLkVTQykge3ZhciBfYWN0aXZlJHRhcmdldDtcbiAgICAgICAgICAgIGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogKF9hY3RpdmUkdGFyZ2V0ID0gYWN0aXZlLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hY3RpdmUkdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlTmF2SXRlbU5hdmlnYXRpb24oZSwgdGhpcy50b2dnbGVzLCBhY3RpdmUpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnbW91c2VsZWF2ZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgYWN0aXZlICYmXG4gICAgICAgICAgaW5jbHVkZXMoYWN0aXZlLm1vZGUsICdob3ZlcicpICYmXG4gICAgICAgICAgIXRoaXMuZHJvcGRvd25zLnNvbWUoKGVsKSA9PiBtYXRjaGVzKGVsLCAnOmhvdmVyJykpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjdGl2ZS5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3Jlc2hvdycsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF8sIF9yZWY5KSB7bGV0IHsgJGVsIH0gPSBfcmVmOTtcbiAgICAgICAgICBpZiAoIWhhc0NsYXNzKCRlbCwgdGhpcy5jbHNEcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcGFyZW50KHRoaXMuZHJvcGJhcikpIHtcbiAgICAgICAgICAgIGFmdGVyKHRoaXMuZHJvcGJhckFuY2hvciB8fCB0aGlzLiRlbCwgdGhpcy5kcm9wYmFyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRDbGFzcygkZWwsIHRoaXMuY2xzRHJvcCArIFwiLWRyb3BiYXJcIik7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93JyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoXywgX3JlZjEwKSB7bGV0IHsgJGVsLCBkaXIgfSA9IF9yZWYxMDtcbiAgICAgICAgICBpZiAoIWhhc0NsYXNzKCRlbCwgdGhpcy5jbHNEcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaXIgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcbiAgICAgICAgICAgIG9mZnNldCgkZWwpLmJvdHRvbSAtXG4gICAgICAgICAgICBvZmZzZXQodGhpcy5kcm9wYmFyKS50b3AgK1xuICAgICAgICAgICAgdG9GbG9hdChjc3MoJGVsLCAnbWFyZ2luQm90dG9tJykpLFxuICAgICAgICAgICAgJGVsKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2JlZm9yZWhpZGUnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BDb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlLCBfcmVmMTEpIHtsZXQgeyAkZWwgfSA9IF9yZWYxMTtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIG1hdGNoZXModGhpcy5kcm9wYmFyLCAnOmhvdmVyJykgJiZcbiAgICAgICAgICAoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuJGVsKSA9PT0gJGVsICYmXG4gICAgICAgICAgIXRoaXMudG9nZ2xlcy5zb21lKChlbCkgPT4gYWN0aXZlLnRhcmdldCAhPT0gZWwgJiYgbWF0Y2hlcyhlbCwgJzpmb2N1cycpKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF8sIF9yZWYxMikge2xldCB7ICRlbCB9ID0gX3JlZjEyO1xuICAgICAgICAgIGlmICghaGFzQ2xhc3MoJGVsLCB0aGlzLmNsc0Ryb3ApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcblxuICAgICAgICAgIGlmICghYWN0aXZlIHx8IChhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS4kZWwpID09PSAkZWwpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2V0QWN0aXZlKCkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmUkMSAmJiB3aXRoaW4oYWN0aXZlJDEudGFyZ2V0LCB0aGlzLiRlbCkgJiYgYWN0aXZlJDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvblRvKG5ld0hlaWdodCwgZWwpIHtcbiAgICAgICAgICBjb25zdCB7IGRyb3BiYXIgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gaXNWaXNpYmxlKGRyb3BiYXIpID8gaGVpZ2h0KGRyb3BiYXIpIDogMDtcblxuICAgICAgICAgIGVsID0gb2xkSGVpZ2h0IDwgbmV3SGVpZ2h0ICYmIGVsO1xuXG4gICAgICAgICAgY3NzKGVsLCAnY2xpcCcsIFwicmVjdCgwLFwiICsgZWwub2Zmc2V0V2lkdGggKyBcInB4LFwiICsgb2xkSGVpZ2h0ICsgXCJweCwwKVwiKTtcblxuICAgICAgICAgIGhlaWdodChkcm9wYmFyLCBvbGRIZWlnaHQpO1xuXG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwoW2VsLCBkcm9wYmFyXSk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KGRyb3BiYXIsIHsgaGVpZ2h0OiBuZXdIZWlnaHQgfSwgdGhpcy5kdXJhdGlvbiksXG4gICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChcbiAgICAgICAgICBlbCxcbiAgICAgICAgICB7IGNsaXA6IFwicmVjdCgwLFwiICsgZWwub2Zmc2V0V2lkdGggKyBcInB4LFwiICsgbmV3SGVpZ2h0ICsgXCJweCwwKVwiIH0sXG4gICAgICAgICAgdGhpcy5kdXJhdGlvbildKS5cblxuXG4gICAgICAgICAgY2F0Y2gobm9vcCkuXG4gICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjc3MoZWwsIHsgY2xpcDogJycgfSk7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGUoZHJvcGJhcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RHJvcGRvd24oZWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kZ2V0Q29tcG9uZW50KGVsLCAnZHJvcCcpIHx8IHRoaXMuJGdldENvbXBvbmVudChlbCwgJ2Ryb3Bkb3duJyk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU5hdkl0ZW1OYXZpZ2F0aW9uKGUsIHRvZ2dsZXMsIGFjdGl2ZSkge1xuICAgICAgY29uc3QgeyBjdXJyZW50LCBrZXlDb2RlIH0gPSBlO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gKGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLnRhcmdldCkgfHwgY3VycmVudDtcbiAgICAgIGNvbnN0IGkgPSB0b2dnbGVzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgLy8gTGVmdFxuICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5MRUZUICYmIGkgPiAwKSB7XG4gICAgICAgIGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLmhpZGUoZmFsc2UpO1xuICAgICAgICB0b2dnbGVzW2kgLSAxXS5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICAvLyBSaWdodFxuICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5SSUdIVCAmJiBpIDwgdG9nZ2xlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLmhpZGUoZmFsc2UpO1xuICAgICAgICB0b2dnbGVzW2kgKyAxXS5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLlRBQikge1xuICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaGlkZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQoZWwpIHtcbiAgICAgIGlmICghJCgnOmZvY3VzJywgZWwpKSB7dmFyIF8kO1xuICAgICAgICAoXyQgPSAkKHNlbEZvY3VzYWJsZSwgZWwpKSA9PSBudWxsID8gdm9pZCAwIDogXyQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBrZXlNYXAgPSB7XG4gICAgICBUQUI6IDksXG4gICAgICBFU0M6IDI3LFxuICAgICAgTEVGVDogMzcsXG4gICAgICBVUDogMzgsXG4gICAgICBSSUdIVDogMzksXG4gICAgICBET1dOOiA0MCB9O1xuXG4gICAgdmFyIFN3aXBlID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc3dpcGluZzogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc3dpcGluZzogdHJ1ZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHN3aXBlVGFyZ2V0KHByb3BzLCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gJGVsO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3dpcGluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVyRXZlbnQodGhpcywge1xuICAgICAgICAgIGVsOiB0aGlzLnN3aXBlVGFyZ2V0LFxuICAgICAgICAgIG5hbWU6IHBvaW50ZXJEb3duLFxuICAgICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoIWlzVG91Y2goZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgU3dpcGUgR2VzdHVyZVxuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXZlbnRQb3MoZSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAndGFnTmFtZScgaW4gZS50YXJnZXQgPyBlLnRhcmdldCA6IHBhcmVudChlLnRhcmdldCk7XG4gICAgICAgICAgICBvbmNlKGRvY3VtZW50LCBwb2ludGVyVXAgKyBcIiBcIiArIHBvaW50ZXJDYW5jZWwgKyBcIiBzY3JvbGxcIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvcyhlKTtcblxuICAgICAgICAgICAgICAvLyBzd2lwZVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGUudHlwZSAhPT0gJ3Njcm9sbCcgJiYgdGFyZ2V0ICYmIHggJiYgTWF0aC5hYnMocG9zLnggLSB4KSA+IDEwMCB8fFxuICAgICAgICAgICAgICB5ICYmIE1hdGguYWJzKHBvcy55IC0geSkgPiAxMDApXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCAnc3dpcGUnKTtcbiAgICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInN3aXBlXCIgKyBzd2lwZURpcmVjdGlvbihwb3MueCwgcG9zLnksIHgsIHkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSB9KTtcblxuICAgICAgfSB9O1xuXG5cbiAgICBmdW5jdGlvbiBzd2lwZURpcmVjdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHgxIC0geDIpID49IE1hdGguYWJzKHkxIC0geTIpID9cbiAgICAgIHgxIC0geDIgPiAwID9cbiAgICAgICdMZWZ0JyA6XG4gICAgICAnUmlnaHQnIDpcbiAgICAgIHkxIC0geTIgPiAwID9cbiAgICAgICdVcCcgOlxuICAgICAgJ0Rvd24nO1xuICAgIH1cblxuICAgIHZhciBvZmZjYW52YXMgPSB7XG4gICAgICBtaXhpbnM6IFtNb2RhbCwgU3dpcGVdLFxuXG4gICAgICBhcmdzOiAnbW9kZScsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG1vZGU6IFN0cmluZyxcbiAgICAgICAgZmxpcDogQm9vbGVhbixcbiAgICAgICAgb3ZlcmxheTogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbW9kZTogJ3NsaWRlJyxcbiAgICAgICAgZmxpcDogZmFsc2UsXG4gICAgICAgIG92ZXJsYXk6IGZhbHNlLFxuICAgICAgICBjbHNQYWdlOiAndWstb2ZmY2FudmFzLXBhZ2UnLFxuICAgICAgICBjbHNDb250YWluZXI6ICd1ay1vZmZjYW52YXMtY29udGFpbmVyJyxcbiAgICAgICAgc2VsUGFuZWw6ICcudWstb2ZmY2FudmFzLWJhcicsXG4gICAgICAgIGNsc0ZsaXA6ICd1ay1vZmZjYW52YXMtZmxpcCcsXG4gICAgICAgIGNsc0NvbnRhaW5lckFuaW1hdGlvbjogJ3VrLW9mZmNhbnZhcy1jb250YWluZXItYW5pbWF0aW9uJyxcbiAgICAgICAgY2xzU2lkZWJhckFuaW1hdGlvbjogJ3VrLW9mZmNhbnZhcy1iYXItYW5pbWF0aW9uJyxcbiAgICAgICAgY2xzTW9kZTogJ3VrLW9mZmNhbnZhcycsXG4gICAgICAgIGNsc092ZXJsYXk6ICd1ay1vZmZjYW52YXMtb3ZlcmxheScsXG4gICAgICAgIHNlbENsb3NlOiAnLnVrLW9mZmNhbnZhcy1jbG9zZScsXG4gICAgICAgIGNvbnRhaW5lcjogZmFsc2UgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBjbHNGbGlwKF9yZWYpIHtsZXQgeyBmbGlwLCBjbHNGbGlwIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBmbGlwID8gY2xzRmxpcCA6ICcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsc092ZXJsYXkoX3JlZjIpIHtsZXQgeyBvdmVybGF5LCBjbHNPdmVybGF5IH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gb3ZlcmxheSA/IGNsc092ZXJsYXkgOiAnJztcbiAgICAgICAgfSxcblxuICAgICAgICBjbHNNb2RlKF9yZWYzKSB7bGV0IHsgbW9kZSwgY2xzTW9kZSB9ID0gX3JlZjM7XG4gICAgICAgICAgcmV0dXJuIGNsc01vZGUgKyBcIi1cIiArIG1vZGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xzU2lkZWJhckFuaW1hdGlvbihfcmVmNCkge2xldCB7IG1vZGUsIGNsc1NpZGViYXJBbmltYXRpb24gfSA9IF9yZWY0O1xuICAgICAgICAgIHJldHVybiBtb2RlID09PSAnbm9uZScgfHwgbW9kZSA9PT0gJ3JldmVhbCcgPyAnJyA6IGNsc1NpZGViYXJBbmltYXRpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xzQ29udGFpbmVyQW5pbWF0aW9uKF9yZWY1KSB7bGV0IHsgbW9kZSwgY2xzQ29udGFpbmVyQW5pbWF0aW9uIH0gPSBfcmVmNTtcbiAgICAgICAgICByZXR1cm4gbW9kZSAhPT0gJ3B1c2gnICYmIG1vZGUgIT09ICdyZXZlYWwnID8gJycgOiBjbHNDb250YWluZXJBbmltYXRpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvbkVsZW1lbnQoX3JlZjYpIHtsZXQgeyBtb2RlIH0gPSBfcmVmNjtcbiAgICAgICAgICByZXR1cm4gbW9kZSA9PT0gJ3JldmVhbCcgPyBwYXJlbnQodGhpcy5wYW5lbCkgOiB0aGlzLnBhbmVsO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKCkgJiYgIWlzVmlzaWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gJ2FbaHJlZl49XCIjXCJdJztcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF9yZWY3KSB7bGV0IHsgY3VycmVudDogeyBoYXNoIH0sIGRlZmF1bHRQcmV2ZW50ZWQgfSA9IF9yZWY3O1xuICAgICAgICAgIGlmICghZGVmYXVsdFByZXZlbnRlZCAmJiBoYXNoICYmICQoaGFzaCwgZG9jdW1lbnQuYm9keSkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvdWNoc3RhcnQnLFxuXG4gICAgICAgIHBhc3NpdmU6IHRydWUsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFuZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmOCkge2xldCB7IHRhcmdldFRvdWNoZXMgfSA9IF9yZWY4O1xuICAgICAgICAgIGlmICh0YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRZID0gdGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvdWNobW92ZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5jYW5jZWxhYmxlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvdWNobW92ZScsXG5cbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFuZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjbGllbnRZID0gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkgLSB0aGlzLmNsaWVudFk7XG4gICAgICAgICAgY29uc3QgeyBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCwgY2xpZW50SGVpZ2h0IH0gPSB0aGlzLnBhbmVsO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGNsaWVudEhlaWdodCA+PSBzY3JvbGxIZWlnaHQgfHxcbiAgICAgICAgICBzY3JvbGxUb3AgPT09IDAgJiYgY2xpZW50WSA+IDAgfHxcbiAgICAgICAgICBzY3JvbGxIZWlnaHQgLSBzY3JvbGxUb3AgPD0gY2xpZW50SGVpZ2h0ICYmIGNsaWVudFkgPCAwKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdyZXZlYWwnICYmICFoYXNDbGFzcyhwYXJlbnQodGhpcy5wYW5lbCksIHRoaXMuY2xzTW9kZSkpIHtcbiAgICAgICAgICAgIHdyYXBBbGwodGhpcy5wYW5lbCwgJzxkaXY+Jyk7XG4gICAgICAgICAgICBhZGRDbGFzcyhwYXJlbnQodGhpcy5wYW5lbCksIHRoaXMuY2xzTW9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3NzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ292ZXJmbG93WScsIHRoaXMub3ZlcmxheSA/ICdoaWRkZW4nIDogJycpO1xuICAgICAgICAgIGFkZENsYXNzKGRvY3VtZW50LmJvZHksIHRoaXMuY2xzQ29udGFpbmVyLCB0aGlzLmNsc0ZsaXApO1xuICAgICAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndG91Y2gtYWN0aW9uJywgJ3Bhbi15IHBpbmNoLXpvb20nKTtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzT3ZlcmxheSk7XG4gICAgICAgICAgYWRkQ2xhc3MoXG4gICAgICAgICAgdGhpcy5wYW5lbCxcbiAgICAgICAgICB0aGlzLmNsc1NpZGViYXJBbmltYXRpb24sXG4gICAgICAgICAgdGhpcy5tb2RlICE9PSAncmV2ZWFsJyA/IHRoaXMuY2xzTW9kZSA6ICcnKTtcblxuXG4gICAgICAgICAgaGVpZ2h0KGRvY3VtZW50LmJvZHkpOyAvLyBmb3JjZSByZWZsb3dcbiAgICAgICAgICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCB0aGlzLmNsc0NvbnRhaW5lckFuaW1hdGlvbik7XG5cbiAgICAgICAgICB0aGlzLmNsc0NvbnRhaW5lckFuaW1hdGlvbiAmJiBzdXBwcmVzc1VzZXJTY2FsZSgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIHRoaXMuY2xzQ29udGFpbmVyQW5pbWF0aW9uKTtcbiAgICAgICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3RvdWNoLWFjdGlvbicsICcnKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGRlbicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuY2xzQ29udGFpbmVyQW5pbWF0aW9uICYmIHJlc3VtZVVzZXJTY2FsZSgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ3JldmVhbCcpIHtcbiAgICAgICAgICAgIHVud3JhcCh0aGlzLnBhbmVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLnBhbmVsLCB0aGlzLmNsc1NpZGViYXJBbmltYXRpb24sIHRoaXMuY2xzTW9kZSk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzT3ZlcmxheSk7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCB0aGlzLmNsc0NvbnRhaW5lciwgdGhpcy5jbHNGbGlwKTtcblxuICAgICAgICAgIGNzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdvdmVyZmxvd1knLCAnJyk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzd2lwZUxlZnQgc3dpcGVSaWdodCcsXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKCkgJiYgZW5kc1dpdGgoZS50eXBlLCAnTGVmdCcpIF4gdGhpcy5mbGlwKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0gfTtcblxuXG5cblxuICAgIC8vIENocm9tZSBpbiByZXNwb25zaXZlIG1vZGUgem9vbXMgcGFnZSB1cG9uIG9wZW5pbmcgb2ZmY2FudmFzXG4gICAgZnVuY3Rpb24gc3VwcHJlc3NVc2VyU2NhbGUoKSB7XG4gICAgICBnZXRWaWV3cG9ydCgpLmNvbnRlbnQgKz0gJyx1c2VyLXNjYWxhYmxlPTAnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc3VtZVVzZXJTY2FsZSgpIHtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnQoKTtcbiAgICAgIHZpZXdwb3J0LmNvbnRlbnQgPSB2aWV3cG9ydC5jb250ZW50LnJlcGxhY2UoLyx1c2VyLXNjYWxhYmxlPTAkLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZpZXdwb3J0KCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgJCgnbWV0YVtuYW1lPVwidmlld3BvcnRcIl0nLCBkb2N1bWVudC5oZWFkKSB8fCBhcHBlbmQoZG9jdW1lbnQuaGVhZCwgJzxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiPicpKTtcblxuICAgIH1cblxuICAgIHZhciBvdmVyZmxvd0F1dG8gPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgUmVzaXplXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc2VsQ29udGFpbmVyOiBTdHJpbmcsXG4gICAgICAgIHNlbENvbnRlbnQ6IFN0cmluZyxcbiAgICAgICAgbWluSGVpZ2h0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNlbENvbnRhaW5lcjogJy51ay1tb2RhbCcsXG4gICAgICAgIHNlbENvbnRlbnQ6ICcudWstbW9kYWwtZGlhbG9nJyxcbiAgICAgICAgbWluSGVpZ2h0OiAxNTAgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBjb250YWluZXIoX3JlZiwgJGVsKSB7bGV0IHsgc2VsQ29udGFpbmVyIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBjbG9zZXN0KCRlbCwgc2VsQ29udGFpbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250ZW50KF9yZWYyLCAkZWwpIHtsZXQgeyBzZWxDb250ZW50IH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdCgkZWwsIHNlbENvbnRlbnQpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgcmVzaXplVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmNvbnRhaW5lciwgdGhpcy5jb250ZW50XTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICghdGhpcy5jb250ZW50IHx8ICF0aGlzLmNvbnRhaW5lciB8fCAhaXNWaXNpYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXg6IE1hdGgubWF4KFxuICAgICAgICAgICAgdGhpcy5taW5IZWlnaHQsXG4gICAgICAgICAgICBoZWlnaHQodGhpcy5jb250YWluZXIpIC0gKGRpbWVuc2lvbnMkMSh0aGlzLmNvbnRlbnQpLmhlaWdodCAtIGhlaWdodCh0aGlzLiRlbCkpKSB9O1xuXG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMykge2xldCB7IG1heCB9ID0gX3JlZjM7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCB7IG1pbkhlaWdodDogdGhpcy5taW5IZWlnaHQsIG1heEhlaWdodDogbWF4IH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cbiAgICB2YXIgcmVzcG9uc2l2ZSA9IHtcbiAgICAgIG1peGluczogW1Jlc2l6ZV0sXG5cbiAgICAgIHByb3BzOiBbJ3dpZHRoJywgJ2hlaWdodCddLFxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuJGVsLCBwYXJlbnQodGhpcy4kZWwpXTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsICd1ay1yZXNwb25zaXZlLXdpZHRoJyk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICByZXR1cm4gaXNWaXNpYmxlKHRoaXMuJGVsKSAmJiB0aGlzLndpZHRoICYmIHRoaXMuaGVpZ2h0ID9cbiAgICAgICAgICB7IHdpZHRoOiB3aWR0aChwYXJlbnQodGhpcy4kZWwpKSwgaGVpZ2h0OiB0aGlzLmhlaWdodCB9IDpcbiAgICAgICAgICBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShkaW0pIHtcbiAgICAgICAgICBoZWlnaHQoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgRGltZW5zaW9ucy5jb250YWluKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCB9LFxuXG4gICAgICAgICAgZGltKS5cbiAgICAgICAgICBoZWlnaHQpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuICAgIHZhciBzY3JvbGwgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBvZmZzZXQ6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgb2Zmc2V0OiAwIH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBzY3JvbGxUbyhlbCkge1xuICAgICAgICAgIGVsID0gZWwgJiYgJChlbCkgfHwgZG9jdW1lbnQuYm9keTtcblxuICAgICAgICAgIGlmICh0cmlnZ2VyKHRoaXMuJGVsLCAnYmVmb3Jlc2Nyb2xsJywgW3RoaXMsIGVsXSkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNjcm9sbEludG9WaWV3KGVsLCB7IG9mZnNldDogdGhpcy5vZmZzZXQgfSk7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnc2Nyb2xsZWQnLCBbdGhpcywgZWxdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgY2xpY2soZSkge1xuICAgICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zY3JvbGxUbyhnZXRUYXJnZXRFbGVtZW50KHRoaXMuJGVsKSk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldFRhcmdldEVsZW1lbnQoZWwpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkZWNvZGVVUklDb21wb25lbnQoZWwuaGFzaCkuc3Vic3RyaW5nKDEpKTtcbiAgICB9XG5cbiAgICB2YXIgc2Nyb2xsc3B5ID0ge1xuICAgICAgbWl4aW5zOiBbU2Nyb2xsXSxcblxuICAgICAgYXJnczogJ2NscycsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsczogU3RyaW5nLFxuICAgICAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICAgICAgaGlkZGVuOiBCb29sZWFuLFxuICAgICAgICBvZmZzZXRUb3A6IE51bWJlcixcbiAgICAgICAgb2Zmc2V0TGVmdDogTnVtYmVyLFxuICAgICAgICByZXBlYXQ6IEJvb2xlYW4sXG4gICAgICAgIGRlbGF5OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiAoKSA9PiAoe1xuICAgICAgICBjbHM6ICcnLFxuICAgICAgICB0YXJnZXQ6IGZhbHNlLFxuICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgIG9mZnNldFRvcDogMCxcbiAgICAgICAgb2Zmc2V0TGVmdDogMCxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgIGluVmlld0NsYXNzOiAndWstc2Nyb2xsc3B5LWludmlldycgfSksXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldCA/ICQkKHRhcmdldCwgJGVsKSA6IFskZWxdO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChlbGVtZW50cywgcHJldikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlkZGVuKSB7XG4gICAgICAgICAgICAgIGNzcyhmaWx0ZXIkMShlbGVtZW50cywgXCI6bm90KC5cIiArIHRoaXMuaW5WaWV3Q2xhc3MgKyBcIilcIiksICd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICB0aGlzLiRyZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSB9LFxuXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLl9kYXRhLmVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoXG4gICAgICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oXG4gICAgICAgIHRoaXMuZWxlbWVudHMsXG4gICAgICAgIChyZWNvcmRzKSA9PiB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9kYXRhLmVsZW1lbnRzO1xuICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQ6IGVsLCBpc0ludGVyc2VjdGluZyB9IG9mIHJlY29yZHMpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudHMuaGFzKGVsKSkge1xuICAgICAgICAgICAgICBlbGVtZW50cy5zZXQoZWwsIHtcbiAgICAgICAgICAgICAgICBjbHM6IGRhdGEoZWwsICd1ay1zY3JvbGxzcHktY2xhc3MnKSB8fCB0aGlzLmNscyB9KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGVsZW1lbnRzLmdldChlbCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVwZWF0ICYmIHN0YXRlLnNob3cpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLnNob3cgPSBpc0ludGVyc2VjdGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByb290TWFyZ2luOiB0b1B4KHRoaXMub2Zmc2V0VG9wLCAnaGVpZ2h0JykgLSAxICsgXCJweCBcIiArIChcbiAgICAgICAgICB0b1B4KHRoaXMub2Zmc2V0TGVmdCwgJ3dpZHRoJykgLSAxKSArIFwicHhcIiB9LFxuXG5cbiAgICAgICAgZmFsc2UpKTtcblxuXG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2VsLCBzdGF0ZV0gb2YgdGhpcy5fZGF0YS5lbGVtZW50cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgdGhpcy5pblZpZXdDbGFzcywgKHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5jbHMpIHx8ICcnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiBbXG4gICAgICB7XG4gICAgICAgIHdyaXRlKGRhdGEpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtlbCwgc3RhdGVdIG9mIGRhdGEuZWxlbWVudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2hvdyAmJiAhc3RhdGUuaW52aWV3ICYmICFzdGF0ZS5xdWV1ZWQpIHtcbiAgICAgICAgICAgICAgc3RhdGUucXVldWVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBkYXRhLnByb21pc2UgPSAoZGF0YS5wcm9taXNlIHx8IFByb21pc2UucmVzb2x2ZSgpKS5cbiAgICAgICAgICAgICAgdGhlbigoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLmRlbGF5KSkpLlxuICAgICAgICAgICAgICB0aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZShlbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnNob3cgJiYgc3RhdGUuaW52aWV3ICYmICFzdGF0ZS5xdWV1ZWQgJiYgdGhpcy5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGUoZWwsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHRvZ2dsZShlbCwgaW52aWV3KSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9kYXRhLmVsZW1lbnRzLmdldChlbCk7XG5cbiAgICAgICAgICBzdGF0ZS5vZmYgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLm9mZigpO1xuXG4gICAgICAgICAgY3NzKGVsLCAndmlzaWJpbGl0eScsICFpbnZpZXcgJiYgdGhpcy5oaWRkZW4gPyAnaGlkZGVuJyA6ICcnKTtcblxuICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLmluVmlld0NsYXNzLCBpbnZpZXcpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzdGF0ZS5jbHMpO1xuXG4gICAgICAgICAgaWYgKC9cXGJ1ay1hbmltYXRpb24tLy50ZXN0KHN0YXRlLmNscykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZUFuaW1hdGlvbkNsYXNzZXMgPSAoKSA9PiByZW1vdmVDbGFzc2VzKGVsLCAndWstYW5pbWF0aW9uLVtcXFxcdy1dKycpO1xuICAgICAgICAgICAgaWYgKGludmlldykge1xuICAgICAgICAgICAgICBzdGF0ZS5vZmYgPSBvbmNlKGVsLCAnYW5pbWF0aW9uY2FuY2VsIGFuaW1hdGlvbmVuZCcsIHJlbW92ZUFuaW1hdGlvbkNsYXNzZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQW5pbWF0aW9uQ2xhc3NlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyaWdnZXIoZWwsIGludmlldyA/ICdpbnZpZXcnIDogJ291dHZpZXcnKTtcblxuICAgICAgICAgIHN0YXRlLmludmlldyA9IGludmlldztcblxuICAgICAgICAgIHRoaXMuJHVwZGF0ZShlbCk7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIHNjcm9sbHNweU5hdiA9IHtcbiAgICAgIG1peGluczogW1Njcm9sbF0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsczogU3RyaW5nLFxuICAgICAgICBjbG9zZXN0OiBTdHJpbmcsXG4gICAgICAgIHNjcm9sbDogQm9vbGVhbixcbiAgICAgICAgb3ZlcmZsb3c6IEJvb2xlYW4sXG4gICAgICAgIG9mZnNldDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjbHM6ICd1ay1hY3RpdmUnLFxuICAgICAgICBjbG9zZXN0OiBmYWxzZSxcbiAgICAgICAgc2Nyb2xsOiBmYWxzZSxcbiAgICAgICAgb3ZlcmZsb3c6IHRydWUsXG4gICAgICAgIG9mZnNldDogMCB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGxpbmtzOiB7XG4gICAgICAgICAgZ2V0KF8sICRlbCkge1xuICAgICAgICAgICAgcmV0dXJuICQkKCdhW2hyZWZePVwiI1wiXScsICRlbCkuZmlsdGVyKChlbCkgPT4gZWwuaGFzaCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGxpbmtzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGwpIHtcbiAgICAgICAgICAgICAgdGhpcy4kY3JlYXRlKCdzY3JvbGwnLCBsaW5rcywgeyBvZmZzZXQ6IHRoaXMub2Zmc2V0IHx8IDAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgZWxlbWVudHMoX3JlZikge2xldCB7IGNsb3Nlc3Q6IHNlbGVjdG9yIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBjbG9zZXN0KHRoaXMubGlua3MsIHNlbGVjdG9yIHx8ICcqJyk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB1cGRhdGU6IFtcbiAgICAgIHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRzID0gdGhpcy5saW5rcy5tYXAoZ2V0VGFyZ2V0RWxlbWVudCkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHRhcmdldHM7XG5cbiAgICAgICAgICBpZiAoIWxlbmd0aCB8fCAhaXNWaXNpYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IFtzY3JvbGxFbGVtZW50XSA9IHNjcm9sbFBhcmVudHModGFyZ2V0cywgL2F1dG98c2Nyb2xsLywgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgeyBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCB9ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgICBjb25zdCBtYXggPSBzY3JvbGxIZWlnaHQgLSBnZXRWaWV3cG9ydENsaWVudEhlaWdodChzY3JvbGxFbGVtZW50KTtcbiAgICAgICAgICBsZXQgYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsVG9wID09PSBtYXgpIHtcbiAgICAgICAgICAgIGFjdGl2ZSA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiB0YXJnZXRzKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgb2Zmc2V0KHRhcmdldHNbaV0pLnRvcCAtXG4gICAgICAgICAgICAgIG9mZnNldChnZXRWaWV3cG9ydCQxKHNjcm9sbEVsZW1lbnQpKS50b3AgLVxuICAgICAgICAgICAgICB0aGlzLm9mZnNldCA+XG4gICAgICAgICAgICAgIDApXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhY3RpdmUgPSAraTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5vdmVyZmxvdykge1xuICAgICAgICAgICAgICBhY3RpdmUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IGFjdGl2ZSB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYyKSB7bGV0IHsgYWN0aXZlIH0gPSBfcmVmMjtcbiAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gYWN0aXZlICE9PSBmYWxzZSAmJiAhaGFzQ2xhc3ModGhpcy5lbGVtZW50c1thY3RpdmVdLCB0aGlzLmNscyk7XG5cbiAgICAgICAgICB0aGlzLmxpbmtzLmZvckVhY2goKGVsKSA9PiBlbC5ibHVyKCkpO1xuICAgICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLmVsZW1lbnRzW2ldLCB0aGlzLmNscywgK2kgPT09IGFjdGl2ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdhY3RpdmUnLCBbYWN0aXZlLCB0aGlzLmVsZW1lbnRzW2FjdGl2ZV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Njcm9sbCcsICdyZXNpemUnXSB9XSB9O1xuXG4gICAgdmFyIHN0aWNreSA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBNZWRpYSwgUmVzaXplLCBTY3JvbGxdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBwb3NpdGlvbjogU3RyaW5nLFxuICAgICAgICB0b3A6IG51bGwsXG4gICAgICAgIGJvdHRvbTogQm9vbGVhbixcbiAgICAgICAgb2Zmc2V0OiBTdHJpbmcsXG4gICAgICAgIGFuaW1hdGlvbjogU3RyaW5nLFxuICAgICAgICBjbHNBY3RpdmU6IFN0cmluZyxcbiAgICAgICAgY2xzSW5hY3RpdmU6IFN0cmluZyxcbiAgICAgICAgY2xzRml4ZWQ6IFN0cmluZyxcbiAgICAgICAgY2xzQmVsb3c6IFN0cmluZyxcbiAgICAgICAgc2VsVGFyZ2V0OiBTdHJpbmcsXG4gICAgICAgIHNob3dPblVwOiBCb29sZWFuLFxuICAgICAgICB0YXJnZXRPZmZzZXQ6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJvdHRvbTogZmFsc2UsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgYW5pbWF0aW9uOiAnJyxcbiAgICAgICAgY2xzQWN0aXZlOiAndWstYWN0aXZlJyxcbiAgICAgICAgY2xzSW5hY3RpdmU6ICcnLFxuICAgICAgICBjbHNGaXhlZDogJ3VrLXN0aWNreS1maXhlZCcsXG4gICAgICAgIGNsc0JlbG93OiAndWstc3RpY2t5LWJlbG93JyxcbiAgICAgICAgc2VsVGFyZ2V0OiAnJyxcbiAgICAgICAgc2hvd09uVXA6IGZhbHNlLFxuICAgICAgICB0YXJnZXRPZmZzZXQ6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2VsVGFyZ2V0KF9yZWYsICRlbCkge2xldCB7IHNlbFRhcmdldCB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gc2VsVGFyZ2V0ICYmICQoc2VsVGFyZ2V0LCAkZWwpIHx8ICRlbDtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPVxuICAgICAgICAkKCcrIC51ay1zdGlja3ktcGxhY2Vob2xkZXInLCB0aGlzLiRlbCkgfHxcbiAgICAgICAgJCgnPGRpdiBjbGFzcz1cInVrLXN0aWNreS1wbGFjZWhvbGRlclwiPjwvZGl2PicpO1xuICAgICAgICB0aGlzLmlzRml4ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmUoZmFsc2UpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZpeGVkKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5zZWxUYXJnZXQsIHRoaXMuY2xzSW5hY3RpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlJDEodGhpcy5wbGFjZWhvbGRlcik7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBudWxsO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdsb2FkIGhhc2hjaGFuZ2UgcG9wc3RhdGUnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldE9mZnNldCAhPT0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBpZiAoIWxvY2F0aW9uLmhhc2ggfHwgc2Nyb2xsVG9wKHdpbmRvdykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0KCQobG9jYXRpb24uaGFzaCkpO1xuICAgICAgICAgICAgY29uc3QgZWxPZmZzZXQgPSBvZmZzZXQodGhpcy4kZWwpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpeGVkICYmIGludGVyc2VjdFJlY3QodGFyZ2V0T2Zmc2V0LCBlbE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wKFxuICAgICAgICAgICAgICB3aW5kb3csXG4gICAgICAgICAgICAgIHRhcmdldE9mZnNldC50b3AgLVxuICAgICAgICAgICAgICBlbE9mZnNldC5oZWlnaHQgLVxuICAgICAgICAgICAgICB0b1B4KHRoaXMudGFyZ2V0T2Zmc2V0LCAnaGVpZ2h0JykgLVxuICAgICAgICAgICAgICB0b1B4KHRoaXMub2Zmc2V0LCAnaGVpZ2h0JykpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICB1cGRhdGU6IFtcbiAgICAgIHtcbiAgICAgICAgcmVhZChfcmVmMiwgdHlwZXMpIHtsZXQgeyBoZWlnaHQ6IGhlaWdodCQxLCBtYXJnaW4gfSA9IF9yZWYyO1xuICAgICAgICAgIHRoaXMuaW5hY3RpdmUgPSAhdGhpcy5tYXRjaE1lZGlhIHx8ICFpc1Zpc2libGUodGhpcy4kZWwpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaW5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBoaWRlID0gdGhpcy5hY3RpdmUgJiYgdHlwZXMuaGFzKCdyZXNpemUnKTtcbiAgICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgICAgY3NzKHRoaXMuc2VsVGFyZ2V0LCAndHJhbnNpdGlvbicsICcwcycpO1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgaGVpZ2h0JDEgPSBvZmZzZXQodGhpcy4kZWwpLmhlaWdodDtcbiAgICAgICAgICAgIG1hcmdpbiA9IGNzcyh0aGlzLiRlbCwgJ21hcmdpbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgIGZhc3Rkb20ud3JpdGUoKCkgPT4gY3NzKHRoaXMuc2VsVGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuaXNGaXhlZCA/IHRoaXMucGxhY2Vob2xkZXIgOiB0aGlzLiRlbDtcbiAgICAgICAgICBjb25zdCB3aW5kb3dIZWlnaHQgPSBoZWlnaHQod2luZG93KTtcblxuICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgaGVpZ2h0JDEgPiB3aW5kb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gJ2JvdHRvbSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IG9mZnNldCQxID0gdG9QeCh0aGlzLm9mZnNldCwgJ2hlaWdodCcsIHJlZmVyZW5jZUVsZW1lbnQpO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIG9mZnNldCQxICs9IHdpbmRvd0hlaWdodCAtIGhlaWdodCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gTWF0aC5tYXgoMCwgaGVpZ2h0JDEgKyBvZmZzZXQkMSAtIHdpbmRvd0hlaWdodCk7XG4gICAgICAgICAgY29uc3QgdG9wT2Zmc2V0ID0gb2Zmc2V0KHJlZmVyZW5jZUVsZW1lbnQpLnRvcDtcblxuICAgICAgICAgIGNvbnN0IHRvcCA9IHBhcnNlUHJvcCh0aGlzLnRvcCwgdGhpcy4kZWwsIHRvcE9mZnNldCk7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gcGFyc2VQcm9wKHRoaXMuYm90dG9tLCB0aGlzLiRlbCwgdG9wT2Zmc2V0ICsgaGVpZ2h0JDEsIHRydWUpO1xuXG4gICAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCh0b3AsIHRvcE9mZnNldCkgLSBvZmZzZXQkMTtcbiAgICAgICAgICBjb25zdCBlbmQgPSBib3R0b20gP1xuICAgICAgICAgIGJvdHRvbSAtIG9mZnNldCh0aGlzLiRlbCkuaGVpZ2h0ICsgb3ZlcmZsb3cgLSBvZmZzZXQkMSA6XG4gICAgICAgICAgZ2V0U2Nyb2xsaW5nRWxlbWVudCh0aGlzLiRlbCkuc2Nyb2xsSGVpZ2h0IC0gd2luZG93SGVpZ2h0O1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQkMSxcbiAgICAgICAgICAgIG92ZXJmbG93LFxuICAgICAgICAgICAgdG9wT2Zmc2V0LFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQkMSxcbiAgICAgICAgICAgIG1hcmdpbixcbiAgICAgICAgICAgIHdpZHRoOiBkaW1lbnNpb25zJDEocmVmZXJlbmNlRWxlbWVudCkud2lkdGgsXG4gICAgICAgICAgICB0b3A6IG9mZnNldFBvc2l0aW9uKHJlZmVyZW5jZUVsZW1lbnQpWzBdIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMykge2xldCB7IGhlaWdodCwgbWFyZ2luIH0gPSBfcmVmMztcbiAgICAgICAgICBjb25zdCB7IHBsYWNlaG9sZGVyIH0gPSB0aGlzO1xuXG4gICAgICAgICAgY3NzKHBsYWNlaG9sZGVyLCB7IGhlaWdodCwgbWFyZ2luIH0pO1xuXG4gICAgICAgICAgaWYgKCF3aXRoaW4ocGxhY2Vob2xkZXIsIGRvY3VtZW50KSkge1xuICAgICAgICAgICAgYWZ0ZXIodGhpcy4kZWwsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgcmVhZChfcmVmNClcblxuXG5cblxuXG5cbiAgICAgICAge2xldCB7IHNjcm9sbDogcHJldlNjcm9sbCA9IDAsIGRpcjogcHJldkRpciA9ICdkb3duJywgb3ZlcmZsb3csIG92ZXJmbG93U2Nyb2xsID0gMCwgc3RhcnQsIGVuZCB9ID0gX3JlZjQ7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsID0gc2Nyb2xsVG9wKHdpbmRvdyk7XG4gICAgICAgICAgY29uc3QgZGlyID0gcHJldlNjcm9sbCA8PSBzY3JvbGwgPyAnZG93bicgOiAndXAnO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgIHByZXZEaXIsXG4gICAgICAgICAgICBzY3JvbGwsXG4gICAgICAgICAgICBwcmV2U2Nyb2xsLFxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50VG9wOiBvZmZzZXQodGhpcy4kZWwub2Zmc2V0UGFyZW50KS50b3AsXG4gICAgICAgICAgICBvdmVyZmxvd1Njcm9sbDogY2xhbXAoXG4gICAgICAgICAgICBvdmVyZmxvd1Njcm9sbCArIGNsYW1wKHNjcm9sbCwgc3RhcnQsIGVuZCkgLSBjbGFtcChwcmV2U2Nyb2xsLCBzdGFydCwgZW5kKSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBvdmVyZmxvdykgfTtcblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoZGF0YSwgdHlwZXMpIHtcbiAgICAgICAgICBjb25zdCBpc1Njcm9sbFVwZGF0ZSA9IHR5cGVzLmhhcygnc2Nyb2xsJyk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW5pdFRpbWVzdGFtcCA9IDAsXG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICBwcmV2RGlyLFxuICAgICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgICAgcHJldlNjcm9sbCA9IDAsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIHRvcE9mZnNldCxcbiAgICAgICAgICAgIGhlaWdodCB9ID1cbiAgICAgICAgICBkYXRhO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIHNjcm9sbCA8IDAgfHxcbiAgICAgICAgICBzY3JvbGwgPT09IHByZXZTY3JvbGwgJiYgaXNTY3JvbGxVcGRhdGUgfHxcbiAgICAgICAgICB0aGlzLnNob3dPblVwICYmICFpc1Njcm9sbFVwZGF0ZSAmJiAhdGhpcy5pc0ZpeGVkKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGlmIChub3cgLSBpbml0VGltZXN0YW1wID4gMzAwIHx8IGRpciAhPT0gcHJldkRpcikge1xuICAgICAgICAgICAgZGF0YS5pbml0U2Nyb2xsID0gc2Nyb2xsO1xuICAgICAgICAgICAgZGF0YS5pbml0VGltZXN0YW1wID0gbm93O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLnNob3dPblVwICYmXG4gICAgICAgICAgIXRoaXMuaXNGaXhlZCAmJlxuICAgICAgICAgIE1hdGguYWJzKGRhdGEuaW5pdFNjcm9sbCAtIHNjcm9sbCkgPD0gMzAgJiZcbiAgICAgICAgICBNYXRoLmFicyhwcmV2U2Nyb2xsIC0gc2Nyb2xsKSA8PSAxMClcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuaW5hY3RpdmUgfHxcbiAgICAgICAgICBzY3JvbGwgPCBzdGFydCB8fFxuICAgICAgICAgIHRoaXMuc2hvd09uVXAgJiYgKFxuICAgICAgICAgIHNjcm9sbCA8PSBzdGFydCB8fFxuICAgICAgICAgIGRpciA9PT0gJ2Rvd24nICYmIGlzU2Nyb2xsVXBkYXRlIHx8XG4gICAgICAgICAgZGlyID09PSAndXAnICYmICF0aGlzLmlzRml4ZWQgJiYgc2Nyb2xsIDw9IHRvcE9mZnNldCArIGhlaWdodCkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRml4ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKEFuaW1hdGlvbi5pblByb2dyZXNzKHRoaXMuJGVsKSAmJiB0b3AgPiBzY3JvbGwpIHtcbiAgICAgICAgICAgICAgICBBbmltYXRpb24uY2FuY2VsKHRoaXMuJGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pc0ZpeGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbiAmJiBzY3JvbGwgPiB0b3BPZmZzZXQpIHtcbiAgICAgICAgICAgICAgQW5pbWF0aW9uLmNhbmNlbCh0aGlzLiRlbCk7XG4gICAgICAgICAgICAgIEFuaW1hdGlvbi5vdXQodGhpcy4kZWwsIHRoaXMuYW5pbWF0aW9uKS50aGVuKCgpID0+IHRoaXMuaGlkZSgpLCBub29wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0ZpeGVkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hbmltYXRpb24gJiYgc2Nyb2xsID4gdG9wT2Zmc2V0KSB7XG4gICAgICAgICAgICBBbmltYXRpb24uY2FuY2VsKHRoaXMuJGVsKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgQW5pbWF0aW9uLmluKHRoaXMuJGVsLCB0aGlzLmFuaW1hdGlvbikuY2F0Y2gobm9vcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJywgJ3Njcm9sbCddIH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzaG93KCkge1xuICAgICAgICAgIHRoaXMuaXNGaXhlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGUoKSB7XG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmUoZmFsc2UpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0ZpeGVkLCB0aGlzLmNsc0JlbG93KTtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsIHsgcG9zaXRpb246ICcnLCB0b3A6ICcnLCB3aWR0aDogJycgfSk7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5oaWRkZW4gPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBzY3JvbGwgPSAwLFxuICAgICAgICAgICAgb3ZlcmZsb3csXG4gICAgICAgICAgICBvdmVyZmxvd1Njcm9sbCA9IDAsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIHRvcE9mZnNldCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIG9mZnNldFBhcmVudFRvcCB9ID1cbiAgICAgICAgICB0aGlzLl9kYXRhO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHN0YXJ0ICE9PSAwIHx8IHNjcm9sbCA+IHN0YXJ0O1xuICAgICAgICAgIGxldCBwb3NpdGlvbiA9ICdmaXhlZCc7XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsID4gZW5kKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZW5kIC0gb2Zmc2V0UGFyZW50VG9wO1xuICAgICAgICAgICAgcG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdmVyZmxvdykge1xuICAgICAgICAgICAgb2Zmc2V0IC09IG92ZXJmbG93U2Nyb2xsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNzcyh0aGlzLiRlbCwge1xuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICB0b3A6IG9mZnNldCArIFwicHhcIixcbiAgICAgICAgICAgIHdpZHRoIH0pO1xuXG5cbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZShhY3RpdmUpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0JlbG93LCBzY3JvbGwgPiB0b3BPZmZzZXQgKyBoZWlnaHQpO1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0ZpeGVkKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRBY3RpdmUoYWN0aXZlKSB7XG4gICAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuYWN0aXZlO1xuICAgICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIHJlcGxhY2VDbGFzcyh0aGlzLnNlbFRhcmdldCwgdGhpcy5jbHNJbmFjdGl2ZSwgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICAgICAgcHJldiAhPT0gYWN0aXZlICYmIHRyaWdnZXIodGhpcy4kZWwsICdhY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVwbGFjZUNsYXNzKHRoaXMuc2VsVGFyZ2V0LCB0aGlzLmNsc0FjdGl2ZSwgdGhpcy5jbHNJbmFjdGl2ZSk7XG4gICAgICAgICAgICBwcmV2ICE9PSBhY3RpdmUgJiYgdHJpZ2dlcih0aGlzLiRlbCwgJ2luYWN0aXZlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb3AodmFsdWUsIGVsLCBwcm9wT2Zmc2V0LCBwYWRkaW5nKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLm1hdGNoKC9eLT9cXGQvKSkge1xuICAgICAgICByZXR1cm4gcHJvcE9mZnNldCArIHRvUHgodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVmRWxlbWVudCA9IHZhbHVlID09PSB0cnVlID8gcGFyZW50KGVsKSA6IHF1ZXJ5KHZhbHVlLCBlbCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgb2Zmc2V0KHJlZkVsZW1lbnQpLmJvdHRvbSAtIChcbiAgICAgICAgICBwYWRkaW5nICYmIHJlZkVsZW1lbnQgJiYgd2l0aGluKGVsLCByZWZFbGVtZW50KSA/XG4gICAgICAgICAgdG9GbG9hdChjc3MocmVmRWxlbWVudCwgJ3BhZGRpbmdCb3R0b20nKSkgOlxuICAgICAgICAgIDApKTtcblxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTd2l0Y2hlciA9IHtcbiAgICAgIG1peGluczogW0xhenlsb2FkLCBTd2lwZSwgVG9nZ2xhYmxlXSxcblxuICAgICAgYXJnczogJ2Nvbm5lY3QnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBjb25uZWN0OiBTdHJpbmcsXG4gICAgICAgIHRvZ2dsZTogU3RyaW5nLFxuICAgICAgICBpdGVtTmF2OiBTdHJpbmcsXG4gICAgICAgIGFjdGl2ZTogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjb25uZWN0OiAnfi51ay1zd2l0Y2hlcicsXG4gICAgICAgIHRvZ2dsZTogJz4gKiA+IDpmaXJzdC1jaGlsZCcsXG4gICAgICAgIGl0ZW1OYXY6IGZhbHNlLFxuICAgICAgICBhY3RpdmU6IDAsXG4gICAgICAgIGNsczogJ3VrLWFjdGl2ZScsXG4gICAgICAgIGF0dHJJdGVtOiAndWstc3dpdGNoZXItaXRlbScgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBjb25uZWN0czoge1xuICAgICAgICAgIGdldChfcmVmLCAkZWwpIHtsZXQgeyBjb25uZWN0IH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5QWxsKGNvbm5lY3QsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGNvbm5lY3RzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zd2lwaW5nKSB7XG4gICAgICAgICAgICAgIGNzcyhjb25uZWN0cywgJ3RvdWNoLWFjdGlvbicsICdwYW4teSBwaW5jaC16b29tJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleCgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0cy5mb3JFYWNoKChlbCkgPT5cbiAgICAgICAgICAgIGNoaWxkcmVuKGVsKS5mb3JFYWNoKChjaGlsZCwgaSkgPT4gdG9nZ2xlQ2xhc3MoY2hpbGQsIHRoaXMuY2xzLCBpID09PSBpbmRleCkpKTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIHRvZ2dsZXM6IHtcbiAgICAgICAgICBnZXQoX3JlZjIsICRlbCkge2xldCB7IHRvZ2dsZSB9ID0gX3JlZjI7XG4gICAgICAgICAgICByZXR1cm4gJCQodG9nZ2xlLCAkZWwpLmZpbHRlcihcbiAgICAgICAgICAgIChlbCkgPT4gIW1hdGNoZXMoZWwsICcudWstZGlzYWJsZWQgKiwgLnVrLWRpc2FibGVkLCBbZGlzYWJsZWRdJykpO1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKHRvZ2dsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdyh+YWN0aXZlID8gYWN0aXZlIDogdG9nZ2xlc1t0aGlzLmFjdGl2ZV0gfHwgdG9nZ2xlc1swXSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuKHRoaXMuJGVsKS5maWx0ZXIoKGNoaWxkKSA9PlxuICAgICAgICAgIHRoaXMudG9nZ2xlcy5zb21lKCh0b2dnbGUpID0+IHdpdGhpbih0b2dnbGUsIGNoaWxkKSkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3dpcGVUYXJnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdHM7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMubGF6eWxvYWQodGhpcy4kZWwsIHRoaXMuY29ubmVjdHMpO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBjb25uZWN0c1xuICAgICAgICByZWFkeSgoKSA9PiB0aGlzLiRlbWl0KCkpO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3coZS5jdXJyZW50KTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0cy5jb25jYXQodGhpcy5pdGVtTmF2ID8gcXVlcnlBbGwodGhpcy5pdGVtTmF2LCB0aGlzLiRlbCkgOiBbXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiW1wiICsgdGhpcy5hdHRySXRlbSArIFwiXSxbZGF0YS1cIiArIHRoaXMuYXR0ckl0ZW0gKyBcIl1cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93KGRhdGEoZS5jdXJyZW50LCB0aGlzLmF0dHJJdGVtKSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzd2lwZVJpZ2h0IHN3aXBlTGVmdCcsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN3aXBpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmMykge2xldCB7IHR5cGUgfSA9IF9yZWYzO1xuICAgICAgICAgIHRoaXMuc2hvdyhlbmRzV2l0aCh0eXBlLCAnTGVmdCcpID8gJ25leHQnIDogJ3ByZXZpb3VzJyk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGluZGV4KCkge1xuICAgICAgICAgIHJldHVybiBmaW5kSW5kZXgodGhpcy5jaGlsZHJlbiwgKGVsKSA9PiBoYXNDbGFzcyhlbCwgdGhpcy5jbHMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93KGl0ZW0pIHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5pbmRleCgpO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBnZXRJbmRleChpdGVtLCB0aGlzLnRvZ2dsZXMsIHByZXYpO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IGdldEluZGV4KHRoaXMuY2hpbGRyZW5bbmV4dF0sIGNoaWxkcmVuKHRoaXMuJGVsKSk7XG4gICAgICAgICAgY2hpbGRyZW4odGhpcy4kZWwpLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhjaGlsZCwgdGhpcy5jbHMsIGFjdGl2ZSA9PT0gaSk7XG4gICAgICAgICAgICBhdHRyKHRoaXMudG9nZ2xlc1tpXSwgJ2FyaWEtZXhwYW5kZWQnLCBhY3RpdmUgPT09IGkpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgYW5pbWF0ZSA9IHByZXYgPj0gMCAmJiBwcmV2ICE9PSBuZXh0O1xuICAgICAgICAgIHRoaXMuY29ubmVjdHMuZm9yRWFjaChhc3luYyAoX3JlZjQpID0+IHtsZXQgeyBjaGlsZHJlbiB9ID0gX3JlZjQ7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQoXG4gICAgICAgICAgICB0b05vZGVzKGNoaWxkcmVuKS5maWx0ZXIoKGNoaWxkKSA9PiBoYXNDbGFzcyhjaGlsZCwgdGhpcy5jbHMpKSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYW5pbWF0ZSk7XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudChjaGlsZHJlblthY3RpdmVdLCB0cnVlLCBhbmltYXRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgdGFiID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3NdLFxuXG4gICAgICBleHRlbmRzOiBTd2l0Y2hlcixcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbWVkaWE6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1lZGlhOiA5NjAsXG4gICAgICAgIGF0dHJJdGVtOiAndWstdGFiLWl0ZW0nIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBjb25zdCBjbHMgPSBoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLXRhYi1sZWZ0JykgP1xuICAgICAgICAndWstdGFiLWxlZnQnIDpcbiAgICAgICAgaGFzQ2xhc3ModGhpcy4kZWwsICd1ay10YWItcmlnaHQnKSA/XG4gICAgICAgICd1ay10YWItcmlnaHQnIDpcbiAgICAgICAgZmFsc2U7XG5cbiAgICAgICAgaWYgKGNscykge1xuICAgICAgICAgIHRoaXMuJGNyZWF0ZSgndG9nZ2xlJywgdGhpcy4kZWwsIHsgY2xzLCBtb2RlOiAnbWVkaWEnLCBtZWRpYTogdGhpcy5tZWRpYSB9KTtcbiAgICAgICAgfVxuICAgICAgfSB9O1xuXG4gICAgY29uc3QgS0VZX1NQQUNFID0gMzI7XG5cbiAgICB2YXIgdG9nZ2xlID0ge1xuICAgICAgbWl4aW5zOiBbTGF6eWxvYWQsIE1lZGlhLCBUb2dnbGFibGVdLFxuXG4gICAgICBhcmdzOiAndGFyZ2V0JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaHJlZjogU3RyaW5nLFxuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIG1vZGU6ICdsaXN0JyxcbiAgICAgICAgcXVldWVkOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBocmVmOiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgbW9kZTogJ2NsaWNrJyxcbiAgICAgICAgcXVldWVkOiB0cnVlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgZ2V0KF9yZWYsICRlbCkge2xldCB7IGhyZWYsIHRhcmdldCB9ID0gX3JlZjtcbiAgICAgICAgICAgIHRhcmdldCA9IHF1ZXJ5QWxsKHRhcmdldCB8fCBocmVmLCAkZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGggJiYgdGFyZ2V0IHx8IFskZWxdO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXJpYSgpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSB9LFxuXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAoIWluY2x1ZGVzKHRoaXMubW9kZSwgJ21lZGlhJykgJiYgIWlzRm9jdXNhYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgIGF0dHIodGhpcy4kZWwsICd0YWJpbmRleCcsICcwJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhenlsb2FkKHRoaXMuJGVsLCB0aGlzLnRhcmdldCk7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHRhcmdldFxuICAgICAgICByZWFkeSgoKSA9PiB0aGlzLiRlbWl0KCkpO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IHBvaW50ZXJEb3duLFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZXModGhpcy5tb2RlLCAnaG92ZXInKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoIWlzVG91Y2goZSkgfHwgdGhpcy5fc2hvd1N0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2xpY2tpbmcgYSBidXR0b24gZG9lcyBub3QgZ2l2ZSBpdCBmb2N1cyBvbiBhbGwgYnJvd3NlcnMgYW5kIHBsYXRmb3Jtc1xuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9idXR0b24jY2xpY2tpbmdfYW5kX2ZvY3VzXG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2ZvY3VzJyk7XG4gICAgICAgICAgb25jZShcbiAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICBwb2ludGVyRG93bixcbiAgICAgICAgICAoKSA9PiB0cmlnZ2VyKHRoaXMuJGVsLCAnYmx1cicpLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgKGUpID0+ICF3aXRoaW4oZS50YXJnZXQsIHRoaXMuJGVsKSk7XG5cblxuICAgICAgICAgIC8vIFByZXZlbnQgaW5pdGlhbCBjbGljayB0byBwcmV2ZW50IGRvdWJsZSB0b2dnbGUgdGhyb3VnaCBmb2N1cyArIGNsaWNrXG4gICAgICAgICAgaWYgKGluY2x1ZGVzKHRoaXMubW9kZSwgJ2NsaWNrJykpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRDbGljayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyRW50ZXIgKyBcIiBcIiArIHBvaW50ZXJMZWF2ZSArIFwiIGZvY3VzIGJsdXJcIixcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ2hvdmVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGlzVG91Y2goZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzaG93ID0gaW5jbHVkZXMoW3BvaW50ZXJFbnRlciwgJ2ZvY3VzJ10sIGUudHlwZSk7XG4gICAgICAgICAgY29uc3QgZXhwYW5kZWQgPSBhdHRyKHRoaXMuJGVsLCAnYXJpYS1leHBhbmRlZCcpO1xuXG4gICAgICAgICAgLy8gU2tpcCBoaWRlIGlmIHN0aWxsIGhvdmVyZWQgb3IgZm9jdXNlZFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAhc2hvdyAmJiAoXG4gICAgICAgICAgZS50eXBlID09PSBwb2ludGVyTGVhdmUgJiYgbWF0Y2hlcyh0aGlzLiRlbCwgJzpmb2N1cycpIHx8XG4gICAgICAgICAgZS50eXBlID09PSAnYmx1cicgJiYgbWF0Y2hlcyh0aGlzLiRlbCwgJzpob3ZlcicpKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2tpcCBpZiBzdGF0ZSBkb2VzIG5vdCBjaGFuZ2UgZS5nLiBob3ZlciArIGZvY3VzIHJlY2VpdmVkXG4gICAgICAgICAgaWYgKHRoaXMuX3Nob3dTdGF0ZSAmJiBzaG93ICYmIGV4cGFuZGVkICE9PSB0aGlzLl9zaG93U3RhdGUpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSByZXNldCBpZiBzdGF0ZSBoYXMgY2hhbmdlZCB0aHJvdWdoIGNsaWNrXG4gICAgICAgICAgICBpZiAoIXNob3cpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2hvd1N0YXRlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9zaG93U3RhdGUgPSBzaG93ID8gZXhwYW5kZWQgOiBudWxsO1xuXG4gICAgICAgICAgdGhpcy50b2dnbGUoXCJ0b2dnbGVcIiArIChzaG93ID8gJ3Nob3cnIDogJ2hpZGUnKSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdrZXlkb3duJyxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ2NsaWNrJykgJiYgIWlzVGFnKHRoaXMuJGVsLCAnaW5wdXQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlfU1BBQ0UpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuJGVsLmNsaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZXModGhpcy5tb2RlLCAnY2xpY2snKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcHJldmVudENsaWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJldmVudENsaWNrID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgbGluaztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgY2xvc2VzdChlLnRhcmdldCwgJ2FbaHJlZj1cIiNcIl0sIGFbaHJlZj1cIlwiXScpIHx8XG4gICAgICAgICAgKGxpbmsgPSBjbG9zZXN0KGUudGFyZ2V0LCAnYVtocmVmXScpKSAmJiAoXG4gICAgICAgICAgYXR0cih0aGlzLiRlbCwgJ2FyaWEtZXhwYW5kZWQnKSAhPT0gJ3RydWUnIHx8XG4gICAgICAgICAgbGluay5oYXNoICYmIG1hdGNoZXModGhpcy50YXJnZXQsIGxpbmsuaGFzaCkpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG9nZ2xlZCcsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlLCB0b2dnbGVkKSB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLnRhcmdldFswXSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBcmlhKHRvZ2dsZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ21lZGlhY2hhbmdlJyxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ21lZGlhJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSwgbWVkaWFPYmopIHtcbiAgICAgICAgICBpZiAobWVkaWFPYmoubWF0Y2hlcyBeIHRoaXMuaXNUb2dnbGVkKHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIHRvZ2dsZSh0eXBlKSB7XG4gICAgICAgICAgaWYgKCF0cmlnZ2VyKHRoaXMudGFyZ2V0LCB0eXBlIHx8ICd0b2dnbGUnLCBbdGhpc10pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLnRhcmdldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbGVhdmluZyA9IHRoaXMudGFyZ2V0LmZpbHRlcigoZWwpID0+IGhhc0NsYXNzKGVsLCB0aGlzLmNsc0xlYXZlKSk7XG5cbiAgICAgICAgICBpZiAobGVhdmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgaXNMZWF2aW5nID0gaW5jbHVkZXMobGVhdmluZywgZWwpO1xuICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUVsZW1lbnQoZWwsIGlzTGVhdmluZywgaXNMZWF2aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0b2dnbGVkID0gdGhpcy50YXJnZXQuZmlsdGVyKHRoaXMuaXNUb2dnbGVkKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQodG9nZ2xlZCwgZmFsc2UpO1xuICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudChcbiAgICAgICAgICB0aGlzLnRhcmdldC5maWx0ZXIoKGVsKSA9PiAhaW5jbHVkZXModG9nZ2xlZCwgZWwpKSxcbiAgICAgICAgICB0cnVlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUFyaWEodG9nZ2xlZCkge1xuICAgICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLm1vZGUsICdtZWRpYScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0cihcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCcsXG4gICAgICAgICAgaXNCb29sZWFuKHRvZ2dsZWQpID8gdG9nZ2xlZCA6IHRoaXMuaXNUb2dnbGVkKHRoaXMudGFyZ2V0KSk7XG5cbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgY29tcG9uZW50cyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIEFjY29yZGlvbjogQWNjb3JkaW9uLFxuICAgICAgICBBbGVydDogYWxlcnQsXG4gICAgICAgIENvdmVyOiBjb3ZlcixcbiAgICAgICAgRHJvcDogZHJvcCxcbiAgICAgICAgRHJvcGRvd246IGRyb3AsXG4gICAgICAgIEZvcm1DdXN0b206IGZvcm1DdXN0b20sXG4gICAgICAgIEdyaWQ6IGdyaWQsXG4gICAgICAgIEhlaWdodE1hdGNoOiBoZWlnaHRNYXRjaCxcbiAgICAgICAgSGVpZ2h0Vmlld3BvcnQ6IGhlaWdodFZpZXdwb3J0LFxuICAgICAgICBJY29uOiBJY29uLFxuICAgICAgICBJbWc6IGltZyxcbiAgICAgICAgTGVhZGVyOiBsZWFkZXIsXG4gICAgICAgIE1hcmdpbjogTWFyZ2luLFxuICAgICAgICBNb2RhbDogbW9kYWwsXG4gICAgICAgIE5hdjogbmF2LFxuICAgICAgICBOYXZiYXI6IG5hdmJhcixcbiAgICAgICAgT2ZmY2FudmFzOiBvZmZjYW52YXMsXG4gICAgICAgIE92ZXJmbG93QXV0bzogb3ZlcmZsb3dBdXRvLFxuICAgICAgICBSZXNwb25zaXZlOiByZXNwb25zaXZlLFxuICAgICAgICBTY3JvbGw6IHNjcm9sbCxcbiAgICAgICAgU2Nyb2xsc3B5OiBzY3JvbGxzcHksXG4gICAgICAgIFNjcm9sbHNweU5hdjogc2Nyb2xsc3B5TmF2LFxuICAgICAgICBTdGlja3k6IHN0aWNreSxcbiAgICAgICAgU3ZnOiBTVkcsXG4gICAgICAgIFN3aXRjaGVyOiBTd2l0Y2hlcixcbiAgICAgICAgVGFiOiB0YWIsXG4gICAgICAgIFRvZ2dsZTogdG9nZ2xlLFxuICAgICAgICBWaWRlbzogVmlkZW8sXG4gICAgICAgIENsb3NlOiBDbG9zZSxcbiAgICAgICAgU3Bpbm5lcjogU3Bpbm5lcixcbiAgICAgICAgU2xpZGVuYXZOZXh0OiBTbGlkZW5hdixcbiAgICAgICAgU2xpZGVuYXZQcmV2aW91czogU2xpZGVuYXYsXG4gICAgICAgIFNlYXJjaEljb246IFNlYXJjaCxcbiAgICAgICAgTWFya2VyOiBJY29uQ29tcG9uZW50LFxuICAgICAgICBOYXZiYXJUb2dnbGVJY29uOiBJY29uQ29tcG9uZW50LFxuICAgICAgICBPdmVybGF5SWNvbjogSWNvbkNvbXBvbmVudCxcbiAgICAgICAgUGFnaW5hdGlvbk5leHQ6IEljb25Db21wb25lbnQsXG4gICAgICAgIFBhZ2luYXRpb25QcmV2aW91czogSWNvbkNvbXBvbmVudCxcbiAgICAgICAgVG90b3A6IEljb25Db21wb25lbnRcbiAgICB9KTtcblxuICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudHNcbiAgICBlYWNoKGNvbXBvbmVudHMkMSwgKGNvbXBvbmVudCwgbmFtZSkgPT4gVUlraXQuY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkpO1xuXG4gICAgLy8gY29yZSBmdW5jdGlvbmFsaXR5XG4gICAgVUlraXQudXNlKENvcmUpO1xuXG4gICAgYm9vdChVSWtpdCk7XG5cbiAgICBjb25zdCB1bml0cyA9IFsnZGF5cycsICdob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXTtcblxuICAgIHZhciBjb3VudGRvd24gPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzc10sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRhdGU6IFN0cmluZyxcbiAgICAgICAgY2xzV3JhcHBlcjogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRlOiAnJyxcbiAgICAgICAgY2xzV3JhcHBlcjogJy51ay1jb3VudGRvd24tJXVuaXQlJyB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5kYXRlID0gRGF0ZS5wYXJzZSh0aGlzLiRwcm9wcy5kYXRlKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAndmlzaWJpbGl0eWNoYW5nZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMudXBkYXRlLCAxMDAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdG9wKCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlKCkge1xuICAgICAgICAgIGNvbnN0IHRpbWVzcGFuID0gZ2V0VGltZVNwYW4odGhpcy5kYXRlKTtcblxuICAgICAgICAgIGlmICghdGhpcy5kYXRlIHx8IHRpbWVzcGFuLnRvdGFsIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgICAgICB0aW1lc3Bhbi5kYXlzID0gdGltZXNwYW4uaG91cnMgPSB0aW1lc3Bhbi5taW51dGVzID0gdGltZXNwYW4uc2Vjb25kcyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChjb25zdCB1bml0IG9mIHVuaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9ICQodGhpcy5jbHNXcmFwcGVyLnJlcGxhY2UoJyV1bml0JScsIHVuaXQpLCB0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBkaWdpdHMgPSBTdHJpbmcoTWF0aC50cnVuYyh0aW1lc3Bhblt1bml0XSkpO1xuXG4gICAgICAgICAgICBkaWdpdHMgPSBkaWdpdHMubGVuZ3RoIDwgMiA/IFwiMFwiICsgZGlnaXRzIDogZGlnaXRzO1xuXG4gICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IGRpZ2l0cykge1xuICAgICAgICAgICAgICBkaWdpdHMgPSBkaWdpdHMuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgIGlmIChkaWdpdHMubGVuZ3RoICE9PSBlbC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBodG1sKGVsLCBkaWdpdHMubWFwKCgpID0+ICc8c3Bhbj48L3NwYW4+Jykuam9pbignJykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGlnaXRzLmZvckVhY2goKGRpZ2l0LCBpKSA9PiBlbC5jaGlsZHJlbltpXS50ZXh0Q29udGVudCA9IGRpZ2l0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldFRpbWVTcGFuKGRhdGUpIHtcbiAgICAgIGNvbnN0IHRvdGFsID0gZGF0ZSAtIERhdGUubm93KCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvdGFsLFxuICAgICAgICBzZWNvbmRzOiB0b3RhbCAvIDEwMDAgJSA2MCxcbiAgICAgICAgbWludXRlczogdG90YWwgLyAxMDAwIC8gNjAgJSA2MCxcbiAgICAgICAgaG91cnM6IHRvdGFsIC8gMTAwMCAvIDYwIC8gNjAgJSAyNCxcbiAgICAgICAgZGF5czogdG90YWwgLyAxMDAwIC8gNjAgLyA2MCAvIDI0IH07XG5cbiAgICB9XG5cbiAgICBjb25zdCBjbHNMZWF2ZSA9ICd1ay10cmFuc2l0aW9uLWxlYXZlJztcbiAgICBjb25zdCBjbHNFbnRlciA9ICd1ay10cmFuc2l0aW9uLWVudGVyJztcblxuICAgIGZ1bmN0aW9uIGZhZGUoYWN0aW9uLCB0YXJnZXQsIGR1cmF0aW9uLCBzdGFnZ2VyKSB7aWYgKHN0YWdnZXIgPT09IHZvaWQgMCkge3N0YWdnZXIgPSAwO31cbiAgICAgIGNvbnN0IGluZGV4ID0gdHJhbnNpdGlvbkluZGV4KHRhcmdldCwgdHJ1ZSk7XG4gICAgICBjb25zdCBwcm9wc0luID0geyBvcGFjaXR5OiAxIH07XG4gICAgICBjb25zdCBwcm9wc091dCA9IHsgb3BhY2l0eTogMCB9O1xuXG4gICAgICBjb25zdCB3cmFwSW5kZXhGbiA9IChmbikgPT4gKCkgPT4gaW5kZXggPT09IHRyYW5zaXRpb25JbmRleCh0YXJnZXQpID8gZm4oKSA6IFByb21pc2UucmVqZWN0KCk7XG5cbiAgICAgIGNvbnN0IGxlYXZlRm4gPSB3cmFwSW5kZXhGbigoKSA9PiB7XG4gICAgICAgIGFkZENsYXNzKHRhcmdldCwgY2xzTGVhdmUpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgZ2V0VHJhbnNpdGlvbk5vZGVzKHRhcmdldCkubWFwKFxuICAgICAgICAoY2hpbGQsIGkpID0+XG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PlxuICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PlxuICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KGNoaWxkLCBwcm9wc091dCwgZHVyYXRpb24gLyAyLCAnZWFzZScpLnRoZW4oXG4gICAgICAgIHJlc29sdmUpLFxuXG4gICAgICAgIGkgKiBzdGFnZ2VyKSkpKS5cblxuXG5cbiAgICAgICAgdGhlbigoKSA9PiByZW1vdmVDbGFzcyh0YXJnZXQsIGNsc0xlYXZlKSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZW50ZXJGbiA9IHdyYXBJbmRleEZuKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gaGVpZ2h0KHRhcmdldCk7XG5cbiAgICAgICAgYWRkQ2xhc3ModGFyZ2V0LCBjbHNFbnRlcik7XG4gICAgICAgIGFjdGlvbigpO1xuXG4gICAgICAgIGNzcyhjaGlsZHJlbih0YXJnZXQpLCB7IG9wYWNpdHk6IDAgfSk7XG5cbiAgICAgICAgLy8gRW5zdXJlIFVJa2l0IHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlcyA9IGNoaWxkcmVuKHRhcmdldCk7XG4gICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gaGVpZ2h0KHRhcmdldCk7XG5cbiAgICAgICAgICAvLyBFbnN1cmUgR3JpZCBjZWxscyBkbyBub3Qgc3RyZXRjaCB3aGVuIGhlaWdodCBpcyBhcHBsaWVkXG4gICAgICAgICAgY3NzKHRhcmdldCwgJ2FsaWduQ29udGVudCcsICdmbGV4LXN0YXJ0Jyk7XG4gICAgICAgICAgaGVpZ2h0KHRhcmdldCwgb2xkSGVpZ2h0KTtcblxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25Ob2RlcyA9IGdldFRyYW5zaXRpb25Ob2Rlcyh0YXJnZXQpO1xuICAgICAgICAgIGNzcyhub2RlcywgcHJvcHNPdXQpO1xuXG4gICAgICAgICAgY29uc3QgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uTm9kZXMubWFwKFxuICAgICAgICAgIChjaGlsZCwgaSkgPT5cbiAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICgpID0+XG4gICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChjaGlsZCwgcHJvcHNJbiwgZHVyYXRpb24gLyAyLCAnZWFzZScpLnRoZW4oXG4gICAgICAgICAgcmVzb2x2ZSksXG5cbiAgICAgICAgICBpICogc3RhZ2dlcikpKTtcblxuXG5cblxuICAgICAgICAgIGlmIChvbGRIZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnMucHVzaChcbiAgICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB7IGhlaWdodDogbmV3SGVpZ2h0IH0sXG4gICAgICAgICAgICBkdXJhdGlvbiAvIDIgKyB0cmFuc2l0aW9uTm9kZXMubGVuZ3RoICogc3RhZ2dlcixcbiAgICAgICAgICAgICdlYXNlJykpO1xuXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBQcm9taXNlLmFsbCh0cmFuc2l0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyh0YXJnZXQsIGNsc0VudGVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdHJhbnNpdGlvbkluZGV4KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgY3NzKHRhcmdldCwgeyBoZWlnaHQ6ICcnLCBhbGlnbkNvbnRlbnQ6ICcnIH0pO1xuICAgICAgICAgICAgICBjc3Mobm9kZXMsIHsgb3BhY2l0eTogJycgfSk7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQuZGF0YXNldC50cmFuc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaGFzQ2xhc3ModGFyZ2V0LCBjbHNMZWF2ZSkgP1xuICAgICAgd2FpdFRyYW5zaXRpb25lbmQodGFyZ2V0KS50aGVuKGVudGVyRm4pIDpcbiAgICAgIGhhc0NsYXNzKHRhcmdldCwgY2xzRW50ZXIpID9cbiAgICAgIHdhaXRUcmFuc2l0aW9uZW5kKHRhcmdldCkudGhlbihsZWF2ZUZuKS50aGVuKGVudGVyRm4pIDpcbiAgICAgIGxlYXZlRm4oKS50aGVuKGVudGVyRm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25JbmRleCh0YXJnZXQsIG5leHQpIHtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIHRhcmdldC5kYXRhc2V0LnRyYW5zaXRpb24gPSAxICsgdHJhbnNpdGlvbkluZGV4KHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b051bWJlcih0YXJnZXQuZGF0YXNldC50cmFuc2l0aW9uKSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhaXRUcmFuc2l0aW9uZW5kKHRhcmdldCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgY2hpbGRyZW4odGFyZ2V0KS5cbiAgICAgIGZpbHRlcihUcmFuc2l0aW9uLmluUHJvZ3Jlc3MpLlxuICAgICAgbWFwKFxuICAgICAgKGVsKSA9PlxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IG9uY2UoZWwsICd0cmFuc2l0aW9uZW5kIHRyYW5zaXRpb25jYW5jZWxlZCcsIHJlc29sdmUpKSkpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uTm9kZXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0Um93cyhjaGlsZHJlbih0YXJnZXQpKS5yZWR1Y2UoXG4gICAgICAobm9kZXMsIHJvdykgPT5cbiAgICAgIG5vZGVzLmNvbmNhdChcbiAgICAgIHNvcnRCeSQxKFxuICAgICAgcm93LmZpbHRlcigoZWwpID0+IGlzSW5WaWV3KGVsKSksXG4gICAgICAnb2Zmc2V0TGVmdCcpKSxcblxuXG4gICAgICBbXSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbGlkZSAoYWN0aW9uLCB0YXJnZXQsIGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBsZXQgbm9kZXMgPSBjaGlsZHJlbih0YXJnZXQpO1xuXG4gICAgICAgIC8vIEdldCBjdXJyZW50IHN0YXRlXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9wcyA9IG5vZGVzLm1hcCgoZWwpID0+IGdldFByb3BzKGVsLCB0cnVlKSk7XG4gICAgICAgIGNvbnN0IHRhcmdldFByb3BzID0gY3NzKHRhcmdldCwgWydoZWlnaHQnLCAncGFkZGluZyddKTtcblxuICAgICAgICAvLyBDYW5jZWwgcHJldmlvdXMgYW5pbWF0aW9uc1xuICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbCh0YXJnZXQpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKFRyYW5zaXRpb24uY2FuY2VsKTtcbiAgICAgICAgcmVzZXQodGFyZ2V0KTtcblxuICAgICAgICAvLyBBZGRpbmcsIHNvcnRpbmcsIHJlbW92aW5nIG5vZGVzXG4gICAgICAgIGFjdGlvbigpO1xuXG4gICAgICAgIC8vIEZpbmQgbmV3IG5vZGVzXG4gICAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNoaWxkcmVuKHRhcmdldCkuZmlsdGVyKChlbCkgPT4gIWluY2x1ZGVzKG5vZGVzLCBlbCkpKTtcblxuICAgICAgICAvLyBXYWl0IGZvciB1cGRhdGUgdG8gcHJvcGFnYXRlXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIC8vIEZvcmNlIHVwZGF0ZVxuICAgICAgICAgIGZhc3Rkb20uZmx1c2goKTtcblxuICAgICAgICAgIC8vIEdldCBuZXcgc3RhdGVcbiAgICAgICAgICBjb25zdCB0YXJnZXRQcm9wc1RvID0gY3NzKHRhcmdldCwgWydoZWlnaHQnLCAncGFkZGluZyddKTtcbiAgICAgICAgICBjb25zdCBbcHJvcHNUbywgcHJvcHNGcm9tXSA9IGdldFRyYW5zaXRpb25Qcm9wcyh0YXJnZXQsIG5vZGVzLCBjdXJyZW50UHJvcHMpO1xuXG4gICAgICAgICAgLy8gUmVzZXQgdG8gcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICBub2Rlcy5mb3JFYWNoKChlbCwgaSkgPT4gcHJvcHNGcm9tW2ldICYmIGNzcyhlbCwgcHJvcHNGcm9tW2ldKSk7XG4gICAgICAgICAgY3NzKHRhcmdldCwgeyBkaXNwbGF5OiAnYmxvY2snLCAuLi50YXJnZXRQcm9wcyB9KTtcblxuICAgICAgICAgIC8vIFN0YXJ0IHRyYW5zaXRpb25zIG9uIG5leHQgZnJhbWVcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbnMgPSBub2Rlcy5cbiAgICAgICAgICAgIG1hcChcbiAgICAgICAgICAgIChlbCwgaSkgPT5cbiAgICAgICAgICAgIHBhcmVudChlbCkgPT09IHRhcmdldCAmJlxuICAgICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChlbCwgcHJvcHNUb1tpXSwgZHVyYXRpb24sICdlYXNlJykpLlxuXG4gICAgICAgICAgICBjb25jYXQoVHJhbnNpdGlvbi5zdGFydCh0YXJnZXQsIHRhcmdldFByb3BzVG8sIGR1cmF0aW9uLCAnZWFzZScpKTtcblxuICAgICAgICAgICAgUHJvbWlzZS5hbGwodHJhbnNpdGlvbnMpLlxuICAgICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goXG4gICAgICAgICAgICAgIChlbCwgaSkgPT5cbiAgICAgICAgICAgICAgcGFyZW50KGVsKSA9PT0gdGFyZ2V0ICYmXG4gICAgICAgICAgICAgIGNzcyhlbCwgJ2Rpc3BsYXknLCBwcm9wc1RvW2ldLm9wYWNpdHkgPT09IDAgPyAnbm9uZScgOiAnJykpO1xuXG4gICAgICAgICAgICAgIHJlc2V0KHRhcmdldCk7XG4gICAgICAgICAgICB9LCBub29wKS5cbiAgICAgICAgICAgIHRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJvcHMoZWwsIG9wYWNpdHkpIHtcbiAgICAgIGNvbnN0IHpJbmRleCA9IGNzcyhlbCwgJ3pJbmRleCcpO1xuXG4gICAgICByZXR1cm4gaXNWaXNpYmxlKGVsKSA/XG4gICAgICB7XG4gICAgICAgIGRpc3BsYXk6ICcnLFxuICAgICAgICBvcGFjaXR5OiBvcGFjaXR5ID8gY3NzKGVsLCAnb3BhY2l0eScpIDogJzAnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB6SW5kZXg6IHpJbmRleCA9PT0gJ2F1dG8nID8gaW5kZXgoZWwpIDogekluZGV4LFxuICAgICAgICAuLi5nZXRQb3NpdGlvbldpdGhNYXJnaW4oZWwpIH0gOlxuXG4gICAgICBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uUHJvcHModGFyZ2V0LCBub2RlcywgY3VycmVudFByb3BzKSB7XG4gICAgICBjb25zdCBwcm9wc1RvID0gbm9kZXMubWFwKChlbCwgaSkgPT5cbiAgICAgIHBhcmVudChlbCkgJiYgaSBpbiBjdXJyZW50UHJvcHMgP1xuICAgICAgY3VycmVudFByb3BzW2ldID9cbiAgICAgIGlzVmlzaWJsZShlbCkgP1xuICAgICAgZ2V0UG9zaXRpb25XaXRoTWFyZ2luKGVsKSA6XG4gICAgICB7IG9wYWNpdHk6IDAgfSA6XG4gICAgICB7IG9wYWNpdHk6IGlzVmlzaWJsZShlbCkgPyAxIDogMCB9IDpcbiAgICAgIGZhbHNlKTtcblxuXG4gICAgICBjb25zdCBwcm9wc0Zyb20gPSBwcm9wc1RvLm1hcCgocHJvcHMsIGkpID0+IHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBhcmVudChub2Rlc1tpXSkgPT09IHRhcmdldCAmJiAoY3VycmVudFByb3BzW2ldIHx8IGdldFByb3BzKG5vZGVzW2ldKSk7XG5cbiAgICAgICAgaWYgKCFmcm9tKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgIGRlbGV0ZSBmcm9tLm9wYWNpdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoISgnb3BhY2l0eScgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgY29uc3QgeyBvcGFjaXR5IH0gPSBmcm9tO1xuXG4gICAgICAgICAgaWYgKG9wYWNpdHkgJSAxKSB7XG4gICAgICAgICAgICBwcm9wcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGZyb20ub3BhY2l0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gW3Byb3BzVG8sIHByb3BzRnJvbV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXQoZWwpIHtcbiAgICAgIGNzcyhlbC5jaGlsZHJlbiwge1xuICAgICAgICBoZWlnaHQ6ICcnLFxuICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgb3BhY2l0eTogJycsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICcnLFxuICAgICAgICBwb3NpdGlvbjogJycsXG4gICAgICAgIHRvcDogJycsXG4gICAgICAgIG1hcmdpblRvcDogJycsXG4gICAgICAgIG1hcmdpbkxlZnQ6ICcnLFxuICAgICAgICB0cmFuc2Zvcm06ICcnLFxuICAgICAgICB3aWR0aDogJycsXG4gICAgICAgIHpJbmRleDogJycgfSk7XG5cbiAgICAgIGNzcyhlbCwgeyBoZWlnaHQ6ICcnLCBkaXNwbGF5OiAnJywgcGFkZGluZzogJycgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25XaXRoTWFyZ2luKGVsKSB7XG4gICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IG9mZnNldChlbCk7XG4gICAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gcG9zaXRpb24oZWwpO1xuICAgICAgY29uc3QgeyBtYXJnaW5MZWZ0LCBtYXJnaW5Ub3AgfSA9IGNzcyhlbCwgWydtYXJnaW5Ub3AnLCAnbWFyZ2luTGVmdCddKTtcblxuICAgICAgcmV0dXJuIHsgdG9wLCBsZWZ0LCBoZWlnaHQsIHdpZHRoLCBtYXJnaW5MZWZ0LCBtYXJnaW5Ub3AsIHRyYW5zZm9ybTogJycgfTtcbiAgICB9XG5cbiAgICB2YXIgQW5pbWF0ZSA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIsXG4gICAgICAgIGFuaW1hdGlvbjogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgYW5pbWF0aW9uOiAnc2xpZGUnIH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhbmltYXRlKGFjdGlvbiwgdGFyZ2V0KSB7aWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7dGFyZ2V0ID0gdGhpcy4kZWw7fVxuICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmFuaW1hdGlvbjtcbiAgICAgICAgICBjb25zdCBhbmltYXRpb25GbiA9XG4gICAgICAgICAgbmFtZSA9PT0gJ2ZhZGUnID9cbiAgICAgICAgICBmYWRlIDpcbiAgICAgICAgICBuYW1lID09PSAnZGVsYXllZC1mYWRlJyA/XG4gICAgICAgICAgZnVuY3Rpb24gKCkge2ZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge2FyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07fXJldHVybiBmYWRlKC4uLmFyZ3MsIDQwKTt9IDpcbiAgICAgICAgICBuYW1lID9cbiAgICAgICAgICBzbGlkZSA6XG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBhbmltYXRpb25GbihhY3Rpb24sIHRhcmdldCwgdGhpcy5kdXJhdGlvbikudGhlbihcbiAgICAgICAgICAoKSA9PiB0aGlzLiR1cGRhdGUodGFyZ2V0LCAncmVzaXplJyksXG4gICAgICAgICAgbm9vcCk7XG5cbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgZmlsdGVyID0ge1xuICAgICAgbWl4aW5zOiBbQW5pbWF0ZV0sXG5cbiAgICAgIGFyZ3M6ICd0YXJnZXQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IEJvb2xlYW4sXG4gICAgICAgIHNlbEFjdGl2ZTogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICBzZWxBY3RpdmU6IGZhbHNlLFxuICAgICAgICBhdHRySXRlbTogJ3VrLWZpbHRlci1jb250cm9sJyxcbiAgICAgICAgY2xzOiAndWstYWN0aXZlJyxcbiAgICAgICAgZHVyYXRpb246IDI1MCB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRvZ2dsZXM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgYXR0ckl0ZW0gfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gJCQoXCJbXCIgKyBhdHRySXRlbSArIFwiXSxbZGF0YS1cIiArIGF0dHJJdGVtICsgXCJdXCIsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxBY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZXMgPSAkJCh0aGlzLnNlbEFjdGl2ZSwgdGhpcy4kZWwpO1xuICAgICAgICAgICAgICB0aGlzLnRvZ2dsZXMuZm9yRWFjaCgoZWwpID0+IHRvZ2dsZUNsYXNzKGVsLCB0aGlzLmNscywgaW5jbHVkZXMoYWN0aXZlcywgZWwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgICBnZXQoX3JlZjIsICRlbCkge2xldCB7IHRhcmdldCB9ID0gX3JlZjI7XG4gICAgICAgICAgICByZXR1cm4gJCQodGFyZ2V0ICsgXCIgPiAqXCIsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGxpc3QsIG9sZCkge1xuICAgICAgICAgICAgaWYgKG9sZCAmJiAhaXNFcXVhbExpc3QobGlzdCwgb2xkKSkge1xuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9IH0sXG5cblxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gXCJbXCIgKyB0aGlzLmF0dHJJdGVtICsgXCJdLFtkYXRhLVwiICsgdGhpcy5hdHRySXRlbSArIFwiXVwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmFwcGx5KGUuY3VycmVudCk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFwcGx5KGVsKSB7XG4gICAgICAgICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gbWVyZ2VTdGF0ZShlbCwgdGhpcy5hdHRySXRlbSwgdGhpcy5nZXRTdGF0ZSgpKTtcblxuICAgICAgICAgIGlmICghaXNFcXVhbFN0YXRlKHByZXZTdGF0ZSwgbmV3U3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlcy5cbiAgICAgICAgICBmaWx0ZXIoKGl0ZW0pID0+IGhhc0NsYXNzKGl0ZW0sIHRoaXMuY2xzKSkuXG4gICAgICAgICAgcmVkdWNlKChzdGF0ZSwgZWwpID0+IG1lcmdlU3RhdGUoZWwsIHRoaXMuYXR0ckl0ZW0sIHN0YXRlKSwge1xuICAgICAgICAgICAgZmlsdGVyOiB7ICcnOiAnJyB9LFxuICAgICAgICAgICAgc29ydDogW10gfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRTdGF0ZShzdGF0ZSwgYW5pbWF0ZSkge2lmIChhbmltYXRlID09PSB2b2lkIDApIHthbmltYXRlID0gdHJ1ZTt9XG4gICAgICAgICAgc3RhdGUgPSB7IGZpbHRlcjogeyAnJzogJycgfSwgc29ydDogW10sIC4uLnN0YXRlIH07XG5cbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnYmVmb3JlRmlsdGVyJywgW3RoaXMsIHN0YXRlXSk7XG5cbiAgICAgICAgICB0aGlzLnRvZ2dsZXMuZm9yRWFjaCgoZWwpID0+XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzLCAhIW1hdGNoRmlsdGVyKGVsLCB0aGlzLmF0dHJJdGVtLCBzdGF0ZSkpKTtcblxuXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgJCQodGhpcy50YXJnZXQsIHRoaXMuJGVsKS5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGFwcGx5U3RhdGUoc3RhdGUsIHRhcmdldCwgY2hpbGRyZW4odGFyZ2V0KSk7XG4gICAgICAgICAgICAgIHRoaXMuJHVwZGF0ZSh0aGlzLiRlbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGUgPyB0aGlzLmFuaW1hdGUoZmlsdGVyRm4sIHRhcmdldCkgOiBmaWx0ZXJGbigpO1xuICAgICAgICAgIH0pKS5cbiAgICAgICAgICB0aGVuKCgpID0+IHRyaWdnZXIodGhpcy4kZWwsICdhZnRlckZpbHRlcicsIFt0aGlzXSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICAgIGZhc3Rkb20ud3JpdGUoKCkgPT4gdGhpcy5zZXRTdGF0ZSh0aGlzLmdldFN0YXRlKCksIGZhbHNlKSk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldEZpbHRlcihlbCwgYXR0cikge1xuICAgICAgcmV0dXJuIHBhcnNlT3B0aW9ucyhkYXRhKGVsLCBhdHRyKSwgWydmaWx0ZXInXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFcXVhbFN0YXRlKHN0YXRlQSwgc3RhdGVCKSB7XG4gICAgICByZXR1cm4gWydmaWx0ZXInLCAnc29ydCddLmV2ZXJ5KChwcm9wKSA9PiBpc0VxdWFsKHN0YXRlQVtwcm9wXSwgc3RhdGVCW3Byb3BdKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlTdGF0ZShzdGF0ZSwgdGFyZ2V0LCBjaGlsZHJlbikge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihzdGF0ZSk7XG5cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goKGVsKSA9PiBjc3MoZWwsICdkaXNwbGF5Jywgc2VsZWN0b3IgJiYgIW1hdGNoZXMoZWwsIHNlbGVjdG9yKSA/ICdub25lJyA6ICcnKSk7XG5cbiAgICAgIGNvbnN0IFtzb3J0LCBvcmRlcl0gPSBzdGF0ZS5zb3J0O1xuXG4gICAgICBpZiAoc29ydCkge1xuICAgICAgICBjb25zdCBzb3J0ZWQgPSBzb3J0SXRlbXMoY2hpbGRyZW4sIHNvcnQsIG9yZGVyKTtcbiAgICAgICAgaWYgKCFpc0VxdWFsKHNvcnRlZCwgY2hpbGRyZW4pKSB7XG4gICAgICAgICAgYXBwZW5kKHRhcmdldCwgc29ydGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlU3RhdGUoZWwsIGF0dHIsIHN0YXRlKSB7XG4gICAgICBjb25zdCBmaWx0ZXJCeSA9IGdldEZpbHRlcihlbCwgYXR0cik7XG4gICAgICBjb25zdCB7IGZpbHRlciwgZ3JvdXAsIHNvcnQsIG9yZGVyID0gJ2FzYycgfSA9IGZpbHRlckJ5O1xuXG4gICAgICBpZiAoZmlsdGVyIHx8IGlzVW5kZWZpbmVkKHNvcnQpKSB7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5maWx0ZXJbJyddO1xuICAgICAgICAgICAgc3RhdGUuZmlsdGVyW2dyb3VwXSA9IGZpbHRlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmZpbHRlcltncm91cF07XG5cbiAgICAgICAgICAgIGlmIChpc0VtcHR5KHN0YXRlLmZpbHRlcikgfHwgJycgaW4gc3RhdGUuZmlsdGVyKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmZpbHRlciA9IHsgJyc6IGZpbHRlciB8fCAnJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5maWx0ZXIgPSB7ICcnOiBmaWx0ZXIgfHwgJycgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHNvcnQpKSB7XG4gICAgICAgIHN0YXRlLnNvcnQgPSBbc29ydCwgb3JkZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hGaWx0ZXIoXG4gICAgZWwsXG4gICAgYXR0ciwgX3JlZjMpXG5cbiAgICB7bGV0IHsgZmlsdGVyOiBzdGF0ZUZpbHRlciA9IHsgJyc6ICcnIH0sIHNvcnQ6IFtzdGF0ZVNvcnQsIHN0YXRlT3JkZXJdIH0gPSBfcmVmMztcbiAgICAgIGNvbnN0IHsgZmlsdGVyID0gJycsIGdyb3VwID0gJycsIHNvcnQsIG9yZGVyID0gJ2FzYycgfSA9IGdldEZpbHRlcihlbCwgYXR0cik7XG5cbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZChzb3J0KSA/XG4gICAgICBncm91cCBpbiBzdGF0ZUZpbHRlciAmJiBmaWx0ZXIgPT09IHN0YXRlRmlsdGVyW2dyb3VwXSB8fFxuICAgICAgIWZpbHRlciAmJiBncm91cCAmJiAhKGdyb3VwIGluIHN0YXRlRmlsdGVyKSAmJiAhc3RhdGVGaWx0ZXJbJyddIDpcbiAgICAgIHN0YXRlU29ydCA9PT0gc29ydCAmJiBzdGF0ZU9yZGVyID09PSBvcmRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0VxdWFsTGlzdChsaXN0QSwgbGlzdEIpIHtcbiAgICAgIHJldHVybiBsaXN0QS5sZW5ndGggPT09IGxpc3RCLmxlbmd0aCAmJiBsaXN0QS5ldmVyeSgoZWwpID0+IH5saXN0Qi5pbmRleE9mKGVsKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0b3IoX3JlZjQpIHtsZXQgeyBmaWx0ZXIgfSA9IF9yZWY0O1xuICAgICAgbGV0IHNlbGVjdG9yID0gJyc7XG4gICAgICBlYWNoKGZpbHRlciwgKHZhbHVlKSA9PiBzZWxlY3RvciArPSB2YWx1ZSB8fCAnJyk7XG4gICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEl0ZW1zKG5vZGVzLCBzb3J0LCBvcmRlcikge1xuICAgICAgcmV0dXJuIFsuLi5ub2Rlc10uc29ydChcbiAgICAgIChhLCBiKSA9PlxuICAgICAgZGF0YShhLCBzb3J0KS5sb2NhbGVDb21wYXJlKGRhdGEoYiwgc29ydCksIHVuZGVmaW5lZCwgeyBudW1lcmljOiB0cnVlIH0pICogKFxuICAgICAgb3JkZXIgPT09ICdhc2MnIHx8IC0xKSk7XG5cbiAgICB9XG5cbiAgICB2YXIgQW5pbWF0aW9ucyQyID0ge1xuICAgICAgc2xpZGU6IHtcbiAgICAgICAgc2hvdyhkaXIpIHtcbiAgICAgICAgICByZXR1cm4gW3sgdHJhbnNmb3JtOiB0cmFuc2xhdGUoZGlyICogLTEwMCkgfSwgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpIH1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkKGN1cnJlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoZGlyICogLTEwMCAqIHBlcmNlbnQpIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZShkaXIgKiAxMDAgKiAoMSAtIHBlcmNlbnQpKSB9XTtcblxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVkKGVsKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoY3NzKGVsLCAndHJhbnNmb3JtJykuc3BsaXQoJywnKVs0XSAvIGVsLm9mZnNldFdpZHRoKSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZSh2YWx1ZSwgdW5pdCkge2lmICh2YWx1ZSA9PT0gdm9pZCAwKSB7dmFsdWUgPSAwO31pZiAodW5pdCA9PT0gdm9pZCAwKSB7dW5pdCA9ICclJzt9XG4gICAgICB2YWx1ZSArPSB2YWx1ZSA/IHVuaXQgOiAnJztcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgdmFsdWUgKyBcIiwgMCwgMClcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZTNkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJzY2FsZTNkKFwiICsgdmFsdWUgKyBcIiwgXCIgKyB2YWx1ZSArIFwiLCAxKVwiO1xuICAgIH1cblxuICAgIHZhciBBbmltYXRpb25zJDEgPSB7XG4gICAgICAuLi5BbmltYXRpb25zJDIsXG4gICAgICBmYWRlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiAxIC0gY3NzKGN1cnJlbnQsICdvcGFjaXR5Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICByZXR1cm4gW3sgb3BhY2l0eTogMSAtIHBlcmNlbnQgfSwgeyBvcGFjaXR5OiBwZXJjZW50IH1dO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgc2NhbGU6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiBzY2FsZTNkKDEgLSAwLjIpIH0sXG4gICAgICAgICAgeyBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06IHNjYWxlM2QoMSkgfV07XG5cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIGNzcyhjdXJyZW50LCAnb3BhY2l0eScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IG9wYWNpdHk6IDEgLSBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSAtIDAuMiAqIHBlcmNlbnQpIH0sXG4gICAgICAgICAgeyBvcGFjaXR5OiBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSAtIDAuMiArIDAuMiAqIHBlcmNlbnQpIH1dO1xuXG4gICAgICAgIH0gfSB9O1xuXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbmVyJDEocHJldiwgbmV4dCwgZGlyLCBfcmVmKSB7bGV0IHsgYW5pbWF0aW9uLCBlYXNpbmcgfSA9IF9yZWY7XG4gICAgICBjb25zdCB7IHBlcmNlbnQsIHRyYW5zbGF0ZSwgc2hvdyA9IG5vb3AgfSA9IGFuaW1hdGlvbjtcbiAgICAgIGNvbnN0IHByb3BzID0gc2hvdyhkaXIpO1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlyLFxuXG4gICAgICAgIHNob3coZHVyYXRpb24sIHBlcmNlbnQsIGxpbmVhcikge2lmIChwZXJjZW50ID09PSB2b2lkIDApIHtwZXJjZW50ID0gMDt9XG4gICAgICAgICAgY29uc3QgdGltaW5nID0gbGluZWFyID8gJ2xpbmVhcicgOiBlYXNpbmc7XG4gICAgICAgICAgZHVyYXRpb24gLT0gTWF0aC5yb3VuZChkdXJhdGlvbiAqIGNsYW1wKHBlcmNlbnQsIC0xLCAxKSk7XG5cbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShwZXJjZW50KTtcblxuICAgICAgICAgIHRyaWdnZXJVcGRhdGUkMShuZXh0LCAnaXRlbWluJywgeyBwZXJjZW50LCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSQxKHByZXYsICdpdGVtb3V0JywgeyBwZXJjZW50OiAxIC0gcGVyY2VudCwgZHVyYXRpb24sIHRpbWluZywgZGlyIH0pO1xuXG4gICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQobmV4dCwgcHJvcHNbMV0sIGR1cmF0aW9uLCB0aW1pbmcpLFxuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQocHJldiwgcHJvcHNbMF0sIGR1cmF0aW9uLCB0aW1pbmcpXSkuXG4gICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfSwgbm9vcCk7XG5cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwoW25leHQsIHByZXZdKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHNbMF0pIHtcbiAgICAgICAgICAgIGNzcyhbbmV4dCwgcHJldl0sIHByb3AsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yd2FyZChkdXJhdGlvbiwgcGVyY2VudCkge2lmIChwZXJjZW50ID09PSB2b2lkIDApIHtwZXJjZW50ID0gdGhpcy5wZXJjZW50KCk7fVxuICAgICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKFtuZXh0LCBwcmV2XSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhkdXJhdGlvbiwgcGVyY2VudCwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHRyYW5zbGF0ZShwZXJjZW50LCBkaXIpO1xuICAgICAgICAgIGNzcyhuZXh0LCBwcm9wc1sxXSk7XG4gICAgICAgICAgY3NzKHByZXYsIHByb3BzWzBdKTtcbiAgICAgICAgICB0cmlnZ2VyVXBkYXRlJDEobmV4dCwgJ2l0ZW10cmFuc2xhdGVpbicsIHsgcGVyY2VudCwgZGlyIH0pO1xuICAgICAgICAgIHRyaWdnZXJVcGRhdGUkMShwcmV2LCAnaXRlbXRyYW5zbGF0ZW91dCcsIHsgcGVyY2VudDogMSAtIHBlcmNlbnQsIGRpciB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KCkge1xuICAgICAgICAgIHJldHVybiBwZXJjZW50KHByZXYgfHwgbmV4dCwgbmV4dCwgZGlyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREaXN0YW5jZSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldi5vZmZzZXRXaWR0aDtcbiAgICAgICAgfSB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZSQxKGVsLCB0eXBlLCBkYXRhKSB7XG4gICAgICB0cmlnZ2VyKGVsLCBjcmVhdGVFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UsIGRhdGEpKTtcbiAgICB9XG5cbiAgICB2YXIgU2xpZGVyQXV0b3BsYXkgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBhdXRvcGxheTogQm9vbGVhbixcbiAgICAgICAgYXV0b3BsYXlJbnRlcnZhbDogTnVtYmVyLFxuICAgICAgICBwYXVzZU9uSG92ZXI6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgYXV0b3BsYXlJbnRlcnZhbDogNzAwMCxcbiAgICAgICAgcGF1c2VPbkhvdmVyOiB0cnVlIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmF1dG9wbGF5ICYmIHRoaXMuc3RhcnRBdXRvcGxheSgpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN0b3BBdXRvcGxheSgpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlKCkge1xuICAgICAgICBhdHRyKHRoaXMuc2xpZGVzLCAndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAndmlzaWJpbGl0eWNoYW5nZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvcGxheTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEF1dG9wbGF5KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRBdXRvcGxheSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc3RhcnRBdXRvcGxheSgpIHtcbiAgICAgICAgICB0aGlzLnN0b3BBdXRvcGxheSgpO1xuXG4gICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgICAgICgpID0+XG4gICAgICAgICAgKCF0aGlzLmRyYWdnYWJsZSB8fCAhJCgnOmZvY3VzJywgdGhpcy4kZWwpKSAmJiAoXG4gICAgICAgICAgIXRoaXMucGF1c2VPbkhvdmVyIHx8ICFtYXRjaGVzKHRoaXMuJGVsLCAnOmhvdmVyJykpICYmXG4gICAgICAgICAgIXRoaXMuc3RhY2subGVuZ3RoICYmXG4gICAgICAgICAgdGhpcy5zaG93KCduZXh0JyksXG4gICAgICAgICAgdGhpcy5hdXRvcGxheUludGVydmFsKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHN0b3BBdXRvcGxheSgpIHtcbiAgICAgICAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIFNsaWRlckRyYWcgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBkcmFnZ2FibGU6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgdGhyZXNob2xkOiAxMCB9LFxuXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnc3RhcnQnLCAnbW92ZScsICdlbmQnXSkge1xuICAgICAgICAgIGNvbnN0IGZuID0gdGhpc1trZXldO1xuICAgICAgICAgIHRoaXNba2V5XSA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBnZXRFdmVudFBvcyhlKS54ICogKGlzUnRsID8gLTEgOiAxKTtcblxuICAgICAgICAgICAgdGhpcy5wcmV2UG9zID0gcG9zID09PSB0aGlzLnBvcyA/IHRoaXMucHJldlBvcyA6IHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG5cbiAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyRG93bixcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxTbGlkZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICF0aGlzLmRyYWdnYWJsZSB8fFxuICAgICAgICAgICFpc1RvdWNoKGUpICYmIGhhc1RleHROb2Rlc09ubHkoZS50YXJnZXQpIHx8XG4gICAgICAgICAgY2xvc2VzdChlLnRhcmdldCwgc2VsSW5wdXQpIHx8XG4gICAgICAgICAgZS5idXR0b24gPiAwIHx8XG4gICAgICAgICAgdGhpcy5sZW5ndGggPCAyKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YXJ0KGUpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZHJhZ3N0YXJ0JyxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgIHRoaXMuZHJhZyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3RyYW5zaXRpb25lcikge1xuICAgICAgICAgICAgdGhpcy5wZXJjZW50ID0gdGhpcy5fdHJhbnNpdGlvbmVyLnBlcmNlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZyArPSB0aGlzLl90cmFuc2l0aW9uZXIuZ2V0RGlzdGFuY2UoKSAqIHRoaXMucGVyY2VudCAqIHRoaXMuZGlyO1xuXG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIudHJhbnNsYXRlKHRoaXMucGVyY2VudCk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJldkluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlck1vdmUsIHRoaXMubW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgICAgICAgIC8vICdpbnB1dCcgZXZlbnQgaXMgdHJpZ2dlcmVkIGJ5IHZpZGVvIGNvbnRyb2xzXG4gICAgICAgICAgb24oZG9jdW1lbnQsIHBvaW50ZXJVcCArIFwiIFwiICsgcG9pbnRlckNhbmNlbCArIFwiIGlucHV0XCIsIHRoaXMuZW5kLCB0cnVlKTtcblxuICAgICAgICAgIGNzcyh0aGlzLmxpc3QsICd1c2VyU2VsZWN0JywgJ25vbmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlKGUpIHtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMucG9zIC0gdGhpcy5kcmFnO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGRpc3RhbmNlID09PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmV2UG9zID09PSB0aGlzLnBvcyB8fFxuICAgICAgICAgICF0aGlzLmRyYWdnaW5nICYmIE1hdGguYWJzKGRpc3RhbmNlKSA8IHRoaXMudGhyZXNob2xkKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwcmV2ZW50IGNsaWNrIGV2ZW50XG4gICAgICAgICAgY3NzKHRoaXMubGlzdCwgJ3BvaW50ZXJFdmVudHMnLCAnbm9uZScpO1xuXG4gICAgICAgICAgZS5jYW5jZWxhYmxlICYmIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGlyID0gZGlzdGFuY2UgPCAwID8gMSA6IC0xO1xuXG4gICAgICAgICAgY29uc3QgeyBzbGlkZXMgfSA9IHRoaXM7XG4gICAgICAgICAgbGV0IHsgcHJldkluZGV4IH0gPSB0aGlzO1xuICAgICAgICAgIGxldCBkaXMgPSBNYXRoLmFicyhkaXN0YW5jZSk7XG4gICAgICAgICAgbGV0IG5leHRJbmRleCA9IHRoaXMuZ2V0SW5kZXgocHJldkluZGV4ICsgdGhpcy5kaXIsIHByZXZJbmRleCk7XG4gICAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5fZ2V0RGlzdGFuY2UocHJldkluZGV4LCBuZXh0SW5kZXgpIHx8IHNsaWRlc1twcmV2SW5kZXhdLm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgd2hpbGUgKG5leHRJbmRleCAhPT0gcHJldkluZGV4ICYmIGRpcyA+IHdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWcgLT0gd2lkdGggKiB0aGlzLmRpcjtcblxuICAgICAgICAgICAgcHJldkluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgZGlzIC09IHdpZHRoO1xuICAgICAgICAgICAgbmV4dEluZGV4ID0gdGhpcy5nZXRJbmRleChwcmV2SW5kZXggKyB0aGlzLmRpciwgcHJldkluZGV4KTtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fZ2V0RGlzdGFuY2UocHJldkluZGV4LCBuZXh0SW5kZXgpIHx8IHNsaWRlc1twcmV2SW5kZXhdLm9mZnNldFdpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucGVyY2VudCA9IGRpcyAvIHdpZHRoO1xuXG4gICAgICAgICAgY29uc3QgcHJldiA9IHNsaWRlc1twcmV2SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBzbGlkZXNbbmV4dEluZGV4XTtcbiAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5pbmRleCAhPT0gbmV4dEluZGV4O1xuICAgICAgICAgIGNvbnN0IGVkZ2UgPSBwcmV2SW5kZXggPT09IG5leHRJbmRleDtcblxuICAgICAgICAgIGxldCBpdGVtU2hvd247XG5cbiAgICAgICAgICBbdGhpcy5pbmRleCwgdGhpcy5wcmV2SW5kZXhdLlxuICAgICAgICAgIGZpbHRlcigoaSkgPT4gIWluY2x1ZGVzKFtuZXh0SW5kZXgsIHByZXZJbmRleF0sIGkpKS5cbiAgICAgICAgICBmb3JFYWNoKChpKSA9PiB7XG4gICAgICAgICAgICB0cmlnZ2VyKHNsaWRlc1tpXSwgJ2l0ZW1oaWRkZW4nLCBbdGhpc10pO1xuXG4gICAgICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgICBpdGVtU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLnByZXZJbmRleCA9IHByZXZJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSBwcmV2SW5kZXggJiYgdGhpcy5wcmV2SW5kZXggIT09IHByZXZJbmRleCB8fCBpdGVtU2hvd24pIHtcbiAgICAgICAgICAgIHRyaWdnZXIoc2xpZGVzW3RoaXMuaW5kZXhdLCAnaXRlbXNob3duJywgW3RoaXNdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gbmV4dEluZGV4O1xuXG4gICAgICAgICAgICAhZWRnZSAmJiB0cmlnZ2VyKHByZXYsICdiZWZvcmVpdGVtaGlkZScsIFt0aGlzXSk7XG4gICAgICAgICAgICB0cmlnZ2VyKG5leHQsICdiZWZvcmVpdGVtc2hvdycsIFt0aGlzXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gdGhpcy5fdHJhbnNsYXRlKE1hdGguYWJzKHRoaXMucGVyY2VudCksIHByZXYsICFlZGdlICYmIG5leHQpO1xuXG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICFlZGdlICYmIHRyaWdnZXIocHJldiwgJ2l0ZW1oaWRlJywgW3RoaXNdKTtcbiAgICAgICAgICAgIHRyaWdnZXIobmV4dCwgJ2l0ZW1zaG93JywgW3RoaXNdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgcG9pbnRlck1vdmUsIHRoaXMubW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIHBvaW50ZXJVcCArIFwiIFwiICsgcG9pbnRlckNhbmNlbCArIFwiIGlucHV0XCIsIHRoaXMuZW5kLCB0cnVlKTtcblxuICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHRoaXMucHJldkluZGV4KSB7XG4gICAgICAgICAgICAgIHRoaXMucGVyY2VudCA9IDEgLSB0aGlzLnBlcmNlbnQ7XG4gICAgICAgICAgICAgIHRoaXMuZGlyICo9IC0xO1xuICAgICAgICAgICAgICB0aGlzLl9zaG93KGZhbHNlLCB0aGlzLmluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRpckNoYW5nZSA9XG4gICAgICAgICAgICAgIChpc1J0bCA/IHRoaXMuZGlyICogKGlzUnRsID8gMSA6IC0xKSA6IHRoaXMuZGlyKSA8IDAgPT09XG4gICAgICAgICAgICAgIHRoaXMucHJldlBvcyA+IHRoaXMucG9zO1xuICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gZGlyQ2hhbmdlID8gdGhpcy5pbmRleCA6IHRoaXMucHJldkluZGV4O1xuXG4gICAgICAgICAgICAgIGlmIChkaXJDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmNlbnQgPSAxIC0gdGhpcy5wZXJjZW50O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zaG93KFxuICAgICAgICAgICAgICB0aGlzLmRpciA+IDAgJiYgIWRpckNoYW5nZSB8fCB0aGlzLmRpciA8IDAgJiYgZGlyQ2hhbmdlID9cbiAgICAgICAgICAgICAgJ25leHQnIDpcbiAgICAgICAgICAgICAgJ3ByZXZpb3VzJyxcbiAgICAgICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjc3ModGhpcy5saXN0LCB7IHVzZXJTZWxlY3Q6ICcnLCBwb2ludGVyRXZlbnRzOiAnJyB9KTtcblxuICAgICAgICAgIHRoaXMuZHJhZyA9IHRoaXMucGVyY2VudCA9IG51bGw7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGhhc1RleHROb2Rlc09ubHkoZWwpIHtcbiAgICAgIHJldHVybiAhZWwuY2hpbGRyZW4ubGVuZ3RoICYmIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBTbGlkZXJOYXYgPSB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNlbE5hdjogZmFsc2UgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBuYXYoX3JlZiwgJGVsKSB7bGV0IHsgc2VsTmF2IH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAkKHNlbE5hdiwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZWxOYXZJdGVtKF9yZWYyKSB7bGV0IHsgYXR0ckl0ZW0gfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiBcIltcIiArIGF0dHJJdGVtICsgXCJdLFtkYXRhLVwiICsgYXR0ckl0ZW0gKyBcIl1cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBuYXZJdGVtcyhfLCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gJCQodGhpcy5zZWxOYXZJdGVtLCAkZWwpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHdyaXRlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5hdiAmJiB0aGlzLmxlbmd0aCAhPT0gdGhpcy5uYXYuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBodG1sKFxuICAgICAgICAgICAgdGhpcy5uYXYsXG4gICAgICAgICAgICB0aGlzLnNsaWRlcy5cbiAgICAgICAgICAgIG1hcCgoXywgaSkgPT4gXCI8bGkgXCIgKyB0aGlzLmF0dHJJdGVtICsgXCI9XFxcIlwiICsgaSArIFwiXFxcIj48YSBocmVmPjwvYT48L2xpPlwiKS5cbiAgICAgICAgICAgIGpvaW4oJycpKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubmF2SXRlbXMuY29uY2F0KHRoaXMubmF2KS5mb3JFYWNoKChlbCkgPT4gZWwgJiYgKGVsLmhpZGRlbiA9ICF0aGlzLm1heEluZGV4KSk7XG5cbiAgICAgICAgICB0aGlzLnVwZGF0ZU5hdigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9LFxuXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbE5hdkl0ZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvdyhkYXRhKGUuY3VycmVudCwgdGhpcy5hdHRySXRlbSkpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaXRlbXNob3cnLFxuICAgICAgICBoYW5kbGVyOiAndXBkYXRlTmF2JyB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdXBkYXRlTmF2KCkge1xuICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLmdldFZhbGlkSW5kZXgoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMubmF2SXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IGRhdGEoZWwsIHRoaXMuYXR0ckl0ZW0pO1xuXG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcy5jbHNBY3RpdmUsIHRvTnVtYmVyKGNtZCkgPT09IGkpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICd1ay1pbnZpc2libGUnLFxuICAgICAgICAgICAgdGhpcy5maW5pdGUgJiYgKFxuICAgICAgICAgICAgY21kID09PSAncHJldmlvdXMnICYmIGkgPT09IDAgfHwgY21kID09PSAnbmV4dCcgJiYgaSA+PSB0aGlzLm1heEluZGV4KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIFNsaWRlciA9IHtcbiAgICAgIG1peGluczogW1NsaWRlckF1dG9wbGF5LCBTbGlkZXJEcmFnLCBTbGlkZXJOYXYsIFJlc2l6ZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsc0FjdGl2YXRlZDogQm9vbGVhbixcbiAgICAgICAgZWFzaW5nOiBTdHJpbmcsXG4gICAgICAgIGluZGV4OiBOdW1iZXIsXG4gICAgICAgIGZpbml0ZTogQm9vbGVhbixcbiAgICAgICAgdmVsb2NpdHk6IE51bWJlcixcbiAgICAgICAgc2VsU2xpZGVzOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiAoKSA9PiAoe1xuICAgICAgICBlYXNpbmc6ICdlYXNlJyxcbiAgICAgICAgZmluaXRlOiBmYWxzZSxcbiAgICAgICAgdmVsb2NpdHk6IDEsXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBwcmV2SW5kZXg6IC0xLFxuICAgICAgICBzdGFjazogW10sXG4gICAgICAgIHBlcmNlbnQ6IDAsXG4gICAgICAgIGNsc0FjdGl2ZTogJ3VrLWFjdGl2ZScsXG4gICAgICAgIGNsc0FjdGl2YXRlZDogZmFsc2UsXG4gICAgICAgIFRyYW5zaXRpb25lcjogZmFsc2UsXG4gICAgICAgIHRyYW5zaXRpb25PcHRpb25zOiB7fSB9KSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucHJldkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmdldFZhbGlkSW5kZXgodGhpcy4kcHJvcHMuaW5kZXgpO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuc2xpZGVzLCB0aGlzLmNsc0FjdGl2ZSk7XG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBkdXJhdGlvbihfcmVmLCAkZWwpIHtsZXQgeyB2ZWxvY2l0eSB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gc3BlZWRVcCgkZWwub2Zmc2V0V2lkdGggLyB2ZWxvY2l0eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlzdChfcmVmMiwgJGVsKSB7bGV0IHsgc2VsTGlzdCB9ID0gX3JlZjI7XG4gICAgICAgICAgcmV0dXJuICQoc2VsTGlzdCwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXhJbmRleCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlbFNsaWRlcyhfcmVmMykge2xldCB7IHNlbExpc3QsIHNlbFNsaWRlcyB9ID0gX3JlZjM7XG4gICAgICAgICAgcmV0dXJuIHNlbExpc3QgKyBcIiBcIiArIChzZWxTbGlkZXMgfHwgJz4gKicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNsaWRlczoge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkJCh0aGlzLnNlbFNsaWRlcywgdGhpcy4kZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIHRoaXMuJHJlc2V0KCk7XG4gICAgICAgICAgfSB9LFxuXG5cbiAgICAgICAgbGVuZ3RoKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWRlcy5sZW5ndGg7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coaW5kZXgsIGZvcmNlKSB7aWYgKGZvcmNlID09PSB2b2lkIDApIHtmb3JjZSA9IGZhbHNlO31cbiAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyB8fCAhdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IHN0YWNrIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IHF1ZXVlSW5kZXggPSBmb3JjZSA/IDAgOiBzdGFjay5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBzdGFjay5zcGxpY2UocXVldWVJbmRleCwgMSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaG93KHN0YWNrLnNoaWZ0KCksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzdGFja1tmb3JjZSA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oaW5kZXgpO1xuXG4gICAgICAgICAgaWYgKCFmb3JjZSAmJiBzdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lci5mb3J3YXJkKE1hdGgubWluKHRoaXMuZHVyYXRpb24sIDIwMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJldkluZGV4ID0gdGhpcy5nZXRJbmRleCh0aGlzLmluZGV4KTtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gaGFzQ2xhc3ModGhpcy5zbGlkZXMsIHRoaXMuY2xzQWN0aXZlKSAmJiB0aGlzLnNsaWRlc1twcmV2SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuZ2V0SW5kZXgoaW5kZXgsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLnNsaWRlc1tuZXh0SW5kZXhdO1xuXG4gICAgICAgICAgaWYgKHByZXYgPT09IG5leHQpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kaXIgPSBnZXREaXJlY3Rpb24oaW5kZXgsIHByZXZJbmRleCk7XG4gICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICBwcmV2ICYmICF0cmlnZ2VyKHByZXYsICdiZWZvcmVpdGVtaGlkZScsIFt0aGlzXSkgfHxcbiAgICAgICAgICAhdHJpZ2dlcihuZXh0LCAnYmVmb3JlaXRlbXNob3cnLCBbdGhpcywgcHJldl0pKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnByZXZJbmRleDtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX3Nob3cocHJldiwgbmV4dCwgZm9yY2UpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcHJldiAmJiB0cmlnZ2VyKHByZXYsICdpdGVtaGlkZGVuJywgW3RoaXNdKTtcbiAgICAgICAgICAgIHRyaWdnZXIobmV4dCwgJ2l0ZW1zaG93bicsIFt0aGlzXSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBmYXN0ZG9tLndyaXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdyhzdGFjay5zaGlmdCgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcHJldiAmJiB0cmlnZ2VyKHByZXYsICdpdGVtaGlkZScsIFt0aGlzXSk7XG4gICAgICAgICAgdHJpZ2dlcihuZXh0LCAnaXRlbXNob3cnLCBbdGhpc10pO1xuXG4gICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SW5kZXgoaW5kZXgsIHByZXYpIHtpZiAoaW5kZXggPT09IHZvaWQgMCkge2luZGV4ID0gdGhpcy5pbmRleDt9aWYgKHByZXYgPT09IHZvaWQgMCkge3ByZXYgPSB0aGlzLmluZGV4O31cbiAgICAgICAgICByZXR1cm4gY2xhbXAoZ2V0SW5kZXgoaW5kZXgsIHRoaXMuc2xpZGVzLCBwcmV2LCB0aGlzLmZpbml0ZSksIDAsIHRoaXMubWF4SW5kZXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFZhbGlkSW5kZXgoaW5kZXgsIHByZXZJbmRleCkge2lmIChpbmRleCA9PT0gdm9pZCAwKSB7aW5kZXggPSB0aGlzLmluZGV4O31pZiAocHJldkluZGV4ID09PSB2b2lkIDApIHtwcmV2SW5kZXggPSB0aGlzLnByZXZJbmRleDt9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXgoaW5kZXgsIHByZXZJbmRleCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Nob3cocHJldiwgbmV4dCwgZm9yY2UpIHtcbiAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIocHJldiwgbmV4dCwgdGhpcy5kaXIsIHtcbiAgICAgICAgICAgIGVhc2luZzogZm9yY2UgP1xuICAgICAgICAgICAgbmV4dC5vZmZzZXRXaWR0aCA8IDYwMCA/XG4gICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpJyAvKiBlYXNlT3V0UXVhZCAqLyA6XG4gICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAuMTY1LCAwLjg0LCAwLjQ0LCAxKScgLyogZWFzZU91dFF1YXJ0ICovIDpcbiAgICAgICAgICAgIHRoaXMuZWFzaW5nLFxuICAgICAgICAgICAgLi4udGhpcy50cmFuc2l0aW9uT3B0aW9ucyB9KTtcblxuXG4gICAgICAgICAgaWYgKCFmb3JjZSAmJiAhcHJldikge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB0aGlzLnN0YWNrO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uZXJbbGVuZ3RoID4gMSA/ICdmb3J3YXJkJyA6ICdzaG93J10oXG4gICAgICAgICAgbGVuZ3RoID4gMSA/IE1hdGgubWluKHRoaXMuZHVyYXRpb24sIDc1ICsgNzUgLyAobGVuZ3RoIC0gMSkpIDogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aGlzLnBlcmNlbnQpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldERpc3RhbmNlKHByZXYsIG5leHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNpdGlvbmVyKHByZXYsIHByZXYgIT09IG5leHQgJiYgbmV4dCkuZ2V0RGlzdGFuY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdHJhbnNsYXRlKHBlcmNlbnQsIHByZXYsIG5leHQpIHtpZiAocHJldiA9PT0gdm9pZCAwKSB7cHJldiA9IHRoaXMucHJldkluZGV4O31pZiAobmV4dCA9PT0gdm9pZCAwKSB7bmV4dCA9IHRoaXMuaW5kZXg7fVxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25lciA9IHRoaXMuX2dldFRyYW5zaXRpb25lcihwcmV2ICE9PSBuZXh0ID8gcHJldiA6IGZhbHNlLCBuZXh0KTtcbiAgICAgICAgICB0cmFuc2l0aW9uZXIudHJhbnNsYXRlKHBlcmNlbnQpO1xuICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFRyYW5zaXRpb25lcihcbiAgICAgICAgcHJldixcbiAgICAgICAgbmV4dCxcbiAgICAgICAgZGlyLFxuICAgICAgICBvcHRpb25zKVxuICAgICAgICB7aWYgKHByZXYgPT09IHZvaWQgMCkge3ByZXYgPSB0aGlzLnByZXZJbmRleDt9aWYgKG5leHQgPT09IHZvaWQgMCkge25leHQgPSB0aGlzLmluZGV4O31pZiAoZGlyID09PSB2b2lkIDApIHtkaXIgPSB0aGlzLmRpciB8fCAxO31pZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7b3B0aW9ucyA9IHRoaXMudHJhbnNpdGlvbk9wdGlvbnM7fVxuICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5UcmFuc2l0aW9uZXIoXG4gICAgICAgICAgaXNOdW1iZXIocHJldikgPyB0aGlzLnNsaWRlc1twcmV2XSA6IHByZXYsXG4gICAgICAgICAgaXNOdW1iZXIobmV4dCkgPyB0aGlzLnNsaWRlc1tuZXh0XSA6IG5leHQsXG4gICAgICAgICAgZGlyICogKGlzUnRsID8gLTEgOiAxKSxcbiAgICAgICAgICBvcHRpb25zKTtcblxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBnZXREaXJlY3Rpb24oaW5kZXgsIHByZXZJbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4ID09PSAnbmV4dCcgPyAxIDogaW5kZXggPT09ICdwcmV2aW91cycgPyAtMSA6IGluZGV4IDwgcHJldkluZGV4ID8gLTEgOiAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNwZWVkVXAoeCkge1xuICAgICAgcmV0dXJuIDAuNSAqIHggKyAzMDA7IC8vIHBhcmFib2xhIHRocm91Z2ggKDQwMCw1MDA7IDYwMCw2MDA7IDE4MDAsMTIwMClcbiAgICB9XG5cbiAgICB2YXIgU2xpZGVzaG93ID0ge1xuICAgICAgbWl4aW5zOiBbU2xpZGVyXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGFuaW1hdGlvbjogJ3NsaWRlJyxcbiAgICAgICAgY2xzQWN0aXZhdGVkOiAndWstdHJhbnNpdGlvbi1hY3RpdmUnLFxuICAgICAgICBBbmltYXRpb25zOiBBbmltYXRpb25zJDIsXG4gICAgICAgIFRyYW5zaXRpb25lcjogVHJhbnNpdGlvbmVyJDEgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBhbmltYXRpb24oX3JlZikge2xldCB7IGFuaW1hdGlvbiwgQW5pbWF0aW9ucyB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4geyAuLi4oQW5pbWF0aW9uc1thbmltYXRpb25dIHx8IEFuaW1hdGlvbnMuc2xpZGUpLCBuYW1lOiBhbmltYXRpb24gfTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2l0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgICByZXR1cm4geyBhbmltYXRpb246IHRoaXMuYW5pbWF0aW9uIH07XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgYmVmb3JlaXRlbXNob3coX3JlZjIpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWYyO1xuICAgICAgICAgIGFkZENsYXNzKHRhcmdldCwgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGl0ZW1zaG93bihfcmVmMykge2xldCB7IHRhcmdldCB9ID0gX3JlZjM7XG4gICAgICAgICAgYWRkQ2xhc3ModGFyZ2V0LCB0aGlzLmNsc0FjdGl2YXRlZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbWhpZGRlbihfcmVmNCkge2xldCB7IHRhcmdldCB9ID0gX3JlZjQ7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGFyZ2V0LCB0aGlzLmNsc0FjdGl2ZSwgdGhpcy5jbHNBY3RpdmF0ZWQpO1xuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBMaWdodGJveFBhbmVsID0ge1xuICAgICAgbWl4aW5zOiBbQ29udGFpbmVyLCBNb2RhbCwgVG9nZ2xhYmxlLCBTbGlkZXNob3ddLFxuXG4gICAgICBmdW5jdGlvbmFsOiB0cnVlLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBkZWxheUNvbnRyb2xzOiBOdW1iZXIsXG4gICAgICAgIHByZWxvYWQ6IE51bWJlcixcbiAgICAgICAgdmlkZW9BdXRvcGxheTogQm9vbGVhbixcbiAgICAgICAgdGVtcGxhdGU6IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6ICgpID0+ICh7XG4gICAgICAgIHByZWxvYWQ6IDEsXG4gICAgICAgIHZpZGVvQXV0b3BsYXk6IGZhbHNlLFxuICAgICAgICBkZWxheUNvbnRyb2xzOiAzMDAwLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGNsczogJ3VrLW9wZW4nLFxuICAgICAgICBjbHNQYWdlOiAndWstbGlnaHRib3gtcGFnZScsXG4gICAgICAgIHNlbExpc3Q6ICcudWstbGlnaHRib3gtaXRlbXMnLFxuICAgICAgICBhdHRySXRlbTogJ3VrLWxpZ2h0Ym94LWl0ZW0nLFxuICAgICAgICBzZWxDbG9zZTogJy51ay1jbG9zZS1sYXJnZScsXG4gICAgICAgIHNlbENhcHRpb246ICcudWstbGlnaHRib3gtY2FwdGlvbicsXG4gICAgICAgIHBhdXNlT25Ib3ZlcjogZmFsc2UsXG4gICAgICAgIHZlbG9jaXR5OiAyLFxuICAgICAgICBBbmltYXRpb25zOiBBbmltYXRpb25zJDEsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcInVrLWxpZ2h0Ym94IHVrLW92ZXJmbG93LWhpZGRlblxcXCI+IDx1bCBjbGFzcz1cXFwidWstbGlnaHRib3gtaXRlbXNcXFwiPjwvdWw+IDxkaXYgY2xhc3M9XFxcInVrLWxpZ2h0Ym94LXRvb2xiYXIgdWstcG9zaXRpb24tdG9wIHVrLXRleHQtcmlnaHQgdWstdHJhbnNpdGlvbi1zbGlkZS10b3AgdWstdHJhbnNpdGlvbi1vcGFxdWVcXFwiPiA8YnV0dG9uIGNsYXNzPVxcXCJ1ay1saWdodGJveC10b29sYmFyLWljb24gdWstY2xvc2UtbGFyZ2VcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgdWstY2xvc2U+PC9idXR0b24+IDwvZGl2PiA8YSBjbGFzcz1cXFwidWstbGlnaHRib3gtYnV0dG9uIHVrLXBvc2l0aW9uLWNlbnRlci1sZWZ0IHVrLXBvc2l0aW9uLW1lZGl1bSB1ay10cmFuc2l0aW9uLWZhZGVcXFwiIGhyZWYgdWstc2xpZGVuYXYtcHJldmlvdXMgdWstbGlnaHRib3gtaXRlbT1cXFwicHJldmlvdXNcXFwiPjwvYT4gPGEgY2xhc3M9XFxcInVrLWxpZ2h0Ym94LWJ1dHRvbiB1ay1wb3NpdGlvbi1jZW50ZXItcmlnaHQgdWstcG9zaXRpb24tbWVkaXVtIHVrLXRyYW5zaXRpb24tZmFkZVxcXCIgaHJlZiB1ay1zbGlkZW5hdi1uZXh0IHVrLWxpZ2h0Ym94LWl0ZW09XFxcIm5leHRcXFwiPjwvYT4gPGRpdiBjbGFzcz1cXFwidWstbGlnaHRib3gtdG9vbGJhciB1ay1saWdodGJveC1jYXB0aW9uIHVrLXBvc2l0aW9uLWJvdHRvbSB1ay10ZXh0LWNlbnRlciB1ay10cmFuc2l0aW9uLXNsaWRlLWJvdHRvbSB1ay10cmFuc2l0aW9uLW9wYXF1ZVxcXCI+PC9kaXY+IDwvZGl2PlwiIH0pLFxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICBjb25zdCAkZWwgPSAkKHRoaXMudGVtcGxhdGUpO1xuICAgICAgICBjb25zdCBsaXN0ID0gJCh0aGlzLnNlbExpc3QsICRlbCk7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoKSA9PiBhcHBlbmQobGlzdCwgJzxsaT4nKSk7XG5cbiAgICAgICAgdGhpcy4kbW91bnQoYXBwZW5kKHRoaXMuY29udGFpbmVyLCAkZWwpKTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNhcHRpb24oX3JlZiwgJGVsKSB7bGV0IHsgc2VsQ2FwdGlvbiB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gJChzZWxDYXB0aW9uLCAkZWwpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IHBvaW50ZXJNb3ZlICsgXCIgXCIgKyBwb2ludGVyRG93biArIFwiIGtleWRvd25cIixcblxuICAgICAgICBoYW5kbGVyOiAnc2hvd0NvbnRyb2xzJyB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbFNsaWRlcztcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93bicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuc2hvd0NvbnRyb2xzKCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRlJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5oaWRlQ29udHJvbHMoKTtcblxuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuc2xpZGVzLCB0aGlzLmNsc0FjdGl2ZSk7XG4gICAgICAgICAgVHJhbnNpdGlvbi5zdG9wKHRoaXMuc2xpZGVzKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGRlbicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuJGRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdrZXl1cCcsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICghdGhpcy5pc1RvZ2dsZWQodGhpcy4kZWwpIHx8ICF0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgICB0aGlzLnNob3coJ3ByZXZpb3VzJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgdGhpcy5zaG93KCduZXh0Jyk7XG4gICAgICAgICAgICAgIGJyZWFrO31cblxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3JlaXRlbXNob3cnLFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcblxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBBbmltYXRpb25zJDFbJ3NjYWxlJ107XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZS50YXJnZXQsIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSgxLCAwLCB0aGlzLmluZGV4KTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2l0ZW1zaG93JyxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGh0bWwodGhpcy5jYXB0aW9uLCB0aGlzLmdldEl0ZW0oKS5jYXB0aW9uIHx8ICcnKTtcblxuICAgICAgICAgIGZvciAobGV0IGogPSAtdGhpcy5wcmVsb2FkOyBqIDw9IHRoaXMucHJlbG9hZDsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRJdGVtKHRoaXMuaW5kZXggKyBqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpdGVtc2hvd24nLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSB0aGlzLiRwcm9wcy5kcmFnZ2FibGU7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpdGVtbG9hZCcsXG5cbiAgICAgICAgYXN5bmMgaGFuZGxlcihfLCBpdGVtKSB7XG4gICAgICAgICAgY29uc3QgeyBzb3VyY2U6IHNyYywgdHlwZSwgYWx0ID0gJycsIHBvc3RlciwgYXR0cnMgPSB7fSB9ID0gaXRlbTtcblxuICAgICAgICAgIHRoaXMuc2V0SXRlbShpdGVtLCAnPHNwYW4gdWstc3Bpbm5lcj48L3NwYW4+Jyk7XG5cbiAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBtYXRjaGVzO1xuICAgICAgICAgIGNvbnN0IGlmcmFtZUF0dHJzID0ge1xuICAgICAgICAgICAgZnJhbWVib3JkZXI6ICcwJyxcbiAgICAgICAgICAgIGFsbG93OiAnYXV0b3BsYXknLFxuICAgICAgICAgICAgYWxsb3dmdWxsc2NyZWVuOiAnJyxcbiAgICAgICAgICAgIHN0eWxlOiAnbWF4LXdpZHRoOiAxMDAlOyBib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4gICAgICAgICAgICAndWstcmVzcG9uc2l2ZSc6ICcnLFxuICAgICAgICAgICAgJ3VrLXZpZGVvJzogXCJcIiArIHRoaXMudmlkZW9BdXRvcGxheSB9O1xuXG5cbiAgICAgICAgICAvLyBJbWFnZVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlID09PSAnaW1hZ2UnIHx8XG4gICAgICAgICAgc3JjLm1hdGNoKC9cXC4oYXZpZnxqcGU/Z3xqZmlmfGE/cG5nfGdpZnxzdmd8d2VicCkoJHxcXD8pL2kpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYXdhaXQgZ2V0SW1hZ2Uoc3JjLCBhdHRycy5zcmNzZXQsIGF0dHJzLnNpemUpO1xuICAgICAgICAgICAgICB0aGlzLnNldEl0ZW0oaXRlbSwgY3JlYXRlRWwoJ2ltZycsIHsgc3JjLCB3aWR0aCwgaGVpZ2h0LCBhbHQsIC4uLmF0dHJzIH0pKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRFcnJvcihpdGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVmlkZW9cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2aWRlbycgfHwgc3JjLm1hdGNoKC9cXC4obXA0fHdlYm18b2d2KSgkfFxcPykvaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gY3JlYXRlRWwoJ3ZpZGVvJywge1xuICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgIHBvc3RlcixcbiAgICAgICAgICAgICAgY29udHJvbHM6ICcnLFxuICAgICAgICAgICAgICBwbGF5c2lubGluZTogJycsXG4gICAgICAgICAgICAgICd1ay12aWRlbyc6IFwiXCIgKyB0aGlzLnZpZGVvQXV0b3BsYXksXG4gICAgICAgICAgICAgIC4uLmF0dHJzIH0pO1xuXG5cbiAgICAgICAgICAgIG9uKHZpZGVvLCAnbG9hZGVkbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGF0dHIodmlkZW8sIHsgd2lkdGg6IHZpZGVvLnZpZGVvV2lkdGgsIGhlaWdodDogdmlkZW8udmlkZW9IZWlnaHQgfSk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0SXRlbShpdGVtLCB2aWRlbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9uKHZpZGVvLCAnZXJyb3InLCAoKSA9PiB0aGlzLnNldEVycm9yKGl0ZW0pKTtcblxuICAgICAgICAgICAgLy8gSWZyYW1lXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaWZyYW1lJyB8fCBzcmMubWF0Y2goL1xcLihodG1sfHBocCkoJHxcXD8pL2kpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEl0ZW0oXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgY3JlYXRlRWwoJ2lmcmFtZScsIHtcbiAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICBmcmFtZWJvcmRlcjogJzAnLFxuICAgICAgICAgICAgICBhbGxvd2Z1bGxzY3JlZW46ICcnLFxuICAgICAgICAgICAgICBjbGFzczogJ3VrLWxpZ2h0Ym94LWlmcmFtZScsXG4gICAgICAgICAgICAgIC4uLmF0dHJzIH0pKTtcblxuXG5cbiAgICAgICAgICAgIC8vIFlvdVR1YmVcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIG1hdGNoZXMgPSBzcmMubWF0Y2goXG4gICAgICAgICAgL1xcL1xcLyg/Oi4qP3lvdXR1YmUoLW5vY29va2llKT9cXC4uKj9bPyZddj18eW91dHVcXC5iZVxcLykoW1xcdy1dezExfSlbJj9dPyguKik/LykpXG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEl0ZW0oXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgY3JlYXRlRWwoJ2lmcmFtZScsIHtcbiAgICAgICAgICAgICAgc3JjOiBcImh0dHBzOi8vd3d3LnlvdXR1YmVcIiArIChtYXRjaGVzWzFdIHx8ICcnKSArIFwiLmNvbS9lbWJlZC9cIiArIG1hdGNoZXNbMl0gKyAoXG4gICAgICAgICAgICAgIG1hdGNoZXNbM10gPyBcIj9cIiArIG1hdGNoZXNbM10gOiAnJyksXG5cbiAgICAgICAgICAgICAgd2lkdGg6IDE5MjAsXG4gICAgICAgICAgICAgIGhlaWdodDogMTA4MCxcbiAgICAgICAgICAgICAgLi4uaWZyYW1lQXR0cnMsXG4gICAgICAgICAgICAgIC4uLmF0dHJzIH0pKTtcblxuXG5cbiAgICAgICAgICAgIC8vIFZpbWVvXG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzID0gc3JjLm1hdGNoKC9cXC9cXC8uKj92aW1lb1xcLlthLXpdK1xcLyhcXGQrKVsmP10/KC4qKT8vKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBhd2FpdCAoXG4gICAgICAgICAgICAgIGF3YWl0IGZldGNoKFwiaHR0cHM6Ly92aW1lby5jb20vYXBpL29lbWJlZC5qc29uP21heHdpZHRoPTE5MjAmdXJsPVwiICtcbiAgICAgICAgICAgICAgZW5jb2RlVVJJKFxuICAgICAgICAgICAgICBzcmMpLFxuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ29taXQnIH0pKS5cblxuXG4gICAgICAgICAgICAgIGpzb24oKTtcblxuICAgICAgICAgICAgICB0aGlzLnNldEl0ZW0oXG4gICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgIGNyZWF0ZUVsKCdpZnJhbWUnLCB7XG4gICAgICAgICAgICAgICAgc3JjOiBcImh0dHBzOi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby9cIiArIG1hdGNoZXNbMV0gKyAoXG4gICAgICAgICAgICAgICAgbWF0Y2hlc1syXSA/IFwiP1wiICsgbWF0Y2hlc1syXSA6ICcnKSxcblxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAuLi5pZnJhbWVBdHRycyxcbiAgICAgICAgICAgICAgICAuLi5hdHRycyB9KSk7XG5cblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldEVycm9yKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgbG9hZEl0ZW0oaW5kZXgpIHtpZiAoaW5kZXggPT09IHZvaWQgMCkge2luZGV4ID0gdGhpcy5pbmRleDt9XG4gICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZ2V0SXRlbShpbmRleCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZ2V0U2xpZGUoaXRlbSkuY2hpbGRFbGVtZW50Q291bnQpIHtcbiAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdpdGVtbG9hZCcsIFtpdGVtXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEl0ZW0oaW5kZXgpIHtpZiAoaW5kZXggPT09IHZvaWQgMCkge2luZGV4ID0gdGhpcy5pbmRleDt9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbZ2V0SW5kZXgoaW5kZXgsIHRoaXMuc2xpZGVzKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0SXRlbShpdGVtLCBjb250ZW50KSB7XG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2l0ZW1sb2FkZWQnLCBbdGhpcywgaHRtbCh0aGlzLmdldFNsaWRlKGl0ZW0pLCBjb250ZW50KV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNsaWRlKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zbGlkZXNbdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pXTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRFcnJvcihpdGVtKSB7XG4gICAgICAgICAgdGhpcy5zZXRJdGVtKGl0ZW0sICc8c3BhbiB1ay1pY29uPVwiaWNvbjogYm9sdDsgcmF0aW86IDJcIj48L3NwYW4+Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd0NvbnRyb2xzKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbnRyb2xzVGltZXIpO1xuICAgICAgICAgIHRoaXMuY29udHJvbHNUaW1lciA9IHNldFRpbWVvdXQodGhpcy5oaWRlQ29udHJvbHMsIHRoaXMuZGVsYXlDb250cm9scyk7XG5cbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLWFjdGl2ZScsICd1ay10cmFuc2l0aW9uLWFjdGl2ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGVDb250cm9scygpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgJ3VrLWFjdGl2ZScsICd1ay10cmFuc2l0aW9uLWFjdGl2ZScpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbCh0YWcsIGF0dHJzKSB7XG4gICAgICBjb25zdCBlbCA9IGZyYWdtZW50KFwiPFwiICsgdGFnICsgXCI+XCIpO1xuICAgICAgYXR0cihlbCwgYXR0cnMpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cblxuICAgIHZhciBsaWdodGJveCA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwkMSxcblxuICAgICAgcHJvcHM6IHsgdG9nZ2xlOiBTdHJpbmcgfSxcblxuICAgICAgZGF0YTogeyB0b2dnbGU6ICdhJyB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICB0b2dnbGVzOiB7XG4gICAgICAgICAgZ2V0KF9yZWYsICRlbCkge2xldCB7IHRvZ2dsZSB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiAkJCh0b2dnbGUsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfSB9IH0sXG5cblxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlICsgXCI6bm90KC51ay1kaXNhYmxlZClcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93KGUuY3VycmVudCk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coaW5kZXgpIHtcbiAgICAgICAgICBjb25zdCBpdGVtcyA9IHVuaXF1ZUJ5KHRoaXMudG9nZ2xlcy5tYXAodG9JdGVtKSwgJ3NvdXJjZScpO1xuXG4gICAgICAgICAgaWYgKGlzRWxlbWVudChpbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlIH0gPSB0b0l0ZW0oaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggPSBmaW5kSW5kZXgoaXRlbXMsIChfcmVmMikgPT4ge2xldCB7IHNvdXJjZTogc3JjIH0gPSBfcmVmMjtyZXR1cm4gc291cmNlID09PSBzcmM7fSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wYW5lbCA9IHRoaXMucGFuZWwgfHwgdGhpcy4kY3JlYXRlKCdsaWdodGJveFBhbmVsJywgeyAuLi50aGlzLiRwcm9wcywgaXRlbXMgfSk7XG5cbiAgICAgICAgICBvbih0aGlzLnBhbmVsLiRlbCwgJ2hpZGRlbicsICgpID0+IHRoaXMucGFuZWwgPSBmYWxzZSk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYW5lbC5zaG93KGluZGV4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlKCkge3ZhciBfdGhpcyRwYW5lbDtcbiAgICAgICAgICByZXR1cm4gKF90aGlzJHBhbmVsID0gdGhpcy5wYW5lbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBhbmVsLmhpZGUoKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCQxKFVJa2l0LCBMaWdodGJveCkge1xuICAgICAgaWYgKCFVSWtpdC5saWdodGJveFBhbmVsKSB7XG4gICAgICAgIFVJa2l0LmNvbXBvbmVudCgnbGlnaHRib3hQYW5lbCcsIExpZ2h0Ym94UGFuZWwpO1xuICAgICAgfVxuXG4gICAgICBhc3NpZ24oTGlnaHRib3gucHJvcHMsIFVJa2l0LmNvbXBvbmVudCgnbGlnaHRib3hQYW5lbCcpLm9wdGlvbnMucHJvcHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSXRlbShlbCkge1xuICAgICAgY29uc3QgaXRlbSA9IHt9O1xuXG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgWydocmVmJywgJ2NhcHRpb24nLCAndHlwZScsICdwb3N0ZXInLCAnYWx0JywgJ2F0dHJzJ10pIHtcbiAgICAgICAgaXRlbVthdHRyID09PSAnaHJlZicgPyAnc291cmNlJyA6IGF0dHJdID0gZGF0YShlbCwgYXR0cik7XG4gICAgICB9XG5cbiAgICAgIGl0ZW0uYXR0cnMgPSBwYXJzZU9wdGlvbnMoaXRlbS5hdHRycyk7XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIHZhciBub3RpZmljYXRpb24gPSB7XG4gICAgICBtaXhpbnM6IFtDb250YWluZXJdLFxuXG4gICAgICBmdW5jdGlvbmFsOiB0cnVlLFxuXG4gICAgICBhcmdzOiBbJ21lc3NhZ2UnLCAnc3RhdHVzJ10sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWVzc2FnZTogJycsXG4gICAgICAgIHN0YXR1czogJycsXG4gICAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgICAgIGdyb3VwOiBudWxsLFxuICAgICAgICBwb3M6ICd0b3AtY2VudGVyJyxcbiAgICAgICAgY2xzQ29udGFpbmVyOiAndWstbm90aWZpY2F0aW9uJyxcbiAgICAgICAgY2xzQ2xvc2U6ICd1ay1ub3RpZmljYXRpb24tY2xvc2UnLFxuICAgICAgICBjbHNNc2c6ICd1ay1ub3RpZmljYXRpb24tbWVzc2FnZScgfSxcblxuXG4gICAgICBpbnN0YWxsLFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBtYXJnaW5Qcm9wKF9yZWYpIHtsZXQgeyBwb3MgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIFwibWFyZ2luXCIgKyAoc3RhcnRzV2l0aChwb3MsICd0b3AnKSA/ICdUb3AnIDogJ0JvdHRvbScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0UHJvcHMoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgb3BhY2l0eTogMCwgW3RoaXMubWFyZ2luUHJvcF06IC10aGlzLiRlbC5vZmZzZXRIZWlnaHQgfTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9XG4gICAgICAgICQoXCIuXCIgKyB0aGlzLmNsc0NvbnRhaW5lciArIFwiLVwiICsgdGhpcy5wb3MsIHRoaXMuY29udGFpbmVyKSB8fFxuICAgICAgICBhcHBlbmQoXG4gICAgICAgIHRoaXMuY29udGFpbmVyLCBcIjxkaXYgY2xhc3M9XFxcIlwiICtcbiAgICAgICAgdGhpcy5jbHNDb250YWluZXIgKyBcIiBcIiArIHRoaXMuY2xzQ29udGFpbmVyICsgXCItXCIgKyB0aGlzLnBvcyArIFwiXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogYmxvY2tcXFwiPjwvZGl2PlwiKTtcblxuXG4gICAgICAgIHRoaXMuJG1vdW50KFxuICAgICAgICBhcHBlbmQoXG4gICAgICAgIGNvbnRhaW5lciwgXCI8ZGl2IGNsYXNzPVxcXCJcIiArXG4gICAgICAgIHRoaXMuY2xzTXNnICsgKHRoaXMuc3RhdHVzID8gXCIgXCIgKyB0aGlzLmNsc01zZyArIFwiLVwiICsgdGhpcy5zdGF0dXMgOiAnJykgKyBcIlxcXCI+IDxhIGhyZWYgY2xhc3M9XFxcIlwiICtcbiAgICAgICAgdGhpcy5jbHNDbG9zZSArIFwiXFxcIiBkYXRhLXVrLWNsb3NlPjwvYT4gPGRpdj5cIiArXG4gICAgICAgIHRoaXMubWVzc2FnZSArIFwiPC9kaXY+IDwvZGl2PlwiKSk7XG5cblxuXG4gICAgICB9LFxuXG4gICAgICBhc3luYyBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHRvRmxvYXQoY3NzKHRoaXMuJGVsLCB0aGlzLm1hcmdpblByb3ApKTtcbiAgICAgICAgYXdhaXQgVHJhbnNpdGlvbi5zdGFydChjc3ModGhpcy4kZWwsIHRoaXMuc3RhcnRQcm9wcyksIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIFt0aGlzLm1hcmdpblByb3BdOiBtYXJnaW4gfSk7XG5cblxuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5jbG9zZSwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGNsaWNrKGUpIHtcbiAgICAgICAgICBpZiAoY2xvc2VzdChlLnRhcmdldCwgJ2FbaHJlZj1cIiNcIl0sYVtocmVmPVwiXCJdJykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFtwb2ludGVyRW50ZXJdKCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFtwb2ludGVyTGVhdmVdKCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuY2xvc2UsIHRoaXMudGltZW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBjbG9zZShpbW1lZGlhdGUpIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVGbiA9IChlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50KGVsKTtcblxuICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ2Nsb3NlJywgW3RoaXNdKTtcbiAgICAgICAgICAgIHJlbW92ZSQxKGVsKTtcblxuICAgICAgICAgICAgaWYgKCEoY29udGFpbmVyICE9IG51bGwgJiYgY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlJDEoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgYXdhaXQgVHJhbnNpdGlvbi5zdGFydCh0aGlzLiRlbCwgdGhpcy5zdGFydFByb3BzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmVGbih0aGlzLiRlbCk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoVUlraXQpIHtcbiAgICAgIFVJa2l0Lm5vdGlmaWNhdGlvbi5jbG9zZUFsbCA9IGZ1bmN0aW9uIChncm91cCwgaW1tZWRpYXRlKSB7XG4gICAgICAgIGFwcGx5KGRvY3VtZW50LmJvZHksIChlbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IFVJa2l0LmdldENvbXBvbmVudChlbCwgJ25vdGlmaWNhdGlvbicpO1xuICAgICAgICAgIGlmIChub3RpZmljYXRpb24gJiYgKCFncm91cCB8fCBncm91cCA9PT0gbm90aWZpY2F0aW9uLmdyb3VwKSkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uLmNsb3NlKGltbWVkaWF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICB4OiB0cmFuc2Zvcm1GbixcbiAgICAgIHk6IHRyYW5zZm9ybUZuLFxuICAgICAgcm90YXRlOiB0cmFuc2Zvcm1GbixcbiAgICAgIHNjYWxlOiB0cmFuc2Zvcm1GbixcbiAgICAgIGNvbG9yOiBjb2xvckZuLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvckZuLFxuICAgICAgYm9yZGVyQ29sb3I6IGNvbG9yRm4sXG4gICAgICBibHVyOiBmaWx0ZXJGbixcbiAgICAgIGh1ZTogZmlsdGVyRm4sXG4gICAgICBmb3BhY2l0eTogZmlsdGVyRm4sXG4gICAgICBncmF5c2NhbGU6IGZpbHRlckZuLFxuICAgICAgaW52ZXJ0OiBmaWx0ZXJGbixcbiAgICAgIHNhdHVyYXRlOiBmaWx0ZXJGbixcbiAgICAgIHNlcGlhOiBmaWx0ZXJGbixcbiAgICAgIG9wYWNpdHk6IGNzc1Byb3BGbixcbiAgICAgIHN0cm9rZTogc3Ryb2tlRm4sXG4gICAgICBiZ3g6IGJhY2tncm91bmRGbixcbiAgICAgIGJneTogYmFja2dyb3VuZEZuIH07XG5cblxuICAgIGNvbnN0IHsga2V5cyB9ID0gT2JqZWN0O1xuXG4gICAgdmFyIFBhcmFsbGF4ID0ge1xuICAgICAgbWl4aW5zOiBbTWVkaWFdLFxuXG4gICAgICBwcm9wczogZmlsbE9iamVjdChrZXlzKHByb3BzKSwgJ2xpc3QnKSxcblxuICAgICAgZGF0YTogZmlsbE9iamVjdChrZXlzKHByb3BzKSwgdW5kZWZpbmVkKSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgcHJvcHMocHJvcGVydGllcywgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGtleXMocHJvcHMpLnJlZHVjZSgocmVzdWx0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHByb3BlcnRpZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHByb3BzW3Byb3BdKHByb3AsICRlbCwgcHJvcGVydGllc1twcm9wXS5zbGljZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGxvYWQoKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBlYWNoKHRoaXMuZ2V0Q3NzKDApLCAoXywgcHJvcCkgPT4gY3NzKHRoaXMuJGVsLCBwcm9wLCAnJykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENzcyhwZXJjZW50KSB7XG4gICAgICAgICAgY29uc3QgY3NzID0geyB0cmFuc2Zvcm06ICcnLCBmaWx0ZXI6ICcnIH07XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHRoaXMucHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHNbcHJvcF0oY3NzLCBwZXJjZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNzcztcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBjb25zdCB1bml0ID0gZ2V0VW5pdChzdG9wcykgfHwgeyB4OiAncHgnLCB5OiAncHgnLCByb3RhdGU6ICdkZWcnIH1bcHJvcF0gfHwgJyc7XG4gICAgICBsZXQgdHJhbnNmb3JtRm47XG5cbiAgICAgIGlmIChwcm9wID09PSAneCcgfHwgcHJvcCA9PT0gJ3knKSB7XG4gICAgICAgIHByb3AgPSBcInRyYW5zbGF0ZVwiICsgdWNmaXJzdChwcm9wKTtcbiAgICAgICAgdHJhbnNmb3JtRm4gPSAoc3RvcCkgPT4gdG9GbG9hdCh0b0Zsb2F0KHN0b3ApLnRvRml4ZWQodW5pdCA9PT0gJ3B4JyA/IDAgOiA2KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdChwcm9wID09PSAnc2NhbGUnID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMsIHRyYW5zZm9ybUZuKTtcblxuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY3NzLnRyYW5zZm9ybSArPSBcIiBcIiArIHByb3AgKyBcIihcIiArIGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KSArIHVuaXQgKyBcIilcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sb3JGbihwcm9wLCBlbCwgc3RvcHMpIHtcbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdChnZXRDc3NWYWx1ZShlbCwgcHJvcCwgJycpKTtcbiAgICAgIH1cblxuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzLCAoc3RvcCkgPT4gcGFyc2VDb2xvcihlbCwgc3RvcCkpO1xuXG4gICAgICByZXR1cm4gKGNzcywgcGVyY2VudCkgPT4ge1xuICAgICAgICBjb25zdCBbc3RhcnQsIGVuZCwgcF0gPSBnZXRTdG9wKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdGFydC5cbiAgICAgICAgbWFwKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgICAgIHZhbHVlICs9IHAgKiAoZW5kW2ldIC0gdmFsdWUpO1xuICAgICAgICAgIHJldHVybiBpID09PSAzID8gdG9GbG9hdCh2YWx1ZSkgOiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICB9KS5cbiAgICAgICAgam9pbignLCcpO1xuICAgICAgICBjc3NbcHJvcF0gPSBcInJnYmEoXCIgKyB2YWx1ZSArIFwiKVwiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbG9yKGVsLCBjb2xvcikge1xuICAgICAgcmV0dXJuIGdldENzc1ZhbHVlKGVsLCAnY29sb3InLCBjb2xvcikuXG4gICAgICBzcGxpdCgvWygpLF0vZykuXG4gICAgICBzbGljZSgxLCAtMSkuXG4gICAgICBjb25jYXQoMSkuXG4gICAgICBzbGljZSgwLCA0KS5cbiAgICAgIG1hcCh0b0Zsb2F0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJGbihwcm9wLCBlbCwgc3RvcHMpIHtcbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdCgwKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdW5pdCA9IGdldFVuaXQoc3RvcHMpIHx8IHsgYmx1cjogJ3B4JywgaHVlOiAnZGVnJyB9W3Byb3BdIHx8ICclJztcbiAgICAgIHByb3AgPSB7IGZvcGFjaXR5OiAnb3BhY2l0eScsIGh1ZTogJ2h1ZS1yb3RhdGUnIH1bcHJvcF0gfHwgcHJvcDtcbiAgICAgIHN0b3BzID0gcGFyc2VTdG9wcyhzdG9wcyk7XG5cbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0VmFsdWUoc3RvcHMsIHBlcmNlbnQpO1xuICAgICAgICBjc3MuZmlsdGVyICs9IFwiIFwiICsgcHJvcCArIFwiKFwiICsgKHZhbHVlICsgdW5pdCkgKyBcIilcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3NzUHJvcEZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KGdldENzc1ZhbHVlKGVsLCBwcm9wLCAnJykpO1xuICAgICAgfVxuXG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMpO1xuXG4gICAgICByZXR1cm4gKGNzcywgcGVyY2VudCkgPT4ge1xuICAgICAgICBjc3NbcHJvcF0gPSBnZXRWYWx1ZShzdG9wcywgcGVyY2VudCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cm9rZUZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KDApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bml0ID0gZ2V0VW5pdChzdG9wcyk7XG4gICAgICBjb25zdCBsZW5ndGggPSBnZXRNYXhQYXRoTGVuZ3RoKGVsKTtcbiAgICAgIHN0b3BzID0gcGFyc2VTdG9wcyhzdG9wcy5yZXZlcnNlKCksIChzdG9wKSA9PiB7XG4gICAgICAgIHN0b3AgPSB0b0Zsb2F0KHN0b3ApO1xuICAgICAgICByZXR1cm4gdW5pdCA9PT0gJyUnID8gc3RvcCAqIGxlbmd0aCAvIDEwMCA6IHN0b3A7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFzdG9wcy5zb21lKChfcmVmKSA9PiB7bGV0IFt2YWx1ZV0gPSBfcmVmO3JldHVybiB2YWx1ZTt9KSkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgIH1cblxuICAgICAgY3NzKGVsLCAnc3Ryb2tlRGFzaGFycmF5JywgbGVuZ3RoKTtcblxuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY3NzLnN0cm9rZURhc2hvZmZzZXQgPSBnZXRWYWx1ZShzdG9wcywgcGVyY2VudCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhY2tncm91bmRGbihwcm9wLCBlbCwgc3RvcHMpIHtcbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdCgwKTtcbiAgICAgIH1cblxuICAgICAgcHJvcCA9IHByb3Auc3Vic3RyKC0xKTtcbiAgICAgIGNvbnN0IGF0dHIgPSBwcm9wID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMsIChzdG9wKSA9PiB0b1B4KHN0b3AsIGF0dHIsIGVsKSk7XG5cbiAgICAgIGNvbnN0IGJnUG9zID0gZ2V0Q3NzVmFsdWUoZWwsIFwiYmFja2dyb3VuZC1wb3NpdGlvbi1cIiArIHByb3AsICcnKTtcblxuICAgICAgcmV0dXJuIGdldENzc1ZhbHVlKGVsLCAnYmFja2dyb3VuZFNpemUnLCAnJykgPT09ICdjb3ZlcicgP1xuICAgICAgYmFja2dyb3VuZENvdmVyRm4ocHJvcCwgZWwsIHN0b3BzLCBiZ1BvcywgYXR0cikgOlxuICAgICAgc2V0QmFja2dyb3VuZFBvc0ZuKHByb3AsIHN0b3BzLCBiZ1Bvcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmFja2dyb3VuZENvdmVyRm4ocHJvcCwgZWwsIHN0b3BzLCBiZ1BvcywgYXR0cikge1xuICAgICAgY29uc3QgZGltSW1hZ2UgPSBnZXRCYWNrZ3JvdW5kSW1hZ2VEaW1lbnNpb25zKGVsKTtcblxuICAgICAgaWYgKCFkaW1JbWFnZS53aWR0aCkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsdWVzID0gc3RvcHMubWFwKChfcmVmMikgPT4ge2xldCBbdmFsdWVdID0gX3JlZjI7cmV0dXJuIHZhbHVlO30pO1xuICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oLi4udmFsdWVzKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnZhbHVlcyk7XG4gICAgICBjb25zdCBkb3duID0gdmFsdWVzLmluZGV4T2YobWluKSA8IHZhbHVlcy5pbmRleE9mKG1heCk7XG5cbiAgICAgIGNvbnN0IGRpZmYgPSBtYXggLSBtaW47XG4gICAgICBsZXQgcG9zID0gKGRvd24gPyAtZGlmZiA6IDApIC0gKGRvd24gPyBtaW4gOiBtYXgpO1xuXG4gICAgICBjb25zdCBkaW1FbCA9IHtcbiAgICAgICAgd2lkdGg6IGVsLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGVsLm9mZnNldEhlaWdodCB9O1xuXG5cbiAgICAgIGNvbnN0IGJhc2VEaW0gPSBEaW1lbnNpb25zLmNvdmVyKGRpbUltYWdlLCBkaW1FbCk7XG4gICAgICBjb25zdCBzcGFuID0gYmFzZURpbVthdHRyXSAtIGRpbUVsW2F0dHJdO1xuXG4gICAgICBpZiAoc3BhbiA8IGRpZmYpIHtcbiAgICAgICAgZGltRWxbYXR0cl0gPSBiYXNlRGltW2F0dHJdICsgZGlmZiAtIHNwYW47XG4gICAgICB9IGVsc2UgaWYgKHNwYW4gPiBkaWZmKSB7XG4gICAgICAgIGNvbnN0IHBvc1BlcmNlbnRhZ2UgPSBkaW1FbFthdHRyXSAvIHRvUHgoYmdQb3MsIGF0dHIsIGVsLCB0cnVlKTtcblxuICAgICAgICBpZiAocG9zUGVyY2VudGFnZSkge1xuICAgICAgICAgIHBvcyAtPSAoc3BhbiAtIGRpZmYpIC8gcG9zUGVyY2VudGFnZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkaW0gPSBEaW1lbnNpb25zLmNvdmVyKGRpbUltYWdlLCBkaW1FbCk7XG5cbiAgICAgIGNvbnN0IGZuID0gc2V0QmFja2dyb3VuZFBvc0ZuKHByb3AsIHN0b3BzLCBwb3MgKyBcInB4XCIpO1xuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgZm4oY3NzLCBwZXJjZW50KTtcbiAgICAgICAgY3NzLmJhY2tncm91bmRTaXplID0gZGltLndpZHRoICsgXCJweCBcIiArIGRpbS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIGNzcy5iYWNrZ3JvdW5kUmVwZWF0ID0gJ25vLXJlcGVhdCc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEJhY2tncm91bmRQb3NGbihwcm9wLCBzdG9wcywgcG9zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGNzcywgcGVyY2VudCkge1xuICAgICAgICBjc3NbXCJiYWNrZ3JvdW5kLXBvc2l0aW9uLVwiICsgcHJvcF0gPSBcImNhbGMoXCIgKyBwb3MgKyBcIiArIFwiICsgZ2V0VmFsdWUoc3RvcHMsIHBlcmNlbnQpICsgXCJweClcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZGltZW5zaW9ucyA9IHt9O1xuICAgIGZ1bmN0aW9uIGdldEJhY2tncm91bmRJbWFnZURpbWVuc2lvbnMoZWwpIHtcbiAgICAgIGNvbnN0IHNyYyA9IGNzcyhlbCwgJ2JhY2tncm91bmRJbWFnZScpLnJlcGxhY2UoL15ub25lfHVybFxcKFtcIiddPyguKz8pW1wiJ10/XFwpJC8sICckMScpO1xuXG4gICAgICBpZiAoZGltZW5zaW9uc1tzcmNdKSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb25zW3NyY107XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIGltYWdlLnNyYyA9IHNyYztcblxuICAgICAgICBpZiAoIWltYWdlLm5hdHVyYWxXaWR0aCkge1xuICAgICAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnNbc3JjXSA9IHRvRGltZW5zaW9ucyhpbWFnZSk7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCBjcmVhdGVFdmVudCgnbG9hZCcsIGZhbHNlKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gdG9EaW1lbnNpb25zKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGltZW5zaW9uc1tzcmNdID0gdG9EaW1lbnNpb25zKGltYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RpbWVuc2lvbnMoaW1hZ2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBpbWFnZS5uYXR1cmFsV2lkdGgsXG4gICAgICAgIGhlaWdodDogaW1hZ2UubmF0dXJhbEhlaWdodCB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdG9wcyhzdG9wcywgZm4pIHtpZiAoZm4gPT09IHZvaWQgMCkge2ZuID0gdG9GbG9hdDt9XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdG9wcztcbiAgICAgIGxldCBudWxsSW5kZXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgW3ZhbHVlLCBwZXJjZW50XSA9IGlzU3RyaW5nKHN0b3BzW2ldKSA/IHN0b3BzW2ldLnRyaW0oKS5zcGxpdCgnICcpIDogW3N0b3BzW2ldXTtcbiAgICAgICAgdmFsdWUgPSBmbih2YWx1ZSk7XG4gICAgICAgIHBlcmNlbnQgPSBwZXJjZW50ID8gdG9GbG9hdChwZXJjZW50KSAvIDEwMCA6IG51bGw7XG5cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBpZiAocGVyY2VudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbdmFsdWUsIDBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGlmIChwZXJjZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgIT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFt2YWx1ZSwgcGVyY2VudF0pO1xuICAgICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goW3ZhbHVlLCBwZXJjZW50XSk7XG5cbiAgICAgICAgaWYgKHBlcmNlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBudWxsSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIGlmIChudWxsSW5kZXgpIHtcbiAgICAgICAgICBjb25zdCBsZWZ0UGVyY2VudCA9IHJlc3VsdFtpIC0gbnVsbEluZGV4IC0gMV1bMV07XG4gICAgICAgICAgY29uc3QgcCA9IChwZXJjZW50IC0gbGVmdFBlcmNlbnQpIC8gKG51bGxJbmRleCArIDEpO1xuICAgICAgICAgIGZvciAobGV0IGogPSBudWxsSW5kZXg7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdFtpIC0gal1bMV0gPSBsZWZ0UGVyY2VudCArIHAgKiAobnVsbEluZGV4IC0gaiArIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG51bGxJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdG9wKHN0b3BzLCBwZXJjZW50KSB7XG4gICAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleChzdG9wcy5zbGljZSgxKSwgKF9yZWYzKSA9PiB7bGV0IFssIHRhcmdldFBlcmNlbnRdID0gX3JlZjM7cmV0dXJuIHBlcmNlbnQgPD0gdGFyZ2V0UGVyY2VudDt9KSArIDE7XG4gICAgICByZXR1cm4gW1xuICAgICAgc3RvcHNbaW5kZXggLSAxXVswXSxcbiAgICAgIHN0b3BzW2luZGV4XVswXSxcbiAgICAgIChwZXJjZW50IC0gc3RvcHNbaW5kZXggLSAxXVsxXSkgLyAoc3RvcHNbaW5kZXhdWzFdIC0gc3RvcHNbaW5kZXggLSAxXVsxXSldO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWUoc3RvcHMsIHBlcmNlbnQpIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kLCBwXSA9IGdldFN0b3Aoc3RvcHMsIHBlcmNlbnQpO1xuICAgICAgcmV0dXJuIGlzTnVtYmVyKHN0YXJ0KSA/IHN0YXJ0ICsgTWF0aC5hYnMoc3RhcnQgLSBlbmQpICogcCAqIChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiArZW5kO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaXRSZSA9IC9eLT9cXGQrKFteXFxzXSopLztcbiAgICBmdW5jdGlvbiBnZXRVbml0KHN0b3BzLCBkZWZhdWx0VW5pdCkge1xuICAgICAgZm9yIChjb25zdCBzdG9wIG9mIHN0b3BzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3RvcC5tYXRjaCA9PSBudWxsID8gdm9pZCAwIDogc3RvcC5tYXRjaCh1bml0UmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZhdWx0VW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDc3NWYWx1ZShlbCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBlbC5zdHlsZVtwcm9wXTtcbiAgICAgIGNvbnN0IHZhbCA9IGNzcyhjc3MoZWwsIHByb3AsIHZhbHVlKSwgcHJvcCk7XG4gICAgICBlbC5zdHlsZVtwcm9wXSA9IHByZXY7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxPYmplY3Qoa2V5cywgdmFsdWUpIHtcbiAgICAgIHJldHVybiBrZXlzLnJlZHVjZSgoZGF0YSwgcHJvcCkgPT4ge1xuICAgICAgICBkYXRhW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIHZhciBwYXJhbGxheCA9IHtcbiAgICAgIG1peGluczogW1BhcmFsbGF4LCBSZXNpemUsIFNjcm9sbF0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICB2aWV3cG9ydDogTnVtYmVyLCAvLyBEZXByZWNhdGVkXG4gICAgICAgIGVhc2luZzogTnVtYmVyLFxuICAgICAgICBzdGFydDogU3RyaW5nLFxuICAgICAgICBlbmQ6IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgdmlld3BvcnQ6IDEsXG4gICAgICAgIGVhc2luZzogMSxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogMCB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRhcmdldChfcmVmLCAkZWwpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIGdldE9mZnNldEVsZW1lbnQodGFyZ2V0ICYmIHF1ZXJ5KHRhcmdldCwgJGVsKSB8fCAkZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0KF9yZWYyKSB7bGV0IHsgc3RhcnQgfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiB0b1B4KHN0YXJ0LCAnaGVpZ2h0JywgdGhpcy50YXJnZXQsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZChfcmVmMykge2xldCB7IGVuZCwgdmlld3BvcnQgfSA9IF9yZWYzO1xuICAgICAgICAgIHJldHVybiB0b1B4KFxuICAgICAgICAgIGVuZCB8fCAodmlld3BvcnQgPSAoMSAtIHZpZXdwb3J0KSAqIDEwMCkgJiYgdmlld3BvcnQgKyBcInZoK1wiICsgdmlld3BvcnQgKyBcIiVcIixcbiAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICB0aGlzLnRhcmdldCxcbiAgICAgICAgICB0cnVlKTtcblxuICAgICAgICB9IH0sXG5cblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoX3JlZjQsIHR5cGVzKSB7bGV0IHsgcGVyY2VudCB9ID0gX3JlZjQ7XG4gICAgICAgICAgaWYgKCF0eXBlcy5oYXMoJ3Njcm9sbCcpKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLm1hdGNoTWVkaWEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwcmV2ID0gcGVyY2VudDtcbiAgICAgICAgICBwZXJjZW50ID0gZWFzZShzY3JvbGxlZE92ZXIodGhpcy50YXJnZXQsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKSwgdGhpcy5lYXNpbmcpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBlcmNlbnQsXG4gICAgICAgICAgICBzdHlsZTogcHJldiA9PT0gcGVyY2VudCA/IGZhbHNlIDogdGhpcy5nZXRDc3MocGVyY2VudCkgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWY1KSB7bGV0IHsgc3R5bGUgfSA9IF9yZWY1O1xuICAgICAgICAgIGlmICghdGhpcy5tYXRjaE1lZGlhKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3R5bGUgJiYgY3NzKHRoaXMuJGVsLCBzdHlsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Njcm9sbCcsICdyZXNpemUnXSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZWFzZShwZXJjZW50LCBlYXNpbmcpIHtcbiAgICAgIHJldHVybiBlYXNpbmcgPj0gMCA/IE1hdGgucG93KHBlcmNlbnQsIGVhc2luZyArIDEpIDogMSAtIE1hdGgucG93KDEgLSBwZXJjZW50LCAtZWFzaW5nICsgMSk7XG4gICAgfVxuXG4gICAgLy8gU1ZHIGVsZW1lbnRzIGRvIG5vdCBpbmhlcml0IGZyb20gSFRNTEVsZW1lbnRcbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRFbGVtZW50KGVsKSB7XG4gICAgICByZXR1cm4gZWwgPyAnb2Zmc2V0VG9wJyBpbiBlbCA/IGVsIDogZ2V0T2Zmc2V0RWxlbWVudChwYXJlbnQoZWwpKSA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgU2xpZGVyUmVhY3RpdmUgPSB7XG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgd3JpdGUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIHx8IHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0VmFsaWRJbmRleCh0aGlzLmluZGV4KTtcblxuICAgICAgICAgIGlmICghfnRoaXMucHJldkluZGV4IHx8IHRoaXMuaW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnNob3coaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSB9O1xuXG4gICAgdmFyIFNsaWRlclByZWxvYWQgPSB7XG4gICAgICBtaXhpbnM6IFtMYXp5bG9hZF0sXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5sYXp5bG9hZCh0aGlzLnNsaWRlcywgdGhpcy5nZXRBZGphY2VudFNsaWRlcyk7XG4gICAgICB9IH07XG5cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uZXIgKHByZXYsIG5leHQsIGRpciwgX3JlZikge2xldCB7IGNlbnRlciwgZWFzaW5nLCBsaXN0IH0gPSBfcmVmO1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcblxuICAgICAgY29uc3QgZnJvbSA9IHByZXYgP1xuICAgICAgZ2V0TGVmdChwcmV2LCBsaXN0LCBjZW50ZXIpIDpcbiAgICAgIGdldExlZnQobmV4dCwgbGlzdCwgY2VudGVyKSArIGRpbWVuc2lvbnMkMShuZXh0KS53aWR0aCAqIGRpcjtcbiAgICAgIGNvbnN0IHRvID0gbmV4dCA/XG4gICAgICBnZXRMZWZ0KG5leHQsIGxpc3QsIGNlbnRlcikgOlxuICAgICAgZnJvbSArIGRpbWVuc2lvbnMkMShwcmV2KS53aWR0aCAqIGRpciAqIChpc1J0bCA/IC0xIDogMSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpcixcblxuICAgICAgICBzaG93KGR1cmF0aW9uLCBwZXJjZW50LCBsaW5lYXIpIHtpZiAocGVyY2VudCA9PT0gdm9pZCAwKSB7cGVyY2VudCA9IDA7fVxuICAgICAgICAgIGNvbnN0IHRpbWluZyA9IGxpbmVhciA/ICdsaW5lYXInIDogZWFzaW5nO1xuICAgICAgICAgIGR1cmF0aW9uIC09IE1hdGgucm91bmQoZHVyYXRpb24gKiBjbGFtcChwZXJjZW50LCAtMSwgMSkpO1xuXG4gICAgICAgICAgdGhpcy50cmFuc2xhdGUocGVyY2VudCk7XG5cbiAgICAgICAgICBwZXJjZW50ID0gcHJldiA/IHBlcmNlbnQgOiBjbGFtcChwZXJjZW50LCAwLCAxKTtcbiAgICAgICAgICB0cmlnZ2VyVXBkYXRlKHRoaXMuZ2V0SXRlbUluKCksICdpdGVtaW4nLCB7IHBlcmNlbnQsIGR1cmF0aW9uLCB0aW1pbmcsIGRpciB9KTtcbiAgICAgICAgICBwcmV2ICYmXG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSh0aGlzLmdldEl0ZW1Jbih0cnVlKSwgJ2l0ZW1vdXQnLCB7XG4gICAgICAgICAgICBwZXJjZW50OiAxIC0gcGVyY2VudCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nLFxuICAgICAgICAgICAgZGlyIH0pO1xuXG5cbiAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KFxuICAgICAgICAgIGxpc3QsXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtdG8gKiAoaXNSdGwgPyAtMSA6IDEpLCAncHgnKSB9LFxuICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZykuXG4gICAgICAgICAgdGhlbihkZWZlcnJlZC5yZXNvbHZlLCBub29wKTtcblxuICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbChsaXN0KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBjc3MobGlzdCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmb3J3YXJkKGR1cmF0aW9uLCBwZXJjZW50KSB7aWYgKHBlcmNlbnQgPT09IHZvaWQgMCkge3BlcmNlbnQgPSB0aGlzLnBlcmNlbnQoKTt9XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwobGlzdCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhkdXJhdGlvbiwgcGVyY2VudCwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuZ2V0RGlzdGFuY2UoKSAqIGRpciAqIChpc1J0bCA/IC0xIDogMSk7XG5cbiAgICAgICAgICBjc3MoXG4gICAgICAgICAgbGlzdCxcbiAgICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICB0cmFuc2xhdGUoXG4gICAgICAgICAgY2xhbXAoXG4gICAgICAgICAgLXRvICsgKGRpc3RhbmNlIC0gZGlzdGFuY2UgKiBwZXJjZW50KSxcbiAgICAgICAgICAtZ2V0V2lkdGgobGlzdCksXG4gICAgICAgICAgZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoKSAqIChcbiAgICAgICAgICBpc1J0bCA/IC0xIDogMSksXG4gICAgICAgICAgJ3B4JykpO1xuXG5cblxuICAgICAgICAgIGNvbnN0IGFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZXMoKTtcbiAgICAgICAgICBjb25zdCBpdGVtSW4gPSB0aGlzLmdldEl0ZW1JbigpO1xuICAgICAgICAgIGNvbnN0IGl0ZW1PdXQgPSB0aGlzLmdldEl0ZW1Jbih0cnVlKTtcblxuICAgICAgICAgIHBlcmNlbnQgPSBwcmV2ID8gY2xhbXAocGVyY2VudCwgLTEsIDEpIDogMDtcblxuICAgICAgICAgIGZvciAoY29uc3Qgc2xpZGUgb2YgY2hpbGRyZW4obGlzdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQWN0aXZlID0gaW5jbHVkZXMoYWN0aXZlcywgc2xpZGUpO1xuICAgICAgICAgICAgY29uc3QgaXNJbiA9IHNsaWRlID09PSBpdGVtSW47XG4gICAgICAgICAgICBjb25zdCBpc091dCA9IHNsaWRlID09PSBpdGVtT3V0O1xuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlSW4gPVxuICAgICAgICAgICAgaXNJbiB8fFxuICAgICAgICAgICAgIWlzT3V0ICYmIChcbiAgICAgICAgICAgIGlzQWN0aXZlIHx8XG4gICAgICAgICAgICBkaXIgKiAoaXNSdGwgPyAtMSA6IDEpID09PSAtMSBeXG4gICAgICAgICAgICBnZXRFbExlZnQoc2xpZGUsIGxpc3QpID4gZ2V0RWxMZWZ0KHByZXYgfHwgbmV4dCkpO1xuXG4gICAgICAgICAgICB0cmlnZ2VyVXBkYXRlKHNsaWRlLCBcIml0ZW10cmFuc2xhdGVcIiArICh0cmFuc2xhdGVJbiA/ICdpbicgOiAnb3V0JyksIHtcbiAgICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgICBwZXJjZW50OiBpc091dCA/IDEgLSBwZXJjZW50IDogaXNJbiA/IHBlcmNlbnQgOiBpc0FjdGl2ZSA/IDEgOiAwIH0pO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKFxuICAgICAgICAgIChjc3MobGlzdCwgJ3RyYW5zZm9ybScpLnNwbGl0KCcsJylbNF0gKiAoaXNSdGwgPyAtMSA6IDEpICsgZnJvbSkgLyAodG8gLSBmcm9tKSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBnZXREaXN0YW5jZSgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5hYnModG8gLSBmcm9tKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRJdGVtSW4ob3V0KSB7aWYgKG91dCA9PT0gdm9pZCAwKSB7b3V0ID0gZmFsc2U7fVxuICAgICAgICAgIGxldCBhY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVzKCk7XG4gICAgICAgICAgbGV0IG5leHRBY3RpdmVzID0gaW5WaWV3KGxpc3QsIGdldExlZnQobmV4dCB8fCBwcmV2LCBsaXN0LCBjZW50ZXIpKTtcblxuICAgICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBhY3RpdmVzO1xuICAgICAgICAgICAgYWN0aXZlcyA9IG5leHRBY3RpdmVzO1xuICAgICAgICAgICAgbmV4dEFjdGl2ZXMgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXh0QWN0aXZlc1tmaW5kSW5kZXgobmV4dEFjdGl2ZXMsIChlbCkgPT4gIWluY2x1ZGVzKGFjdGl2ZXMsIGVsKSldO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFjdGl2ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGluVmlldyhsaXN0LCBnZXRMZWZ0KHByZXYgfHwgbmV4dCwgbGlzdCwgY2VudGVyKSk7XG4gICAgICAgIH0gfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldExlZnQoZWwsIGxpc3QsIGNlbnRlcikge1xuICAgICAgY29uc3QgbGVmdCA9IGdldEVsTGVmdChlbCwgbGlzdCk7XG5cbiAgICAgIHJldHVybiBjZW50ZXIgPyBsZWZ0IC0gY2VudGVyRWwoZWwsIGxpc3QpIDogTWF0aC5taW4obGVmdCwgZ2V0TWF4KGxpc3QpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXgobGlzdCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGdldFdpZHRoKGxpc3QpIC0gZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaWR0aChsaXN0KSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW4obGlzdCkucmVkdWNlKChyaWdodCwgZWwpID0+IGRpbWVuc2lvbnMkMShlbCkud2lkdGggKyByaWdodCwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2VudGVyRWwoZWwsIGxpc3QpIHtcbiAgICAgIHJldHVybiBkaW1lbnNpb25zJDEobGlzdCkud2lkdGggLyAyIC0gZGltZW5zaW9ucyQxKGVsKS53aWR0aCAvIDI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RWxMZWZ0KGVsLCBsaXN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBlbCAmJlxuICAgICAgICAocG9zaXRpb24oZWwpLmxlZnQgKyAoaXNSdGwgPyBkaW1lbnNpb25zJDEoZWwpLndpZHRoIC0gZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoIDogMCkpICogKFxuICAgICAgICBpc1J0bCA/IC0xIDogMSkgfHxcbiAgICAgICAgMCk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpblZpZXcobGlzdCwgbGlzdExlZnQpIHtcbiAgICAgIGxpc3RMZWZ0IC09IDE7XG4gICAgICBjb25zdCBsaXN0V2lkdGggPSBkaW1lbnNpb25zJDEobGlzdCkud2lkdGg7XG4gICAgICBjb25zdCBsaXN0UmlnaHQgPSBsaXN0TGVmdCArIGxpc3RXaWR0aCArIDI7XG5cbiAgICAgIHJldHVybiBjaGlsZHJlbihsaXN0KS5maWx0ZXIoKHNsaWRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNsaWRlTGVmdCA9IGdldEVsTGVmdChzbGlkZSwgbGlzdCk7XG4gICAgICAgIGNvbnN0IHNsaWRlUmlnaHQgPSBzbGlkZUxlZnQgKyBNYXRoLm1pbihkaW1lbnNpb25zJDEoc2xpZGUpLndpZHRoLCBsaXN0V2lkdGgpO1xuXG4gICAgICAgIHJldHVybiBzbGlkZUxlZnQgPj0gbGlzdExlZnQgJiYgc2xpZGVSaWdodCA8PSBsaXN0UmlnaHQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyVXBkYXRlKGVsLCB0eXBlLCBkYXRhKSB7XG4gICAgICB0cmlnZ2VyKGVsLCBjcmVhdGVFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UsIGRhdGEpKTtcbiAgICB9XG5cbiAgICB2YXIgc2xpZGVyID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIFNsaWRlciwgU2xpZGVyUmVhY3RpdmUsIFNsaWRlclByZWxvYWRdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBjZW50ZXI6IEJvb2xlYW4sXG4gICAgICAgIHNldHM6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNlbnRlcjogZmFsc2UsXG4gICAgICAgIHNldHM6IGZhbHNlLFxuICAgICAgICBhdHRySXRlbTogJ3VrLXNsaWRlci1pdGVtJyxcbiAgICAgICAgc2VsTGlzdDogJy51ay1zbGlkZXItaXRlbXMnLFxuICAgICAgICBzZWxOYXY6ICcudWstc2xpZGVyLW5hdicsXG4gICAgICAgIGNsc0NvbnRhaW5lcjogJ3VrLXNsaWRlci1jb250YWluZXInLFxuICAgICAgICBUcmFuc2l0aW9uZXIgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBhdmdXaWR0aCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0V2lkdGgodGhpcy5saXN0KSAvIHRoaXMubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbml0ZShfcmVmKSB7bGV0IHsgZmluaXRlIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBmaW5pdGUgfHxcbiAgICAgICAgICAgIE1hdGguY2VpbChnZXRXaWR0aCh0aGlzLmxpc3QpKSA8XG4gICAgICAgICAgICBNYXRoLnRydW5jKGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpLndpZHRoICsgZ2V0TWF4RWxXaWR0aCh0aGlzLmxpc3QpICsgdGhpcy5jZW50ZXIpKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIG1heEluZGV4KCkge1xuICAgICAgICAgIGlmICghdGhpcy5maW5pdGUgfHwgdGhpcy5jZW50ZXIgJiYgIXRoaXMuc2V0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0KHRoaXMuc2V0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGxmdCA9IDA7XG4gICAgICAgICAgY29uc3QgbWF4ID0gZ2V0TWF4KHRoaXMubGlzdCk7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgodGhpcy5zbGlkZXMsIChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxmdCA+PSBtYXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxmdCArPSBkaW1lbnNpb25zJDEoZWwpLndpZHRoO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIH5pbmRleCA/IGluZGV4IDogdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldHMoX3JlZjIpIHtsZXQgeyBzZXRzOiBlbmFibGVkIH0gPSBfcmVmMjtcbiAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgbGVmdCA9IDA7XG4gICAgICAgICAgY29uc3Qgc2V0cyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gZGltZW5zaW9ucyQxKHRoaXMubGlzdCkud2lkdGg7XG4gICAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLnNsaWRlcykge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVXaWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1tpXSkud2lkdGg7XG5cbiAgICAgICAgICAgIGlmIChsZWZ0ICsgc2xpZGVXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBsZWZ0IDwgd2lkdGggLyAyICYmXG4gICAgICAgICAgICAgIGxlZnQgKyBzbGlkZVdpZHRoICsgZGltZW5zaW9ucyQxKHRoaXMuc2xpZGVzWytpICsgMV0pLndpZHRoIC8gMiA+IHdpZHRoIC8gMilcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNldHMucHVzaCgraSk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHdpZHRoIC8gMiAtIHNsaWRlV2lkdGggLyAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgc2V0cy5wdXNoKE1hdGgubWluKCtpLCB0aGlzLm1heEluZGV4KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlZnQgKz0gc2xpZGVXaWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2l0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2VudGVyOiB0aGlzLmNlbnRlcixcbiAgICAgICAgICAgIGxpc3Q6IHRoaXMubGlzdCB9O1xuXG4gICAgICAgIH0gfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0NvbnRhaW5lciwgISQoXCIuXCIgKyB0aGlzLmNsc0NvbnRhaW5lciwgdGhpcy4kZWwpKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZSgpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMubmF2SXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdG9OdW1iZXIoZGF0YShlbCwgdGhpcy5hdHRySXRlbSkpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlbC5oaWRkZW4gPVxuICAgICAgICAgICAgICAhdGhpcy5tYXhJbmRleCB8fFxuICAgICAgICAgICAgICBpbmRleCA+IHRoaXMubWF4SW5kZXggfHxcbiAgICAgICAgICAgICAgdGhpcy5zZXRzICYmICFpbmNsdWRlcyh0aGlzLnNldHMsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5sZW5ndGggJiYgIXRoaXMuZHJhZ2dpbmcgJiYgIXRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlb3JkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZSgxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUNsYXNzZXMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgYmVmb3JlaXRlbXNob3coZSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAhdGhpcy5kcmFnZ2luZyAmJlxuICAgICAgICAgIHRoaXMuc2V0cyAmJlxuICAgICAgICAgIHRoaXMuc3RhY2subGVuZ3RoIDwgMiAmJlxuICAgICAgICAgICFpbmNsdWRlcyh0aGlzLnNldHMsIHRoaXMuaW5kZXgpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmdldFZhbGlkSW5kZXgoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMoXG4gICAgICAgICAgdGhpcy5pbmRleCAtXG4gICAgICAgICAgdGhpcy5wcmV2SW5kZXggKyAoXG4gICAgICAgICAgdGhpcy5kaXIgPiAwICYmIHRoaXMuaW5kZXggPCB0aGlzLnByZXZJbmRleCB8fFxuICAgICAgICAgIHRoaXMuZGlyIDwgMCAmJiB0aGlzLmluZGV4ID4gdGhpcy5wcmV2SW5kZXggP1xuICAgICAgICAgICh0aGlzLm1heEluZGV4ICsgMSkgKiB0aGlzLmRpciA6XG4gICAgICAgICAgMCkpO1xuXG5cbiAgICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcgJiYgZGlmZiA+IDEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhY2suc3BsaWNlKDEsIDAsIHRoaXMuZGlyID4gMCA/ICduZXh0JyA6ICdwcmV2aW91cycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5kZXggPVxuICAgICAgICAgIHRoaXMuZGlyIDwgMCB8fCAhdGhpcy5zbGlkZXNbdGhpcy5wcmV2SW5kZXhdID8gdGhpcy5pbmRleCA6IHRoaXMucHJldkluZGV4O1xuICAgICAgICAgIHRoaXMuZHVyYXRpb24gPVxuICAgICAgICAgIHNwZWVkVXAodGhpcy5hdmdXaWR0aCAvIHRoaXMudmVsb2NpdHkpICogKFxuICAgICAgICAgIGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1tpbmRleF0pLndpZHRoIC8gdGhpcy5hdmdXaWR0aCk7XG5cbiAgICAgICAgICB0aGlzLnJlb3JkZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtc2hvdygpIHtcbiAgICAgICAgICBpZiAofnRoaXMucHJldkluZGV4KSB7XG4gICAgICAgICAgICBhZGRDbGFzcyh0aGlzLl9nZXRUcmFuc2l0aW9uZXIoKS5nZXRJdGVtSW4oKSwgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtc2hvd24oKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVDbGFzc2VzKCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHJlb3JkZXIoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZmluaXRlKSB7XG4gICAgICAgICAgICBjc3ModGhpcy5zbGlkZXMsICdvcmRlcicsICcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGlyID4gMCAmJiB0aGlzLnNsaWRlc1t0aGlzLnByZXZJbmRleF0gPyB0aGlzLnByZXZJbmRleCA6IHRoaXMuaW5kZXg7XG5cbiAgICAgICAgICB0aGlzLnNsaWRlcy5mb3JFYWNoKChzbGlkZSwgaSkgPT5cbiAgICAgICAgICBjc3MoXG4gICAgICAgICAgc2xpZGUsXG4gICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICB0aGlzLmRpciA+IDAgJiYgaSA8IGluZGV4ID8gMSA6IHRoaXMuZGlyIDwgMCAmJiBpID49IHRoaXMuaW5kZXggPyAtMSA6ICcnKSk7XG5cblxuXG4gICAgICAgICAgaWYgKCF0aGlzLmNlbnRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLnNsaWRlc1tpbmRleF07XG4gICAgICAgICAgbGV0IHdpZHRoID0gZGltZW5zaW9ucyQxKHRoaXMubGlzdCkud2lkdGggLyAyIC0gZGltZW5zaW9ucyQxKG5leHQpLndpZHRoIC8gMjtcbiAgICAgICAgICBsZXQgaiA9IDA7XG5cbiAgICAgICAgICB3aGlsZSAod2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRJbmRleCgtLWogKyBpbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgc2xpZGUgPSB0aGlzLnNsaWRlc1tzbGlkZUluZGV4XTtcblxuICAgICAgICAgICAgY3NzKHNsaWRlLCAnb3JkZXInLCBzbGlkZUluZGV4ID4gaW5kZXggPyAtMiA6IC0xKTtcbiAgICAgICAgICAgIHdpZHRoIC09IGRpbWVuc2lvbnMkMShzbGlkZSkud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUFjdGl2ZUNsYXNzZXMoKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlcyA9IHRoaXMuX2dldFRyYW5zaXRpb25lcih0aGlzLmluZGV4KS5nZXRBY3RpdmVzKCk7XG4gICAgICAgICAgY29uc3QgYWN0aXZlQ2xhc3NlcyA9IFtcbiAgICAgICAgICB0aGlzLmNsc0FjdGl2ZSxcbiAgICAgICAgICAoIXRoaXMuc2V0cyB8fCBpbmNsdWRlcyh0aGlzLnNldHMsIHRvRmxvYXQodGhpcy5pbmRleCkpKSAmJiB0aGlzLmNsc0FjdGl2YXRlZCB8fFxuICAgICAgICAgICcnXTtcblxuICAgICAgICAgIGZvciAoY29uc3Qgc2xpZGUgb2YgdGhpcy5zbGlkZXMpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNsaWRlLCBhY3RpdmVDbGFzc2VzLCBpbmNsdWRlcyhhY3RpdmVzLCBzbGlkZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRWYWxpZEluZGV4KGluZGV4LCBwcmV2SW5kZXgpIHtpZiAoaW5kZXggPT09IHZvaWQgMCkge2luZGV4ID0gdGhpcy5pbmRleDt9aWYgKHByZXZJbmRleCA9PT0gdm9pZCAwKSB7cHJldkluZGV4ID0gdGhpcy5wcmV2SW5kZXg7fVxuICAgICAgICAgIGluZGV4ID0gdGhpcy5nZXRJbmRleChpbmRleCwgcHJldkluZGV4KTtcblxuICAgICAgICAgIGlmICghdGhpcy5zZXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHByZXY7XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5zZXRzLCBpbmRleCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2ID0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoaW5kZXggKyB0aGlzLmRpciwgcHJldkluZGV4KTtcbiAgICAgICAgICB9IHdoaWxlIChpbmRleCAhPT0gcHJldik7XG5cbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QWRqYWNlbnRTbGlkZXMoKSB7XG4gICAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gZGltZW5zaW9ucyQxKHRoaXMubGlzdCk7XG4gICAgICAgICAgY29uc3QgbGVmdCA9IC13aWR0aDtcbiAgICAgICAgICBjb25zdCByaWdodCA9IHdpZHRoICogMjtcbiAgICAgICAgICBjb25zdCBzbGlkZVdpZHRoID0gZGltZW5zaW9ucyQxKHRoaXMuc2xpZGVzW3RoaXMuaW5kZXhdKS53aWR0aDtcbiAgICAgICAgICBjb25zdCBzbGlkZUxlZnQgPSB0aGlzLmNlbnRlciA/IHdpZHRoIC8gMiAtIHNsaWRlV2lkdGggLyAyIDogMDtcbiAgICAgICAgICBjb25zdCBzbGlkZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgZm9yIChjb25zdCBpIG9mIFstMSwgMV0pIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGVmdCA9IHNsaWRlTGVmdCArIChpID4gMCA/IHNsaWRlV2lkdGggOiAwKTtcbiAgICAgICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2xpZGUgPSB0aGlzLnNsaWRlc1t0aGlzLmdldEluZGV4KHRoaXMuaW5kZXggKyBpICsgaisrICogaSldO1xuICAgICAgICAgICAgICBjdXJyZW50TGVmdCArPSBkaW1lbnNpb25zJDEoc2xpZGUpLndpZHRoICogaTtcbiAgICAgICAgICAgICAgc2xpZGVzLmFkZChzbGlkZSk7XG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLnNsaWRlcy5sZW5ndGggPiBqICYmIGN1cnJlbnRMZWZ0ID4gbGVmdCAmJiBjdXJyZW50TGVmdCA8IHJpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc2xpZGVzKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0TWF4RWxXaWR0aChsaXN0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgLi4uY2hpbGRyZW4obGlzdCkubWFwKChlbCkgPT4gZGltZW5zaW9ucyQxKGVsKS53aWR0aCkpO1xuICAgIH1cblxuICAgIHZhciBzbGlkZXJQYXJhbGxheCA9IHtcbiAgICAgIG1peGluczogW1BhcmFsbGF4XSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBzZWxJdGVtOiAnIWxpJyB9LFxuXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuaXRlbSA9IHF1ZXJ5KHRoaXMuc2VsSXRlbSwgdGhpcy4kZWwpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLml0ZW0gPSBudWxsO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpdGVtaW4gaXRlbW91dCcsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZikge2xldCB7IHR5cGUsIGRldGFpbDogeyBwZXJjZW50LCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSB9ID0gX3JlZjtcbiAgICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcHNGcm9tID0gdGhpcy5nZXRDc3MoZ2V0Q3VycmVudFBlcmNlbnQodHlwZSwgZGlyLCBwZXJjZW50KSk7XG4gICAgICAgICAgICBjb25zdCBwcm9wc1RvID0gdGhpcy5nZXRDc3MoaXNJbih0eXBlKSA/IDAuNSA6IGRpciA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICBmYXN0ZG9tLndyaXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCBwcm9wc0Zyb20pO1xuICAgICAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KHRoaXMuJGVsLCBwcm9wc1RvLCBkdXJhdGlvbiwgdGltaW5nKS5jYXRjaChub29wKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndHJhbnNpdGlvbmNhbmNlbGVkIHRyYW5zaXRpb25lbmQnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKHRoaXMuJGVsKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2l0ZW10cmFuc2xhdGVpbiBpdGVtdHJhbnNsYXRlb3V0JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmMikge2xldCB7IHR5cGUsIGRldGFpbDogeyBwZXJjZW50LCBkaXIgfSB9ID0gX3JlZjI7XG4gICAgICAgICAgZmFzdGRvbS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5nZXRDc3MoZ2V0Q3VycmVudFBlcmNlbnQodHlwZSwgZGlyLCBwZXJjZW50KSk7XG4gICAgICAgICAgICBmYXN0ZG9tLndyaXRlKCgpID0+IGNzcyh0aGlzLiRlbCwgcHJvcHMpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9XSB9O1xuXG5cblxuXG4gICAgZnVuY3Rpb24gaXNJbih0eXBlKSB7XG4gICAgICByZXR1cm4gZW5kc1dpdGgodHlwZSwgJ2luJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFBlcmNlbnQodHlwZSwgZGlyLCBwZXJjZW50KSB7XG4gICAgICBwZXJjZW50IC89IDI7XG5cbiAgICAgIHJldHVybiBpc0luKHR5cGUpIF4gZGlyIDwgMCA/IHBlcmNlbnQgOiAxIC0gcGVyY2VudDtcbiAgICB9XG5cbiAgICB2YXIgQW5pbWF0aW9ucyA9IHtcbiAgICAgIC4uLkFuaW1hdGlvbnMkMixcbiAgICAgIGZhZGU6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICByZXR1cm4gW3sgb3BhY2l0eTogMCwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIGNzcyhjdXJyZW50LCAnb3BhY2l0eScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDEgLSBwZXJjZW50LCB6SW5kZXg6IDAgfSwgeyB6SW5kZXg6IC0xIH1dO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgc2NhbGU6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICByZXR1cm4gW3sgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiBzY2FsZTNkKDEgKyAwLjUpLCB6SW5kZXg6IDAgfSwgeyB6SW5kZXg6IC0xIH1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiAxIC0gY3NzKGN1cnJlbnQsICdvcGFjaXR5Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgb3BhY2l0eTogMSAtIHBlcmNlbnQsIHRyYW5zZm9ybTogc2NhbGUzZCgxICsgMC41ICogcGVyY2VudCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgekluZGV4OiAtMSB9XTtcblxuICAgICAgICB9IH0sXG5cblxuICAgICAgcHVsbDoge1xuICAgICAgICBzaG93KGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID9cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgzMCksIHpJbmRleDogLTEgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKCksIHpJbmRleDogMCB9XSA6XG5cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTAwKSwgekluZGV4OiAwIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpLCB6SW5kZXg6IC0xIH1dO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyY2VudChjdXJyZW50LCBuZXh0LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IDEgLSB0cmFuc2xhdGVkKG5leHQpIDogdHJhbnNsYXRlZChjdXJyZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCwgZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgP1xuICAgICAgICAgIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDMwICogcGVyY2VudCksIHpJbmRleDogLTEgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC0xMDAgKiAoMSAtIHBlcmNlbnQpKSwgekluZGV4OiAwIH1dIDpcblxuICAgICAgICAgIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC1wZXJjZW50ICogMTAwKSwgekluZGV4OiAwIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgzMCAqICgxIC0gcGVyY2VudCkpLCB6SW5kZXg6IC0xIH1dO1xuXG4gICAgICAgIH0gfSxcblxuXG4gICAgICBwdXNoOiB7XG4gICAgICAgIHNob3coZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgP1xuICAgICAgICAgIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSwgekluZGV4OiAtMSB9XSA6XG5cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMzApLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpLCB6SW5kZXg6IDAgfV07XG5cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQsIG5leHQsIGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPiAwID8gMSAtIHRyYW5zbGF0ZWQobmV4dCkgOiB0cmFuc2xhdGVkKGN1cnJlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/XG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUocGVyY2VudCAqIDEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTMwICogKDEgLSBwZXJjZW50KSksIHpJbmRleDogLTEgfV0gOlxuXG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTMwICogcGVyY2VudCksIHpJbmRleDogLTEgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDEwMCAqICgxIC0gcGVyY2VudCkpLCB6SW5kZXg6IDAgfV07XG5cbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgc2xpZGVzaG93ID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIFNsaWRlc2hvdywgU2xpZGVyUmVhY3RpdmUsIFNsaWRlclByZWxvYWRdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICByYXRpbzogU3RyaW5nLFxuICAgICAgICBtaW5IZWlnaHQ6IE51bWJlcixcbiAgICAgICAgbWF4SGVpZ2h0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJhdGlvOiAnMTY6OScsXG4gICAgICAgIG1pbkhlaWdodDogZmFsc2UsXG4gICAgICAgIG1heEhlaWdodDogZmFsc2UsXG4gICAgICAgIHNlbExpc3Q6ICcudWstc2xpZGVzaG93LWl0ZW1zJyxcbiAgICAgICAgYXR0ckl0ZW06ICd1ay1zbGlkZXNob3ctaXRlbScsXG4gICAgICAgIHNlbE5hdjogJy51ay1zbGlkZXNob3ctbmF2JyxcbiAgICAgICAgQW5pbWF0aW9ucyB9LFxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICghdGhpcy5saXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucmF0aW8uc3BsaXQoJzonKS5tYXAoTnVtYmVyKTtcblxuICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAqIHRoaXMubGlzdC5vZmZzZXRXaWR0aCAvIHdpZHRoIHx8IDA7XG5cbiAgICAgICAgICBpZiAodGhpcy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KHRoaXMubWluSGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLm1heEhlaWdodCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgaGVpZ2h0OiBoZWlnaHQgLSBib3hNb2RlbEFkanVzdCh0aGlzLmxpc3QsICdoZWlnaHQnLCAnY29udGVudC1ib3gnKSB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYpIHtsZXQgeyBoZWlnaHQgfSA9IF9yZWY7XG4gICAgICAgICAgaGVpZ2h0ID4gMCAmJiBjc3ModGhpcy5saXN0LCAnbWluSGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldEFkamFjZW50U2xpZGVzKCkge1xuICAgICAgICAgIHJldHVybiBbMSwgLTFdLm1hcCgoaSkgPT4gdGhpcy5zbGlkZXNbdGhpcy5nZXRJbmRleCh0aGlzLmluZGV4ICsgaSldKTtcbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgc29ydGFibGUgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgQW5pbWF0ZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGdyb3VwOiBTdHJpbmcsXG4gICAgICAgIHRocmVzaG9sZDogTnVtYmVyLFxuICAgICAgICBjbHNJdGVtOiBTdHJpbmcsXG4gICAgICAgIGNsc1BsYWNlaG9sZGVyOiBTdHJpbmcsXG4gICAgICAgIGNsc0RyYWc6IFN0cmluZyxcbiAgICAgICAgY2xzRHJhZ1N0YXRlOiBTdHJpbmcsXG4gICAgICAgIGNsc0Jhc2U6IFN0cmluZyxcbiAgICAgICAgY2xzTm9EcmFnOiBTdHJpbmcsXG4gICAgICAgIGNsc0VtcHR5OiBTdHJpbmcsXG4gICAgICAgIGNsc0N1c3RvbTogU3RyaW5nLFxuICAgICAgICBoYW5kbGU6IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZ3JvdXA6IGZhbHNlLFxuICAgICAgICB0aHJlc2hvbGQ6IDUsXG4gICAgICAgIGNsc0l0ZW06ICd1ay1zb3J0YWJsZS1pdGVtJyxcbiAgICAgICAgY2xzUGxhY2Vob2xkZXI6ICd1ay1zb3J0YWJsZS1wbGFjZWhvbGRlcicsXG4gICAgICAgIGNsc0RyYWc6ICd1ay1zb3J0YWJsZS1kcmFnJyxcbiAgICAgICAgY2xzRHJhZ1N0YXRlOiAndWstZHJhZycsXG4gICAgICAgIGNsc0Jhc2U6ICd1ay1zb3J0YWJsZScsXG4gICAgICAgIGNsc05vRHJhZzogJ3VrLXNvcnRhYmxlLW5vZHJhZycsXG4gICAgICAgIGNsc0VtcHR5OiAndWstc29ydGFibGUtZW1wdHknLFxuICAgICAgICBjbHNDdXN0b206ICcnLFxuICAgICAgICBoYW5kbGU6IGZhbHNlLFxuICAgICAgICBwb3M6IHt9IH0sXG5cblxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgWydpbml0JywgJ3N0YXJ0JywgJ21vdmUnLCAnZW5kJ10pIHtcbiAgICAgICAgICBjb25zdCBmbiA9IHRoaXNba2V5XTtcbiAgICAgICAgICB0aGlzW2tleV0gPSAoZSkgPT4ge1xuICAgICAgICAgICAgYXNzaWduKHRoaXMucG9zLCBnZXRFdmVudFBvcyhlKSk7XG4gICAgICAgICAgICBmbihlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgbmFtZTogcG9pbnRlckRvd24sXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBoYW5kbGVyOiAnaW5pdCcgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICB0YXJnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLiRlbC50Qm9kaWVzIHx8IFt0aGlzLiRlbF0pWzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGl0ZW1zKCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbih0aGlzLnRhcmdldCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eToge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0VtcHR5KHRoaXMuaXRlbXMpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChlbXB0eSkge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy50YXJnZXQsIHRoaXMuY2xzRW1wdHksIGVtcHR5KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0sXG5cblxuICAgICAgICBoYW5kbGVzOiB7XG4gICAgICAgICAgZ2V0KF9yZWYsIGVsKSB7bGV0IHsgaGFuZGxlIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZSA/ICQkKGhhbmRsZSwgZWwpIDogdGhpcy5pdGVtcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goaGFuZGxlcywgcHJldikge1xuICAgICAgICAgICAgY3NzKHByZXYsIHsgdG91Y2hBY3Rpb246ICcnLCB1c2VyU2VsZWN0OiAnJyB9KTtcbiAgICAgICAgICAgIGNzcyhoYW5kbGVzLCB7IHRvdWNoQWN0aW9uOiBoYXNUb3VjaCA/ICdub25lJyA6ICcnLCB1c2VyU2VsZWN0OiAnbm9uZScgfSk7IC8vIHRvdWNoQWN0aW9uIHNldCB0byAnbm9uZScgY2F1c2VzIGEgcGVyZm9ybWFuY2UgZHJvcCBpbiBDaHJvbWUgODBcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0gfSxcblxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWcgfHwgIXBhcmVudCh0aGlzLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHBvczogeyB4LCB5IH0sXG4gICAgICAgICAgICBvcmlnaW46IHsgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0IH0sXG4gICAgICAgICAgICBwbGFjZWhvbGRlciB9ID1cbiAgICAgICAgICB0aGlzO1xuXG4gICAgICAgICAgY3NzKHRoaXMuZHJhZywge1xuICAgICAgICAgICAgdG9wOiB5IC0gb2Zmc2V0VG9wLFxuICAgICAgICAgICAgbGVmdDogeCAtIG9mZnNldExlZnQgfSk7XG5cblxuICAgICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5nZXRTb3J0YWJsZShkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpKTtcblxuICAgICAgICAgIGlmICghc29ydGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IGl0ZW1zIH0gPSBzb3J0YWJsZTtcblxuICAgICAgICAgIGlmIChpdGVtcy5zb21lKFRyYW5zaXRpb24uaW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBmaW5kVGFyZ2V0KGl0ZW1zLCB7IHgsIHkgfSk7XG5cbiAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoICYmICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gcGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLmdldFNvcnRhYmxlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICBjb25zdCBpbnNlcnRUYXJnZXQgPSBmaW5kSW5zZXJ0VGFyZ2V0KFxuICAgICAgICAgIHNvcnRhYmxlLnRhcmdldCxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHNvcnRhYmxlID09PSBwcmV2aW91cyAmJiBkYXRhLm1vdmVkICE9PSB0YXJnZXQpO1xuXG5cbiAgICAgICAgICBpZiAoaW5zZXJ0VGFyZ2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnNlcnRUYXJnZXQgJiYgcGxhY2Vob2xkZXIgPT09IGluc2VydFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzb3J0YWJsZSAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICAgIHByZXZpb3VzLnJlbW92ZShwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICBkYXRhLm1vdmVkID0gdGFyZ2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5tb3ZlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzb3J0YWJsZS5pbnNlcnQocGxhY2Vob2xkZXIsIGluc2VydFRhcmdldCk7XG5cbiAgICAgICAgICB0aGlzLnRvdWNoZWQuYWRkKHNvcnRhYmxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsnbW92ZSddIH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBpbml0KGUpIHtcbiAgICAgICAgICBjb25zdCB7IHRhcmdldCwgYnV0dG9uLCBkZWZhdWx0UHJldmVudGVkIH0gPSBlO1xuICAgICAgICAgIGNvbnN0IFtwbGFjZWhvbGRlcl0gPSB0aGlzLml0ZW1zLmZpbHRlcigoZWwpID0+IHdpdGhpbih0YXJnZXQsIGVsKSk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXBsYWNlaG9sZGVyIHx8XG4gICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCB8fFxuICAgICAgICAgIGJ1dHRvbiA+IDAgfHxcbiAgICAgICAgICBpc0lucHV0KHRhcmdldCkgfHxcbiAgICAgICAgICB3aXRoaW4odGFyZ2V0LCBcIi5cIiArIHRoaXMuY2xzTm9EcmFnKSB8fFxuICAgICAgICAgIHRoaXMuaGFuZGxlICYmICF3aXRoaW4odGFyZ2V0LCB0aGlzLmhhbmRsZSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHRoaXMudG91Y2hlZCA9IG5ldyBTZXQoW3RoaXNdKTtcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgdGhpcy5vcmlnaW4gPSB7IHRhcmdldCwgaW5kZXg6IGluZGV4KHBsYWNlaG9sZGVyKSwgLi4udGhpcy5wb3MgfTtcblxuICAgICAgICAgIG9uKGRvY3VtZW50LCBwb2ludGVyTW92ZSwgdGhpcy5tb3ZlKTtcbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlclVwLCB0aGlzLmVuZCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMudGhyZXNob2xkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydChlKSB7XG4gICAgICAgICAgdGhpcy5kcmFnID0gYXBwZW5kRHJhZyh0aGlzLiRjb250YWluZXIsIHRoaXMucGxhY2Vob2xkZXIpO1xuICAgICAgICAgIGNvbnN0IHsgbGVmdCwgdG9wIH0gPSB0aGlzLnBsYWNlaG9sZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGFzc2lnbih0aGlzLm9yaWdpbiwgeyBvZmZzZXRMZWZ0OiB0aGlzLnBvcy54IC0gbGVmdCwgb2Zmc2V0VG9wOiB0aGlzLnBvcy55IC0gdG9wIH0pO1xuXG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5kcmFnLCB0aGlzLmNsc0RyYWcsIHRoaXMuY2xzQ3VzdG9tKTtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLnBsYWNlaG9sZGVyLCB0aGlzLmNsc1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLml0ZW1zLCB0aGlzLmNsc0l0ZW0pO1xuICAgICAgICAgIGFkZENsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy5jbHNEcmFnU3RhdGUpO1xuXG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ3N0YXJ0JywgW3RoaXMsIHRoaXMucGxhY2Vob2xkZXJdKTtcblxuICAgICAgICAgIHRyYWNrU2Nyb2xsKHRoaXMucG9zKTtcblxuICAgICAgICAgIHRoaXMubW92ZShlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5kcmFnKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdtb3ZlJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBNYXRoLmFicyh0aGlzLnBvcy54IC0gdGhpcy5vcmlnaW4ueCkgPiB0aGlzLnRocmVzaG9sZCB8fFxuICAgICAgICAgIE1hdGguYWJzKHRoaXMucG9zLnkgLSB0aGlzLm9yaWdpbi55KSA+IHRoaXMudGhyZXNob2xkKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIHBvaW50ZXJNb3ZlLCB0aGlzLm1vdmUpO1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgcG9pbnRlclVwLCB0aGlzLmVuZCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZHJhZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVudHJhY2tTY3JvbGwoKTtcblxuICAgICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5nZXRTb3J0YWJsZSh0aGlzLnBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgIGlmICh0aGlzID09PSBzb3J0YWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luLmluZGV4ICE9PSBpbmRleCh0aGlzLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnbW92ZWQnLCBbdGhpcywgdGhpcy5wbGFjZWhvbGRlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmlnZ2VyKHNvcnRhYmxlLiRlbCwgJ2FkZGVkJywgW3NvcnRhYmxlLCB0aGlzLnBsYWNlaG9sZGVyXSk7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAncmVtb3ZlZCcsIFt0aGlzLCB0aGlzLnBsYWNlaG9sZGVyXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ3N0b3AnLCBbdGhpcywgdGhpcy5wbGFjZWhvbGRlcl0pO1xuXG4gICAgICAgICAgcmVtb3ZlJDEodGhpcy5kcmFnKTtcbiAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsO1xuXG4gICAgICAgICAgZm9yIChjb25zdCB7IGNsc1BsYWNlaG9sZGVyLCBjbHNJdGVtIH0gb2YgdGhpcy50b3VjaGVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNvcnRhYmxlIG9mIHRoaXMudG91Y2hlZCkge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzcyhzb3J0YWJsZS5pdGVtcywgY2xzUGxhY2Vob2xkZXIsIGNsc0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRvdWNoZWQgPSBudWxsO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy5jbHNEcmFnU3RhdGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluc2VydChlbGVtZW50LCB0YXJnZXQpIHtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLml0ZW1zLCB0aGlzLmNsc0l0ZW0pO1xuXG4gICAgICAgICAgY29uc3QgaW5zZXJ0ID0gKCkgPT4gdGFyZ2V0ID8gYmVmb3JlKHRhcmdldCwgZWxlbWVudCkgOiBhcHBlbmQodGhpcy50YXJnZXQsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgdGhpcy5hbmltYXRlKGluc2VydCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlKGVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoIXdpdGhpbihlbGVtZW50LCB0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmFuaW1hdGUoKCkgPT4gcmVtb3ZlJDEoZWxlbWVudCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNvcnRhYmxlKGVsZW1lbnQpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBzb3J0YWJsZSA9IHRoaXMuJGdldENvbXBvbmVudChlbGVtZW50LCAnc29ydGFibGUnKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc29ydGFibGUgJiYgKFxuICAgICAgICAgICAgc29ydGFibGUgPT09IHRoaXMgfHwgdGhpcy5ncm91cCAhPT0gZmFsc2UgJiYgc29ydGFibGUuZ3JvdXAgPT09IHRoaXMuZ3JvdXApKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm4gc29ydGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoZWxlbWVudCA9IHBhcmVudChlbGVtZW50KSk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGxldCB0cmFja1RpbWVyO1xuICAgIGZ1bmN0aW9uIHRyYWNrU2Nyb2xsKHBvcykge1xuICAgICAgbGV0IGxhc3QgPSBEYXRlLm5vdygpO1xuICAgICAgdHJhY2tUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgbGV0IHsgeCwgeSB9ID0gcG9zO1xuICAgICAgICB5ICs9IHNjcm9sbFRvcCh3aW5kb3cpO1xuXG4gICAgICAgIGNvbnN0IGRpc3QgPSAoRGF0ZS5ub3coKSAtIGxhc3QpICogMC4zO1xuICAgICAgICBsYXN0ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBzY3JvbGxQYXJlbnRzKGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgcG9zLnkpLCAvYXV0b3xzY3JvbGwvKS5cbiAgICAgICAgcmV2ZXJzZSgpLlxuICAgICAgICBzb21lKChzY3JvbGxFbCkgPT4ge1xuICAgICAgICAgIGxldCB7IHNjcm9sbFRvcDogc2Nyb2xsLCBzY3JvbGxIZWlnaHQgfSA9IHNjcm9sbEVsO1xuXG4gICAgICAgICAgY29uc3QgeyB0b3AsIGJvdHRvbSwgaGVpZ2h0IH0gPSBvZmZzZXQoZ2V0Vmlld3BvcnQkMShzY3JvbGxFbCkpO1xuXG4gICAgICAgICAgaWYgKHRvcCA8IHkgJiYgdG9wICsgMzUgPiB5KSB7XG4gICAgICAgICAgICBzY3JvbGwgLT0gZGlzdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJvdHRvbSA+IHkgJiYgYm90dG9tIC0gMzUgPCB5KSB7XG4gICAgICAgICAgICBzY3JvbGwgKz0gZGlzdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzY3JvbGwgPiAwICYmIHNjcm9sbCA8IHNjcm9sbEhlaWdodCAtIGhlaWdodCkge1xuICAgICAgICAgICAgc2Nyb2xsVG9wKHNjcm9sbEVsLCBzY3JvbGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIDE1KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRyYWNrU2Nyb2xsKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0cmFja1RpbWVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBlbmREcmFnKGNvbnRhaW5lciwgZWxlbWVudCkge1xuICAgICAgY29uc3QgY2xvbmUgPSBhcHBlbmQoXG4gICAgICBjb250YWluZXIsXG4gICAgICBlbGVtZW50Lm91dGVySFRNTC5yZXBsYWNlKC8oXjwpKD86bGl8dHIpfCg/OmxpfHRyKShcXC8+JCkvZywgJyQxZGl2JDInKSk7XG5cblxuICAgICAgY3NzKGNsb25lLCAnbWFyZ2luJywgJzAnLCAnaW1wb3J0YW50Jyk7XG4gICAgICBjc3MoY2xvbmUsIHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICBwYWRkaW5nOiBjc3MoZWxlbWVudCwgJ3BhZGRpbmcnKSB9KTtcblxuXG4gICAgICBoZWlnaHQoY2xvbmUuZmlyc3RFbGVtZW50Q2hpbGQsIGhlaWdodChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSk7XG5cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kVGFyZ2V0KGl0ZW1zLCBwb2ludCkge1xuICAgICAgcmV0dXJuIGl0ZW1zW2ZpbmRJbmRleChpdGVtcywgKGl0ZW0pID0+IHBvaW50SW5SZWN0KHBvaW50LCBpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRJbnNlcnRUYXJnZXQobGlzdCwgdGFyZ2V0LCBwbGFjZWhvbGRlciwgeCwgeSwgc2FtZUxpc3QpIHtcbiAgICAgIGlmICghY2hpbGRyZW4obGlzdCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICghc2FtZUxpc3QpIHtcbiAgICAgICAgaWYgKCFpc0hvcml6b250YWwobGlzdCwgcGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHkgPCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMiA/IHRhcmdldCA6IHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwbGFjZWhvbGRlclJlY3QgPSBwbGFjZWhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNhbWVSb3cgPSBsaW5lc0ludGVyc2VjdChcbiAgICAgIFtyZWN0LnRvcCwgcmVjdC5ib3R0b21dLFxuICAgICAgW3BsYWNlaG9sZGVyUmVjdC50b3AsIHBsYWNlaG9sZGVyUmVjdC5ib3R0b21dKTtcblxuXG4gICAgICBjb25zdCBwb2ludGVyUG9zID0gc2FtZVJvdyA/IHggOiB5O1xuICAgICAgY29uc3QgbGVuZ3RoUHJvcCA9IHNhbWVSb3cgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICBjb25zdCBzdGFydFByb3AgPSBzYW1lUm93ID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICBjb25zdCBlbmRQcm9wID0gc2FtZVJvdyA/ICdyaWdodCcgOiAnYm90dG9tJztcblxuICAgICAgY29uc3QgZGlmZiA9XG4gICAgICBwbGFjZWhvbGRlclJlY3RbbGVuZ3RoUHJvcF0gPCByZWN0W2xlbmd0aFByb3BdID9cbiAgICAgIHJlY3RbbGVuZ3RoUHJvcF0gLSBwbGFjZWhvbGRlclJlY3RbbGVuZ3RoUHJvcF0gOlxuICAgICAgMDtcblxuICAgICAgaWYgKHBsYWNlaG9sZGVyUmVjdFtzdGFydFByb3BdIDwgcmVjdFtzdGFydFByb3BdKSB7XG4gICAgICAgIGlmIChkaWZmICYmIHBvaW50ZXJQb3MgPCByZWN0W3N0YXJ0UHJvcF0gKyBkaWZmKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmICYmIHBvaW50ZXJQb3MgPiByZWN0W2VuZFByb3BdIC0gZGlmZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIb3Jpem9udGFsKGxpc3QsIHBsYWNlaG9sZGVyKSB7XG4gICAgICBjb25zdCBzaW5nbGUgPSBjaGlsZHJlbihsaXN0KS5sZW5ndGggPT09IDE7XG5cbiAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgYXBwZW5kKGxpc3QsIHBsYWNlaG9sZGVyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXRlbXMgPSBjaGlsZHJlbihsaXN0KTtcbiAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGl0ZW1zLnNvbWUoKGVsLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY3RBID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBpdGVtcy5zbGljZShpICsgMSkuc29tZSgoZWwpID0+IHtcbiAgICAgICAgICBjb25zdCByZWN0QiA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHJldHVybiAhbGluZXNJbnRlcnNlY3QoW3JlY3RBLmxlZnQsIHJlY3RBLnJpZ2h0XSwgW3JlY3RCLmxlZnQsIHJlY3RCLnJpZ2h0XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgcmVtb3ZlJDEocGxhY2Vob2xkZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNIb3Jpem9udGFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVzSW50ZXJzZWN0KGxpbmVBLCBsaW5lQikge1xuICAgICAgcmV0dXJuIGxpbmVBWzFdID4gbGluZUJbMF0gJiYgbGluZUJbMV0gPiBsaW5lQVswXTtcbiAgICB9XG5cbiAgICB2YXIgdG9vbHRpcCA9IHtcbiAgICAgIG1peGluczogW0NvbnRhaW5lciwgVG9nZ2xhYmxlLCBQb3NpdGlvbl0sXG5cbiAgICAgIGFyZ3M6ICd0aXRsZScsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRlbGF5OiBOdW1iZXIsXG4gICAgICAgIHRpdGxlOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBvczogJ3RvcCcsXG4gICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgIGFuaW1hdGlvbjogWyd1ay1hbmltYXRpb24tc2NhbGUtdXAnXSxcbiAgICAgICAgZHVyYXRpb246IDEwMCxcbiAgICAgICAgY2xzOiAndWstYWN0aXZlJyB9LFxuXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuX2hhc1RpdGxlID0gaGFzQXR0cih0aGlzLiRlbCwgJ3RpdGxlJyk7XG4gICAgICAgIGF0dHIodGhpcy4kZWwsICd0aXRsZScsICcnKTtcbiAgICAgICAgdGhpcy51cGRhdGVBcmlhKGZhbHNlKTtcbiAgICAgICAgbWFrZUZvY3VzYWJsZSh0aGlzLiRlbCk7XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICBhdHRyKHRoaXMuJGVsLCAndGl0bGUnLCB0aGlzLl9oYXNUaXRsZSA/IHRoaXMudGl0bGUgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQodGhpcy50b29sdGlwIHx8IG51bGwpIHx8ICF0aGlzLnRpdGxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fdW5iaW5kID0gb25jZShcbiAgICAgICAgICBkb2N1bWVudCwgXCJzaG93IGtleWRvd24gXCIgK1xuICAgICAgICAgIHBvaW50ZXJEb3duLFxuICAgICAgICAgIHRoaXMuaGlkZSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAoZSkgPT5cbiAgICAgICAgICBlLnR5cGUgPT09IHBvaW50ZXJEb3duICYmICF3aXRoaW4oZS50YXJnZXQsIHRoaXMuJGVsKSB8fFxuICAgICAgICAgIGUudHlwZSA9PT0gJ2tleWRvd24nICYmIGUua2V5Q29kZSA9PT0gMjcgfHxcbiAgICAgICAgICBlLnR5cGUgPT09ICdzaG93JyAmJiBlLmRldGFpbFswXSAhPT0gdGhpcyAmJiBlLmRldGFpbFswXS4kbmFtZSA9PT0gdGhpcy4kbmFtZSk7XG5cblxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lcik7XG4gICAgICAgICAgdGhpcy5zaG93VGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX3Nob3csIHRoaXMuZGVsYXkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFzeW5jIGhpZGUoKSB7XG4gICAgICAgICAgaWYgKG1hdGNoZXModGhpcy4kZWwsICdpbnB1dDpmb2N1cycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVyKTtcblxuICAgICAgICAgIGlmICghdGhpcy5pc1RvZ2dsZWQodGhpcy50b29sdGlwIHx8IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdGhpcy50b2dnbGVFbGVtZW50KHRoaXMudG9vbHRpcCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICByZW1vdmUkMSh0aGlzLnRvb2x0aXApO1xuICAgICAgICAgIHRoaXMudG9vbHRpcCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fdW5iaW5kKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Nob3coKSB7XG4gICAgICAgICAgdGhpcy50b29sdGlwID0gYXBwZW5kKFxuICAgICAgICAgIHRoaXMuY29udGFpbmVyLCBcIjxkaXYgY2xhc3M9XFxcInVrLVwiICtcbiAgICAgICAgICB0aGlzLiRvcHRpb25zLm5hbWUgKyBcIlxcXCI+IDxkaXYgY2xhc3M9XFxcInVrLVwiICtcbiAgICAgICAgICB0aGlzLiRvcHRpb25zLm5hbWUgKyBcIi1pbm5lclxcXCI+XCIgKyB0aGlzLnRpdGxlICsgXCI8L2Rpdj4gPC9kaXY+XCIpO1xuXG5cblxuICAgICAgICAgIG9uKHRoaXMudG9vbHRpcCwgJ3RvZ2dsZWQnLCAoZSwgdG9nZ2xlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBcmlhKHRvZ2dsZWQpO1xuXG4gICAgICAgICAgICBpZiAoIXRvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uQXQodGhpcy50b29sdGlwLCB0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgIHRoaXMub3JpZ2luID1cbiAgICAgICAgICAgIHRoaXMuZ2V0QXhpcygpID09PSAneScgP1xuICAgICAgICAgICAgZmxpcFBvc2l0aW9uKHRoaXMuZGlyKSArIFwiLVwiICsgdGhpcy5hbGlnbiA6XG4gICAgICAgICAgICB0aGlzLmFsaWduICsgXCItXCIgKyBmbGlwUG9zaXRpb24odGhpcy5kaXIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy50b2dnbGVFbGVtZW50KHRoaXMudG9vbHRpcCwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlQXJpYSh0b2dnbGVkKSB7XG4gICAgICAgICAgYXR0cih0aGlzLiRlbCwgJ2FyaWEtZXhwYW5kZWQnLCB0b2dnbGVkKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBmb2N1czogJ3Nob3cnLFxuICAgICAgICBibHVyOiAnaGlkZScsXG5cbiAgICAgICAgW3BvaW50ZXJFbnRlciArIFwiIFwiICsgcG9pbnRlckxlYXZlXShlKSB7XG4gICAgICAgICAgaWYgKCFpc1RvdWNoKGUpKSB7XG4gICAgICAgICAgICB0aGlzW2UudHlwZSA9PT0gcG9pbnRlckVudGVyID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDbGlja2luZyBhIGJ1dHRvbiBkb2VzIG5vdCBnaXZlIGl0IGZvY3VzIG9uIGFsbCBicm93c2VycyBhbmQgcGxhdGZvcm1zXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9idXR0b24jY2xpY2tpbmdfYW5kX2ZvY3VzXG4gICAgICAgIFtwb2ludGVyRG93bl0oZSkge1xuICAgICAgICAgIGlmIChpc1RvdWNoKGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIG1ha2VGb2N1c2FibGUoZWwpIHtcbiAgICAgIGlmICghaXNGb2N1c2FibGUoZWwpKSB7XG4gICAgICAgIGF0dHIoZWwsICd0YWJpbmRleCcsICcwJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVwbG9hZCA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGFsbG93OiBTdHJpbmcsXG4gICAgICAgIGNsc0RyYWdvdmVyOiBTdHJpbmcsXG4gICAgICAgIGNvbmN1cnJlbnQ6IE51bWJlcixcbiAgICAgICAgbWF4U2l6ZTogTnVtYmVyLFxuICAgICAgICBtZXRob2Q6IFN0cmluZyxcbiAgICAgICAgbWltZTogU3RyaW5nLFxuICAgICAgICBtc2dJbnZhbGlkTWltZTogU3RyaW5nLFxuICAgICAgICBtc2dJbnZhbGlkTmFtZTogU3RyaW5nLFxuICAgICAgICBtc2dJbnZhbGlkU2l6ZTogU3RyaW5nLFxuICAgICAgICBtdWx0aXBsZTogQm9vbGVhbixcbiAgICAgICAgbmFtZTogU3RyaW5nLFxuICAgICAgICBwYXJhbXM6IE9iamVjdCxcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB1cmw6IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYWxsb3c6IGZhbHNlLFxuICAgICAgICBjbHNEcmFnb3ZlcjogJ3VrLWRyYWdvdmVyJyxcbiAgICAgICAgY29uY3VycmVudDogMSxcbiAgICAgICAgbWF4U2l6ZTogMCxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIG1pbWU6IGZhbHNlLFxuICAgICAgICBtc2dJbnZhbGlkTWltZTogJ0ludmFsaWQgRmlsZSBUeXBlOiAlcycsXG4gICAgICAgIG1zZ0ludmFsaWROYW1lOiAnSW52YWxpZCBGaWxlIE5hbWU6ICVzJyxcbiAgICAgICAgbXNnSW52YWxpZFNpemU6ICdJbnZhbGlkIEZpbGUgU2l6ZTogJXMgS2lsb2J5dGVzIE1heCcsXG4gICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgbmFtZTogJ2ZpbGVzW10nLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICB0eXBlOiAnJyxcbiAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgYWJvcnQ6IG5vb3AsXG4gICAgICAgIGJlZm9yZUFsbDogbm9vcCxcbiAgICAgICAgYmVmb3JlU2VuZDogbm9vcCxcbiAgICAgICAgY29tcGxldGU6IG5vb3AsXG4gICAgICAgIGNvbXBsZXRlQWxsOiBub29wLFxuICAgICAgICBlcnJvcjogbm9vcCxcbiAgICAgICAgZmFpbDogbm9vcCxcbiAgICAgICAgbG9hZDogbm9vcCxcbiAgICAgICAgbG9hZEVuZDogbm9vcCxcbiAgICAgICAgbG9hZFN0YXJ0OiBub29wLFxuICAgICAgICBwcm9ncmVzczogbm9vcCB9LFxuXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBjaGFuZ2UoZSkge1xuICAgICAgICAgIGlmICghbWF0Y2hlcyhlLnRhcmdldCwgJ2lucHV0W3R5cGU9XCJmaWxlXCJdJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoZS50YXJnZXQuZmlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkKGUudGFyZ2V0LmZpbGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnRhcmdldC52YWx1ZSA9ICcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyb3AoZSkge1xuICAgICAgICAgIHN0b3AoZSk7XG5cbiAgICAgICAgICBjb25zdCB0cmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuXG4gICAgICAgICAgaWYgKCEodHJhbnNmZXIgIT0gbnVsbCAmJiB0cmFuc2Zlci5maWxlcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcmFnb3Zlcik7XG5cbiAgICAgICAgICB0aGlzLnVwbG9hZCh0cmFuc2Zlci5maWxlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJhZ2VudGVyKGUpIHtcbiAgICAgICAgICBzdG9wKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdvdmVyKGUpIHtcbiAgICAgICAgICBzdG9wKGUpO1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0RyYWdvdmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmFnbGVhdmUoZSkge1xuICAgICAgICAgIHN0b3AoZSk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRHJhZ292ZXIpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyB1cGxvYWQoZmlsZXMpIHtcbiAgICAgICAgICBmaWxlcyA9IHRvQXJyYXkoZmlsZXMpO1xuXG4gICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAndXBsb2FkJywgW2ZpbGVzXSk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heFNpemUgJiYgdGhpcy5tYXhTaXplICogMTAwMCA8IGZpbGUuc2l6ZSkge1xuICAgICAgICAgICAgICB0aGlzLmZhaWwodGhpcy5tc2dJbnZhbGlkU2l6ZS5yZXBsYWNlKCclcycsIHRoaXMubWF4U2l6ZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93ICYmICFtYXRjaCh0aGlzLmFsbG93LCBmaWxlLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmFpbCh0aGlzLm1zZ0ludmFsaWROYW1lLnJlcGxhY2UoJyVzJywgdGhpcy5hbGxvdykpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1pbWUgJiYgIW1hdGNoKHRoaXMubWltZSwgZmlsZS50eXBlKSkge1xuICAgICAgICAgICAgICB0aGlzLmZhaWwodGhpcy5tc2dJbnZhbGlkTWltZS5yZXBsYWNlKCclcycsIHRoaXMubWltZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICBmaWxlcyA9IGZpbGVzLnNsaWNlKDAsIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYmVmb3JlQWxsKHRoaXMsIGZpbGVzKTtcblxuICAgICAgICAgIGNvbnN0IGNodW5rcyA9IGNodW5rKGZpbGVzLCB0aGlzLmNvbmN1cnJlbnQpO1xuICAgICAgICAgIGNvbnN0IHVwbG9hZCA9IGFzeW5jIChmaWxlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiBkYXRhLmFwcGVuZCh0aGlzLm5hbWUsIGZpbGUpKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoa2V5LCB0aGlzLnBhcmFtc1trZXldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeGhyID0gYXdhaXQgYWpheCh0aGlzLnVybCwge1xuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICBiZWZvcmVTZW5kOiAoZW52KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB7IHhociB9ID0gZW52O1xuICAgICAgICAgICAgICAgICAgeGhyLnVwbG9hZCAmJiBvbih4aHIudXBsb2FkLCAncHJvZ3Jlc3MnLCB0aGlzLnByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ2xvYWRTdGFydCcsICdsb2FkJywgJ2xvYWRFbmQnLCAnYWJvcnQnXSkge1xuICAgICAgICAgICAgICAgICAgICBvbih4aHIsIHR5cGUudG9Mb3dlckNhc2UoKSwgdGhpc1t0eXBlXSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNlbmQoZW52KTtcbiAgICAgICAgICAgICAgICB9IH0pO1xuXG5cbiAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSh4aHIpO1xuXG4gICAgICAgICAgICAgIGlmIChjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXBsb2FkKGNodW5rcy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlQWxsKHhocik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgYXdhaXQgdXBsb2FkKGNodW5rcy5zaGlmdCgpKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gbWF0Y2gocGF0dGVybiwgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubWF0Y2goXG4gICAgICBuZXcgUmVnRXhwKFwiXlwiICtcbiAgICAgIHBhdHRlcm4uXG4gICAgICByZXBsYWNlKC9cXC8vZywgJ1xcXFwvJykuXG4gICAgICByZXBsYWNlKC9cXCpcXCovZywgJyhcXFxcL1teXFxcXC9dKykqJykuXG4gICAgICByZXBsYWNlKC9cXCovZywgJ1teXFxcXC9dKycpLlxuICAgICAgcmVwbGFjZSgvKCg/IVxcXFwpKVxcPy9nLCAnJDEuJykgKyBcIiRcIixcbiAgICAgICdpJykpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaHVuayhmaWxlcywgc2l6ZSkge1xuICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSArPSBzaXplKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKGZpbGVzLnNsaWNlKGksIGkgKyBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2h1bmtzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3AoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBDb3VudGRvd246IGNvdW50ZG93bixcbiAgICAgICAgRmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIExpZ2h0Ym94OiBsaWdodGJveCxcbiAgICAgICAgTGlnaHRib3hQYW5lbDogTGlnaHRib3hQYW5lbCxcbiAgICAgICAgTm90aWZpY2F0aW9uOiBub3RpZmljYXRpb24sXG4gICAgICAgIFBhcmFsbGF4OiBwYXJhbGxheCxcbiAgICAgICAgU2xpZGVyOiBzbGlkZXIsXG4gICAgICAgIFNsaWRlclBhcmFsbGF4OiBzbGlkZXJQYXJhbGxheCxcbiAgICAgICAgU2xpZGVzaG93OiBzbGlkZXNob3csXG4gICAgICAgIFNsaWRlc2hvd1BhcmFsbGF4OiBzbGlkZXJQYXJhbGxheCxcbiAgICAgICAgU29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICBUb29sdGlwOiB0b29sdGlwLFxuICAgICAgICBVcGxvYWQ6IHVwbG9hZFxuICAgIH0pO1xuXG4gICAgZWFjaChjb21wb25lbnRzLCAoY29tcG9uZW50LCBuYW1lKSA9PiBVSWtpdC5jb21wb25lbnQobmFtZSwgY29tcG9uZW50KSk7XG5cbiAgICByZXR1cm4gVUlraXQ7XG5cbn0pKTtcbiJdfQ==
