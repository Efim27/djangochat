(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const signin_1 = __importDefault(require("./blocks/signin"));
const signup_1 = __importDefault(require("./blocks/signup"));
exports.default = () => {
    new signin_1.default();
    new signup_1.default();
};
},{"./blocks/signin":3,"./blocks/signup":4}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PageBlock {
    constructor() {
        if (!this.init()) {
            return;
        }
        this.start();
    }
}
exports.default = PageBlock;
},{}],3:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PageBlock_1 = __importDefault(require("./PageBlock"));
class signin extends PageBlock_1.default {
    init() {
        if (document.querySelector('.signin')) {
            return true;
        }
        return false;
    }
    start() {
        const signinForm = document.querySelector(".signin__form");
        signinForm.addEventListener('submit', (event) => {
            event.preventDefault();
            //@ts-ignore
            const data = Object.fromEntries(new FormData(signinForm).entries());
            console.log(data);
        });
    }
}
exports.default = signin;
},{"./PageBlock":2}],4:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PageBlock_1 = __importDefault(require("./PageBlock"));
class signup extends PageBlock_1.default {
    init() {
        if (document.querySelector('.signup')) {
            return true;
        }
        return false;
    }
    start() {
        const signupForm = document.querySelector(".signup__form");
        signupForm.addEventListener('submit', (event) => {
            event.preventDefault();
            //@ts-ignore
            const data = Object.fromEntries(new FormData(signupForm).entries());
            console.log(data);
        });
    }
}
exports.default = signup;
},{"./PageBlock":2}],5:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const uikit_1 = __importDefault(require("./libs/uikit"));
exports.default = () => {
    (0, uikit_1.default)();
};
},{"./libs/uikit":6}],6:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const UIkit = __importStar(require("uikit"));
// @ts-ignore
const uikit_icons_1 = __importDefault(require("uikit/dist/js/uikit-icons"));
exports.default = () => {
    // @ts-ignore
    window.UIkit = UIkit;
    // @ts-ignore
    UIkit.use(uikit_icons_1.default);
};
},{"uikit":9,"uikit/dist/js/uikit-icons":8}],7:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const libs_1 = __importDefault(require("./libs"));
const blocks_1 = __importDefault(require("./blocks"));
const main = () => __awaiter(void 0, void 0, void 0, function* () {
    (0, libs_1.default)();
    (0, blocks_1.default)();
});
main();
},{"./blocks":1,"./libs":5}],8:[function(require,module,exports){
/*! UIkit 3.13.9 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define('uikiticons', factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.UIkitIcons = factory());
})(this, (function () { 'use strict';

    function plugin(UIkit) {
      if (plugin.installed) {
        return;
      }

      UIkit.icon.add({
        "500px": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.624,11.866c-0.141,0.132,0.479,0.658,0.662,0.418c0.051-0.046,0.607-0.61,0.662-0.664c0,0,0.738,0.719,0.814,0.719 c0.1,0,0.207-0.055,0.322-0.17c0.27-0.269,0.135-0.416,0.066-0.495l-0.631-0.616l0.658-0.668c0.146-0.156,0.021-0.314-0.1-0.449 c-0.182-0.18-0.359-0.226-0.471-0.125l-0.656,0.654l-0.654-0.654c-0.033-0.034-0.08-0.045-0.124-0.045 c-0.079,0-0.191,0.068-0.307,0.181c-0.202,0.202-0.247,0.351-0.133,0.462l0.665,0.665L9.624,11.866z\"/><path d=\"M11.066,2.884c-1.061,0-2.185,0.248-3.011,0.604c-0.087,0.034-0.141,0.106-0.15,0.205C7.893,3.784,7.919,3.909,7.982,4.066 c0.05,0.136,0.187,0.474,0.452,0.372c0.844-0.326,1.779-0.507,2.633-0.507c0.963,0,1.9,0.191,2.781,0.564 c0.695,0.292,1.357,0.719,2.078,1.34c0.051,0.044,0.105,0.068,0.164,0.068c0.143,0,0.273-0.137,0.389-0.271 c0.191-0.214,0.324-0.395,0.135-0.575c-0.686-0.654-1.436-1.138-2.363-1.533C13.24,3.097,12.168,2.884,11.066,2.884z\"/><path d=\"M16.43,15.747c-0.092-0.028-0.242,0.05-0.309,0.119l0,0c-0.652,0.652-1.42,1.169-2.268,1.521 c-0.877,0.371-1.814,0.551-2.779,0.551c-0.961,0-1.896-0.189-2.775-0.564c-0.848-0.36-1.612-0.879-2.268-1.53 c-0.682-0.688-1.196-1.455-1.529-2.268c-0.325-0.799-0.471-1.643-0.471-1.643c-0.045-0.24-0.258-0.249-0.567-0.203 c-0.128,0.021-0.519,0.079-0.483,0.36v0.01c0.105,0.644,0.289,1.284,0.545,1.895c0.417,0.969,1.002,1.849,1.756,2.604 c0.757,0.754,1.636,1.34,2.604,1.757C8.901,18.785,9.97,19,11.088,19c1.104,0,2.186-0.215,3.188-0.645 c1.838-0.896,2.604-1.757,2.604-1.757c0.182-0.204,0.227-0.317-0.1-0.643C16.779,15.956,16.525,15.774,16.43,15.747z\"/><path d=\"M5.633,13.287c0.293,0.71,0.723,1.341,1.262,1.882c0.54,0.54,1.172,0.971,1.882,1.264c0.731,0.303,1.509,0.461,2.298,0.461 c0.801,0,1.578-0.158,2.297-0.461c0.711-0.293,1.344-0.724,1.883-1.264c0.543-0.541,0.971-1.172,1.264-1.882 c0.314-0.721,0.463-1.5,0.463-2.298c0-0.79-0.148-1.569-0.463-2.289c-0.293-0.699-0.721-1.329-1.264-1.881 c-0.539-0.541-1.172-0.959-1.867-1.263c-0.721-0.303-1.5-0.461-2.299-0.461c-0.802,0-1.613,0.159-2.322,0.461 c-0.577,0.25-1.544,0.867-2.119,1.454v0.012V2.108h8.16C15.1,2.104,15.1,1.69,15.1,1.552C15.1,1.417,15.1,1,14.809,1H5.915 C5.676,1,5.527,1.192,5.527,1.384v6.84c0,0.214,0.273,0.372,0.529,0.428c0.5,0.105,0.614-0.056,0.737-0.224l0,0 c0.18-0.273,0.776-0.884,0.787-0.894c0.901-0.905,2.117-1.408,3.416-1.408c1.285,0,2.5,0.501,3.412,1.408 c0.914,0.914,1.408,2.122,1.408,3.405c0,1.288-0.508,2.496-1.408,3.405c-0.9,0.896-2.152,1.406-3.438,1.406 c-0.877,0-1.711-0.229-2.433-0.671v-4.158c0-0.553,0.237-1.151,0.643-1.614c0.462-0.519,1.094-0.799,1.782-0.799 c0.664,0,1.293,0.253,1.758,0.715c0.459,0.459,0.709,1.071,0.709,1.723c0,1.385-1.094,2.468-2.488,2.468 c-0.273,0-0.769-0.121-0.781-0.125c-0.281-0.087-0.405,0.306-0.438,0.436c-0.159,0.496,0.079,0.585,0.123,0.607 c0.452,0.137,0.743,0.157,1.129,0.157c1.973,0,3.572-1.6,3.572-3.57c0-1.964-1.6-3.552-3.572-3.552c-0.97,0-1.872,0.36-2.546,1.038 c-0.656,0.631-1.027,1.487-1.027,2.322v3.438v-0.011c-0.372-0.42-0.732-1.041-0.981-1.682c-0.102-0.248-0.315-0.202-0.607-0.113 c-0.135,0.035-0.519,0.157-0.44,0.439C5.372,12.799,5.577,13.164,5.633,13.287z\"/></svg>",
        "album": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"5\" y=\"2\" width=\"10\" height=\"1\"/><rect x=\"3\" y=\"4\" width=\"14\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"6.5\" width=\"17\" height=\"11\"/></svg>",
        "arrow-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10.5,16.08 5.63,10.66 6.37,10 10.5,14.58 14.63,10 15.37,10.66\"/><line fill=\"none\" stroke=\"#000\" x1=\"10.5\" y1=\"4\" x2=\"10.5\" y2=\"15\"/></svg>",
        "arrow-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"10 14 5 9.5 10 5\"/><line fill=\"none\" stroke=\"#000\" x1=\"16\" y1=\"9.5\" x2=\"5\" y2=\"9.52\"/></svg>",
        "arrow-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"10 5 15 9.5 10 14\"/><line fill=\"none\" stroke=\"#000\" x1=\"4\" y1=\"9.5\" x2=\"15\" y2=\"9.5\"/></svg>",
        "arrow-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10.5,4 15.37,9.4 14.63,10.08 10.5,5.49 6.37,10.08 5.63,9.4\"/><line fill=\"none\" stroke=\"#000\" x1=\"10.5\" y1=\"16\" x2=\"10.5\" y2=\"5\"/></svg>",
        "bag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M7.5,7.5V4A2.48,2.48,0,0,1,10,1.5,2.54,2.54,0,0,1,12.5,4V7.5\"/><polygon fill=\"none\" stroke=\"#000\" points=\"16.5 7.5 3.5 7.5 2.5 18.5 17.5 18.5 16.5 7.5\"/></svg>",
        "ban": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"4\" y1=\"3.5\" x2=\"16\" y2=\"16.5\"/></svg>",
        "behance": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.5,10.6c-0.4-0.5-0.9-0.9-1.6-1.1c1.7-1,2.2-3.2,0.7-4.7C7.8,4,6.3,4,5.2,4C3.5,4,1.7,4,0,4v12c1.7,0,3.4,0,5.2,0 c1,0,2.1,0,3.1-0.5C10.2,14.6,10.5,12.3,9.5,10.6L9.5,10.6z M5.6,6.1c1.8,0,1.8,2.7-0.1,2.7c-1,0-2,0-2.9,0V6.1H5.6z M2.6,13.8v-3.1 c1.1,0,2.1,0,3.2,0c2.1,0,2.1,3.2,0.1,3.2L2.6,13.8z\"/><path d=\"M19.9,10.9C19.7,9.2,18.7,7.6,17,7c-4.2-1.3-7.3,3.4-5.3,7.1c0.9,1.7,2.8,2.3,4.7,2.1c1.7-0.2,2.9-1.3,3.4-2.9h-2.2 c-0.4,1.3-2.4,1.5-3.5,0.6c-0.4-0.4-0.6-1.1-0.6-1.7H20C20,11.7,19.9,10.9,19.9,10.9z M13.5,10.6c0-1.6,2.3-2.7,3.5-1.4 c0.4,0.4,0.5,0.9,0.6,1.4H13.5L13.5,10.6z\"/><rect x=\"13\" y=\"4\" width=\"5\" height=\"1.4\"/></svg>",
        "bell": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17,15.5 L3,15.5 C2.99,14.61 3.79,13.34 4.1,12.51 C4.58,11.3 4.72,10.35 5.19,7.01 C5.54,4.53 5.89,3.2 7.28,2.16 C8.13,1.56 9.37,1.5 9.81,1.5 L9.96,1.5 C9.96,1.5 11.62,1.41 12.67,2.17 C14.08,3.2 14.42,4.54 14.77,7.02 C15.26,10.35 15.4,11.31 15.87,12.52 C16.2,13.34 17.01,14.61 17,15.5 L17,15.5 Z\"/><path fill=\"none\" stroke=\"#000\" d=\"M12.39,16 C12.39,17.37 11.35,18.43 9.91,18.43 C8.48,18.43 7.42,17.37 7.42,16\"/></svg>",
        "bold": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5,15.3 C5.66,15.3 5.9,15 5.9,14.53 L5.9,5.5 C5.9,4.92 5.56,4.7 5,4.7 L5,4 L8.95,4 C12.6,4 13.7,5.37 13.7,6.9 C13.7,7.87 13.14,9.17 10.86,9.59 L10.86,9.7 C13.25,9.86 14.29,11.28 14.3,12.54 C14.3,14.47 12.94,16 9,16 L5,16 L5,15.3 Z M9,9.3 C11.19,9.3 11.8,8.5 11.85,7 C11.85,5.65 11.3,4.8 9,4.8 L7.67,4.8 L7.67,9.3 L9,9.3 Z M9.185,15.22 C11.97,15 12.39,14 12.4,12.58 C12.4,11.15 11.39,10 9,10 L7.67,10 L7.67,15 L9.18,15 Z\"/></svg>",
        "bolt": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.74,20 L7.73,12 L3,12 L15.43,1 L12.32,9 L17.02,9 L4.74,20 L4.74,20 L4.74,20 Z M9.18,11 L7.1,16.39 L14.47,10 L10.86,10 L12.99,4.67 L5.61,11 L9.18,11 L9.18,11 L9.18,11 Z\"/></svg>",
        "bookmark": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"5.5 1.5 15.5 1.5 15.5 17.5 10.5 12.5 5.5 17.5\"/></svg>",
        "calendar": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M 2,3 2,17 18,17 18,3 2,3 Z M 17,16 3,16 3,8 17,8 17,16 Z M 17,7 3,7 3,4 17,4 17,7 Z\"/><rect width=\"1\" height=\"3\" x=\"6\" y=\"2\"/><rect width=\"1\" height=\"3\" x=\"13\" y=\"2\"/></svg>",
        "camera": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10.8\" r=\"3.8\"/><path fill=\"none\" stroke=\"#000\" d=\"M1,4.5 C0.7,4.5 0.5,4.7 0.5,5 L0.5,17 C0.5,17.3 0.7,17.5 1,17.5 L19,17.5 C19.3,17.5 19.5,17.3 19.5,17 L19.5,5 C19.5,4.7 19.3,4.5 19,4.5 L13.5,4.5 L13.5,2.9 C13.5,2.6 13.3,2.5 13,2.5 L7,2.5 C6.7,2.5 6.5,2.6 6.5,2.9 L6.5,4.5 L1,4.5 L1,4.5 Z\"/></svg>",
        "cart": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"7.3\" cy=\"17.3\" r=\"1.4\"/><circle cx=\"13.3\" cy=\"17.3\" r=\"1.4\"/><polyline fill=\"none\" stroke=\"#000\" points=\"0 2 3.2 4 5.3 12.5 16 12.5 18 6.5 8 6.5\"/></svg>",
        "check": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"4,10 8,15 17,4\"/></svg>",
        "chevron-double-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"10 14 6 10 10 6\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"14 14 10 10 14 6\"/></svg>",
        "chevron-double-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"10 6 14 10 10 14\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"6 6 10 10 6 14\"/></svg>",
        "chevron-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"16 7 10 13 4 7\"/></svg>",
        "chevron-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"13 16 7 10 13 4\"/></svg>",
        "chevron-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"7 4 13 10 7 16\"/></svg>",
        "chevron-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"4 13 10 7 16 13\"/></svg>",
        "clock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.018,14.197 L9.445,10.625\"/></svg>",
        "close": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.06\" d=\"M16,16 L4,4\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.06\" d=\"M16,4 L4,16\"/></svg>",
        "cloud-download": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.3,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\"/><polyline fill=\"none\" stroke=\"#000\" points=\"11.75 16 9.5 18.25 7.25 16\"/><path fill=\"none\" stroke=\"#000\" d=\"M9.5,18 L9.5,9.5\"/></svg>",
        "cloud-upload": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.31,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\"/><polyline fill=\"none\" stroke=\"#000\" points=\"7.25 11.75 9.5 9.5 11.75 11.75\"/><path fill=\"none\" stroke=\"#000\" d=\"M9.5,18 L9.5,9.5\"/></svg>",
        "code": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"13,4 19,10 13,16\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"7,4 1,10 7,16\"/></svg>",
        "cog": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"9.997\" cy=\"10\" r=\"3.31\"/><path fill=\"none\" stroke=\"#000\" d=\"M18.488,12.285 L16.205,16.237 C15.322,15.496 14.185,15.281 13.303,15.791 C12.428,16.289 12.047,17.373 12.246,18.5 L7.735,18.5 C7.938,17.374 7.553,16.299 6.684,15.791 C5.801,15.27 4.655,15.492 3.773,16.237 L1.5,12.285 C2.573,11.871 3.317,10.999 3.317,9.991 C3.305,8.98 2.573,8.121 1.5,7.716 L3.765,3.784 C4.645,4.516 5.794,4.738 6.687,4.232 C7.555,3.722 7.939,2.637 7.735,1.5 L12.263,1.5 C12.072,2.637 12.441,3.71 13.314,4.22 C14.206,4.73 15.343,4.516 16.225,3.794 L18.487,7.714 C17.404,8.117 16.661,8.988 16.67,10.009 C16.672,11.018 17.415,11.88 18.488,12.285 L18.488,12.285 Z\"/></svg>",
        "comment": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6,18.71 L6,14 L1,14 L1,1 L19,1 L19,14 L10.71,14 L6,18.71 L6,18.71 Z M2,13 L7,13 L7,16.29 L10.29,13 L18,13 L18,2 L2,2 L2,13 L2,13 Z\"/></svg>",
        "commenting": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"1.5,1.5 18.5,1.5 18.5,13.5 10.5,13.5 6.5,17.5 6.5,13.5 1.5,13.5\"/><circle cx=\"10\" cy=\"8\" r=\"1\"/><circle cx=\"6\" cy=\"8\" r=\"1\"/><circle cx=\"14\" cy=\"8\" r=\"1\"/></svg>",
        "comments": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"2 0.5 19.5 0.5 19.5 13\"/><path d=\"M5,19.71 L5,15 L0,15 L0,2 L18,2 L18,15 L9.71,15 L5,19.71 L5,19.71 L5,19.71 Z M1,14 L6,14 L6,17.29 L9.29,14 L17,14 L17,3 L1,3 L1,14 L1,14 L1,14 Z\"/></svg>",
        "copy": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"2.5\" width=\"12\" height=\"16\"/><polyline fill=\"none\" stroke=\"#000\" points=\"5 0.5 17.5 0.5 17.5 17\"/></svg>",
        "credit-card": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"4.5\" width=\"17\" height=\"12\"/><rect x=\"1\" y=\"7\" width=\"18\" height=\"3\"/></svg>",
        "database": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><ellipse fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"4.64\" rx=\"7.5\" ry=\"3.14\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.5,8.11 C17.5,9.85 14.14,11.25 10,11.25 C5.86,11.25 2.5,9.84 2.5,8.11\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.5,11.25 C17.5,12.99 14.14,14.39 10,14.39 C5.86,14.39 2.5,12.98 2.5,11.25\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.49,4.64 L17.5,14.36 C17.5,16.1 14.14,17.5 10,17.5 C5.86,17.5 2.5,16.09 2.5,14.36 L2.5,4.64\"/></svg>",
        "desktop": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"8\" y=\"15\" width=\"1\" height=\"2\"/><rect x=\"11\" y=\"15\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"16\" width=\"10\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"3.5\" width=\"17\" height=\"11\"/></svg>",
        "discord": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path d=\"M16.074,4.361a14.243,14.243,0,0,0-3.61-1.134,10.61,10.61,0,0,0-.463.96,13.219,13.219,0,0,0-4,0,10.138,10.138,0,0,0-.468-.96A14.206,14.206,0,0,0,3.919,4.364,15.146,15.146,0,0,0,1.324,14.5a14.435,14.435,0,0,0,4.428,2.269A10.982,10.982,0,0,0,6.7,15.21a9.294,9.294,0,0,1-1.494-.727c.125-.093.248-.19.366-.289a10.212,10.212,0,0,0,8.854,0c.119.1.242.2.366.289a9.274,9.274,0,0,1-1.5.728,10.8,10.8,0,0,0,.948,1.562,14.419,14.419,0,0,0,4.431-2.27A15.128,15.128,0,0,0,16.074,4.361Zm-8.981,8.1a1.7,1.7,0,0,1-1.573-1.79A1.689,1.689,0,0,1,7.093,8.881a1.679,1.679,0,0,1,1.573,1.791A1.687,1.687,0,0,1,7.093,12.462Zm5.814,0a1.7,1.7,0,0,1-1.573-1.79,1.689,1.689,0,0,1,1.573-1.791,1.679,1.679,0,0,1,1.573,1.791A1.688,1.688,0,0,1,12.907,12.462Z\"/></svg>",
        "download": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"14,10 9.5,14.5 5,10\"/><rect x=\"3\" y=\"17\" width=\"13\" height=\"1\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"13.91\" x2=\"9.5\" y2=\"3\"/></svg>",
        "dribbble": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M1.3,8.9c0,0,5,0.1,8.6-1c1.4-0.4,2.6-0.9,4-1.9 c1.4-1.1,2.5-2.5,2.5-2.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M3.9,16.6c0,0,1.7-2.8,3.5-4.2 c1.8-1.3,4-2,5.7-2.2C16,10,19,10.6,19,10.6\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M6.9,1.6c0,0,3.3,4.6,4.2,6.8 c0.4,0.9,1.3,3.1,1.9,5.2c0.6,2,0.9,4.4,0.9,4.4\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
        "etsy": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path d=\"M8,4.26C8,4.07,8,4,8.31,4h4.46c.79,0,1.22.67,1.53,1.91l.25,1h.76c.14-2.82.26-4,.26-4S13.65,3,12.52,3H6.81L3.75,2.92v.84l1,.2c.73.11.9.27,1,1,0,0,.06,2,.06,5.17s-.06,5.14-.06,5.14c0,.59-.23.81-1,.94l-1,.2v.84l3.06-.1h5.11c1.15,0,3.82.1,3.82.1,0-.7.45-3.88.51-4.22h-.73l-.76,1.69a2.25,2.25,0,0,1-2.45,1.47H9.4c-1,0-1.44-.4-1.44-1.24V10.44s2.16,0,2.86.06c.55,0,.85.19,1.06,1l.23,1H13L12.9,9.94,13,7.41h-.85l-.28,1.13c-.16.74-.28.84-1,1-1,.1-2.89.09-2.89.09Z\"/></svg>",
        "expand": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"13 2 18 2 18 7 17 7 17 3 13 3\"/><polygon points=\"2 13 3 13 3 17 7 17 7 18 2 18\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M11,9 L17,3\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M3,17 L9,11\"/></svg>",
        "facebook": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11,10h2.6l0.4-3H11V5.3c0-0.9,0.2-1.5,1.5-1.5H14V1.1c-0.3,0-1-0.1-2.1-0.1C9.6,1,8,2.4,8,5v2H5.5v3H8v8h3V10z\"/></svg>",
        "file-edit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M18.65,1.68 C18.41,1.45 18.109,1.33 17.81,1.33 C17.499,1.33 17.209,1.45 16.98,1.68 L8.92,9.76 L8,12.33 L10.55,11.41 L18.651,3.34 C19.12,2.87 19.12,2.15 18.65,1.68 L18.65,1.68 L18.65,1.68 Z\"/><polyline fill=\"none\" stroke=\"#000\" points=\"16.5 8.482 16.5 18.5 3.5 18.5 3.5 1.5 14.211 1.5\"/></svg>",
        "file-pdf": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" width=\"13\" height=\"17\" x=\"3.5\" y=\"1.5\"/><path d=\"M14.65 11.67c-.48.3-1.37-.19-1.79-.37a4.65 4.65 0 0 1 1.49.06c.35.1.36.28.3.31zm-6.3.06l.43-.79a14.7 14.7 0 0 0 .75-1.64 5.48 5.48 0 0 0 1.25 1.55l.2.15a16.36 16.36 0 0 0-2.63.73zM9.5 5.32c.2 0 .32.5.32.97a1.99 1.99 0 0 1-.23 1.04 5.05 5.05 0 0 1-.17-1.3s0-.71.08-.71zm-3.9 9a4.35 4.35 0 0 1 1.21-1.46l.24-.22a4.35 4.35 0 0 1-1.46 1.68zm9.23-3.3a2.05 2.05 0 0 0-1.32-.3 11.07 11.07 0 0 0-1.58.11 4.09 4.09 0 0 1-.74-.5 5.39 5.39 0 0 1-1.32-2.06 10.37 10.37 0 0 0 .28-2.62 1.83 1.83 0 0 0-.07-.25.57.57 0 0 0-.52-.4H9.4a.59.59 0 0 0-.6.38 6.95 6.95 0 0 0 .37 3.14c-.26.63-1 2.12-1 2.12-.3.58-.57 1.08-.82 1.5l-.8.44A3.11 3.11 0 0 0 5 14.16a.39.39 0 0 0 .15.42l.24.13c1.15.56 2.28-1.74 2.66-2.42a23.1 23.1 0 0 1 3.59-.85 4.56 4.56 0 0 0 2.91.8.5.5 0 0 0 .3-.21 1.1 1.1 0 0 0 .12-.75.84.84 0 0 0-.14-.25z\"/></svg>",
        "file-text": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" width=\"13\" height=\"17\" x=\"3.5\" y=\"1.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"12\" y1=\"12.5\" y2=\"12.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"8.5\" y2=\"8.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"6.5\" y2=\"6.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"10.5\" y2=\"10.5\"/></svg>",
        "file": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"1.5\" width=\"13\" height=\"17\"/></svg>",
        "flickr": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"5.5\" cy=\"9.5\" r=\"3.5\"/><circle cx=\"14.5\" cy=\"9.5\" r=\"3.5\"/></svg>",
        "folder": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"9.5 5.5 8.5 3.5 1.5 3.5 1.5 16.5 18.5 16.5 18.5 5.5\"/></svg>",
        "forward": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.47,13.11 C4.02,10.02 6.27,7.85 9.04,6.61 C9.48,6.41 10.27,6.13 11,5.91 L11,2 L18.89,9 L11,16 L11,12.13 C9.25,12.47 7.58,13.19 6.02,14.25 C3.03,16.28 1.63,18.54 1.63,18.54 C1.63,18.54 1.38,15.28 2.47,13.11 L2.47,13.11 Z M5.3,13.53 C6.92,12.4 9.04,11.4 12,10.92 L12,13.63 L17.36,9 L12,4.25 L12,6.8 C11.71,6.86 10.86,7.02 9.67,7.49 C6.79,8.65 4.58,10.96 3.49,13.08 C3.18,13.7 2.68,14.87 2.49,16 C3.28,15.05 4.4,14.15 5.3,13.53 L5.3,13.53 Z\"/></svg>",
        "foursquare": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.23,2 C15.96,2 16.4,2.41 16.5,2.86 C16.57,3.15 16.56,3.44 16.51,3.73 C16.46,4.04 14.86,11.72 14.75,12.03 C14.56,12.56 14.16,12.82 13.61,12.83 C13.03,12.84 11.09,12.51 10.69,13 C10.38,13.38 7.79,16.39 6.81,17.53 C6.61,17.76 6.4,17.96 6.08,17.99 C5.68,18.04 5.29,17.87 5.17,17.45 C5.12,17.28 5.1,17.09 5.1,16.91 C5.1,12.4 4.86,7.81 5.11,3.31 C5.17,2.5 5.81,2.12 6.53,2 L15.23,2 L15.23,2 Z M9.76,11.42 C9.94,11.19 10.17,11.1 10.45,11.1 L12.86,11.1 C13.12,11.1 13.31,10.94 13.36,10.69 C13.37,10.64 13.62,9.41 13.74,8.83 C13.81,8.52 13.53,8.28 13.27,8.28 C12.35,8.29 11.42,8.28 10.5,8.28 C9.84,8.28 9.83,7.69 9.82,7.21 C9.8,6.85 10.13,6.55 10.5,6.55 C11.59,6.56 12.67,6.55 13.76,6.55 C14.03,6.55 14.23,6.4 14.28,6.14 C14.34,5.87 14.67,4.29 14.67,4.29 C14.67,4.29 14.82,3.74 14.19,3.74 L7.34,3.74 C7,3.75 6.84,4.02 6.84,4.33 C6.84,7.58 6.85,14.95 6.85,14.99 C6.87,15 8.89,12.51 9.76,11.42 L9.76,11.42 Z\"/></svg>",
        "future": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"19 2 18 2 18 6 14 6 14 7 19 7 19 2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M18,6.548 C16.709,3.29 13.354,1 9.6,1 C4.6,1 0.6,5 0.6,10 C0.6,15 4.6,19 9.6,19 C14.6,19 18.6,15 18.6,10\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path d=\"M13.018,14.197 L9.445,10.625\" fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\"/></svg>",
        "git-branch": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"7\" cy=\"3\" r=\"2\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"14\" cy=\"6\" r=\"2\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"7\" cy=\"17\" r=\"2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"2\" d=\"M14,8 C14,10.41 12.43,10.87 10.56,11.25 C9.09,11.54 7,12.06 7,15 L7,5\"/></svg>",
        "git-fork": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"5.79\" cy=\"2.79\" r=\"1.79\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"14.19\" cy=\"2.79\" r=\"1.79\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"10.03\" cy=\"16.79\" r=\"1.79\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"2\" d=\"M5.79,4.57 L5.79,6.56 C5.79,9.19 10.03,10.22 10.03,13.31 C10.03,14.86 10.04,14.55 10.04,14.55 C10.04,14.37 10.04,14.86 10.04,13.31 C10.04,10.22 14.2,9.19 14.2,6.56 L14.2,4.57\"/></svg>",
        "github-alt": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5 C4.75,0.5 0.5,4.76 0.5,10.01 C0.5,15.26 4.75,19.51 10,19.51 C15.24,19.51 19.5,15.26 19.5,10.01 C19.5,4.76 15.25,0.5 10,0.5 L10,0.5 Z M12.81,17.69 C12.81,17.69 12.81,17.7 12.79,17.69 C12.47,17.75 12.35,17.59 12.35,17.36 L12.35,16.17 C12.35,15.45 12.09,14.92 11.58,14.56 C12.2,14.51 12.77,14.39 13.26,14.21 C13.87,13.98 14.36,13.69 14.74,13.29 C15.42,12.59 15.76,11.55 15.76,10.17 C15.76,9.25 15.45,8.46 14.83,7.8 C15.1,7.08 15.07,6.29 14.75,5.44 L14.51,5.42 C14.34,5.4 14.06,5.46 13.67,5.61 C13.25,5.78 12.79,6.03 12.31,6.35 C11.55,6.16 10.81,6.05 10.09,6.05 C9.36,6.05 8.61,6.15 7.88,6.35 C7.28,5.96 6.75,5.68 6.26,5.54 C6.07,5.47 5.9,5.44 5.78,5.44 L5.42,5.44 C5.06,6.29 5.04,7.08 5.32,7.8 C4.7,8.46 4.4,9.25 4.4,10.17 C4.4,11.94 4.96,13.16 6.08,13.84 C6.53,14.13 7.05,14.32 7.69,14.43 C8.03,14.5 8.32,14.54 8.55,14.55 C8.07,14.89 7.82,15.42 7.82,16.16 L7.82,17.51 C7.8,17.69 7.7,17.8 7.51,17.8 C4.21,16.74 1.82,13.65 1.82,10.01 C1.82,5.5 5.49,1.83 10,1.83 C14.5,1.83 18.17,5.5 18.17,10.01 C18.18,13.53 15.94,16.54 12.81,17.69 L12.81,17.69 Z\"/></svg>",
        "github": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,1 C5.03,1 1,5.03 1,10 C1,13.98 3.58,17.35 7.16,18.54 C7.61,18.62 7.77,18.34 7.77,18.11 C7.77,17.9 7.76,17.33 7.76,16.58 C5.26,17.12 4.73,15.37 4.73,15.37 C4.32,14.33 3.73,14.05 3.73,14.05 C2.91,13.5 3.79,13.5 3.79,13.5 C4.69,13.56 5.17,14.43 5.17,14.43 C5.97,15.8 7.28,15.41 7.79,15.18 C7.87,14.6 8.1,14.2 8.36,13.98 C6.36,13.75 4.26,12.98 4.26,9.53 C4.26,8.55 4.61,7.74 5.19,7.11 C5.1,6.88 4.79,5.97 5.28,4.73 C5.28,4.73 6.04,4.49 7.75,5.65 C8.47,5.45 9.24,5.35 10,5.35 C10.76,5.35 11.53,5.45 12.25,5.65 C13.97,4.48 14.72,4.73 14.72,4.73 C15.21,5.97 14.9,6.88 14.81,7.11 C15.39,7.74 15.73,8.54 15.73,9.53 C15.73,12.99 13.63,13.75 11.62,13.97 C11.94,14.25 12.23,14.8 12.23,15.64 C12.23,16.84 12.22,17.81 12.22,18.11 C12.22,18.35 12.38,18.63 12.84,18.54 C16.42,17.35 19,13.98 19,10 C19,5.03 14.97,1 10,1 L10,1 Z\"/></svg>",
        "gitter": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"3.5\" y=\"1\" width=\"1.531\" height=\"11.471\"/><rect x=\"7.324\" y=\"4.059\" width=\"1.529\" height=\"15.294\"/><rect x=\"11.148\" y=\"4.059\" width=\"1.527\" height=\"15.294\"/><rect x=\"14.971\" y=\"4.059\" width=\"1.529\" height=\"8.412\"/></svg>",
        "google": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.86,9.09 C18.46,12.12 17.14,16.05 13.81,17.56 C9.45,19.53 4.13,17.68 2.47,12.87 C0.68,7.68 4.22,2.42 9.5,2.03 C11.57,1.88 13.42,2.37 15.05,3.65 C15.22,3.78 15.37,3.93 15.61,4.14 C14.9,4.81 14.23,5.45 13.5,6.14 C12.27,5.08 10.84,4.72 9.28,4.98 C8.12,5.17 7.16,5.76 6.37,6.63 C4.88,8.27 4.62,10.86 5.76,12.82 C6.95,14.87 9.17,15.8 11.57,15.25 C13.27,14.87 14.76,13.33 14.89,11.75 L10.51,11.75 L10.51,9.09 L17.86,9.09 L17.86,9.09 Z\"/></svg>",
        "grid": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"2\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"2\" y=\"14\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"14\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"14\" width=\"3\" height=\"3\"/></svg>",
        "happy": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"13\" cy=\"7\" r=\"1\"/><circle cx=\"7\" cy=\"7\" r=\"1\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10\" r=\"8.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M14.6,11.4 C13.9,13.3 12.1,14.5 10,14.5 C7.9,14.5 6.1,13.3 5.4,11.4\"/></svg>",
        "hashtag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.431,8 L15.661,7 L12.911,7 L13.831,3 L12.901,3 L11.98,7 L9.29,7 L10.21,3 L9.281,3 L8.361,7 L5.23,7 L5,8 L8.13,8 L7.21,12 L4.23,12 L4,13 L6.98,13 L6.061,17 L6.991,17 L7.911,13 L10.601,13 L9.681,17 L10.611,17 L11.531,13 L14.431,13 L14.661,12 L11.76,12 L12.681,8 L15.431,8 Z M10.831,12 L8.141,12 L9.061,8 L11.75,8 L10.831,12 Z\"/></svg>",
        "heart": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" d=\"M10,4 C10,4 8.1,2 5.74,2 C3.38,2 1,3.55 1,6.73 C1,8.84 2.67,10.44 2.67,10.44 L10,18 L17.33,10.44 C17.33,10.44 19,8.84 19,6.73 C19,3.55 16.62,2 14.26,2 C11.9,2 10,4 10,4 L10,4 Z\"/></svg>",
        "history": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"#000\" points=\"1 2 2 2 2 6 6 6 6 7 1 7 1 2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M2.1,6.548 C3.391,3.29 6.746,1 10.5,1 C15.5,1 19.5,5 19.5,10 C19.5,15 15.5,19 10.5,19 C5.5,19 1.5,15 1.5,10\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.018,14.197 L9.445,10.625\"/></svg>",
        "home": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"18.65 11.35 10 2.71 1.35 11.35 0.65 10.65 10 1.29 19.35 10.65\"/><polygon points=\"15 4 18 4 18 7 17 7 17 5 15 5\"/><polygon points=\"3 11 4 11 4 18 7 18 7 12 12 12 12 18 16 18 16 11 17 11 17 19 11 19 11 13 8 13 8 19 3 19\"/></svg>",
        "image": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"16.1\" cy=\"6.1\" r=\"1.1\"/><rect fill=\"none\" stroke=\"#000\" x=\".5\" y=\"2.5\" width=\"19\" height=\"15\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"4,13 8,9 13,14\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"11,12 12.5,10.5 16,14\"/></svg>",
        "info": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.13,11.59 C11.97,12.84 10.35,14.12 9.1,14.16 C6.17,14.2 9.89,9.46 8.74,8.37 C9.3,8.16 10.62,7.83 10.62,8.81 C10.62,9.63 10.12,10.55 9.88,11.32 C8.66,15.16 12.13,11.15 12.14,11.18 C12.16,11.21 12.16,11.35 12.13,11.59 C12.08,11.95 12.16,11.35 12.13,11.59 L12.13,11.59 Z M11.56,5.67 C11.56,6.67 9.36,7.15 9.36,6.03 C9.36,5 11.56,4.54 11.56,5.67 L11.56,5.67 Z\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
        "instagram": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.55,1H6.46C3.45,1,1,3.44,1,6.44v7.12c0,3,2.45,5.44,5.46,5.44h7.08c3.02,0,5.46-2.44,5.46-5.44V6.44 C19.01,3.44,16.56,1,13.55,1z M17.5,14c0,1.93-1.57,3.5-3.5,3.5H6c-1.93,0-3.5-1.57-3.5-3.5V6c0-1.93,1.57-3.5,3.5-3.5h8 c1.93,0,3.5,1.57,3.5,3.5V14z\"/><circle cx=\"14.87\" cy=\"5.26\" r=\"1.09\"/><path d=\"M10.03,5.45c-2.55,0-4.63,2.06-4.63,4.6c0,2.55,2.07,4.61,4.63,4.61c2.56,0,4.63-2.061,4.63-4.61 C14.65,7.51,12.58,5.45,10.03,5.45L10.03,5.45L10.03,5.45z M10.08,13c-1.66,0-3-1.34-3-2.99c0-1.65,1.34-2.99,3-2.99s3,1.34,3,2.99 C13.08,11.66,11.74,13,10.08,13L10.08,13L10.08,13z\"/></svg>",
        "italic": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.63,5.48 L10.15,14.52 C10,15.08 10.37,15.25 11.92,15.3 L11.72,16 L6,16 L6.2,15.31 C7.78,15.26 8.19,15.09 8.34,14.53 L10.82,5.49 C10.97,4.92 10.63,4.76 9.09,4.71 L9.28,4 L15,4 L14.81,4.69 C13.23,4.75 12.78,4.91 12.63,5.48 L12.63,5.48 Z\"/></svg>",
        "joomla": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7.8,13.4l1.7-1.7L5.9,8c-0.6-0.5-0.6-1.5,0-2c0.6-0.6,1.4-0.6,2,0l1.7-1.7c-1-1-2.3-1.3-3.6-1C5.8,2.2,4.8,1.4,3.7,1.4 c-1.3,0-2.3,1-2.3,2.3c0,1.1,0.8,2,1.8,2.3c-0.4,1.3-0.1,2.8,1,3.8L7.8,13.4L7.8,13.4z\"/><path d=\"M10.2,4.3c1-1,2.5-1.4,3.8-1c0.2-1.1,1.1-2,2.3-2c1.3,0,2.3,1,2.3,2.3c0,1.2-0.9,2.2-2,2.3c0.4,1.3,0,2.8-1,3.8L13.9,8 c0.6-0.5,0.6-1.5,0-2c-0.5-0.6-1.5-0.6-2,0L8.2,9.7L6.5,8\"/><path d=\"M14.1,16.8c-1.3,0.4-2.8,0.1-3.8-1l1.7-1.7c0.6,0.6,1.5,0.6,2,0c0.5-0.6,0.6-1.5,0-2l-3.7-3.7L12,6.7l3.7,3.7 c1,1,1.3,2.4,1,3.6c1.1,0.2,2,1.1,2,2.3c0,1.3-1,2.3-2.3,2.3C15.2,18.6,14.3,17.8,14.1,16.8\"/><path d=\"M13.2,12.2l-3.7,3.7c-1,1-2.4,1.3-3.6,1c-0.2,1-1.2,1.8-2.2,1.8c-1.3,0-2.3-1-2.3-2.3c0-1.1,0.8-2,1.8-2.3 c-0.3-1.3,0-2.7,1-3.7l1.7,1.7c-0.6,0.6-0.6,1.5,0,2c0.6,0.6,1.4,0.6,2,0l3.7-3.7\"/></svg>",
        "laptop": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"16\" width=\"20\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"2.5\" y=\"4.5\" width=\"15\" height=\"10\"/></svg>",
        "lifesaver": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5 C4.76,0.5 0.5,4.76 0.5,10 C0.5,15.24 4.76,19.5 10,19.5 C15.24,19.5 19.5,15.24 19.5,10 C19.5,4.76 15.24,0.5 10,0.5 L10,0.5 Z M10,1.5 C11.49,1.5 12.89,1.88 14.11,2.56 L11.85,4.82 C11.27,4.61 10.65,4.5 10,4.5 C9.21,4.5 8.47,4.67 7.79,4.96 L5.58,2.75 C6.87,1.95 8.38,1.5 10,1.5 L10,1.5 Z M4.96,7.8 C4.67,8.48 4.5,9.21 4.5,10 C4.5,10.65 4.61,11.27 4.83,11.85 L2.56,14.11 C1.88,12.89 1.5,11.49 1.5,10 C1.5,8.38 1.95,6.87 2.75,5.58 L4.96,7.79 L4.96,7.8 L4.96,7.8 Z M10,18.5 C8.25,18.5 6.62,17.97 5.27,17.06 L7.46,14.87 C8.22,15.27 9.08,15.5 10,15.5 C10.79,15.5 11.53,15.33 12.21,15.04 L14.42,17.25 C13.13,18.05 11.62,18.5 10,18.5 L10,18.5 Z M10,14.5 C7.52,14.5 5.5,12.48 5.5,10 C5.5,7.52 7.52,5.5 10,5.5 C12.48,5.5 14.5,7.52 14.5,10 C14.5,12.48 12.48,14.5 10,14.5 L10,14.5 Z M15.04,12.21 C15.33,11.53 15.5,10.79 15.5,10 C15.5,9.08 15.27,8.22 14.87,7.46 L17.06,5.27 C17.97,6.62 18.5,8.25 18.5,10 C18.5,11.62 18.05,13.13 17.25,14.42 L15.04,12.21 L15.04,12.21 Z\"/></svg>",
        "link": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M10.625,12.375 L7.525,15.475 C6.825,16.175 5.925,16.175 5.225,15.475 L4.525,14.775 C3.825,14.074 3.825,13.175 4.525,12.475 L7.625,9.375\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M9.325,7.375 L12.425,4.275 C13.125,3.575 14.025,3.575 14.724,4.275 L15.425,4.975 C16.125,5.675 16.125,6.575 15.425,7.275 L12.325,10.375\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M7.925,11.875 L11.925,7.975\"/></svg>",
        "linkedin": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.77,17.89 L5.77,7.17 L2.21,7.17 L2.21,17.89 L5.77,17.89 L5.77,17.89 Z M3.99,5.71 C5.23,5.71 6.01,4.89 6.01,3.86 C5.99,2.8 5.24,2 4.02,2 C2.8,2 2,2.8 2,3.85 C2,4.88 2.77,5.7 3.97,5.7 L3.99,5.7 L3.99,5.71 L3.99,5.71 Z\"/><path d=\"M7.75,17.89 L11.31,17.89 L11.31,11.9 C11.31,11.58 11.33,11.26 11.43,11.03 C11.69,10.39 12.27,9.73 13.26,9.73 C14.55,9.73 15.06,10.71 15.06,12.15 L15.06,17.89 L18.62,17.89 L18.62,11.74 C18.62,8.45 16.86,6.92 14.52,6.92 C12.6,6.92 11.75,7.99 11.28,8.73 L11.3,8.73 L11.3,7.17 L7.75,7.17 C7.79,8.17 7.75,17.89 7.75,17.89 L7.75,17.89 L7.75,17.89 Z\"/></svg>",
        "list": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"6\" y=\"4\" width=\"12\" height=\"1\"/><rect x=\"6\" y=\"9\" width=\"12\" height=\"1\"/><rect x=\"6\" y=\"14\" width=\"12\" height=\"1\"/><rect x=\"2\" y=\"4\" width=\"2\" height=\"1\"/><rect x=\"2\" y=\"9\" width=\"2\" height=\"1\"/><rect x=\"2\" y=\"14\" width=\"2\" height=\"1\"/></svg>",
        "location": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" d=\"M10,0.5 C6.41,0.5 3.5,3.39 3.5,6.98 C3.5,11.83 10,19 10,19 C10,19 16.5,11.83 16.5,6.98 C16.5,3.39 13.59,0.5 10,0.5 L10,0.5 Z\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"6.8\" r=\"2.3\"/></svg>",
        "lock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" height=\"10\" width=\"13\" y=\"8.5\" x=\"3.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M6.5,8 L6.5,4.88 C6.5,3.01 8.07,1.5 10,1.5 C11.93,1.5 13.5,3.01 13.5,4.88 L13.5,8\"/></svg>",
        "mail": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"1.4,6.5 10,11 18.6,6.5\"/><path d=\"M 1,4 1,16 19,16 19,4 1,4 Z M 18,15 2,15 2,5 18,5 18,15 Z\"/></svg>",
        "menu": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"4\" width=\"16\" height=\"1\"/><rect x=\"2\" y=\"9\" width=\"16\" height=\"1\"/><rect x=\"2\" y=\"14\" width=\"16\" height=\"1\"/></svg>",
        "microphone": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" x1=\"10\" x2=\"10\" y1=\"16.44\" y2=\"18.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"7\" x2=\"13\" y1=\"18.5\" y2=\"18.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.5 4.89v5.87a3.5 3.5 0 0 1-7 0V4.89a3.5 3.5 0 0 1 7 0z\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M15.5 10.36V11a5.5 5.5 0 0 1-11 0v-.6\"/></svg>",
        "minus-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" x1=\"5\" y1=\"9.5\" x2=\"14\" y2=\"9.5\"/></svg>",
        "minus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect height=\"1\" width=\"18\" y=\"9\" x=\"1\"/></svg>",
        "more-vertical": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"10\" cy=\"3\" r=\"2\"/><circle cx=\"10\" cy=\"10\" r=\"2\"/><circle cx=\"10\" cy=\"17\" r=\"2\"/></svg>",
        "more": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"3\" cy=\"10\" r=\"2\"/><circle cx=\"10\" cy=\"10\" r=\"2\"/><circle cx=\"17\" cy=\"10\" r=\"2\"/></svg>",
        "move": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"4,5 1,5 1,9 2,9 2,6 4,6\"/><polygon points=\"1,16 2,16 2,18 4,18 4,19 1,19\"/><polygon points=\"14,16 14,19 11,19 11,18 13,18 13,16\"/><rect fill=\"none\" stroke=\"#000\" x=\"5.5\" y=\"1.5\" width=\"13\" height=\"13\"/><rect x=\"1\" y=\"11\" width=\"1\" height=\"3\"/><rect x=\"6\" y=\"18\" width=\"3\" height=\"1\"/></svg>",
        "nut": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"2.5,5.7 10,1.3 17.5,5.7 17.5,14.3 10,18.7 2.5,14.3\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10\" r=\"3.5\"/></svg>",
        "pagekit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"3,1 17,1 17,16 10,16 10,13 14,13 14,4 6,4 6,16 10,16 10,19 3,19\"/></svg>",
        "paint-bucket": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.21,1 L0,11.21 L8.1,19.31 L18.31,9.1 L10.21,1 L10.21,1 Z M16.89,9.1 L15,11 L1.7,11 L10.21,2.42 L16.89,9.1 Z\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.42,2.33 L11.7,7.61\"/><path d=\"M18.49,12 C18.49,12 20,14.06 20,15.36 C20,16.28 19.24,17 18.49,17 L18.49,17 C17.74,17 17,16.28 17,15.36 C17,14.06 18.49,12 18.49,12 L18.49,12 Z\"/></svg>",
        "pencil": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M17.25,6.01 L7.12,16.1 L3.82,17.2 L5.02,13.9 L15.12,3.88 C15.71,3.29 16.66,3.29 17.25,3.88 C17.83,4.47 17.83,5.42 17.25,6.01 L17.25,6.01 Z\"/><path fill=\"none\" stroke=\"#000\" d=\"M15.98,7.268 L13.851,5.148\"/></svg>",
        "phone-landscape": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M17,5.5 C17.8,5.5 18.5,6.2 18.5,7 L18.5,14 C18.5,14.8 17.8,15.5 17,15.5 L3,15.5 C2.2,15.5 1.5,14.8 1.5,14 L1.5,7 C1.5,6.2 2.2,5.5 3,5.5 L17,5.5 L17,5.5 L17,5.5 Z\"/><circle cx=\"3.8\" cy=\"10.5\" r=\".8\"/></svg>",
        "phone": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M15.5,17 C15.5,17.8 14.8,18.5 14,18.5 L7,18.5 C6.2,18.5 5.5,17.8 5.5,17 L5.5,3 C5.5,2.2 6.2,1.5 7,1.5 L14,1.5 C14.8,1.5 15.5,2.2 15.5,3 L15.5,17 L15.5,17 L15.5,17 Z\"/><circle cx=\"10.5\" cy=\"16.5\" r=\".8\"/></svg>",
        "pinterest": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.21,1 C5.5,1 3,4.16 3,7.61 C3,9.21 3.85,11.2 5.22,11.84 C5.43,11.94 5.54,11.89 5.58,11.69 C5.62,11.54 5.8,10.8 5.88,10.45 C5.91,10.34 5.89,10.24 5.8,10.14 C5.36,9.59 5,8.58 5,7.65 C5,5.24 6.82,2.91 9.93,2.91 C12.61,2.91 14.49,4.74 14.49,7.35 C14.49,10.3 13,12.35 11.06,12.35 C9.99,12.35 9.19,11.47 9.44,10.38 C9.75,9.08 10.35,7.68 10.35,6.75 C10.35,5.91 9.9,5.21 8.97,5.21 C7.87,5.21 6.99,6.34 6.99,7.86 C6.99,8.83 7.32,9.48 7.32,9.48 C7.32,9.48 6.24,14.06 6.04,14.91 C5.7,16.35 6.08,18.7 6.12,18.9 C6.14,19.01 6.26,19.05 6.33,18.95 C6.44,18.81 7.74,16.85 8.11,15.44 C8.24,14.93 8.79,12.84 8.79,12.84 C9.15,13.52 10.19,14.09 11.29,14.09 C14.58,14.09 16.96,11.06 16.96,7.3 C16.94,3.7 14,1 10.21,1\"/></svg>",
        "play-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"8.5 7 13.5 10 8.5 13\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
        "play": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"6.5,5 14.5,10 6.5,15\"/></svg>",
        "plus-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"5\" x2=\"9.5\" y2=\"14\"/><line fill=\"none\" stroke=\"#000\" x1=\"5\" y1=\"9.5\" x2=\"14\" y2=\"9.5\"/></svg>",
        "plus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"1\" width=\"1\" height=\"17\"/><rect x=\"1\" y=\"9\" width=\"17\" height=\"1\"/></svg>",
        "print": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"4.5 13.5 1.5 13.5 1.5 6.5 18.5 6.5 18.5 13.5 15.5 13.5\"/><polyline fill=\"none\" stroke=\"#000\" points=\"15.5 6.5 15.5 2.5 4.5 2.5 4.5 6.5\"/><rect fill=\"none\" stroke=\"#000\" width=\"11\" height=\"6\" x=\"4.5\" y=\"11.5\"/><rect width=\"8\" height=\"1\" x=\"6\" y=\"13\"/><rect width=\"8\" height=\"1\" x=\"6\" y=\"15\"/></svg>",
        "pull": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"6.85,8 9.5,10.6 12.15,8 12.85,8.7 9.5,12 6.15,8.7\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"11\" x2=\"9.5\" y2=\"2\"/><polyline fill=\"none\" stroke=\"#000\" points=\"6,5.5 3.5,5.5 3.5,18.5 15.5,18.5 15.5,5.5 13,5.5\"/></svg>",
        "push": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"12.15,4 9.5,1.4 6.85,4 6.15,3.3 9.5,0 12.85,3.3\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"10\" x2=\"9.5\" y2=\"1\"/><polyline fill=\"none\" stroke=\"#000\" points=\"6 5.5 3.5 5.5 3.5 18.5 15.5 18.5 15.5 5.5 13 5.5\"/></svg>",
        "question": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><circle cx=\"10.44\" cy=\"14.42\" r=\"1.05\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" d=\"M8.17,7.79 C8.17,4.75 12.72,4.73 12.72,7.72 C12.72,8.67 11.81,9.15 11.23,9.75 C10.75,10.24 10.51,10.73 10.45,11.4 C10.44,11.53 10.43,11.64 10.43,11.75\"/></svg>",
        "quote-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.27,7.79 C17.27,9.45 16.97,10.43 15.99,12.02 C14.98,13.64 13,15.23 11.56,15.97 L11.1,15.08 C12.34,14.2 13.14,13.51 14.02,11.82 C14.27,11.34 14.41,10.92 14.49,10.54 C14.3,10.58 14.09,10.6 13.88,10.6 C12.06,10.6 10.59,9.12 10.59,7.3 C10.59,5.48 12.06,4 13.88,4 C15.39,4 16.67,5.02 17.05,6.42 C17.19,6.82 17.27,7.27 17.27,7.79 L17.27,7.79 Z\"/><path d=\"M8.68,7.79 C8.68,9.45 8.38,10.43 7.4,12.02 C6.39,13.64 4.41,15.23 2.97,15.97 L2.51,15.08 C3.75,14.2 4.55,13.51 5.43,11.82 C5.68,11.34 5.82,10.92 5.9,10.54 C5.71,10.58 5.5,10.6 5.29,10.6 C3.47,10.6 2,9.12 2,7.3 C2,5.48 3.47,4 5.29,4 C6.8,4 8.08,5.02 8.46,6.42 C8.6,6.82 8.68,7.27 8.68,7.79 L8.68,7.79 Z\"/></svg>",
        "receiver": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" d=\"M6.189,13.611C8.134,15.525 11.097,18.239 13.867,18.257C16.47,18.275 18.2,16.241 18.2,16.241L14.509,12.551L11.539,13.639L6.189,8.29L7.313,5.355L3.76,1.8C3.76,1.8 1.732,3.537 1.7,6.092C1.667,8.809 4.347,11.738 6.189,13.611\"/></svg>",
        "reddit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19 9.05a2.56 2.56 0 0 0-2.56-2.56 2.59 2.59 0 0 0-1.88.82 10.63 10.63 0 0 0-4.14-1v-.08c.58-1.62 1.58-3.89 2.7-4.1.38-.08.77.12 1.19.57a1.15 1.15 0 0 0-.06.37 1.48 1.48 0 1 0 1.51-1.45 1.43 1.43 0 0 0-.76.19A2.29 2.29 0 0 0 12.91 1c-2.11.43-3.39 4.38-3.63 5.19 0 0 0 .11-.06.11a10.65 10.65 0 0 0-3.75 1A2.56 2.56 0 0 0 1 9.05a2.42 2.42 0 0 0 .72 1.76A5.18 5.18 0 0 0 1.24 13c0 3.66 3.92 6.64 8.73 6.64s8.74-3 8.74-6.64a5.23 5.23 0 0 0-.46-2.13A2.58 2.58 0 0 0 19 9.05zm-16.88 0a1.44 1.44 0 0 1 2.27-1.19 7.68 7.68 0 0 0-2.07 1.91 1.33 1.33 0 0 1-.2-.72zM10 18.4c-4.17 0-7.55-2.4-7.55-5.4S5.83 7.53 10 7.53 17.5 10 17.5 13s-3.38 5.4-7.5 5.4zm7.69-8.61a7.62 7.62 0 0 0-2.09-1.91 1.41 1.41 0 0 1 .84-.28 1.47 1.47 0 0 1 1.44 1.45 1.34 1.34 0 0 1-.21.72z\"/><path d=\"M6.69 12.58a1.39 1.39 0 1 1 1.39-1.39 1.38 1.38 0 0 1-1.38 1.39z\"/><path d=\"M14.26 11.2a1.39 1.39 0 1 1-1.39-1.39 1.39 1.39 0 0 1 1.39 1.39z\"/><path d=\"M13.09 14.88a.54.54 0 0 1-.09.77 5.3 5.3 0 0 1-3.26 1.19 5.61 5.61 0 0 1-3.4-1.22.55.55 0 1 1 .73-.83 4.09 4.09 0 0 0 5.25 0 .56.56 0 0 1 .77.09z\"/></svg>",
        "refresh": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17.08,11.15 C17.09,11.31 17.1,11.47 17.1,11.64 C17.1,15.53 13.94,18.69 10.05,18.69 C6.16,18.68 3,15.53 3,11.63 C3,7.74 6.16,4.58 10.05,4.58 C10.9,4.58 11.71,4.73 12.46,5\"/><polyline fill=\"none\" stroke=\"#000\" points=\"9.9 2 12.79 4.89 9.79 7.9\"/></svg>",
        "reply": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.7,13.11 C16.12,10.02 13.84,7.85 11.02,6.61 C10.57,6.41 9.75,6.13 9,5.91 L9,2 L1,9 L9,16 L9,12.13 C10.78,12.47 12.5,13.19 14.09,14.25 C17.13,16.28 18.56,18.54 18.56,18.54 C18.56,18.54 18.81,15.28 17.7,13.11 L17.7,13.11 Z M14.82,13.53 C13.17,12.4 11.01,11.4 8,10.92 L8,13.63 L2.55,9 L8,4.25 L8,6.8 C8.3,6.86 9.16,7.02 10.37,7.49 C13.3,8.65 15.54,10.96 16.65,13.08 C16.97,13.7 17.48,14.86 17.68,16 C16.87,15.05 15.73,14.15 14.82,13.53 L14.82,13.53 Z\"/></svg>",
        "rss": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"3.12\" cy=\"16.8\" r=\"1.85\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,8.2 C1.78,8.18 2.06,8.16 2.35,8.16 C7.57,8.16 11.81,12.37 11.81,17.57 C11.81,17.89 11.79,18.19 11.76,18.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,2.52 C1.78,2.51 2.06,2.5 2.35,2.5 C10.72,2.5 17.5,9.24 17.5,17.57 C17.5,17.89 17.49,18.19 17.47,18.5\"/></svg>",
        "search": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>",
        "server": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"3\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"7\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"16\" y=\"3\" width=\"1\" height=\"1\"/><rect x=\"16\" y=\"10\" width=\"1\" height=\"1\"/><circle fill=\"none\" stroke=\"#000\" cx=\"9.9\" cy=\"17.4\" r=\"1.4\"/><rect x=\"3\" y=\"10\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"10\" width=\"1\" height=\"2\"/><rect x=\"9.5\" y=\"14\" width=\"1\" height=\"2\"/><rect x=\"3\" y=\"17\" width=\"6\" height=\"1\"/><rect x=\"11\" y=\"17\" width=\"6\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"1.5\" width=\"17\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"8.5\" width=\"17\" height=\"5\"/></svg>",
        "settings": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><ellipse fill=\"none\" stroke=\"#000\" cx=\"6.11\" cy=\"3.55\" rx=\"2.11\" ry=\"2.15\"/><ellipse fill=\"none\" stroke=\"#000\" cx=\"6.11\" cy=\"15.55\" rx=\"2.11\" ry=\"2.15\"/><circle fill=\"none\" stroke=\"#000\" cx=\"13.15\" cy=\"9.55\" r=\"2.15\"/><rect x=\"1\" y=\"3\" width=\"3\" height=\"1\"/><rect x=\"10\" y=\"3\" width=\"8\" height=\"1\"/><rect x=\"1\" y=\"9\" width=\"8\" height=\"1\"/><rect x=\"15\" y=\"9\" width=\"3\" height=\"1\"/><rect x=\"1\" y=\"15\" width=\"3\" height=\"1\"/><rect x=\"10\" y=\"15\" width=\"8\" height=\"1\"/></svg>",
        "shrink": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"11 4 12 4 12 8 16 8 16 9 11 9\"/><polygon points=\"4 11 9 11 9 16 8 16 8 12 4 12\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M12,8 L18,2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M2,18 L8,12\"/></svg>",
        "sign-in": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"7 2 17 2 17 17 7 17 7 16 16 16 16 3 7 3\"/><polygon points=\"9.1 13.4 8.5 12.8 11.28 10 4 10 4 9 11.28 9 8.5 6.2 9.1 5.62 13 9.5\"/></svg>",
        "sign-out": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"13.1 13.4 12.5 12.8 15.28 10 8 10 8 9 15.28 9 12.5 6.2 13.1 5.62 17 9.5\"/><polygon points=\"13 2 3 2 3 17 13 17 13 16 4 16 4 3 13 3\"/></svg>",
        "social": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13.4\" y1=\"14\" x2=\"6.3\" y2=\"10.7\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13.5\" y1=\"5.5\" x2=\"6.5\" y2=\"8.8\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"15.5\" cy=\"4.6\" r=\"2.3\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"15.5\" cy=\"14.8\" r=\"2.3\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"4.5\" cy=\"9.8\" r=\"2.3\"/></svg>",
        "soundcloud": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.2,9.4c-0.4,0-0.8,0.1-1.101,0.2c-0.199-2.5-2.399-4.5-5-4.5c-0.6,0-1.2,0.1-1.7,0.3C9.2,5.5,9.1,5.6,9.1,5.6V15h8 c1.601,0,2.801-1.2,2.801-2.8C20,10.7,18.7,9.4,17.2,9.4L17.2,9.4z\"/><rect x=\"6\" y=\"6.5\" width=\"1.5\" height=\"8.5\"/><rect x=\"3\" y=\"8\" width=\"1.5\" height=\"7\"/><rect y=\"10\" width=\"1.5\" height=\"5\"/></svg>",
        "star": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"10 2 12.63 7.27 18.5 8.12 14.25 12.22 15.25 18 10 15.27 4.75 18 5.75 12.22 1.5 8.12 7.37 7.27\"/></svg>",
        "strikethrough": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6,13.02 L6.65,13.02 C7.64,15.16 8.86,16.12 10.41,16.12 C12.22,16.12 12.92,14.93 12.92,13.89 C12.92,12.55 11.99,12.03 9.74,11.23 C8.05,10.64 6.23,10.11 6.23,7.83 C6.23,5.5 8.09,4.09 10.4,4.09 C11.44,4.09 12.13,4.31 12.72,4.54 L13.33,4 L13.81,4 L13.81,7.59 L13.16,7.59 C12.55,5.88 11.52,4.89 10.07,4.89 C8.84,4.89 7.89,5.69 7.89,7.03 C7.89,8.29 8.89,8.78 10.88,9.45 C12.57,10.03 14.38,10.6 14.38,12.91 C14.38,14.75 13.27,16.93 10.18,16.93 C9.18,16.93 8.17,16.69 7.46,16.39 L6.52,17 L6,17 L6,13.02 L6,13.02 Z\"/><rect x=\"3\" y=\"10\" width=\"15\" height=\"1\"/></svg>",
        "table": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"1\" y=\"3\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"7\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"11\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"15\" width=\"18\" height=\"1\"/></svg>",
        "tablet-landscape": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M1.5,5 C1.5,4.2 2.2,3.5 3,3.5 L17,3.5 C17.8,3.5 18.5,4.2 18.5,5 L18.5,16 C18.5,16.8 17.8,17.5 17,17.5 L3,17.5 C2.2,17.5 1.5,16.8 1.5,16 L1.5,5 L1.5,5 L1.5,5 Z\"/><circle cx=\"3.7\" cy=\"10.5\" r=\".8\"/></svg>",
        "tablet": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M5,18.5 C4.2,18.5 3.5,17.8 3.5,17 L3.5,3 C3.5,2.2 4.2,1.5 5,1.5 L16,1.5 C16.8,1.5 17.5,2.2 17.5,3 L17.5,17 C17.5,17.8 16.8,18.5 16,18.5 L5,18.5 L5,18.5 L5,18.5 Z\"/><circle cx=\"10.5\" cy=\"16.3\" r=\".8\"/></svg>",
        "tag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17.5,3.71 L17.5,7.72 C17.5,7.96 17.4,8.2 17.21,8.39 L8.39,17.2 C7.99,17.6 7.33,17.6 6.93,17.2 L2.8,13.07 C2.4,12.67 2.4,12.01 2.8,11.61 L11.61,2.8 C11.81,2.6 12.08,2.5 12.34,2.5 L16.19,2.5 C16.52,2.5 16.86,2.63 17.11,2.88 C17.35,3.11 17.48,3.4 17.5,3.71 L17.5,3.71 Z\"/><circle cx=\"14\" cy=\"6\" r=\"1\"/></svg>",
        "thumbnails": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"3.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"11.5\" y=\"3.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"11.5\" y=\"11.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"11.5\" width=\"5\" height=\"5\"/></svg>",
        "tiktok": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.24,6V8.82a6.79,6.79,0,0,1-4-1.28v5.81A5.26,5.26,0,1,1,8,8.1a4.36,4.36,0,0,1,.72.05v2.9A2.57,2.57,0,0,0,7.64,11a2.4,2.4,0,1,0,2.77,2.38V2h2.86a4,4,0,0,0,1.84,3.38A4,4,0,0,0,17.24,6Z\"/></svg>",
        "trash": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"6.5 3 6.5 1.5 13.5 1.5 13.5 3\"/><polyline fill=\"none\" stroke=\"#000\" points=\"4.5 4 4.5 18.5 15.5 18.5 15.5 4\"/><rect x=\"8\" y=\"7\" width=\"1\" height=\"9\"/><rect x=\"11\" y=\"7\" width=\"1\" height=\"9\"/><rect x=\"2\" y=\"3\" width=\"16\" height=\"1\"/></svg>",
        "triangle-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"5 7 15 7 10 12\"/></svg>",
        "triangle-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"12 5 7 10 12 15\"/></svg>",
        "triangle-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"8 5 13 10 8 15\"/></svg>",
        "triangle-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"5 13 10 8 15 13\"/></svg>",
        "tripadvisor": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19.021,7.866C19.256,6.862,20,5.854,20,5.854h-3.346C14.781,4.641,12.504,4,9.98,4C7.363,4,4.999,4.651,3.135,5.876H0\tc0,0,0.738,0.987,0.976,1.988c-0.611,0.837-0.973,1.852-0.973,2.964c0,2.763,2.249,5.009,5.011,5.009\tc1.576,0,2.976-0.737,3.901-1.879l1.063,1.599l1.075-1.615c0.475,0.611,1.1,1.111,1.838,1.451c1.213,0.547,2.574,0.612,3.825,0.15\tc2.589-0.963,3.913-3.852,2.964-6.439c-0.175-0.463-0.4-0.876-0.675-1.238H19.021z M16.38,14.594\tc-1.002,0.371-2.088,0.328-3.06-0.119c-0.688-0.317-1.252-0.817-1.657-1.438c-0.164-0.25-0.313-0.52-0.417-0.811\tc-0.124-0.328-0.186-0.668-0.217-1.014c-0.063-0.689,0.037-1.396,0.339-2.043c0.448-0.971,1.251-1.71,2.25-2.079\tc2.075-0.765,4.375,0.3,5.14,2.366c0.762,2.066-0.301,4.37-2.363,5.134L16.38,14.594L16.38,14.594z M8.322,13.066\tc-0.72,1.059-1.935,1.76-3.309,1.76c-2.207,0-4.001-1.797-4.001-3.996c0-2.203,1.795-4.002,4.001-4.002\tc2.204,0,3.999,1.8,3.999,4.002c0,0.137-0.024,0.261-0.04,0.396c-0.067,0.678-0.284,1.313-0.648,1.853v-0.013H8.322z M2.472,10.775\tc0,1.367,1.112,2.479,2.476,2.479c1.363,0,2.472-1.11,2.472-2.479c0-1.359-1.11-2.468-2.472-2.468\tC3.584,8.306,2.473,9.416,2.472,10.775L2.472,10.775z M12.514,10.775c0,1.367,1.104,2.479,2.471,2.479\tc1.363,0,2.474-1.108,2.474-2.479c0-1.359-1.11-2.468-2.474-2.468c-1.364,0-2.477,1.109-2.477,2.468H12.514z M3.324,10.775\tc0-0.893,0.726-1.618,1.614-1.618c0.889,0,1.625,0.727,1.625,1.618c0,0.898-0.725,1.627-1.625,1.627\tc-0.901,0-1.625-0.729-1.625-1.627H3.324z M13.354,10.775c0-0.893,0.726-1.618,1.627-1.618c0.886,0,1.61,0.727,1.61,1.618\tc0,0.898-0.726,1.627-1.626,1.627s-1.625-0.729-1.625-1.627H13.354z M9.977,4.875c1.798,0,3.425,0.324,4.849,0.968\tc-0.535,0.015-1.061,0.108-1.586,0.3c-1.264,0.463-2.264,1.388-2.815,2.604c-0.262,0.551-0.398,1.133-0.448,1.72\tC9.79,7.905,7.677,5.873,5.076,5.82C6.501,5.208,8.153,4.875,9.94,4.875H9.977z\"/></svg>",
        "tumblr": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.885,8.598c0,0,0,3.393,0,4.996c0,0.282,0,0.66,0.094,0.942c0.377,1.509,1.131,2.545,2.545,3.11 c1.319,0.472,2.356,0.472,3.676,0c0.565-0.188,1.132-0.659,1.132-0.659l-0.849-2.263c0,0-1.036,0.378-1.603,0.283 c-0.565-0.094-1.226-0.66-1.226-1.508c0-1.603,0-4.902,0-4.902h2.828V5.771h-2.828V2H8.205c0,0-0.094,0.66-0.188,0.942 C7.828,3.791,7.262,4.733,6.603,5.394C5.848,6.147,5,6.43,5,6.43v2.168H6.885z\"/></svg>",
        "tv": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"7\" y=\"16\" width=\"6\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\".5\" y=\"3.5\" width=\"19\" height=\"11\"/></svg>",
        "twitch": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.23,1,2,4.23V15.85H5.88v3.23L9.1,15.85h2.59L17.5,10V1Zm11,8.4L13.62,12H11L8.78,14.24V12H5.88V2.29H16.21Z\"/><rect x=\"12.98\" y=\"4.55\" width=\"1.29\" height=\"3.88\"/><rect x=\"9.43\" y=\"4.55\" width=\"1.29\" height=\"3.88\"/></svg>",
        "twitter": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19,4.74 C18.339,5.029 17.626,5.229 16.881,5.32 C17.644,4.86 18.227,4.139 18.503,3.28 C17.79,3.7 17.001,4.009 16.159,4.17 C15.485,3.45 14.526,3 13.464,3 C11.423,3 9.771,4.66 9.771,6.7 C9.771,6.99 9.804,7.269 9.868,7.539 C6.795,7.38 4.076,5.919 2.254,3.679 C1.936,4.219 1.754,4.86 1.754,5.539 C1.754,6.82 2.405,7.95 3.397,8.61 C2.79,8.589 2.22,8.429 1.723,8.149 L1.723,8.189 C1.723,9.978 2.997,11.478 4.686,11.82 C4.376,11.899 4.049,11.939 3.713,11.939 C3.475,11.939 3.245,11.919 3.018,11.88 C3.49,13.349 4.852,14.419 6.469,14.449 C5.205,15.429 3.612,16.019 1.882,16.019 C1.583,16.019 1.29,16.009 1,15.969 C2.635,17.019 4.576,17.629 6.662,17.629 C13.454,17.629 17.17,12 17.17,7.129 C17.17,6.969 17.166,6.809 17.157,6.649 C17.879,6.129 18.504,5.478 19,4.74\"/></svg>",
        "uikit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"14.4,3.1 11.3,5.1 15,7.3 15,12.9 10,15.7 5,12.9 5,8.5 2,6.8 2,14.8 9.9,19.5 18,14.8 18,5.3\"/><polygon points=\"9.8,4.2 6.7,2.4 9.8,0.4 12.9,2.3\"/></svg>",
        "unlock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"8.5\" width=\"13\" height=\"10\"/><path fill=\"none\" stroke=\"#000\" d=\"M6.5,8.5 L6.5,4.9 C6.5,3 8.1,1.5 10,1.5 C11.9,1.5 13.5,3 13.5,4.9\"/></svg>",
        "upload": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"5 8 9.5 3.5 14 8\"/><rect x=\"3\" y=\"17\" width=\"13\" height=\"1\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"15\" x2=\"9.5\" y2=\"4\"/></svg>",
        "user": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.9\" cy=\"6.4\" r=\"4.4\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,19 C2.3,14.5 5.8,11.2 10,11.2 C14.2,11.2 17.7,14.6 18.5,19.2\"/></svg>",
        "users": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"7.7\" cy=\"8.6\" r=\"3.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1,18.1 C1.7,14.6 4.4,12.1 7.6,12.1 C10.9,12.1 13.7,14.8 14.3,18.3\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M11.4,4 C12.8,2.4 15.4,2.8 16.3,4.7 C17.2,6.6 15.7,8.9 13.6,8.9 C16.5,8.9 18.8,11.3 19.2,14.1\"/></svg>",
        "video-camera": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"17.5 6.9 17.5 13.1 13.5 10.4 13.5 14.5 2.5 14.5 2.5 5.5 13.5 5.5 13.5 9.6 17.5 6.9\"/></svg>",
        "vimeo": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.065,7.59C1.84,7.367,1.654,7.082,1.468,6.838c-0.332-0.42-0.137-0.411,0.274-0.772c1.026-0.91,2.004-1.896,3.127-2.688 c1.017-0.713,2.365-1.173,3.286-0.039c0.849,1.045,0.869,2.629,1.084,3.891c0.215,1.309,0.421,2.648,0.88,3.901 c0.127,0.352,0.37,1.018,0.81,1.074c0.567,0.078,1.145-0.917,1.408-1.289c0.684-0.987,1.611-2.317,1.494-3.587 c-0.115-1.349-1.572-1.095-2.482-0.773c0.146-1.514,1.555-3.216,2.912-3.792c1.439-0.597,3.579-0.587,4.302,1.036 c0.772,1.759,0.078,3.802-0.763,5.396c-0.918,1.731-2.1,3.333-3.363,4.829c-1.114,1.329-2.432,2.787-4.093,3.422 c-1.897,0.723-3.021-0.686-3.667-2.318c-0.705-1.777-1.056-3.771-1.565-5.621C4.898,8.726,4.644,7.836,4.136,7.191 C3.473,6.358,2.72,7.141,2.065,7.59C1.977,7.502,2.115,7.551,2.065,7.59L2.065,7.59z\"/></svg>",
        "warning": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"10\" cy=\"14\" r=\"1\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M10.97,7.72 C10.85,9.54 10.56,11.29 10.56,11.29 C10.51,11.87 10.27,12 9.99,12 C9.69,12 9.49,11.87 9.43,11.29 C9.43,11.29 9.16,9.54 9.03,7.72 C8.96,6.54 9.03,6 9.03,6 C9.03,5.45 9.46,5.02 9.99,5 C10.53,5.01 10.97,5.44 10.97,6 C10.97,6 11.04,6.54 10.97,7.72 L10.97,7.72 Z\"/></svg>",
        "whatsapp": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16.7,3.3c-1.8-1.8-4.1-2.8-6.7-2.8c-5.2,0-9.4,4.2-9.4,9.4c0,1.7,0.4,3.3,1.3,4.7l-1.3,4.9l5-1.3c1.4,0.8,2.9,1.2,4.5,1.2 l0,0l0,0c5.2,0,9.4-4.2,9.4-9.4C19.5,7.4,18.5,5,16.7,3.3 M10.1,17.7L10.1,17.7c-1.4,0-2.8-0.4-4-1.1l-0.3-0.2l-3,0.8l0.8-2.9 l-0.2-0.3c-0.8-1.2-1.2-2.7-1.2-4.2c0-4.3,3.5-7.8,7.8-7.8c2.1,0,4.1,0.8,5.5,2.3c1.5,1.5,2.3,3.4,2.3,5.5 C17.9,14.2,14.4,17.7,10.1,17.7 M14.4,11.9c-0.2-0.1-1.4-0.7-1.6-0.8c-0.2-0.1-0.4-0.1-0.5,0.1c-0.2,0.2-0.6,0.8-0.8,0.9 c-0.1,0.2-0.3,0.2-0.5,0.1c-0.2-0.1-1-0.4-1.9-1.2c-0.7-0.6-1.2-1.4-1.3-1.6c-0.1-0.2,0-0.4,0.1-0.5C8,8.8,8.1,8.7,8.2,8.5 c0.1-0.1,0.2-0.2,0.2-0.4c0.1-0.2,0-0.3,0-0.4C8.4,7.6,7.9,6.5,7.7,6C7.5,5.5,7.3,5.6,7.2,5.6c-0.1,0-0.3,0-0.4,0 c-0.2,0-0.4,0.1-0.6,0.3c-0.2,0.2-0.8,0.8-0.8,2c0,1.2,0.8,2.3,1,2.4c0.1,0.2,1.7,2.5,4,3.5c0.6,0.2,1,0.4,1.3,0.5 c0.6,0.2,1.1,0.2,1.5,0.1c0.5-0.1,1.4-0.6,1.6-1.1c0.2-0.5,0.2-1,0.1-1.1C14.8,12.1,14.6,12,14.4,11.9\"/></svg>",
        "wordpress": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5c-5.2,0-9.5,4.3-9.5,9.5s4.3,9.5,9.5,9.5c5.2,0,9.5-4.3,9.5-9.5S15.2,0.5,10,0.5L10,0.5L10,0.5z M15.6,3.9h-0.1 c-0.8,0-1.4,0.7-1.4,1.5c0,0.7,0.4,1.3,0.8,1.9c0.3,0.6,0.7,1.3,0.7,2.3c0,0.7-0.3,1.5-0.6,2.7L14.1,15l-3-8.9 c0.5,0,0.9-0.1,0.9-0.1C12.5,6,12.5,5.3,12,5.4c0,0-1.3,0.1-2.2,0.1C9,5.5,7.7,5.4,7.7,5.4C7.2,5.3,7.2,6,7.6,6c0,0,0.4,0.1,0.9,0.1 l1.3,3.5L8,15L5,6.1C5.5,6.1,5.9,6,5.9,6C6.4,6,6.3,5.3,5.9,5.4c0,0-1.3,0.1-2.2,0.1c-0.2,0-0.3,0-0.5,0c1.5-2.2,4-3.7,6.9-3.7 C12.2,1.7,14.1,2.6,15.6,3.9L15.6,3.9L15.6,3.9z M2.5,6.6l3.9,10.8c-2.7-1.3-4.6-4.2-4.6-7.4C1.8,8.8,2,7.6,2.5,6.6L2.5,6.6L2.5,6.6 z M10.2,10.7l2.5,6.9c0,0,0,0.1,0.1,0.1C11.9,18,11,18.2,10,18.2c-0.8,0-1.6-0.1-2.3-0.3L10.2,10.7L10.2,10.7L10.2,10.7z M14.2,17.1 l2.5-7.3c0.5-1.2,0.6-2.1,0.6-2.9c0-0.3,0-0.6-0.1-0.8c0.6,1.2,1,2.5,1,4C18.3,13,16.6,15.7,14.2,17.1L14.2,17.1L14.2,17.1z\"/></svg>",
        "world": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M1,10.5 L19,10.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M2.35,15.5 L17.65,15.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M2.35,5.5 L17.523,5.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M10,19.46 L9.98,19.46 C7.31,17.33 5.61,14.141 5.61,10.58 C5.61,7.02 7.33,3.83 10,1.7 C10.01,1.7 9.99,1.7 10,1.7 L10,1.7 C12.67,3.83 14.4,7.02 14.4,10.58 C14.4,14.141 12.67,17.33 10,19.46 L10,19.46 L10,19.46 L10,19.46 Z\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10.5\" r=\"9\"/></svg>",
        "xing": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.4,4.56 C4.24,4.56 4.11,4.61 4.05,4.72 C3.98,4.83 3.99,4.97 4.07,5.12 L5.82,8.16 L5.82,8.17 L3.06,13.04 C2.99,13.18 2.99,13.33 3.06,13.44 C3.12,13.55 3.24,13.62 3.4,13.62 L6,13.62 C6.39,13.62 6.57,13.36 6.71,13.12 C6.71,13.12 9.41,8.35 9.51,8.16 C9.49,8.14 7.72,5.04 7.72,5.04 C7.58,4.81 7.39,4.56 6.99,4.56 L4.4,4.56 L4.4,4.56 Z\"/><path d=\"M15.3,1 C14.91,1 14.74,1.25 14.6,1.5 C14.6,1.5 9.01,11.42 8.82,11.74 C8.83,11.76 12.51,18.51 12.51,18.51 C12.64,18.74 12.84,19 13.23,19 L15.82,19 C15.98,19 16.1,18.94 16.16,18.83 C16.23,18.72 16.23,18.57 16.16,18.43 L12.5,11.74 L12.5,11.72 L18.25,1.56 C18.32,1.42 18.32,1.27 18.25,1.16 C18.21,1.06 18.08,1 17.93,1 L15.3,1 L15.3,1 Z\"/></svg>",
        "yelp": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.175,14.971c-0.112,0.77-1.686,2.767-2.406,3.054c-0.246,0.1-0.487,0.076-0.675-0.069\tc-0.122-0.096-2.446-3.859-2.446-3.859c-0.194-0.293-0.157-0.682,0.083-0.978c0.234-0.284,0.581-0.393,0.881-0.276\tc0.016,0.01,4.21,1.394,4.332,1.482c0.178,0.148,0.263,0.379,0.225,0.646L17.175,14.971L17.175,14.971z M11.464,10.789\tc-0.203-0.307-0.199-0.666,0.009-0.916c0,0,2.625-3.574,2.745-3.657c0.203-0.135,0.452-0.141,0.69-0.025\tc0.691,0.335,2.085,2.405,2.167,3.199v0.027c0.024,0.271-0.082,0.491-0.273,0.623c-0.132,0.083-4.43,1.155-4.43,1.155\tc-0.322,0.096-0.68-0.06-0.882-0.381L11.464,10.789z M9.475,9.563C9.32,9.609,8.848,9.757,8.269,8.817c0,0-3.916-6.16-4.007-6.351\tc-0.057-0.212,0.011-0.455,0.202-0.65C5.047,1.211,8.21,0.327,9.037,0.529c0.27,0.069,0.457,0.238,0.522,0.479\tc0.047,0.266,0.433,5.982,0.488,7.264C10.098,9.368,9.629,9.517,9.475,9.563z M9.927,19.066c-0.083,0.225-0.273,0.373-0.54,0.421\tc-0.762,0.13-3.15-0.751-3.647-1.342c-0.096-0.131-0.155-0.262-0.167-0.394c-0.011-0.095,0-0.189,0.036-0.272\tc0.061-0.155,2.917-3.538,2.917-3.538c0.214-0.272,0.595-0.355,0.952-0.213c0.345,0.13,0.56,0.428,0.536,0.749\tC10.014,14.479,9.977,18.923,9.927,19.066z M3.495,13.912c-0.235-0.009-0.444-0.148-0.568-0.382c-0.089-0.17-0.151-0.453-0.19-0.794\tC2.63,11.701,2.761,10.144,3.07,9.648c0.145-0.226,0.357-0.345,0.592-0.336c0.154,0,4.255,1.667,4.255,1.667\tc0.321,0.118,0.521,0.453,0.5,0.833c-0.023,0.37-0.236,0.655-0.551,0.738L3.495,13.912z\"/></svg>",
        "youtube": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15,4.1c1,0.1,2.3,0,3,0.8c0.8,0.8,0.9,2.1,0.9,3.1C19,9.2,19,10.9,19,12c-0.1,1.1,0,2.4-0.5,3.4c-0.5,1.1-1.4,1.5-2.5,1.6 c-1.2,0.1-8.6,0.1-11,0c-1.1-0.1-2.4-0.1-3.2-1c-0.7-0.8-0.7-2-0.8-3C1,11.8,1,10.1,1,8.9c0-1.1,0-2.4,0.5-3.4C2,4.5,3,4.3,4.1,4.2 C5.3,4.1,12.6,4,15,4.1z M8,7.5v6l5.5-3L8,7.5z\"/></svg>" });

    }

    if (typeof window !== 'undefined' && window.UIkit) {
      window.UIkit.use(plugin);
    }

    return plugin;

}));

},{}],9:[function(require,module,exports){
/*! UIkit 3.13.9 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define('uikit', factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.UIkit = factory());
})(this, (function () { 'use strict';

    const { hasOwnProperty, toString } = Object.prototype;

    function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
    }

    const hyphenateRe = /\B([A-Z])/g;

    const hyphenate = memoize((str) => str.replace(hyphenateRe, '-$1').toLowerCase());

    const camelizeRe = /-(\w)/g;

    const camelize = memoize((str) => str.replace(camelizeRe, toUpper));

    const ucfirst = memoize((str) =>
    str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '');


    function toUpper(_, c) {
      return c ? c.toUpperCase() : '';
    }

    function startsWith(str, search) {
      return str == null ? void 0 : str.startsWith == null ? void 0 : str.startsWith(search);
    }

    function endsWith(str, search) {
      return str == null ? void 0 : str.endsWith == null ? void 0 : str.endsWith(search);
    }

    function includes(obj, search) {
      return obj == null ? void 0 : obj.includes == null ? void 0 : obj.includes(search);
    }

    function findIndex(array, predicate) {
      return array == null ? void 0 : array.findIndex == null ? void 0 : array.findIndex(predicate);
    }

    const { isArray, from: toArray } = Array;
    const { assign } = Object;

    function isFunction(obj) {
      return typeof obj === 'function';
    }

    function isObject(obj) {
      return obj !== null && typeof obj === 'object';
    }

    function isPlainObject(obj) {
      return toString.call(obj) === '[object Object]';
    }

    function isWindow(obj) {
      return isObject(obj) && obj === obj.window;
    }

    function isDocument(obj) {
      return nodeType(obj) === 9;
    }

    function isNode(obj) {
      return nodeType(obj) >= 1;
    }

    function isElement(obj) {
      return nodeType(obj) === 1;
    }

    function nodeType(obj) {
      return !isWindow(obj) && isObject(obj) && obj.nodeType;
    }

    function isBoolean(value) {
      return typeof value === 'boolean';
    }

    function isString(value) {
      return typeof value === 'string';
    }

    function isNumber(value) {
      return typeof value === 'number';
    }

    function isNumeric(value) {
      return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));
    }

    function isEmpty(obj) {
      return !(isArray(obj) ? obj.length : isObject(obj) ? Object.keys(obj).length : false);
    }

    function isUndefined(value) {
      return value === void 0;
    }

    function toBoolean(value) {
      return isBoolean(value) ?
      value :
      value === 'true' || value === '1' || value === '' ?
      true :
      value === 'false' || value === '0' ?
      false :
      value;
    }

    function toNumber(value) {
      const number = Number(value);
      return isNaN(number) ? false : number;
    }

    function toFloat(value) {
      return parseFloat(value) || 0;
    }

    function toNode(element) {
      return toNodes(element)[0];
    }

    function toNodes(element) {
      return element && (isNode(element) ? [element] : Array.from(element).filter(isNode)) || [];
    }

    function toWindow(element) {var _element;
      if (isWindow(element)) {
        return element;
      }

      element = toNode(element);
      const document = isDocument(element) ? element : (_element = element) == null ? void 0 : _element.ownerDocument;

      return (document == null ? void 0 : document.defaultView) || window;
    }

    function toMs(time) {
      return time ? endsWith(time, 'ms') ? toFloat(time) : toFloat(time) * 1000 : 0;
    }

    function isEqual(value, other) {
      return (
        value === other ||
        isObject(value) &&
        isObject(other) &&
        Object.keys(value).length === Object.keys(other).length &&
        each(value, (val, key) => val === other[key]));

    }

    function swap(value, a, b) {
      return value.replace(new RegExp(a + "|" + b, 'g'), (match) => match === a ? b : a);
    }

    function last(array) {
      return array[array.length - 1];
    }

    function each(obj, cb) {
      for (const key in obj) {
        if (false === cb(obj[key], key)) {
          return false;
        }
      }
      return true;
    }

    function sortBy$1(array, prop) {
      return array.
      slice().
      sort((_ref, _ref2) => {let { [prop]: propA = 0 } = _ref;let { [prop]: propB = 0 } = _ref2;return (
          propA > propB ? 1 : propB > propA ? -1 : 0);});

    }

    function uniqueBy(array, prop) {
      const seen = new Set();
      return array.filter((_ref3) => {let { [prop]: check } = _ref3;return seen.has(check) ? false : seen.add(check);});
    }

    function clamp(number, min, max) {if (min === void 0) {min = 0;}if (max === void 0) {max = 1;}
      return Math.min(Math.max(toNumber(number) || 0, min), max);
    }

    function noop() {}

    function intersectRect() {for (var _len = arguments.length, rects = new Array(_len), _key = 0; _key < _len; _key++) {rects[_key] = arguments[_key];}
      return [
      ['bottom', 'top'],
      ['right', 'left']].
      every(
      (_ref4) => {let [minProp, maxProp] = _ref4;return (
          Math.min(...rects.map((_ref5) => {let { [minProp]: min } = _ref5;return min;})) -
          Math.max(...rects.map((_ref6) => {let { [maxProp]: max } = _ref6;return max;})) >
          0);});

    }

    function pointInRect(point, rect) {
      return (
        point.x <= rect.right &&
        point.x >= rect.left &&
        point.y <= rect.bottom &&
        point.y >= rect.top);

    }

    const Dimensions = {
      ratio(dimensions, prop, value) {
        const aProp = prop === 'width' ? 'height' : 'width';

        return {
          [aProp]: dimensions[prop] ?
          Math.round(value * dimensions[aProp] / dimensions[prop]) :
          dimensions[aProp],
          [prop]: value };

      },

      contain(dimensions, maxDimensions) {
        dimensions = { ...dimensions };

        each(
        dimensions,
        (_, prop) =>
        dimensions =
        dimensions[prop] > maxDimensions[prop] ?
        this.ratio(dimensions, prop, maxDimensions[prop]) :
        dimensions);


        return dimensions;
      },

      cover(dimensions, maxDimensions) {
        dimensions = this.contain(dimensions, maxDimensions);

        each(
        dimensions,
        (_, prop) =>
        dimensions =
        dimensions[prop] < maxDimensions[prop] ?
        this.ratio(dimensions, prop, maxDimensions[prop]) :
        dimensions);


        return dimensions;
      } };


    function getIndex(i, elements, current, finite) {if (current === void 0) {current = 0;}if (finite === void 0) {finite = false;}
      elements = toNodes(elements);

      const { length } = elements;

      if (!length) {
        return -1;
      }

      i = isNumeric(i) ?
      toNumber(i) :
      i === 'next' ?
      current + 1 :
      i === 'previous' ?
      current - 1 :
      elements.indexOf(toNode(i));

      if (finite) {
        return clamp(i, 0, length - 1);
      }

      i %= length;

      return i < 0 ? i + length : i;
    }

    function memoize(fn) {
      const cache = Object.create(null);
      return (key) => cache[key] || (cache[key] = fn(key));
    }

    class Deferred {
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this.reject = reject;
          this.resolve = resolve;
        });
      }}

    function attr(element, name, value) {
      if (isObject(name)) {
        for (const key in name) {
          attr(element, key, name[key]);
        }
        return;
      }

      if (isUndefined(value)) {var _toNode;
        return (_toNode = toNode(element)) == null ? void 0 : _toNode.getAttribute(name);
      } else {
        for (const el of toNodes(element)) {
          if (isFunction(value)) {
            value = value.call(el, attr(el, name));
          }

          if (value === null) {
            removeAttr(el, name);
          } else {
            el.setAttribute(name, value);
          }
        }
      }
    }

    function hasAttr(element, name) {
      return toNodes(element).some((element) => element.hasAttribute(name));
    }

    function removeAttr(element, name) {
      const elements = toNodes(element);
      for (const attribute of name.split(' ')) {
        for (const element of elements) {
          element.removeAttribute(attribute);
        }
      }
    }

    function data(element, attribute) {
      for (const name of [attribute, "data-" + attribute]) {
        if (hasAttr(element, name)) {
          return attr(element, name);
        }
      }
    }

    const voidElements = {
      area: true,
      base: true,
      br: true,
      col: true,
      embed: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      menuitem: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true };

    function isVoidElement(element) {
      return toNodes(element).some((element) => voidElements[element.tagName.toLowerCase()]);
    }

    function isVisible(element) {
      return toNodes(element).some(
      (element) => element.offsetWidth || element.offsetHeight || element.getClientRects().length);

    }

    const selInput = 'input,select,textarea,button';
    function isInput(element) {
      return toNodes(element).some((element) => matches(element, selInput));
    }

    const selFocusable = selInput + ",a[href],[tabindex]";
    function isFocusable(element) {
      return matches(element, selFocusable);
    }

    function parent(element) {var _toNode;
      return (_toNode = toNode(element)) == null ? void 0 : _toNode.parentElement;
    }

    function filter$1(element, selector) {
      return toNodes(element).filter((element) => matches(element, selector));
    }

    function matches(element, selector) {
      return toNodes(element).some((element) => element.matches(selector));
    }

    function closest(element, selector) {
      if (startsWith(selector, '>')) {
        selector = selector.slice(1);
      }

      return isElement(element) ?
      element.closest(selector) :
      toNodes(element).
      map((element) => closest(element, selector)).
      filter(Boolean);
    }

    function within(element, selector) {
      return isString(selector) ?
      matches(element, selector) || !!closest(element, selector) :
      element === selector || toNode(selector).contains(toNode(element));
    }

    function parents(element, selector) {
      const elements = [];

      while (element = parent(element)) {
        if (!selector || matches(element, selector)) {
          elements.push(element);
        }
      }

      return elements;
    }

    function children(element, selector) {
      element = toNode(element);
      const children = element ? toNodes(element.children) : [];
      return selector ? filter$1(children, selector) : children;
    }

    function index(element, ref) {
      return ref ? toNodes(element).indexOf(toNode(ref)) : children(parent(element)).indexOf(element);
    }

    function query(selector, context) {
      return find(selector, getContext(selector, context));
    }

    function queryAll(selector, context) {
      return findAll(selector, getContext(selector, context));
    }

    function find(selector, context) {
      return toNode(_query(selector, context, 'querySelector'));
    }

    function findAll(selector, context) {
      return toNodes(_query(selector, context, 'querySelectorAll'));
    }

    const contextSelectorRe = /(^|[^\\],)\s*[!>+~-]/;
    const isContextSelector = memoize((selector) => selector.match(contextSelectorRe));

    function getContext(selector, context) {if (context === void 0) {context = document;}
      return isString(selector) && isContextSelector(selector) || isDocument(context) ?
      context :
      context.ownerDocument;
    }

    const contextSanitizeRe = /([!>+~-])(?=\s+[!>+~-]|\s*$)/g;
    const sanatize = memoize((selector) => selector.replace(contextSanitizeRe, '$1 *'));

    function _query(selector, context, queryFn) {if (context === void 0) {context = document;}
      if (!selector || !isString(selector)) {
        return selector;
      }

      selector = sanatize(selector);

      if (isContextSelector(selector)) {
        const split = splitSelector(selector);
        selector = '';
        for (let sel of split) {
          let ctx = context;

          if (sel[0] === '!') {
            const selectors = sel.substr(1).trim().split(' ');
            ctx = closest(parent(context), selectors[0]);
            sel = selectors.slice(1).join(' ').trim();
            if (!sel.length && split.length === 1) {
              return ctx;
            }
          }

          if (sel[0] === '-') {
            const selectors = sel.substr(1).trim().split(' ');
            const prev = (ctx || context).previousElementSibling;
            ctx = matches(prev, sel.substr(1)) ? prev : null;
            sel = selectors.slice(1).join(' ');
          }

          if (ctx) {
            selector += "" + (selector ? ',' : '') + domPath(ctx) + " " + sel;
          }
        }

        context = document;
      }

      try {
        return context[queryFn](selector);
      } catch (e) {
        return null;
      }
    }

    const selectorRe = /.*?[^\\](?:,|$)/g;

    const splitSelector = memoize((selector) =>
    selector.match(selectorRe).map((selector) => selector.replace(/,$/, '').trim()));


    function domPath(element) {
      const names = [];
      while (element.parentNode) {
        const id = attr(element, 'id');
        if (id) {
          names.unshift("#" + escape(id));
          break;
        } else {
          let { tagName } = element;
          if (tagName !== 'HTML') {
            tagName += ":nth-child(" + (index(element) + 1) + ")";
          }
          names.unshift(tagName);
          element = element.parentNode;
        }
      }
      return names.join(' > ');
    }

    function escape(css) {
      return isString(css) ? CSS.escape(css) : '';
    }

    function on() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
      let [targets, types, selector, listener, useCapture = false] = getArgs(args);

      if (listener.length > 1) {
        listener = detail(listener);
      }

      if (useCapture != null && useCapture.self) {
        listener = selfFilter(listener);
      }

      if (selector) {
        listener = delegate(selector, listener);
      }

      for (const type of types) {
        for (const target of targets) {
          target.addEventListener(type, listener, useCapture);
        }
      }

      return () => off(targets, types, listener, useCapture);
    }

    function off() {for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}
      let [targets, types,, listener, useCapture = false] = getArgs(args);
      for (const type of types) {
        for (const target of targets) {
          target.removeEventListener(type, listener, useCapture);
        }
      }
    }

    function once() {for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {args[_key3] = arguments[_key3];}
      const [element, types, selector, listener, useCapture = false, condition] = getArgs(args);
      const off = on(
      element,
      types,
      selector,
      (e) => {
        const result = !condition || condition(e);
        if (result) {
          off();
          listener(e, result);
        }
      },
      useCapture);


      return off;
    }

    function trigger(targets, event, detail) {
      return toEventTargets(targets).every((target) =>
      target.dispatchEvent(createEvent(event, true, true, detail)));

    }

    function createEvent(e, bubbles, cancelable, detail) {if (bubbles === void 0) {bubbles = true;}if (cancelable === void 0) {cancelable = false;}
      if (isString(e)) {
        e = new CustomEvent(e, { bubbles, cancelable, detail });
      }

      return e;
    }

    function getArgs(args) {
      // Event targets
      args[0] = toEventTargets(args[0]);

      // Event types
      if (isString(args[1])) {
        args[1] = args[1].split(' ');
      }

      // Delegate?
      if (isFunction(args[2])) {
        args.splice(2, 0, false);
      }

      return args;
    }

    function delegate(selector, listener) {
      return (e) => {
        const current =
        selector[0] === '>' ?
        findAll(selector, e.currentTarget).
        reverse().
        filter((element) => within(e.target, element))[0] :
        closest(e.target, selector);

        if (current) {
          e.current = current;
          listener.call(this, e);
        }
      };
    }

    function detail(listener) {
      return (e) => isArray(e.detail) ? listener(e, ...e.detail) : listener(e);
    }

    function selfFilter(listener) {
      return function (e) {
        if (e.target === e.currentTarget || e.target === e.current) {
          return listener.call(null, e);
        }
      };
    }

    function isEventTarget(target) {
      return target && 'addEventListener' in target;
    }

    function toEventTarget(target) {
      return isEventTarget(target) ? target : toNode(target);
    }

    function toEventTargets(target) {
      return isArray(target) ?
      target.map(toEventTarget).filter(Boolean) :
      isString(target) ?
      findAll(target) :
      isEventTarget(target) ?
      [target] :
      toNodes(target);
    }

    function isTouch(e) {
      return e.pointerType === 'touch' || !!e.touches;
    }

    function getEventPos(e) {var _e$touches, _e$changedTouches;
      const { clientX: x, clientY: y } = ((_e$touches = e.touches) == null ? void 0 : _e$touches[0]) || ((_e$changedTouches = e.changedTouches) == null ? void 0 : _e$changedTouches[0]) || e;

      return { x, y };
    }

    function ajax(url, options) {
      const env = {
        data: null,
        method: 'GET',
        headers: {},
        xhr: new XMLHttpRequest(),
        beforeSend: noop,
        responseType: '',
        ...options };

      return Promise.resolve().
      then(() => env.beforeSend(env)).
      then(() => send(url, env));
    }

    function send(url, env) {
      return new Promise((resolve, reject) => {
        const { xhr } = env;

        for (const prop in env) {
          if (prop in xhr) {
            try {
              xhr[prop] = env[prop];
            } catch (e) {
              // noop
            }
          }
        }

        xhr.open(env.method.toUpperCase(), url);

        for (const header in env.headers) {
          xhr.setRequestHeader(header, env.headers[header]);
        }

        on(xhr, 'load', () => {
          if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
            resolve(xhr);
          } else {
            reject(
            assign(Error(xhr.statusText), {
              xhr,
              status: xhr.status }));


          }
        });

        on(xhr, 'error', () => reject(assign(Error('Network Error'), { xhr })));
        on(xhr, 'timeout', () => reject(assign(Error('Network Timeout'), { xhr })));

        xhr.send(env.data);
      });
    }

    function getImage(src, srcset, sizes) {
      return new Promise((resolve, reject) => {
        const img = new Image();

        img.onerror = (e) => {
          reject(e);
        };
        img.onload = () => {
          resolve(img);
        };

        sizes && (img.sizes = sizes);
        srcset && (img.srcset = srcset);
        img.src = src;
      });
    }

    const cssNumber = {
      'animation-iteration-count': true,
      'column-count': true,
      'fill-opacity': true,
      'flex-grow': true,
      'flex-shrink': true,
      'font-weight': true,
      'line-height': true,
      opacity: true,
      order: true,
      orphans: true,
      'stroke-dasharray': true,
      'stroke-dashoffset': true,
      widows: true,
      'z-index': true,
      zoom: true };


    function css(element, property, value, priority) {if (priority === void 0) {priority = '';}
      const elements = toNodes(element);
      for (const element of elements) {
        if (isString(property)) {
          property = propName(property);

          if (isUndefined(value)) {
            return getComputedStyle(element).getPropertyValue(property);
          } else {
            element.style.setProperty(
            property,
            isNumeric(value) && !cssNumber[property] ?
            value + "px" :
            value || isNumber(value) ?
            value :
            '',
            priority);

          }
        } else if (isArray(property)) {
          const props = {};
          for (const prop of property) {
            props[prop] = css(element, prop);
          }
          return props;
        } else if (isObject(property)) {
          priority = value;
          each(property, (value, property) => css(element, property, value, priority));
        }
      }
      return elements[0];
    }

    const propertyRe = /^\s*(["'])?(.*?)\1\s*$/;
    function getCssVar(name, element) {if (element === void 0) {element = document.documentElement;}
      return css(element, "--uk-" + name).replace(propertyRe, '$2');
    }

    // https://drafts.csswg.org/cssom/#dom-cssstyledeclaration-setproperty
    const propName = memoize((name) => vendorPropName(name));

    const cssPrefixes = ['webkit', 'moz'];

    function vendorPropName(name) {
      if (name[0] === '-') {
        return name;
      }

      name = hyphenate(name);

      const { style } = document.documentElement;

      if (name in style) {
        return name;
      }

      let i = cssPrefixes.length,
      prefixedName;

      while (i--) {
        prefixedName = "-" + cssPrefixes[i] + "-" + name;
        if (prefixedName in style) {
          return prefixedName;
        }
      }
    }

    function addClass(element) {for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {args[_key - 1] = arguments[_key];}
      apply$1(element, args, 'add');
    }

    function removeClass(element) {for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {args[_key2 - 1] = arguments[_key2];}
      apply$1(element, args, 'remove');
    }

    function removeClasses(element, cls) {
      attr(element, 'class', (value) => (value || '').replace(new RegExp("\\b" + cls + "\\b", 'g'), ''));
    }

    function replaceClass(element) {
      (arguments.length <= 1 ? undefined : arguments[1]) && removeClass(element, arguments.length <= 1 ? undefined : arguments[1]);
      (arguments.length <= 2 ? undefined : arguments[2]) && addClass(element, arguments.length <= 2 ? undefined : arguments[2]);
    }

    function hasClass(element, cls) {
      [cls] = getClasses(cls);
      return !!cls && toNodes(element).some((node) => node.classList.contains(cls));
    }

    function toggleClass(element, cls, force) {
      const classes = getClasses(cls);

      if (!isUndefined(force)) {
        force = !!force;
      }

      for (const node of toNodes(element)) {
        for (const cls of classes) {
          node.classList.toggle(cls, force);
        }
      }
    }

    function apply$1(element, args, fn) {
      args = args.reduce((args, arg) => args.concat(getClasses(arg)), []);

      for (const node of toNodes(element)) {
        node.classList[fn](...args);
      }
    }

    function getClasses(str) {
      return String(str).split(/\s|,/).filter(Boolean);
    }

    function transition(element, props, duration, timing) {if (duration === void 0) {duration = 400;}if (timing === void 0) {timing = 'linear';}
      return Promise.all(
      toNodes(element).map(
      (element) =>
      new Promise((resolve, reject) => {
        for (const name in props) {
          const value = css(element, name);
          if (value === '') {
            css(element, name, value);
          }
        }

        const timer = setTimeout(() => trigger(element, 'transitionend'), duration);

        once(
        element,
        'transitionend transitioncanceled',
        (_ref) => {let { type } = _ref;
          clearTimeout(timer);
          removeClass(element, 'uk-transition');
          css(element, {
            transitionProperty: '',
            transitionDuration: '',
            transitionTimingFunction: '' });

          type === 'transitioncanceled' ? reject() : resolve(element);
        },
        { self: true });


        addClass(element, 'uk-transition');
        css(element, {
          transitionProperty: Object.keys(props).map(propName).join(','),
          transitionDuration: duration + "ms",
          transitionTimingFunction: timing,
          ...props });

      })));


    }

    const Transition = {
      start: transition,

      stop(element) {
        trigger(element, 'transitionend');
        return Promise.resolve();
      },

      cancel(element) {
        trigger(element, 'transitioncanceled');
      },

      inProgress(element) {
        return hasClass(element, 'uk-transition');
      } };


    const animationPrefix = 'uk-animation-';

    function animate$1(element, animation, duration, origin, out) {if (duration === void 0) {duration = 200;}
      return Promise.all(
      toNodes(element).map(
      (element) =>
      new Promise((resolve, reject) => {
        trigger(element, 'animationcanceled');
        const timer = setTimeout(() => trigger(element, 'animationend'), duration);

        once(
        element,
        'animationend animationcanceled',
        (_ref2) => {let { type } = _ref2;
          clearTimeout(timer);

          type === 'animationcanceled' ? reject() : resolve(element);

          css(element, 'animationDuration', '');
          removeClasses(element, animationPrefix + "\\S*");
        },
        { self: true });


        css(element, 'animationDuration', duration + "ms");
        addClass(element, animation, animationPrefix + (out ? 'leave' : 'enter'));

        if (startsWith(animation, animationPrefix)) {
          origin && addClass(element, "uk-transform-origin-" + origin);
          out && addClass(element, animationPrefix + "reverse");
        }
      })));


    }

    const inProgress = new RegExp(animationPrefix + "(enter|leave)");
    const Animation = {
      in: animate$1,

      out(element, animation, duration, origin) {
        return animate$1(element, animation, duration, origin, true);
      },

      inProgress(element) {
        return inProgress.test(attr(element, 'class'));
      },

      cancel(element) {
        trigger(element, 'animationcanceled');
      } };

    const dirs$1 = {
      width: ['left', 'right'],
      height: ['top', 'bottom'] };


    function dimensions$1(element) {
      const rect = isElement(element) ?
      toNode(element).getBoundingClientRect() :
      { height: height(element), width: width(element), top: 0, left: 0 };

      return {
        height: rect.height,
        width: rect.width,
        top: rect.top,
        left: rect.left,
        bottom: rect.top + rect.height,
        right: rect.left + rect.width };

    }

    function offset(element, coordinates) {
      const currentOffset = dimensions$1(element);

      if (element) {
        const { scrollY, scrollX } = toWindow(element);
        const offsetBy = { height: scrollY, width: scrollX };

        for (const dir in dirs$1) {
          for (const prop of dirs$1[dir]) {
            currentOffset[prop] += offsetBy[dir];
          }
        }
      }

      if (!coordinates) {
        return currentOffset;
      }

      const pos = css(element, 'position');

      each(css(element, ['left', 'top']), (value, prop) =>
      css(
      element,
      prop,
      coordinates[prop] -
      currentOffset[prop] +
      toFloat(pos === 'absolute' && value === 'auto' ? position(element)[prop] : value)));


    }

    function position(element) {
      let { top, left } = offset(element);

      const {
        ownerDocument: { body, documentElement },
        offsetParent } =
      toNode(element);
      let parent = offsetParent || documentElement;

      while (
      parent && (
      parent === body || parent === documentElement) &&
      css(parent, 'position') === 'static')
      {
        parent = parent.parentNode;
      }

      if (isElement(parent)) {
        const parentOffset = offset(parent);
        top -= parentOffset.top + toFloat(css(parent, 'borderTopWidth'));
        left -= parentOffset.left + toFloat(css(parent, 'borderLeftWidth'));
      }

      return {
        top: top - toFloat(css(element, 'marginTop')),
        left: left - toFloat(css(element, 'marginLeft')) };

    }

    function offsetPosition(element) {
      const offset = [0, 0];

      element = toNode(element);

      do {
        offset[0] += element.offsetTop;
        offset[1] += element.offsetLeft;

        if (css(element, 'position') === 'fixed') {
          const win = toWindow(element);
          offset[0] += win.scrollY;
          offset[1] += win.scrollX;
          return offset;
        }
      } while (element = element.offsetParent);

      return offset;
    }

    const height = dimension('height');
    const width = dimension('width');

    function dimension(prop) {
      const propName = ucfirst(prop);
      return (element, value) => {
        if (isUndefined(value)) {
          if (isWindow(element)) {
            return element["inner" + propName];
          }

          if (isDocument(element)) {
            const doc = element.documentElement;
            return Math.max(doc["offset" + propName], doc["scroll" + propName]);
          }

          element = toNode(element);

          value = css(element, prop);
          value = value === 'auto' ? element["offset" + propName] : toFloat(value) || 0;

          return value - boxModelAdjust(element, prop);
        } else {
          return css(
          element,
          prop,
          !value && value !== 0 ? '' : +value + boxModelAdjust(element, prop) + 'px');

        }
      };
    }

    function boxModelAdjust(element, prop, sizing) {if (sizing === void 0) {sizing = 'border-box';}
      return css(element, 'boxSizing') === sizing ?
      dirs$1[prop].
      map(ucfirst).
      reduce(
      (value, prop) =>
      value +
      toFloat(css(element, "padding" + prop)) +
      toFloat(css(element, "border" + prop + "Width")),
      0) :

      0;
    }

    function flipPosition(pos) {
      for (const dir in dirs$1) {
        for (const i in dirs$1[dir]) {
          if (dirs$1[dir][i] === pos) {
            return dirs$1[dir][1 - i];
          }
        }
      }
      return pos;
    }

    function toPx(value, property, element, offsetDim) {if (property === void 0) {property = 'width';}if (element === void 0) {element = window;}if (offsetDim === void 0) {offsetDim = false;}
      if (!isString(value)) {
        return toFloat(value);
      }

      return parseCalc(value).reduce((result, value) => {
        const unit = parseUnit(value);
        if (unit) {
          value = percent(
          unit === 'vh' ?
          height(toWindow(element)) :
          unit === 'vw' ?
          width(toWindow(element)) :
          offsetDim ?
          element["offset" + ucfirst(property)] :
          dimensions$1(element)[property],
          value);

        }

        return result + toFloat(value);
      }, 0);
    }

    const calcRe = /-?\d+(?:\.\d+)?(?:v[wh]|%|px)?/g;
    const parseCalc = memoize((calc) => calc.toString().replace(/\s/g, '').match(calcRe) || []);
    const unitRe$1 = /(?:v[hw]|%)$/;
    const parseUnit = memoize((str) => (str.match(unitRe$1) || [])[0]);

    function percent(base, value) {
      return base * toFloat(value) / 100;
    }

    function ready(fn) {
      if (document.readyState !== 'loading') {
        fn();
        return;
      }

      once(document, 'DOMContentLoaded', fn);
    }

    function isTag(element, tagName) {var _element$tagName;
      return (element == null ? void 0 : (_element$tagName = element.tagName) == null ? void 0 : _element$tagName.toLowerCase()) === tagName.toLowerCase();
    }

    function empty(element) {
      return replaceChildren(element, '');
    }

    function html(parent, html) {
      return isUndefined(html) ? $(parent).innerHTML : replaceChildren(parent, html);
    }

    const replaceChildren = applyFn('replaceChildren');
    const prepend = applyFn('prepend');
    const append = applyFn('append');
    const before = applyFn('before');
    const after = applyFn('after');

    function applyFn(fn) {
      return function (ref, element) {var _$;
        const nodes = toNodes(isString(element) ? fragment(element) : element);
        (_$ = $(ref)) == null ? void 0 : _$[fn](...nodes);
        return unwrapSingle(nodes);
      };
    }

    function remove$1(element) {
      toNodes(element).forEach((element) => element.remove());
    }

    function wrapAll(element, structure) {
      structure = toNode(before(element, structure));

      while (structure.firstChild) {
        structure = structure.firstChild;
      }

      append(structure, element);

      return structure;
    }

    function wrapInner(element, structure) {
      return toNodes(
      toNodes(element).map((element) =>
      element.hasChildNodes() ?
      wrapAll(toNodes(element.childNodes), structure) :
      append(element, structure)));


    }

    function unwrap(element) {
      toNodes(element).
      map(parent).
      filter((value, index, self) => self.indexOf(value) === index).
      forEach((parent) => parent.replaceWith(...parent.childNodes));
    }

    const fragmentRe = /^\s*<(\w+|!)[^>]*>/;
    const singleTagRe = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;

    function fragment(html) {
      const matches = singleTagRe.exec(html);
      if (matches) {
        return document.createElement(matches[1]);
      }

      const container = document.createElement('div');
      if (fragmentRe.test(html)) {
        container.insertAdjacentHTML('beforeend', html.trim());
      } else {
        container.textContent = html;
      }

      return unwrapSingle(container.childNodes);
    }

    function unwrapSingle(nodes) {
      return nodes.length > 1 ? nodes : nodes[0];
    }

    function apply(node, fn) {
      if (!isElement(node)) {
        return;
      }

      fn(node);
      node = node.firstElementChild;
      while (node) {
        const next = node.nextElementSibling;
        apply(node, fn);
        node = next;
      }
    }

    function $(selector, context) {
      return isHtml(selector) ? toNode(fragment(selector)) : find(selector, context);
    }

    function $$(selector, context) {
      return isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context);
    }

    function isHtml(str) {
      return isString(str) && startsWith(str.trim(), '<');
    }

    const inBrowser = typeof window !== 'undefined';
    const isRtl = inBrowser && attr(document.documentElement, 'dir') === 'rtl';

    const hasTouch = inBrowser && 'ontouchstart' in window;
    const hasPointerEvents = inBrowser && window.PointerEvent;

    const pointerDown = hasPointerEvents ? 'pointerdown' : hasTouch ? 'touchstart' : 'mousedown';
    const pointerMove = hasPointerEvents ? 'pointermove' : hasTouch ? 'touchmove' : 'mousemove';
    const pointerUp = hasPointerEvents ? 'pointerup' : hasTouch ? 'touchend' : 'mouseup';
    const pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouch ? '' : 'mouseenter';
    const pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouch ? '' : 'mouseleave';
    const pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';

    /*
        Based on:
        Copyright (c) 2016 Wilson Page wilsonpage@me.com
        https://github.com/wilsonpage/fastdom
    */

    const fastdom = {
      reads: [],
      writes: [],

      read(task) {
        this.reads.push(task);
        scheduleFlush();
        return task;
      },

      write(task) {
        this.writes.push(task);
        scheduleFlush();
        return task;
      },

      clear(task) {
        remove(this.reads, task);
        remove(this.writes, task);
      },

      flush };


    function flush(recursion) {
      runTasks(fastdom.reads);
      runTasks(fastdom.writes.splice(0));

      fastdom.scheduled = false;

      if (fastdom.reads.length || fastdom.writes.length) {
        scheduleFlush(recursion + 1);
      }
    }

    const RECURSION_LIMIT = 4;
    function scheduleFlush(recursion) {
      if (fastdom.scheduled) {
        return;
      }

      fastdom.scheduled = true;
      if (recursion && recursion < RECURSION_LIMIT) {
        Promise.resolve().then(() => flush(recursion));
      } else {
        requestAnimationFrame(() => flush(1));
      }
    }

    function runTasks(tasks) {
      let task;
      while (task = tasks.shift()) {
        try {
          task();
        } catch (e) {
          console.error(e);
        }
      }
    }

    function remove(array, item) {
      const index = array.indexOf(item);
      return ~index && array.splice(index, 1);
    }

    function MouseTracker() {}

    MouseTracker.prototype = {
      positions: [],

      init() {
        this.positions = [];

        let position;
        this.unbind = on(document, 'mousemove', (e) => position = getEventPos(e));
        this.interval = setInterval(() => {
          if (!position) {
            return;
          }

          this.positions.push(position);

          if (this.positions.length > 5) {
            this.positions.shift();
          }
        }, 50);
      },

      cancel() {var _this$unbind;
        (_this$unbind = this.unbind) == null ? void 0 : _this$unbind.call(this);
        this.interval && clearInterval(this.interval);
      },

      movesTo(target) {
        if (this.positions.length < 2) {
          return false;
        }

        const p = target.getBoundingClientRect();
        const { left, right, top, bottom } = p;

        const [prevPosition] = this.positions;
        const position = last(this.positions);
        const path = [prevPosition, position];

        if (pointInRect(position, p)) {
          return false;
        }

        const diagonals = [
        [
        { x: left, y: top },
        { x: right, y: bottom }],

        [
        { x: left, y: bottom },
        { x: right, y: top }]];



        return diagonals.some((diagonal) => {
          const intersection = intersect(path, diagonal);
          return intersection && pointInRect(intersection, p);
        });
      } };


    // Inspired by http://paulbourke.net/geometry/pointlineplane/
    function intersect(_ref, _ref2) {let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = _ref;let [{ x: x3, y: y3 }, { x: x4, y: y4 }] = _ref2;
      const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

      // Lines are parallel
      if (denominator === 0) {
        return false;
      }

      const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;

      if (ua < 0) {
        return false;
      }

      // Return an object with the x and y coordinates of the intersection
      return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };
    }

    function observeIntersection(targets, cb, options, intersecting) {if (intersecting === void 0) {intersecting = true;}
      const observer = new IntersectionObserver(
      intersecting ?
      (entries, observer) => {
        if (entries.some((entry) => entry.isIntersecting)) {
          cb(entries, observer);
        }
      } :
      cb,
      options);

      for (const el of toNodes(targets)) {
        observer.observe(el);
      }

      return observer;
    }

    const hasResizeObserver = inBrowser && window.ResizeObserver;
    function observeResize(targets, cb, options) {if (options === void 0) {options = { box: 'border-box' };}
      if (hasResizeObserver) {
        return observe(ResizeObserver, targets, cb, options);
      }

      // Fallback Safari < 13.1
      initResizeListener();
      listeners.add(cb);

      return {
        disconnect() {
          listeners.delete(cb);
        } };

    }

    let listeners;
    function initResizeListener() {
      if (listeners) {
        return;
      }

      listeners = new Set();

      // throttle 'resize'
      let pendingResize;
      const handleResize = () => {
        if (pendingResize) {
          return;
        }
        pendingResize = true;
        fastdom.read(() => pendingResize = false);
        for (const listener of listeners) {
          listener();
        }
      };

      on(window, 'load resize', handleResize);
      on(document, 'loadedmetadata load', handleResize, true);
    }

    function observeMutation(targets, cb, options) {
      return observe(MutationObserver, targets, cb, options);
    }

    function observe(Observer, targets, cb, options) {
      const observer = new Observer(cb);
      for (const el of toNodes(targets)) {
        observer.observe(el, options);
      }

      return observer;
    }

    const strats = {};

    strats.events =
    strats.created =
    strats.beforeConnect =
    strats.connected =
    strats.beforeDisconnect =
    strats.disconnected =
    strats.destroy =
    concatStrat;

    // args strategy
    strats.args = function (parentVal, childVal) {
      return childVal !== false && concatStrat(childVal || parentVal);
    };

    // update strategy
    strats.update = function (parentVal, childVal) {
      return sortBy$1(
      concatStrat(parentVal, isFunction(childVal) ? { read: childVal } : childVal),
      'order');

    };

    // property strategy
    strats.props = function (parentVal, childVal) {
      if (isArray(childVal)) {
        const value = {};
        for (const key of childVal) {
          value[key] = String;
        }
        childVal = value;
      }

      return strats.methods(parentVal, childVal);
    };

    // extend strategy
    strats.computed = strats.methods = function (parentVal, childVal) {
      return childVal ? parentVal ? { ...parentVal, ...childVal } : childVal : parentVal;
    };

    // data strategy
    strats.data = function (parentVal, childVal, vm) {
      if (!vm) {
        if (!childVal) {
          return parentVal;
        }

        if (!parentVal) {
          return childVal;
        }

        return function (vm) {
          return mergeFnData(parentVal, childVal, vm);
        };
      }

      return mergeFnData(parentVal, childVal, vm);
    };

    function mergeFnData(parentVal, childVal, vm) {
      return strats.computed(
      isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal,
      isFunction(childVal) ? childVal.call(vm, vm) : childVal);

    }

    // concat strategy
    function concatStrat(parentVal, childVal) {
      parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;

      return childVal ?
      parentVal ?
      parentVal.concat(childVal) :
      isArray(childVal) ?
      childVal :
      [childVal] :
      parentVal;
    }

    // default strategy
    function defaultStrat(parentVal, childVal) {
      return isUndefined(childVal) ? parentVal : childVal;
    }

    function mergeOptions(parent, child, vm) {
      const options = {};

      if (isFunction(child)) {
        child = child.options;
      }

      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }

      if (child.mixins) {
        for (const mixin of child.mixins) {
          parent = mergeOptions(parent, mixin, vm);
        }
      }

      for (const key in parent) {
        mergeKey(key);
      }

      for (const key in child) {
        if (!hasOwn(parent, key)) {
          mergeKey(key);
        }
      }

      function mergeKey(key) {
        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);
      }

      return options;
    }

    function parseOptions(options, args) {if (args === void 0) {args = [];}
      try {
        return options ?
        startsWith(options, '{') ?
        JSON.parse(options) :
        args.length && !includes(options, ':') ?
        { [args[0]]: options } :
        options.split(';').reduce((options, option) => {
          const [key, value] = option.split(/:(.*)/);
          if (key && !isUndefined(value)) {
            options[key.trim()] = value.trim();
          }
          return options;
        }, {}) :
        {};
      } catch (e) {
        return {};
      }
    }

    function play(el) {
      if (isIFrame(el)) {
        call(el, { func: 'playVideo', method: 'play' });
      }

      if (isHTML5(el)) {
        try {
          el.play().catch(noop);
        } catch (e) {
          // noop
        }
      }
    }

    function pause(el) {
      if (isIFrame(el)) {
        call(el, { func: 'pauseVideo', method: 'pause' });
      }

      if (isHTML5(el)) {
        el.pause();
      }
    }

    function mute(el) {
      if (isIFrame(el)) {
        call(el, { func: 'mute', method: 'setVolume', value: 0 });
      }

      if (isHTML5(el)) {
        el.muted = true;
      }
    }

    function isVideo(el) {
      return isHTML5(el) || isIFrame(el);
    }

    function isHTML5(el) {
      return isTag(el, 'video');
    }

    function isIFrame(el) {
      return isTag(el, 'iframe') && (isYoutube(el) || isVimeo(el));
    }

    function isYoutube(el) {
      return !!el.src.match(
      /\/\/.*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.*/);

    }

    function isVimeo(el) {
      return !!el.src.match(/vimeo\.com\/video\/.*/);
    }

    async function call(el, cmd) {
      await enableApi(el);
      post(el, cmd);
    }

    function post(el, cmd) {
      try {
        el.contentWindow.postMessage(JSON.stringify({ event: 'command', ...cmd }), '*');
      } catch (e) {
        // noop
      }
    }

    const stateKey = '_ukPlayer';
    let counter = 0;
    function enableApi(el) {
      if (el[stateKey]) {
        return el[stateKey];
      }

      const youtube = isYoutube(el);
      const vimeo = isVimeo(el);

      const id = ++counter;
      let poller;

      return el[stateKey] = new Promise((resolve) => {
        youtube &&
        once(el, 'load', () => {
          const listener = () => post(el, { event: 'listening', id });
          poller = setInterval(listener, 100);
          listener();
        });

        once(window, 'message', resolve, false, (_ref) => {let { data } = _ref;
          try {
            data = JSON.parse(data);
            return (
              data && (
              youtube && data.id === id && data.event === 'onReady' ||
              vimeo && Number(data.player_id) === id));

          } catch (e) {
            // noop
          }
        });

        el.src = "" + el.src + (includes(el.src, '?') ? '&' : '?') + (
        youtube ? 'enablejsapi=1' : "api=1&player_id=" + id);

      }).then(() => clearInterval(poller));
    }

    function isInView(element, offsetTop, offsetLeft) {if (offsetTop === void 0) {offsetTop = 0;}if (offsetLeft === void 0) {offsetLeft = 0;}
      if (!isVisible(element)) {
        return false;
      }

      return intersectRect(
      ...scrollParents(element).
      map((parent) => {
        const { top, left, bottom, right } = offset(getViewport$1(parent));

        return {
          top: top - offsetTop,
          left: left - offsetLeft,
          bottom: bottom + offsetTop,
          right: right + offsetLeft };

      }).
      concat(offset(element)));

    }

    function scrollTop(element, top) {
      if (isWindow(element) || isDocument(element)) {
        element = getScrollingElement(element);
      } else {
        element = toNode(element);
      }

      if (isUndefined(top)) {
        return element.scrollTop;
      } else {
        element.scrollTop = top;
      }
    }

    function scrollIntoView(element, _temp) {let { offset: offsetBy = 0 } = _temp === void 0 ? {} : _temp;
      const parents = isVisible(element) ? scrollParents(element) : [];
      return parents.reduce(
      (fn, scrollElement, i) => {
        const { scrollTop, scrollHeight, offsetHeight } = scrollElement;
        const maxScroll = scrollHeight - getViewportClientHeight(scrollElement);
        const { height: elHeight, top: elTop } = offset(parents[i - 1] || element);

        let top = Math.ceil(
        elTop - offset(getViewport$1(scrollElement)).top - offsetBy + scrollTop);


        if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) {
          top += offsetBy;
        } else {
          offsetBy = 0;
        }

        if (top > maxScroll) {
          offsetBy -= top - maxScroll;
          top = maxScroll;
        } else if (top < 0) {
          offsetBy -= top;
          top = 0;
        }

        return () => scrollTo(scrollElement, top - scrollTop).then(fn);
      },
      () => Promise.resolve())();


      function scrollTo(element, top) {
        return new Promise((resolve) => {
          const scroll = element.scrollTop;
          const duration = getDuration(Math.abs(top));
          const start = Date.now();

          (function step() {
            const percent = ease(clamp((Date.now() - start) / duration));

            scrollTop(element, scroll + top * percent);

            // scroll more if we have not reached our destination
            if (percent === 1) {
              resolve();
            } else {
              requestAnimationFrame(step);
            }
          })();
        });
      }

      function getDuration(dist) {
        return 40 * Math.pow(dist, 0.375);
      }

      function ease(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      }
    }

    function scrolledOver(element, startOffset, endOffset) {if (startOffset === void 0) {startOffset = 0;}if (endOffset === void 0) {endOffset = 0;}
      if (!isVisible(element)) {
        return 0;
      }

      const [scrollElement] = scrollParents(element, /auto|scroll/, true);
      const { scrollHeight, scrollTop } = scrollElement;
      const viewportHeight = getViewportClientHeight(scrollElement);
      const maxScroll = scrollHeight - viewportHeight;
      const elementOffsetTop = offsetPosition(element)[0] - offsetPosition(scrollElement)[0];

      const start = Math.max(0, elementOffsetTop - viewportHeight + startOffset);
      const end = Math.min(maxScroll, elementOffsetTop + element.offsetHeight - endOffset);

      return clamp((scrollTop - start) / (end - start));
    }

    function scrollParents(element, overflowRe, scrollable) {if (overflowRe === void 0) {overflowRe = /auto|scroll|hidden/;}if (scrollable === void 0) {scrollable = false;}
      const scrollEl = getScrollingElement(element);

      let ancestors = parents(element).reverse();
      ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1);

      const fixedIndex = findIndex(ancestors, (el) => css(el, 'position') === 'fixed');
      if (~fixedIndex) {
        ancestors = ancestors.slice(fixedIndex);
      }

      return [scrollEl].
      concat(
      ancestors.filter(
      (parent) =>
      overflowRe.test(css(parent, 'overflow')) && (
      !scrollable || parent.scrollHeight > getViewportClientHeight(parent)))).


      reverse();
    }

    function getViewport$1(scrollElement) {
      return scrollElement === getScrollingElement(scrollElement) ? window : scrollElement;
    }

    // iOS 12 returns <body> as scrollingElement
    function getViewportClientHeight(scrollElement) {
      return (
      scrollElement === getScrollingElement(scrollElement) ?
      document.documentElement :
      scrollElement).
      clientHeight;
    }

    function getScrollingElement(element) {
      const { document } = toWindow(element);
      return document.scrollingElement || document.documentElement;
    }

    const dirs = {
      width: ['x', 'left', 'right'],
      height: ['y', 'top', 'bottom'] };


    function positionAt(
    element,
    target,
    elAttach,
    targetAttach,
    elOffset,
    targetOffset,
    flip,
    boundary)
    {
      elAttach = getPos(elAttach);
      targetAttach = getPos(targetAttach);

      const flipped = { element: elAttach, target: targetAttach };

      if (!element || !target) {
        return flipped;
      }

      const dim = offset(element);
      const targetDim = offset(target);
      const position = targetDim;

      moveTo(position, elAttach, dim, -1);
      moveTo(position, targetAttach, targetDim, 1);

      elOffset = getOffsets(elOffset, dim.width, dim.height);
      targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);

      elOffset['x'] += targetOffset['x'];
      elOffset['y'] += targetOffset['y'];

      position.left += elOffset['x'];
      position.top += elOffset['y'];

      if (flip) {
        let boundaries = scrollParents(element).map(getViewport$1);

        if (boundary && !includes(boundaries, boundary)) {
          boundaries.unshift(boundary);
        }

        boundaries = boundaries.map((el) => offset(el));

        each(dirs, (_ref, prop) => {let [dir, align, alignFlip] = _ref;
          if (!(flip === true || includes(flip, dir))) {
            return;
          }

          boundaries.some((boundary) => {
            const elemOffset =
            elAttach[dir] === align ?
            -dim[prop] :
            elAttach[dir] === alignFlip ?
            dim[prop] :
            0;

            const targetOffset =
            targetAttach[dir] === align ?
            targetDim[prop] :
            targetAttach[dir] === alignFlip ?
            -targetDim[prop] :
            0;

            if (
            position[align] < boundary[align] ||
            position[align] + dim[prop] > boundary[alignFlip])
            {
              const centerOffset = dim[prop] / 2;
              const centerTargetOffset =
              targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;

              return (
                elAttach[dir] === 'center' && (
                apply(centerOffset, centerTargetOffset) ||
                apply(-centerOffset, -centerTargetOffset)) ||
                apply(elemOffset, targetOffset));

            }

            function apply(elemOffset, targetOffset) {
              const newVal = toFloat(
              (position[align] + elemOffset + targetOffset - elOffset[dir] * 2).toFixed(4));


              if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {
                position[align] = newVal;

                for (const el of ['element', 'target']) {
                  if (elemOffset) {
                    flipped[el][dir] =
                    flipped[el][dir] === dirs[prop][1] ?
                    dirs[prop][2] :
                    dirs[prop][1];
                  }
                }

                return true;
              }
            }
          });
        });
      }

      offset(element, position);

      return flipped;
    }

    function moveTo(position, attach, dim, factor) {
      each(dirs, (_ref2, prop) => {let [dir, align, alignFlip] = _ref2;
        if (attach[dir] === alignFlip) {
          position[align] += dim[prop] * factor;
        } else if (attach[dir] === 'center') {
          position[align] += dim[prop] * factor / 2;
        }
      });
    }

    function getPos(pos) {
      const x = /left|center|right/;
      const y = /top|center|bottom/;

      pos = (pos || '').split(' ');

      if (pos.length === 1) {
        pos = x.test(pos[0]) ?
        pos.concat('center') :
        y.test(pos[0]) ?
        ['center'].concat(pos) :
        ['center', 'center'];
      }

      return {
        x: x.test(pos[0]) ? pos[0] : 'center',
        y: y.test(pos[1]) ? pos[1] : 'center' };

    }

    function getOffsets(offsets, width, height) {
      const [x, y] = (offsets || '').split(' ');

      return {
        x: x ? toFloat(x) * (endsWith(x, '%') ? width / 100 : 1) : 0,
        y: y ? toFloat(y) * (endsWith(y, '%') ? height / 100 : 1) : 0 };

    }

    var util = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ajax: ajax,
        getImage: getImage,
        transition: transition,
        Transition: Transition,
        animate: animate$1,
        Animation: Animation,
        attr: attr,
        hasAttr: hasAttr,
        removeAttr: removeAttr,
        data: data,
        addClass: addClass,
        removeClass: removeClass,
        removeClasses: removeClasses,
        replaceClass: replaceClass,
        hasClass: hasClass,
        toggleClass: toggleClass,
        dimensions: dimensions$1,
        offset: offset,
        position: position,
        offsetPosition: offsetPosition,
        height: height,
        width: width,
        boxModelAdjust: boxModelAdjust,
        flipPosition: flipPosition,
        toPx: toPx,
        ready: ready,
        isTag: isTag,
        empty: empty,
        html: html,
        replaceChildren: replaceChildren,
        prepend: prepend,
        append: append,
        before: before,
        after: after,
        remove: remove$1,
        wrapAll: wrapAll,
        wrapInner: wrapInner,
        unwrap: unwrap,
        fragment: fragment,
        apply: apply,
        $: $,
        $$: $$,
        inBrowser: inBrowser,
        isRtl: isRtl,
        hasTouch: hasTouch,
        pointerDown: pointerDown,
        pointerMove: pointerMove,
        pointerUp: pointerUp,
        pointerEnter: pointerEnter,
        pointerLeave: pointerLeave,
        pointerCancel: pointerCancel,
        on: on,
        off: off,
        once: once,
        trigger: trigger,
        createEvent: createEvent,
        toEventTargets: toEventTargets,
        isTouch: isTouch,
        getEventPos: getEventPos,
        fastdom: fastdom,
        isVoidElement: isVoidElement,
        isVisible: isVisible,
        selInput: selInput,
        isInput: isInput,
        selFocusable: selFocusable,
        isFocusable: isFocusable,
        parent: parent,
        filter: filter$1,
        matches: matches,
        closest: closest,
        within: within,
        parents: parents,
        children: children,
        index: index,
        hasOwn: hasOwn,
        hyphenate: hyphenate,
        camelize: camelize,
        ucfirst: ucfirst,
        startsWith: startsWith,
        endsWith: endsWith,
        includes: includes,
        findIndex: findIndex,
        isArray: isArray,
        toArray: toArray,
        assign: assign,
        isFunction: isFunction,
        isObject: isObject,
        isPlainObject: isPlainObject,
        isWindow: isWindow,
        isDocument: isDocument,
        isNode: isNode,
        isElement: isElement,
        isBoolean: isBoolean,
        isString: isString,
        isNumber: isNumber,
        isNumeric: isNumeric,
        isEmpty: isEmpty,
        isUndefined: isUndefined,
        toBoolean: toBoolean,
        toNumber: toNumber,
        toFloat: toFloat,
        toNode: toNode,
        toNodes: toNodes,
        toWindow: toWindow,
        toMs: toMs,
        isEqual: isEqual,
        swap: swap,
        last: last,
        each: each,
        sortBy: sortBy$1,
        uniqueBy: uniqueBy,
        clamp: clamp,
        noop: noop,
        intersectRect: intersectRect,
        pointInRect: pointInRect,
        Dimensions: Dimensions,
        getIndex: getIndex,
        memoize: memoize,
        Deferred: Deferred,
        MouseTracker: MouseTracker,
        observeIntersection: observeIntersection,
        observeResize: observeResize,
        observeMutation: observeMutation,
        mergeOptions: mergeOptions,
        parseOptions: parseOptions,
        play: play,
        pause: pause,
        mute: mute,
        isVideo: isVideo,
        positionAt: positionAt,
        query: query,
        queryAll: queryAll,
        find: find,
        findAll: findAll,
        escape: escape,
        css: css,
        getCssVar: getCssVar,
        propName: propName,
        isInView: isInView,
        scrollTop: scrollTop,
        scrollIntoView: scrollIntoView,
        scrolledOver: scrolledOver,
        scrollParents: scrollParents,
        getViewport: getViewport$1,
        getViewportClientHeight: getViewportClientHeight,
        getScrollingElement: getScrollingElement
    });

    function globalAPI (UIkit) {
      const DATA = UIkit.data;

      UIkit.use = function (plugin) {
        if (plugin.installed) {
          return;
        }

        plugin.call(null, this);
        plugin.installed = true;

        return this;
      };

      UIkit.mixin = function (mixin, component) {
        component = (isString(component) ? UIkit.component(component) : component) || this;
        component.options = mergeOptions(component.options, mixin);
      };

      UIkit.extend = function (options) {
        options = options || {};

        const Super = this;
        const Sub = function UIkitComponent(options) {
          this._init(options);
        };

        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.options = mergeOptions(Super.options, options);

        Sub.super = Super;
        Sub.extend = Super.extend;

        return Sub;
      };

      UIkit.update = function (element, e) {
        element = element ? toNode(element) : document.body;

        for (const parentEl of parents(element).reverse()) {
          update(parentEl[DATA], e);
        }

        apply(element, (element) => update(element[DATA], e));
      };

      let container;
      Object.defineProperty(UIkit, 'container', {
        get() {
          return container || document.body;
        },

        set(element) {
          container = $(element);
        } });


      function update(data, e) {
        if (!data) {
          return;
        }

        for (const name in data) {
          if (data[name]._connected) {
            data[name]._callUpdate(e);
          }
        }
      }
    }

    function hooksAPI (UIkit) {
      UIkit.prototype._callHook = function (hook) {var _this$$options$hook;
        (_this$$options$hook = this.$options[hook]) == null ? void 0 : _this$$options$hook.forEach((handler) => handler.call(this));
      };

      UIkit.prototype._callConnected = function () {
        if (this._connected) {
          return;
        }

        this._data = {};
        this._computed = {};

        this._initProps();

        this._callHook('beforeConnect');
        this._connected = true;

        this._initEvents();
        this._initObservers();

        this._callHook('connected');
        this._callUpdate();
      };

      UIkit.prototype._callDisconnected = function () {
        if (!this._connected) {
          return;
        }

        this._callHook('beforeDisconnect');
        this._disconnectObservers();
        this._unbindEvents();
        this._callHook('disconnected');

        this._connected = false;
        delete this._watch;
      };

      UIkit.prototype._callUpdate = function (e) {if (e === void 0) {e = 'update';}
        if (!this._connected) {
          return;
        }

        if (e === 'update' || e === 'resize') {
          this._callWatches();
        }

        if (!this.$options.update) {
          return;
        }

        if (!this._updates) {
          this._updates = new Set();
          fastdom.read(() => {
            if (this._connected) {
              runUpdates.call(this, this._updates);
            }
            delete this._updates;
          });
        }

        this._updates.add(e.type || e);
      };

      UIkit.prototype._callWatches = function () {
        if (this._watch) {
          return;
        }

        const initial = !hasOwn(this, '_watch');

        this._watch = fastdom.read(() => {
          if (this._connected) {
            runWatches.call(this, initial);
          }
          this._watch = null;
        });
      };

      function runUpdates(types) {
        for (const { read, write, events = [] } of this.$options.update) {
          if (!types.has('update') && !events.some((type) => types.has(type))) {
            continue;
          }

          let result;
          if (read) {
            result = read.call(this, this._data, types);

            if (result && isPlainObject(result)) {
              assign(this._data, result);
            }
          }

          if (write && result !== false) {
            fastdom.write(() => write.call(this, this._data, types));
          }
        }
      }

      function runWatches(initial) {
        const {
          $options: { computed } } =
        this;
        const values = { ...(initial ? {} : this._computed) };
        this._computed = {};

        for (const key in computed) {
          const { watch, immediate } = computed[key];
          if (
          watch && (
          initial && immediate ||
          hasOwn(values, key) && !isEqual(values[key], this[key])))
          {
            watch.call(this, this[key], values[key]);
          }
        }
      }
    }

    function stateAPI (UIkit) {
      let uid = 0;

      UIkit.prototype._init = function (options) {
        options = options || {};
        options.data = normalizeData(options, this.constructor.options);

        this.$options = mergeOptions(this.constructor.options, options, this);
        this.$el = null;
        this.$props = {};

        this._uid = uid++;
        this._initData();
        this._initMethods();
        this._initComputeds();
        this._callHook('created');

        if (options.el) {
          this.$mount(options.el);
        }
      };

      UIkit.prototype._initData = function () {
        const { data = {} } = this.$options;

        for (const key in data) {
          this.$props[key] = this[key] = data[key];
        }
      };

      UIkit.prototype._initMethods = function () {
        const { methods } = this.$options;

        if (methods) {
          for (const key in methods) {
            this[key] = methods[key].bind(this);
          }
        }
      };

      UIkit.prototype._initComputeds = function () {
        const { computed } = this.$options;

        this._computed = {};

        if (computed) {
          for (const key in computed) {
            registerComputed(this, key, computed[key]);
          }
        }
      };

      UIkit.prototype._initProps = function (props) {
        let key;

        props = props || getProps$1(this.$options, this.$name);

        for (key in props) {
          if (!isUndefined(props[key])) {
            this.$props[key] = props[key];
          }
        }

        const exclude = [this.$options.computed, this.$options.methods];
        for (key in this.$props) {
          if (key in props && notIn(exclude, key)) {
            this[key] = this.$props[key];
          }
        }
      };

      UIkit.prototype._initEvents = function () {
        this._events = [];
        for (const event of this.$options.events || []) {
          if (hasOwn(event, 'handler')) {
            registerEvent(this, event);
          } else {
            for (const key in event) {
              registerEvent(this, event[key], key);
            }
          }
        }
      };

      UIkit.prototype._unbindEvents = function () {
        this._events.forEach((unbind) => unbind());
        delete this._events;
      };

      UIkit.prototype._initObservers = function () {
        this._observers = [initPropsObserver(this)];

        if (this.$options.computed) {
          this.registerObserver(initChildListObserver(this));
        }
      };

      UIkit.prototype.registerObserver = function (observer) {
        this._observers.push(observer);
      };

      UIkit.prototype._disconnectObservers = function () {
        this._observers.forEach((observer) => observer == null ? void 0 : observer.disconnect());
      };
    }

    function getProps$1(opts, name) {
      const data$1 = {};
      const { args = [], props = {}, el } = opts;

      if (!props) {
        return data$1;
      }

      for (const key in props) {
        const prop = hyphenate(key);
        let value = data(el, prop);

        if (isUndefined(value)) {
          continue;
        }

        value = props[key] === Boolean && value === '' ? true : coerce(props[key], value);

        if (prop === 'target' && (!value || startsWith(value, '_'))) {
          continue;
        }

        data$1[key] = value;
      }

      const options = parseOptions(data(el, name), args);

      for (const key in options) {
        const prop = camelize(key);
        if (props[prop] !== undefined) {
          data$1[prop] = coerce(props[prop], options[key]);
        }
      }

      return data$1;
    }

    function registerComputed(component, key, cb) {
      Object.defineProperty(component, key, {
        enumerable: true,

        get() {
          const { _computed, $props, $el } = component;

          if (!hasOwn(_computed, key)) {
            _computed[key] = (cb.get || cb).call(component, $props, $el);
          }

          return _computed[key];
        },

        set(value) {
          const { _computed } = component;

          _computed[key] = cb.set ? cb.set.call(component, value) : value;

          if (isUndefined(_computed[key])) {
            delete _computed[key];
          }
        } });

    }

    function registerEvent(component, event, key) {
      if (!isPlainObject(event)) {
        event = { name: key, handler: event };
      }

      let { name, el, handler, capture, passive, delegate, filter, self } = event;
      el = isFunction(el) ? el.call(component) : el || component.$el;

      if (isArray(el)) {
        el.forEach((el) => registerEvent(component, { ...event, el }, key));
        return;
      }

      if (!el || filter && !filter.call(component)) {
        return;
      }

      component._events.push(
      on(
      el,
      name,
      delegate ? isString(delegate) ? delegate : delegate.call(component) : null,
      isString(handler) ? component[handler] : handler.bind(component),
      { passive, capture, self }));


    }

    function notIn(options, key) {
      return options.every((arr) => !arr || !hasOwn(arr, key));
    }

    function coerce(type, value) {
      if (type === Boolean) {
        return toBoolean(value);
      } else if (type === Number) {
        return toNumber(value);
      } else if (type === 'list') {
        return toList(value);
      }

      return type ? type(value) : value;
    }

    function toList(value) {
      return isArray(value) ?
      value :
      isString(value) ?
      value.
      split(/,(?![^(]*\))/).
      map((value) => isNumeric(value) ? toNumber(value) : toBoolean(value.trim())) :
      [value];
    }

    function normalizeData(_ref, _ref2) {let { data = {} } = _ref;let { args = [], props = {} } = _ref2;
      if (isArray(data)) {
        data = data.slice(0, args.length).reduce((data, value, index) => {
          if (isPlainObject(value)) {
            assign(data, value);
          } else {
            data[args[index]] = value;
          }
          return data;
        }, {});
      }

      for (const key in data) {
        if (isUndefined(data[key])) {
          delete data[key];
        } else if (props[key]) {
          data[key] = coerce(props[key], data[key]);
        }
      }

      return data;
    }

    function initChildListObserver(component) {
      const { el } = component.$options;

      const observer = new MutationObserver(() => component.$emit());
      observer.observe(el, {
        childList: true,
        subtree: true });


      return observer;
    }

    function initPropsObserver(component) {
      const { $name, $options, $props } = component;
      const { attrs, props, el } = $options;

      if (!props || attrs === false) {
        return;
      }

      const attributes = isArray(attrs) ? attrs : Object.keys(props);
      const filter = attributes.map((key) => hyphenate(key)).concat($name);

      const observer = new MutationObserver((records) => {
        const data = getProps$1($options, $name);
        if (
        records.some((_ref3) => {let { attributeName } = _ref3;
          const prop = attributeName.replace('data-', '');
          return (
          prop === $name ? attributes : [camelize(prop), camelize(attributeName)]).
          some((prop) => !isUndefined(data[prop]) && data[prop] !== $props[prop]);
        }))
        {
          component.$reset();
        }
      });

      observer.observe(el, {
        attributes: true,
        attributeFilter: filter.concat(filter.map((key) => "data-" + key)) });


      return observer;
    }

    function instanceAPI (UIkit) {
      const DATA = UIkit.data;

      UIkit.prototype.$create = function (component, element, data) {
        return UIkit[component](element, data);
      };

      UIkit.prototype.$mount = function (el) {
        const { name } = this.$options;

        if (!el[DATA]) {
          el[DATA] = {};
        }

        if (el[DATA][name]) {
          return;
        }

        el[DATA][name] = this;

        this.$el = this.$options.el = this.$options.el || el;

        if (within(el, document)) {
          this._callConnected();
        }
      };

      UIkit.prototype.$reset = function () {
        this._callDisconnected();
        this._callConnected();
      };

      UIkit.prototype.$destroy = function (removeEl) {if (removeEl === void 0) {removeEl = false;}
        const { el, name } = this.$options;

        if (el) {
          this._callDisconnected();
        }

        this._callHook('destroy');

        if (!(el != null && el[DATA])) {
          return;
        }

        delete el[DATA][name];

        if (!isEmpty(el[DATA])) {
          delete el[DATA];
        }

        if (removeEl) {
          remove$1(this.$el);
        }
      };

      UIkit.prototype.$emit = function (e) {
        this._callUpdate(e);
      };

      UIkit.prototype.$update = function (element, e) {if (element === void 0) {element = this.$el;}
        UIkit.update(element, e);
      };

      UIkit.prototype.$getComponent = UIkit.getComponent;

      const componentName = memoize((name) => UIkit.prefix + hyphenate(name));
      Object.defineProperties(UIkit.prototype, {
        $container: Object.getOwnPropertyDescriptor(UIkit, 'container'),

        $name: {
          get() {
            return componentName(this.$options.name);
          } } });


    }

    function componentAPI (UIkit) {
      const DATA = UIkit.data;

      const components = {};

      UIkit.component = function (name, options) {
        const id = hyphenate(name);

        name = camelize(id);

        if (!options) {
          if (isPlainObject(components[name])) {
            components[name] = UIkit.extend(components[name]);
          }

          return components[name];
        }

        UIkit[name] = function (element, data) {
          const component = UIkit.component(name);

          return component.options.functional ?
          new component({ data: isPlainObject(element) ? element : [...arguments] }) :
          element ?
          $$(element).map(init)[0] :
          init();

          function init(element) {
            const instance = UIkit.getComponent(element, name);

            if (instance) {
              if (data) {
                instance.$destroy();
              } else {
                return instance;
              }
            }

            return new component({ el: element, data });
          }
        };

        const opt = isPlainObject(options) ? { ...options } : options.options;

        opt.name = name;

        opt.install == null ? void 0 : opt.install(UIkit, opt, name);

        if (UIkit._initialized && !opt.functional) {
          fastdom.read(() => UIkit[name]("[uk-" + id + "],[data-uk-" + id + "]"));
        }

        return components[name] = isPlainObject(options) ? opt : options;
      };

      UIkit.getComponents = (element) => (element == null ? void 0 : element[DATA]) || {};
      UIkit.getComponent = (element, name) => UIkit.getComponents(element)[name];

      UIkit.connect = (node) => {
        if (node[DATA]) {
          for (const name in node[DATA]) {
            node[DATA][name]._callConnected();
          }
        }

        for (const attribute of node.attributes) {
          const name = getComponentName(attribute.name);

          if (name && name in components) {
            UIkit[name](node);
          }
        }
      };

      UIkit.disconnect = (node) => {
        for (const name in node[DATA]) {
          node[DATA][name]._callDisconnected();
        }
      };
    }

    const getComponentName = memoize((attribute) => {
      return startsWith(attribute, 'uk-') || startsWith(attribute, 'data-uk-') ?
      camelize(attribute.replace('data-uk-', '').replace('uk-', '')) :
      false;
    });

    const UIkit = function (options) {
      this._init(options);
    };

    UIkit.util = util;
    UIkit.data = '__uikit__';
    UIkit.prefix = 'uk-';
    UIkit.options = {};
    UIkit.version = '3.13.9';

    globalAPI(UIkit);
    hooksAPI(UIkit);
    stateAPI(UIkit);
    componentAPI(UIkit);
    instanceAPI(UIkit);

    function Core () {
      if (!inBrowser) {
        return;
      }

      let started = 0;
      on(
      document,
      'animationstart',
      (_ref) => {let { target } = _ref;
        if ((css(target, 'animationName') || '').match(/^uk-.*(left|right)/)) {
          started++;
          css(document.documentElement, 'overflowX', 'hidden');
          setTimeout(() => {
            if (! --started) {
              css(document.documentElement, 'overflowX', '');
            }
          }, toMs(css(target, 'animationDuration')) + 100);
        }
      },
      true);

    }

    function boot (UIkit) {
      const { connect, disconnect } = UIkit;

      if (!inBrowser || !window.MutationObserver) {
        return;
      }

      fastdom.read(function () {
        if (document.body) {
          apply(document.body, connect);
        }

        new MutationObserver((records) => records.forEach(applyChildListMutation)).observe(
        document,
        {
          childList: true,
          subtree: true });



        new MutationObserver((records) => records.forEach(applyAttributeMutation)).observe(
        document,
        {
          attributes: true,
          subtree: true });



        UIkit._initialized = true;
      });

      function applyChildListMutation(_ref) {let { addedNodes, removedNodes } = _ref;
        for (const node of addedNodes) {
          apply(node, connect);
        }

        for (const node of removedNodes) {
          apply(node, disconnect);
        }
      }

      function applyAttributeMutation(_ref2) {var _UIkit$getComponent;let { target, attributeName } = _ref2;
        const name = getComponentName(attributeName);

        if (!name || !(name in UIkit)) {
          return;
        }

        if (hasAttr(target, attributeName)) {
          UIkit[name](target);
          return;
        }

        (_UIkit$getComponent = UIkit.getComponent(target, name)) == null ? void 0 : _UIkit$getComponent.$destroy();
      }
    }

    var Class = {
      connected() {
        !hasClass(this.$el, this.$name) && addClass(this.$el, this.$name);
      } };

    var Lazyload = {
      methods: {
        lazyload(observeTargets, targets) {if (observeTargets === void 0) {observeTargets = this.$el;}if (targets === void 0) {targets = this.$el;}
          this.registerObserver(
          observeIntersection(observeTargets, (entries, observer) => {
            for (const el of toNodes(isFunction(targets) ? targets() : targets)) {
              $$('[loading="lazy"]', el).forEach((el) => removeAttr(el, 'loading'));
            }
            for (const el of entries.
            filter((_ref) => {let { isIntersecting } = _ref;return isIntersecting;}).
            map((_ref2) => {let { target } = _ref2;return target;})) {
              observer.unobserve(el);
            }
          }));

        } } };

    var Togglable = {
      props: {
        cls: Boolean,
        animation: 'list',
        duration: Number,
        origin: String,
        transition: String },


      data: {
        cls: false,
        animation: [false],
        duration: 200,
        origin: false,
        transition: 'linear',
        clsEnter: 'uk-togglabe-enter',
        clsLeave: 'uk-togglabe-leave',

        initProps: {
          overflow: '',
          height: '',
          paddingTop: '',
          paddingBottom: '',
          marginTop: '',
          marginBottom: '' },


        hideProps: {
          overflow: 'hidden',
          height: 0,
          paddingTop: 0,
          paddingBottom: 0,
          marginTop: 0,
          marginBottom: 0 } },



      computed: {
        hasAnimation(_ref) {let { animation } = _ref;
          return !!animation[0];
        },

        hasTransition(_ref2) {let { animation } = _ref2;
          return this.hasAnimation && animation[0] === true;
        } },


      methods: {
        toggleElement(targets, toggle, animate) {
          return new Promise((resolve) =>
          Promise.all(
          toNodes(targets).map((el) => {
            const show = isBoolean(toggle) ? toggle : !this.isToggled(el);

            if (!trigger(el, "before" + (show ? 'show' : 'hide'), [this])) {
              return Promise.reject();
            }

            const promise = (
            isFunction(animate) ?
            animate :
            animate === false || !this.hasAnimation ?
            this._toggle :
            this.hasTransition ?
            toggleHeight(this) :
            toggleAnimation(this))(
            el, show);

            const cls = show ? this.clsEnter : this.clsLeave;

            addClass(el, cls);

            trigger(el, show ? 'show' : 'hide', [this]);

            const done = () => {
              removeClass(el, cls);
              trigger(el, show ? 'shown' : 'hidden', [this]);
              this.$update(el);
            };

            return promise ?
            promise.then(done, () => {
              removeClass(el, cls);
              return Promise.reject();
            }) :
            done();
          })).
          then(resolve, noop));

        },

        isToggled(el) {if (el === void 0) {el = this.$el;}
          [el] = toNodes(el);
          return hasClass(el, this.clsEnter) ?
          true :
          hasClass(el, this.clsLeave) ?
          false :
          this.cls ?
          hasClass(el, this.cls.split(' ')[0]) :
          isVisible(el);
        },

        _toggle(el, toggled) {
          if (!el) {
            return;
          }

          toggled = Boolean(toggled);

          let changed;
          if (this.cls) {
            changed = includes(this.cls, ' ') || toggled !== hasClass(el, this.cls);
            changed && toggleClass(el, this.cls, includes(this.cls, ' ') ? undefined : toggled);
          } else {
            changed = toggled === el.hidden;
            changed && (el.hidden = !toggled);
          }

          $$('[autofocus]', el).some((el) => isVisible(el) ? el.focus() || true : el.blur());

          if (changed) {
            trigger(el, 'toggled', [toggled, this]);
            this.$update(el);
          }
        } } };



    function toggleHeight(_ref3) {let { isToggled, duration, initProps, hideProps, transition, _toggle } = _ref3;
      return (el, show) => {
        const inProgress = Transition.inProgress(el);
        const inner = el.hasChildNodes() ?
        toFloat(css(el.firstElementChild, 'marginTop')) +
        toFloat(css(el.lastElementChild, 'marginBottom')) :
        0;
        const currentHeight = isVisible(el) ? height(el) + (inProgress ? 0 : inner) : 0;

        Transition.cancel(el);

        if (!isToggled(el)) {
          _toggle(el, true);
        }

        height(el, '');

        // Update child components first
        fastdom.flush();

        const endHeight = height(el) + (inProgress ? 0 : inner);
        height(el, currentHeight);

        return (
        show ?
        Transition.start(
        el,
        { ...initProps, overflow: 'hidden', height: endHeight },
        Math.round(duration * (1 - currentHeight / endHeight)),
        transition) :

        Transition.start(
        el,
        hideProps,
        Math.round(duration * (currentHeight / endHeight)),
        transition).
        then(() => _toggle(el, false))).
        then(() => css(el, initProps));
      };
    }

    function toggleAnimation(cmp) {
      return (el, show) => {
        Animation.cancel(el);

        const { animation, duration, _toggle } = cmp;

        if (show) {
          _toggle(el, true);
          return Animation.in(el, animation[0], duration, cmp.origin);
        }

        return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then(() =>
        _toggle(el, false));

      };
    }

    var Accordion = {
      mixins: [Class, Lazyload, Togglable],

      props: {
        targets: String,
        active: null,
        collapsible: Boolean,
        multiple: Boolean,
        toggle: String,
        content: String,
        transition: String,
        offset: Number },


      data: {
        targets: '> *',
        active: false,
        animation: [true],
        collapsible: true,
        multiple: false,
        clsOpen: 'uk-open',
        toggle: '> .uk-accordion-title',
        content: '> .uk-accordion-content',
        transition: 'ease',
        offset: 0 },


      computed: {
        items: {
          get(_ref, $el) {let { targets } = _ref;
            return $$(targets, $el).filter((el) => $(this.content, el));
          },

          watch(items, prev) {
            items.forEach((el) => hide($(this.content, el), !hasClass(el, this.clsOpen)));

            if (prev || hasClass(items, this.clsOpen)) {
              return;
            }

            const active =
            this.active !== false && items[Number(this.active)] ||
            !this.collapsible && items[0];

            if (active) {
              this.toggle(active, false);
            }
          },

          immediate: true },


        toggles(_ref2) {let { toggle } = _ref2;
          return this.items.map((item) => $(toggle, item));
        } },


      connected() {
        this.lazyload();
      },

      events: [
      {
        name: 'click',

        delegate() {
          return this.targets + " " + this.$props.toggle;
        },

        handler(e) {
          e.preventDefault();
          this.toggle(index(this.toggles, e.current));
        } }],



      methods: {
        toggle(item, animate) {
          let items = [this.items[getIndex(item, this.items)]];
          const activeItems = filter$1(this.items, "." + this.clsOpen);

          if (!this.multiple && !includes(activeItems, items[0])) {
            items = items.concat(activeItems);
          }

          if (
          !this.collapsible &&
          activeItems.length < 2 &&
          !filter$1(items, ":not(." + this.clsOpen + ")").length)
          {
            return;
          }

          for (const el of items) {
            this.toggleElement(el, !hasClass(el, this.clsOpen), async (el, show) => {
              toggleClass(el, this.clsOpen, show);
              attr($(this.$props.toggle, el), 'aria-expanded', show);

              const content = $("" + (el._wrapper ? '> * ' : '') + this.content, el);

              if (animate === false || !this.hasTransition) {
                hide(content, !show);
                return;
              }

              if (!el._wrapper) {
                el._wrapper = wrapAll(content, "<div" + (show ? ' hidden' : '') + ">");
              }

              hide(content, false);
              await toggleHeight(this)(el._wrapper, show);
              hide(content, !show);

              delete el._wrapper;
              unwrap(content);

              if (show) {
                const toggle = $(this.$props.toggle, el);
                fastdom.read(() => {
                  if (!isInView(toggle)) {
                    scrollIntoView(toggle, { offset: this.offset });
                  }
                });
              }
            });
          }
        } } };



    function hide(el, hide) {
      el && (el.hidden = hide);
    }

    var alert = {
      mixins: [Class, Togglable],

      args: 'animation',

      props: {
        close: String },


      data: {
        animation: [true],
        selClose: '.uk-alert-close',
        duration: 150,
        hideProps: { opacity: 0, ...Togglable.data.hideProps } },


      events: [
      {
        name: 'click',

        delegate() {
          return this.selClose;
        },

        handler(e) {
          e.preventDefault();
          this.close();
        } }],



      methods: {
        async close() {
          await this.toggleElement(this.$el);
          this.$destroy(true);
        } } };

    var Video = {
      args: 'autoplay',

      props: {
        automute: Boolean,
        autoplay: Boolean },


      data: {
        automute: false,
        autoplay: true },


      connected() {
        this.inView = this.autoplay === 'inview';

        if (this.inView && !hasAttr(this.$el, 'preload')) {
          this.$el.preload = 'none';
        }

        if (this.automute) {
          mute(this.$el);
        }

        this.registerObserver(observeIntersection(this.$el, () => this.$emit(), {}, false));
      },

      update: {
        read() {
          if (!isVideo(this.$el)) {
            return false;
          }

          return {
            visible: isVisible(this.$el) && css(this.$el, 'visibility') !== 'hidden',
            inView: this.inView && isInView(this.$el) };

        },

        write(_ref) {let { visible, inView } = _ref;
          if (!visible || this.inView && !inView) {
            pause(this.$el);
          } else if (this.autoplay === true || this.inView && inView) {
            play(this.$el);
          }
        } } };

    var Resize = {
      connected() {var _this$$options$resize;
        this.registerObserver(
        observeResize(((_this$$options$resize = this.$options.resizeTargets) == null ? void 0 : _this$$options$resize.call(this)) || this.$el, () =>
        this.$emit('resize')));


      } };

    var cover = {
      mixins: [Resize, Video],

      props: {
        width: Number,
        height: Number },


      data: {
        automute: true },


      events: {
        'load loadedmetadata'() {
          this.$emit('resize');
        } },


      resizeTargets() {
        return [this.$el, parent(this.$el)];
      },

      update: {
        read() {
          const el = this.$el;
          const { offsetHeight: height, offsetWidth: width } =
          getPositionedParent(el) || parent(el);
          const dim = Dimensions.cover(
          {
            width: this.width || el.naturalWidth || el.videoWidth || el.clientWidth,
            height: this.height || el.naturalHeight || el.videoHeight || el.clientHeight },

          {
            width: width + (width % 2 ? 1 : 0),
            height: height + (height % 2 ? 1 : 0) });



          if (!dim.width || !dim.height) {
            return false;
          }

          return dim;
        },

        write(_ref) {let { height, width } = _ref;
          css(this.$el, { height, width });
        },

        events: ['resize'] } };



    function getPositionedParent(el) {
      while (el = parent(el)) {
        if (css(el, 'position') !== 'static') {
          return el;
        }
      }
    }

    var Container = {
      props: {
        container: Boolean },


      data: {
        container: true },


      computed: {
        container(_ref) {let { container } = _ref;
          return container === true && this.$container || container && $(container);
        } } };

    var Position = {
      props: {
        pos: String,
        offset: null,
        flip: Boolean },


      data: {
        pos: "bottom-" + (isRtl ? 'right' : 'left'),
        flip: true,
        offset: false },


      connected() {
        this.pos = this.$props.pos.split('-').concat('center').slice(0, 2);
        this.dir = this.pos[0];
        this.align = this.pos[1];
      },

      methods: {
        positionAt(element, target, boundary) {
          const axis = this.getAxis();
          const dir = this.pos[0];
          const align = this.pos[1];

          let { offset: offset$1 } = this;
          if (!isNumeric(offset$1)) {
            const node = $(offset$1);
            offset$1 = node ?
            offset(node)[axis === 'x' ? 'left' : 'top'] -
            offset(target)[axis === 'x' ? 'right' : 'bottom'] :
            0;
          }
          offset$1 = toPx(offset$1) + toPx(getCssVar('position-offset', element));

          const { x, y } = positionAt(
          element,
          target,
          axis === 'x' ? flipPosition(dir) + " " + align : align + " " + flipPosition(dir),
          axis === 'x' ? dir + " " + align : align + " " + dir,
          axis === 'x' ? "" + (
          dir === 'left' ? -offset$1 : offset$1) : " " + (
          dir === 'top' ? -offset$1 : offset$1),
          null,
          this.flip,
          boundary).
          target;

          this.dir = axis === 'x' ? x : y;
          this.align = axis === 'x' ? y : x;
        },

        getAxis() {
          return this.dir === 'top' || this.dir === 'bottom' ? 'y' : 'x';
        } } };

    let active$1;

    var drop = {
      mixins: [Container, Lazyload, Position, Togglable],

      args: 'pos',

      props: {
        mode: 'list',
        toggle: Boolean,
        boundary: Boolean,
        boundaryAlign: Boolean,
        delayShow: Number,
        delayHide: Number,
        clsDrop: String },


      data: {
        mode: ['click', 'hover'],
        toggle: '- *',
        boundary: true,
        boundaryAlign: false,
        delayShow: 0,
        delayHide: 800,
        clsDrop: false,
        animation: ['uk-animation-fade'],
        cls: 'uk-open',
        container: false },


      created() {
        this.tracker = new MouseTracker();
      },

      beforeConnect() {
        this.clsDrop = this.$props.clsDrop || "uk-" + this.$options.name;
      },

      connected() {
        addClass(this.$el, this.clsDrop);

        if (this.toggle && !this.target) {
          this.target = this.$create('toggle', query(this.toggle, this.$el), {
            target: this.$el,
            mode: this.mode }).
          $el;
          attr(this.target, 'aria-haspopup', true);
          this.lazyload(this.target);
        }
      },

      disconnected() {
        if (this.isActive()) {
          active$1 = null;
        }
      },

      events: [
      {
        name: 'click',

        delegate() {
          return "." + this.clsDrop + "-close";
        },

        handler(e) {
          e.preventDefault();
          this.hide(false);
        } },


      {
        name: 'click',

        delegate() {
          return 'a[href^="#"]';
        },

        handler(_ref) {let { defaultPrevented, current: { hash } } = _ref;
          if (!defaultPrevented && hash && !within(hash, this.$el)) {
            this.hide(false);
          }
        } },


      {
        name: 'beforescroll',

        handler() {
          this.hide(false);
        } },


      {
        name: 'toggle',

        self: true,

        handler(e, toggle) {
          e.preventDefault();

          if (this.isToggled()) {
            this.hide(false);
          } else {
            this.show(toggle == null ? void 0 : toggle.$el, false);
          }
        } },


      {
        name: 'toggleshow',

        self: true,

        handler(e, toggle) {
          e.preventDefault();
          this.show(toggle == null ? void 0 : toggle.$el);
        } },


      {
        name: 'togglehide',

        self: true,

        handler(e) {
          e.preventDefault();
          if (!matches(this.$el, ':focus,:hover')) {
            this.hide();
          }
        } },


      {
        name: pointerEnter + " focusin",

        filter() {
          return includes(this.mode, 'hover');
        },

        handler(e) {
          if (!isTouch(e)) {
            this.clearTimers();
          }
        } },


      {
        name: pointerLeave + " focusout",

        filter() {
          return includes(this.mode, 'hover');
        },

        handler(e) {
          if (!isTouch(e) && e.relatedTarget) {
            this.hide();
          }
        } },


      {
        name: 'toggled',

        self: true,

        handler(e, toggled) {
          if (!toggled) {
            return;
          }

          this.clearTimers();
          this.position();
        } },


      {
        name: 'show',

        self: true,

        handler() {
          active$1 = this;

          this.tracker.init();

          for (const handler of [
          on(
          document,
          pointerDown,
          (_ref2) => {let { target } = _ref2;return (
              !within(target, this.$el) &&
              once(
              document,
              pointerUp + " " + pointerCancel + " scroll",
              (_ref3) => {let { defaultPrevented, type, target: newTarget } = _ref3;
                if (
                !defaultPrevented &&
                type === pointerUp &&
                target === newTarget &&
                !(this.target && within(target, this.target)))
                {
                  this.hide(false);
                }
              },
              true));}),



          on(document, 'keydown', (e) => {
            if (e.keyCode === 27) {
              this.hide(false);
            }
          }),
          on(window, 'resize', () => this.$emit()),
          on(
          document,
          'scroll',
          (_ref4) => {let { target } = _ref4;return target.contains(this.$el) && this.$emit();},
          true)])

          {
            once(this.$el, 'hide', handler, { self: true });
          }
        } },


      {
        name: 'beforehide',

        self: true,

        handler() {
          this.clearTimers();
        } },


      {
        name: 'hide',

        handler(_ref5) {let { target } = _ref5;
          if (this.$el !== target) {
            active$1 =
            active$1 === null && within(target, this.$el) && this.isToggled() ?
            this :
            active$1;
            return;
          }

          active$1 = this.isActive() ? null : active$1;
          this.tracker.cancel();
        } }],



      update: {
        write() {
          if (this.isToggled() && !hasClass(this.$el, this.clsEnter)) {
            this.position();
          }
        } },


      methods: {
        show(target, delay) {if (target === void 0) {target = this.target;}if (delay === void 0) {delay = true;}
          if (this.isToggled() && target && this.target && target !== this.target) {
            this.hide(false);
          }

          this.target = target;

          this.clearTimers();

          if (this.isActive()) {
            return;
          }

          if (active$1) {
            if (delay && active$1.isDelaying) {
              this.showTimer = setTimeout(() => matches(target, ':hover') && this.show(), 10);
              return;
            }

            let prev;
            while (active$1 && prev !== active$1 && !within(this.$el, active$1.$el)) {
              prev = active$1;
              active$1.hide(false);
            }
          }

          if (this.container && parent(this.$el) !== this.container) {
            append(this.container, this.$el);
          }

          this.showTimer = setTimeout(
          () => this.toggleElement(this.$el, true),
          delay && this.delayShow || 0);

        },

        hide(delay) {if (delay === void 0) {delay = true;}
          const hide = () => this.toggleElement(this.$el, false, false);

          this.clearTimers();

          this.isDelaying = getPositionedElements(this.$el).some((el) =>
          this.tracker.movesTo(el));


          if (delay && this.isDelaying) {
            this.hideTimer = setTimeout(this.hide, 50);
          } else if (delay && this.delayHide) {
            this.hideTimer = setTimeout(hide, this.delayHide);
          } else {
            hide();
          }
        },

        clearTimers() {
          clearTimeout(this.showTimer);
          clearTimeout(this.hideTimer);
          this.showTimer = null;
          this.hideTimer = null;
          this.isDelaying = false;
        },

        isActive() {
          return active$1 === this;
        },

        position() {
          const boundary = query(this.boundary, this.$el) || window;
          removeClass(this.$el, this.clsDrop + "-stack");
          toggleClass(this.$el, this.clsDrop + "-boundary", this.boundaryAlign);

          const boundaryOffset = offset(boundary);
          const targetOffset = offset(this.target);
          const alignTo = this.boundaryAlign ? boundaryOffset : targetOffset;

          if (this.pos[1] === 'justify') {
            const prop = this.getAxis() === 'y' ? 'width' : 'height';
            css(this.$el, prop, alignTo[prop]);
          } else if (
          this.$el.offsetWidth >
          Math.max(boundaryOffset.right - alignTo.left, alignTo.right - boundaryOffset.left))
          {
            addClass(this.$el, this.clsDrop + "-stack");
          }

          this.positionAt(this.$el, this.boundaryAlign ? boundary : this.target, boundary);
        } } };



    function getPositionedElements(el) {
      const result = [];
      apply(el, (el) => css(el, 'position') !== 'static' && result.push(el));
      return result;
    }

    var formCustom = {
      mixins: [Class],

      args: 'target',

      props: {
        target: Boolean },


      data: {
        target: false },


      computed: {
        input(_, $el) {
          return $(selInput, $el);
        },

        state() {
          return this.input.nextElementSibling;
        },

        target(_ref, $el) {let { target } = _ref;
          return (
            target && (
            target === true && parent(this.input) === $el && this.input.nextElementSibling ||
            $(target, $el)));

        } },


      update() {var _input$files;
        const { target, input } = this;

        if (!target) {
          return;
        }

        let option;
        const prop = isInput(target) ? 'value' : 'textContent';
        const prev = target[prop];
        const value = (_input$files = input.files) != null && _input$files[0] ?
        input.files[0].name :
        matches(input, 'select') && (
        option = $$('option', input).filter((el) => el.selected)[0]) // eslint-disable-line prefer-destructuring
        ? option.textContent :
        input.value;

        if (prev !== value) {
          target[prop] = value;
        }
      },

      events: [
      {
        name: 'change',

        handler() {
          this.$emit();
        } },


      {
        name: 'reset',

        el() {
          return closest(this.$el, 'form');
        },

        handler() {
          this.$emit();
        } }] };

    var Margin = {
      mixins: [Resize],

      props: {
        margin: String,
        firstColumn: Boolean },


      data: {
        margin: 'uk-margin-small-top',
        firstColumn: 'uk-first-column' },


      resizeTargets() {
        return [this.$el, this.$el.children];
      },

      connected() {
        this.registerObserver(
        observeMutation(this.$el, () => this.$reset(), {
          childList: true }));


      },

      update: {
        read() {
          const rows = getRows(this.$el.children);

          return {
            rows,
            columns: getColumns(rows) };

        },

        write(_ref) {let { columns, rows } = _ref;
          for (const row of rows) {
            for (const column of row) {
              toggleClass(column, this.margin, rows[0] !== row);
              toggleClass(column, this.firstColumn, !!~columns[0].indexOf(column));
            }
          }
        },

        events: ['resize'] } };



    function getRows(items) {
      return sortBy(items, 'top', 'bottom');
    }

    function getColumns(rows) {
      const columns = [];

      for (const row of rows) {
        const sorted = sortBy(row, 'left', 'right');
        for (let j = 0; j < sorted.length; j++) {
          columns[j] = columns[j] ? columns[j].concat(sorted[j]) : sorted[j];
        }
      }

      return isRtl ? columns.reverse() : columns;
    }

    function sortBy(items, startProp, endProp) {
      const sorted = [[]];

      for (const el of items) {
        if (!isVisible(el)) {
          continue;
        }

        let dim = getOffset(el);

        for (let i = sorted.length - 1; i >= 0; i--) {
          const current = sorted[i];

          if (!current[0]) {
            current.push(el);
            break;
          }

          let startDim;
          if (current[0].offsetParent === el.offsetParent) {
            startDim = getOffset(current[0]);
          } else {
            dim = getOffset(el, true);
            startDim = getOffset(current[0], true);
          }

          if (dim[startProp] >= startDim[endProp] - 1 && dim[startProp] !== startDim[startProp]) {
            sorted.push([el]);
            break;
          }

          if (dim[endProp] - 1 > startDim[startProp] || dim[startProp] === startDim[startProp]) {
            current.push(el);
            break;
          }

          if (i === 0) {
            sorted.unshift([el]);
            break;
          }
        }
      }

      return sorted;
    }

    function getOffset(element, offset) {if (offset === void 0) {offset = false;}
      let { offsetTop, offsetLeft, offsetHeight, offsetWidth } = element;

      if (offset) {
        [offsetTop, offsetLeft] = offsetPosition(element);
      }

      return {
        top: offsetTop,
        left: offsetLeft,
        bottom: offsetTop + offsetHeight,
        right: offsetLeft + offsetWidth };

    }

    var Scroll = {
      connected() {
        registerScrollListener(this._uid, () => this.$emit('scroll'));
      },

      disconnected() {
        unregisterScrollListener(this._uid);
      } };


    const scrollListeners = new Map();
    let unbindScrollListener;
    function registerScrollListener(id, listener) {
      unbindScrollListener =
      unbindScrollListener ||
      on(window, 'scroll', () => scrollListeners.forEach((listener) => listener()), {
        passive: true,
        capture: true });


      scrollListeners.set(id, listener);
    }

    function unregisterScrollListener(id) {
      scrollListeners.delete(id);
      if (unbindScrollListener && !scrollListeners.size) {
        unbindScrollListener();
        unbindScrollListener = null;
      }
    }

    var grid = {
      extends: Margin,

      mixins: [Class, Scroll],

      name: 'grid',

      props: {
        masonry: Boolean,
        parallax: Number },


      data: {
        margin: 'uk-grid-margin',
        clsStack: 'uk-grid-stack',
        masonry: false,
        parallax: 0 },


      connected() {
        this.masonry && addClass(this.$el, 'uk-flex-top uk-flex-wrap-top');
      },

      update: [
      {
        write(_ref) {let { columns } = _ref;
          toggleClass(this.$el, this.clsStack, columns.length < 2);
        },

        events: ['resize'] },


      {
        read(data) {
          let { columns, rows } = data;

          // Filter component makes elements positioned absolute
          if (
          !columns.length ||
          !this.masonry && !this.parallax ||
          positionedAbsolute(this.$el))
          {
            data.translates = false;
            return false;
          }

          let translates = false;

          const nodes = children(this.$el);
          const columnHeights = getColumnHeights(columns);
          const margin = getMarginTop(nodes, this.margin) * (rows.length - 1);
          const elHeight = Math.max(...columnHeights) + margin;

          if (this.masonry) {
            columns = columns.map((column) => sortBy$1(column, 'offsetTop'));
            translates = getTranslates(rows, columns);
          }

          let padding = Math.abs(this.parallax);
          if (padding) {
            padding = columnHeights.reduce(
            (newPadding, hgt, i) =>
            Math.max(
            newPadding,
            hgt + margin + (i % 2 ? padding : padding / 8) - elHeight),

            0);

          }

          return { padding, columns, translates, height: translates ? elHeight : '' };
        },

        write(_ref2) {let { height, padding } = _ref2;
          css(this.$el, 'paddingBottom', padding || '');
          height !== false && css(this.$el, 'height', height);
        },

        events: ['resize'] },


      {
        read() {
          if (this.parallax && positionedAbsolute(this.$el)) {
            return false;
          }

          return {
            scrolled: this.parallax ?
            scrolledOver(this.$el) * Math.abs(this.parallax) :
            false };

        },

        write(_ref3) {let { columns, scrolled, translates } = _ref3;
          if (scrolled === false && !translates) {
            return;
          }

          columns.forEach((column, i) =>
          column.forEach((el, j) =>
          css(
          el,
          'transform',
          !scrolled && !translates ?
          '' : "translateY(" + (

          (translates && -translates[i][j]) + (
          scrolled ? i % 2 ? scrolled : scrolled / 8 : 0)) + "px)")));




        },

        events: ['scroll', 'resize'] }] };




    function positionedAbsolute(el) {
      return children(el).some((el) => css(el, 'position') === 'absolute');
    }

    function getTranslates(rows, columns) {
      const rowHeights = rows.map((row) => Math.max(...row.map((el) => el.offsetHeight)));

      return columns.map((elements) => {
        let prev = 0;
        return elements.map(
        (element, row) =>
        prev += row ? rowHeights[row - 1] - elements[row - 1].offsetHeight : 0);

      });
    }

    function getMarginTop(nodes, cls) {
      const [node] = nodes.filter((el) => hasClass(el, cls));

      return toFloat(node ? css(node, 'marginTop') : css(nodes[0], 'paddingLeft'));
    }

    function getColumnHeights(columns) {
      return columns.map((column) => column.reduce((sum, el) => sum + el.offsetHeight, 0));
    }

    var heightMatch = {
      mixins: [Resize],

      args: 'target',

      props: {
        target: String,
        row: Boolean },


      data: {
        target: '> *',
        row: true },


      computed: {
        elements: {
          get(_ref, $el) {let { target } = _ref;
            return $$(target, $el);
          },

          watch() {
            this.$reset();
          } } },



      resizeTargets() {
        return [this.$el, this.elements];
      },

      update: {
        read() {
          return {
            rows: (this.row ? getRows(this.elements) : [this.elements]).map(match$1) };

        },

        write(_ref2) {let { rows } = _ref2;
          for (const { heights, elements } of rows) {
            elements.forEach((el, i) => css(el, 'minHeight', heights[i]));
          }
        },

        events: ['resize'] } };



    function match$1(elements) {
      if (elements.length < 2) {
        return { heights: [''], elements };
      }

      css(elements, 'minHeight', '');
      let heights = elements.map(getHeight);
      const max = Math.max(...heights);

      return {
        heights: elements.map((el, i) => heights[i].toFixed(2) === max.toFixed(2) ? '' : max),
        elements };

    }

    function getHeight(element) {
      let style = false;
      if (!isVisible(element)) {
        style = element.style.display;
        css(element, 'display', 'block', 'important');
      }

      const height = dimensions$1(element).height - boxModelAdjust(element, 'height', 'content-box');

      if (style !== false) {
        css(element, 'display', style);
      }

      return height;
    }

    var heightViewport = {
      mixins: [Class, Resize],

      props: {
        expand: Boolean,
        offsetTop: Boolean,
        offsetBottom: Boolean,
        minHeight: Number },


      data: {
        expand: false,
        offsetTop: false,
        offsetBottom: false,
        minHeight: 0 },


      resizeTargets() {
        // check for offsetTop change
        return [this.$el, document.documentElement];
      },

      update: {
        read(_ref) {let { minHeight: prev } = _ref;
          if (!isVisible(this.$el)) {
            return false;
          }

          let minHeight = '';
          const box = boxModelAdjust(this.$el, 'height', 'content-box');

          if (this.expand) {
            minHeight = Math.max(
            height(window) - (
            dimensions$1(document.documentElement).height -
            dimensions$1(this.$el).height) -
            box,
            0);

          } else {
            // on mobile devices (iOS and Android) window.innerHeight !== 100vh
            minHeight = 'calc(100vh';

            if (this.offsetTop) {
              const { top } = offset(this.$el);
              minHeight += top > 0 && top < height(window) / 2 ? " - " + top + "px" : '';
            }

            if (this.offsetBottom === true) {
              minHeight += " - " + dimensions$1(this.$el.nextElementSibling).height + "px";
            } else if (isNumeric(this.offsetBottom)) {
              minHeight += " - " + this.offsetBottom + "vh";
            } else if (this.offsetBottom && endsWith(this.offsetBottom, 'px')) {
              minHeight += " - " + toFloat(this.offsetBottom) + "px";
            } else if (isString(this.offsetBottom)) {
              minHeight += " - " + dimensions$1(query(this.offsetBottom, this.$el)).height + "px";
            }

            minHeight += (box ? " - " + box + "px" : '') + ")";
          }

          return { minHeight, prev };
        },

        write(_ref2) {let { minHeight } = _ref2;
          css(this.$el, { minHeight });

          if (this.minHeight && toFloat(css(this.$el, 'minHeight')) < this.minHeight) {
            css(this.$el, 'minHeight', this.minHeight);
          }
        },

        events: ['resize'] } };

    var SVG = {
      args: 'src',

      props: {
        id: Boolean,
        icon: String,
        src: String,
        style: String,
        width: Number,
        height: Number,
        ratio: Number,
        class: String,
        strokeAnimation: Boolean,
        focusable: Boolean, // IE 11
        attributes: 'list' },


      data: {
        ratio: 1,
        include: ['style', 'class', 'focusable'],
        class: '',
        strokeAnimation: false },


      beforeConnect() {
        this.class += ' uk-svg';
      },

      connected() {
        if (!this.icon && includes(this.src, '#')) {
          [this.src, this.icon] = this.src.split('#');
        }

        this.svg = this.getSvg().then((el) => {
          if (this._connected) {
            const svg = insertSVG(el, this.$el);

            if (this.svgEl && svg !== this.svgEl) {
              remove$1(this.svgEl);
            }

            this.applyAttributes(svg, el);

            return this.svgEl = svg;
          }
        }, noop);

        if (this.strokeAnimation) {
          this.svg.then((el) => {
            if (this._connected) {
              applyAnimation(el);
              this.registerObserver(
              observeIntersection(el, (records, observer) => {
                applyAnimation(el);
                observer.disconnect();
              }));

            }
          });
        }
      },

      disconnected() {
        this.svg.then((svg) => {
          if (this._connected) {
            return;
          }

          if (isVoidElement(this.$el)) {
            this.$el.hidden = false;
          }

          remove$1(svg);
          this.svgEl = null;
        });

        this.svg = null;
      },

      methods: {
        async getSvg() {
          if (isTag(this.$el, 'img') && !this.$el.complete && this.$el.loading === 'lazy') {
            return new Promise((resolve) =>
            once(this.$el, 'load', () => resolve(this.getSvg())));

          }

          return parseSVG(await loadSVG(this.src), this.icon) || Promise.reject('SVG not found.');
        },

        applyAttributes(el, ref) {
          for (const prop in this.$options.props) {
            if (includes(this.include, prop) && prop in this) {
              attr(el, prop, this[prop]);
            }
          }

          for (const attribute in this.attributes) {
            const [prop, value] = this.attributes[attribute].split(':', 2);
            attr(el, prop, value);
          }

          if (!this.id) {
            removeAttr(el, 'id');
          }

          const props = ['width', 'height'];
          let dimensions = props.map((prop) => this[prop]);

          if (!dimensions.some((val) => val)) {
            dimensions = props.map((prop) => attr(ref, prop));
          }

          const viewBox = attr(ref, 'viewBox');
          if (viewBox && !dimensions.some((val) => val)) {
            dimensions = viewBox.split(' ').slice(2);
          }

          dimensions.forEach((val, i) => attr(el, props[i], toFloat(val) * this.ratio || null));
        } } };



    const loadSVG = memoize(async (src) => {
      if (src) {
        if (startsWith(src, 'data:')) {
          return decodeURIComponent(src.split(',')[1]);
        } else {
          return (await fetch(src)).text();
        }
      } else {
        return Promise.reject();
      }
    });

    function parseSVG(svg, icon) {var _svg;
      if (icon && includes(svg, '<symbol')) {
        svg = parseSymbols(svg, icon) || svg;
      }

      svg = $(svg.substr(svg.indexOf('<svg')));
      return ((_svg = svg) == null ? void 0 : _svg.hasChildNodes()) && svg;
    }

    const symbolRe = /<symbol([^]*?id=(['"])(.+?)\2[^]*?<\/)symbol>/g;
    const symbols = {};

    function parseSymbols(svg, icon) {
      if (!symbols[svg]) {
        symbols[svg] = {};

        symbolRe.lastIndex = 0;

        let match;
        while (match = symbolRe.exec(svg)) {
          symbols[svg][match[3]] = "<svg xmlns=\"http://www.w3.org/2000/svg\"" + match[1] + "svg>";
        }
      }

      return symbols[svg][icon];
    }

    function applyAnimation(el) {
      const length = getMaxPathLength(el);

      if (length) {
        el.style.setProperty('--uk-animation-stroke', length);
      }
    }

    function getMaxPathLength(el) {
      return Math.ceil(
      Math.max(
      0,
      ...$$('[stroke]', el).map((stroke) => {
        try {
          return stroke.getTotalLength();
        } catch (e) {
          return 0;
        }
      })));


    }

    function insertSVG(el, root) {
      if (isVoidElement(root) || isTag(root, 'canvas')) {
        root.hidden = true;

        const next = root.nextElementSibling;
        return equals(el, next) ? next : after(root, el);
      }

      const last = root.lastElementChild;
      return equals(el, last) ? last : append(root, el);
    }

    function equals(el, other) {
      return isTag(el, 'svg') && isTag(other, 'svg') && innerHTML(el) === innerHTML(other);
    }

    function innerHTML(el) {
      return (
      el.innerHTML ||
      new XMLSerializer().serializeToString(el).replace(/<svg.*?>(.*?)<\/svg>/g, '$1')).
      replace(/\s/g, '');
    }

    var closeIcon = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"1\" y1=\"1\" x2=\"13\" y2=\"13\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13\" y1=\"1\" x2=\"1\" y2=\"13\"/></svg>";

    var closeLarge = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"1\" y1=\"1\" x2=\"19\" y2=\"19\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"19\" y1=\"1\" x2=\"1\" y2=\"19\"/></svg>";

    var marker = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"4\" width=\"1\" height=\"11\"/><rect x=\"4\" y=\"9\" width=\"11\" height=\"1\"/></svg>";

    var navbarToggleIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"9\" width=\"20\" height=\"2\"/><rect y=\"3\" width=\"20\" height=\"2\"/><rect y=\"15\" width=\"20\" height=\"2\"/></svg>";

    var overlayIcon = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"19\" y=\"0\" width=\"1\" height=\"40\"/><rect x=\"0\" y=\"19\" width=\"40\" height=\"1\"/></svg>";

    var paginationNext = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 1 6 6 1 11\"/></svg>";

    var paginationPrevious = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"6 1 1 6 6 11\"/></svg>";

    var searchIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>";

    var searchLarge = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" cx=\"17.5\" cy=\"17.5\" r=\"16.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" x1=\"38\" y1=\"39\" x2=\"29\" y2=\"30\"/></svg>";

    var searchNavbar = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10.5\" cy=\"10.5\" r=\"9.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"23\" y1=\"23\" x2=\"17\" y2=\"17\"/></svg>";

    var slidenavNext = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"1.225,23 12.775,12 1.225,1 \"/></svg>";

    var slidenavNextLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"4.002,38.547 22.527,20.024 4,1.5 \"/></svg>";

    var slidenavPrevious = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"12.775,1 1.225,12 12.775,23 \"/></svg>";

    var slidenavPreviousLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"20.527,1.5 2,20.024 20.525,38.547 \"/></svg>";

    var spinner = "<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"15\" cy=\"15\" r=\"14\"/></svg>";

    var totop = "<svg width=\"18\" height=\"10\" viewBox=\"0 0 18 10\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 9 9 1 17 9 \"/></svg>";

    const icons = {
      spinner,
      totop,
      marker,
      'close-icon': closeIcon,
      'close-large': closeLarge,
      'navbar-toggle-icon': navbarToggleIcon,
      'overlay-icon': overlayIcon,
      'pagination-next': paginationNext,
      'pagination-previous': paginationPrevious,
      'search-icon': searchIcon,
      'search-large': searchLarge,
      'search-navbar': searchNavbar,
      'slidenav-next': slidenavNext,
      'slidenav-next-large': slidenavNextLarge,
      'slidenav-previous': slidenavPrevious,
      'slidenav-previous-large': slidenavPreviousLarge };


    const Icon = {
      install: install$3,

      extends: SVG,

      args: 'icon',

      props: ['icon'],

      data: {
        include: ['focusable'] },


      isIcon: true,

      beforeConnect() {
        addClass(this.$el, 'uk-icon');
      },

      methods: {
        async getSvg() {
          const icon = getIcon(this.icon);

          if (!icon) {
            throw 'Icon not found.';
          }

          return icon;
        } } };

    const IconComponent = {
      args: false,

      extends: Icon,

      data: (vm) => ({
        icon: hyphenate(vm.constructor.options.name) }),


      beforeConnect() {
        addClass(this.$el, this.$name);
      } };


    const Slidenav = {
      extends: IconComponent,

      beforeConnect() {
        addClass(this.$el, 'uk-slidenav');
        const icon = this.$props.icon;
        this.icon = hasClass(this.$el, 'uk-slidenav-large') ? icon + "-large" : icon;
      } };


    const Search = {
      extends: IconComponent,

      beforeConnect() {
        this.icon =
        hasClass(this.$el, 'uk-search-icon') && parents(this.$el, '.uk-search-large').length ?
        'search-large' :
        parents(this.$el, '.uk-search-navbar').length ?
        'search-navbar' :
        this.$props.icon;
      } };


    const Close = {
      extends: IconComponent,

      beforeConnect() {
        this.icon = "close-" + (hasClass(this.$el, 'uk-close-large') ? 'large' : 'icon');
      } };


    const Spinner = {
      extends: IconComponent,

      methods: {
        async getSvg() {
          const icon = await Icon.methods.getSvg.call(this);

          if (this.ratio !== 1) {
            css($('circle', icon), 'strokeWidth', 1 / this.ratio);
          }

          return icon;
        } } };



    const parsed = {};
    function install$3(UIkit) {
      UIkit.icon.add = (name, svg) => {
        const added = isString(name) ? { [name]: svg } : name;
        each(added, (svg, name) => {
          icons[name] = svg;
          delete parsed[name];
        });

        if (UIkit._initialized) {
          apply(document.body, (el) =>
          each(UIkit.getComponents(el), (cmp) => {
            cmp.$options.isIcon && cmp.icon in added && cmp.$reset();
          }));

        }
      };
    }

    function getIcon(icon) {
      if (!icons[icon]) {
        return null;
      }

      if (!parsed[icon]) {
        parsed[icon] = $((icons[applyRtl(icon)] || icons[icon]).trim());
      }

      return parsed[icon].cloneNode(true);
    }

    function applyRtl(icon) {
      return isRtl ? swap(swap(icon, 'left', 'right'), 'previous', 'next') : icon;
    }

    const nativeLazyLoad = inBrowser && 'loading' in HTMLImageElement.prototype;

    var img = {
      args: 'dataSrc',

      props: {
        dataSrc: String,
        sources: String,
        offsetTop: String,
        offsetLeft: String,
        target: String,
        loading: String },


      data: {
        dataSrc: '',
        sources: false,
        offsetTop: '50vh',
        offsetLeft: '50vw',
        target: false,
        loading: 'lazy' },


      connected() {
        if (this.loading !== 'lazy') {
          this.load();
          return;
        }

        const target = [this.$el, ...queryAll(this.$props.target, this.$el)];

        if (nativeLazyLoad && isImg(this.$el)) {
          this.$el.loading = 'lazy';
          setSrcAttrs(this.$el);

          if (target.length === 1) {
            return;
          }
        }

        ensureSrcAttribute(this.$el);

        this.registerObserver(
        observeIntersection(
        target,
        (entries, observer) => {
          this.load();
          observer.disconnect();
        },
        {
          rootMargin: toPx(this.offsetTop, 'height') + "px " + toPx(
          this.offsetLeft,
          'width') + "px" }));




      },

      disconnected() {
        if (this._data.image) {
          this._data.image.onload = '';
        }
      },

      methods: {
        load() {
          if (this._data.image) {
            return this._data.image;
          }

          const image = isImg(this.$el) ?
          this.$el :
          getImageFromElement(this.$el, this.dataSrc, this.sources);

          removeAttr(image, 'loading');
          setSrcAttrs(this.$el, image.currentSrc);
          return this._data.image = image;
        } } };



    function setSrcAttrs(el, src) {
      if (isImg(el)) {
        const parentNode = parent(el);
        const elements = isPicture(parentNode) ? children(parentNode) : [el];
        elements.forEach((el) => setSourceProps(el, el));
      } else if (src) {
        const change = !includes(el.style.backgroundImage, src);
        if (change) {
          css(el, 'backgroundImage', "url(" + escape(src) + ")");
          trigger(el, createEvent('load', false));
        }
      }
    }

    const srcProps = ['data-src', 'data-srcset', 'sizes'];
    function setSourceProps(sourceEl, targetEl) {
      srcProps.forEach((prop) => {
        const value = data(sourceEl, prop);
        if (value) {
          attr(targetEl, prop.replace(/^(data-)+/, ''), value);
        }
      });
    }

    function getImageFromElement(el, src, sources) {
      const img = new Image();

      wrapInPicture(img, sources);
      setSourceProps(el, img);
      img.onload = () => {
        setSrcAttrs(el, img.currentSrc);
      };
      attr(img, 'src', src);
      return img;
    }

    function wrapInPicture(img, sources) {
      sources = parseSources(sources);

      if (sources.length) {
        const picture = fragment('<picture>');
        for (const attrs of sources) {
          const source = fragment('<source>');
          attr(source, attrs);
          append(picture, source);
        }
        append(picture, img);
      }
    }

    function parseSources(sources) {
      if (!sources) {
        return [];
      }

      if (startsWith(sources, '[')) {
        try {
          sources = JSON.parse(sources);
        } catch (e) {
          sources = [];
        }
      } else {
        sources = parseOptions(sources);
      }

      if (!isArray(sources)) {
        sources = [sources];
      }

      return sources.filter((source) => !isEmpty(source));
    }

    function ensureSrcAttribute(el) {
      if (isImg(el) && !hasAttr(el, 'src')) {
        attr(el, 'src', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg"></svg>');
      }
    }

    function isPicture(el) {
      return isTag(el, 'picture');
    }

    function isImg(el) {
      return isTag(el, 'img');
    }

    var Media = {
      props: {
        media: Boolean },


      data: {
        media: false },


      connected() {
        const media = toMedia(this.media);
        this.mediaObj = window.matchMedia(media);
        const handler = () => {
          this.matchMedia = this.mediaObj.matches;
          trigger(this.$el, createEvent('mediachange', false, true, [this.mediaObj]));
        };
        this.offMediaObj = on(this.mediaObj, 'change', () => {
          handler();
          this.$emit('resize');
        });
        handler();
      },

      disconnected() {var _this$offMediaObj;
        (_this$offMediaObj = this.offMediaObj) == null ? void 0 : _this$offMediaObj.call(this);
      } };


    function toMedia(value) {
      if (isString(value)) {
        if (startsWith(value, '@')) {
          const name = "breakpoint-" + value.substr(1);
          value = toFloat(getCssVar(name));
        } else if (isNaN(value)) {
          return value;
        }
      }

      return value && isNumeric(value) ? "(min-width: " + value + "px)" : '';
    }

    var leader = {
      mixins: [Class, Media, Resize],

      props: {
        fill: String },


      data: {
        fill: '',
        clsWrapper: 'uk-leader-fill',
        clsHide: 'uk-leader-hide',
        attrFill: 'data-fill' },


      computed: {
        fill(_ref) {let { fill } = _ref;
          return fill || getCssVar('leader-fill-content');
        } },


      connected() {
        [this.wrapper] = wrapInner(this.$el, "<span class=\"" + this.clsWrapper + "\">");
      },

      disconnected() {
        unwrap(this.wrapper.childNodes);
      },

      update: {
        read() {
          const width = Math.trunc(this.$el.offsetWidth / 2);

          return {
            width,
            fill: this.fill,
            hide: !this.matchMedia };

        },

        write(_ref2) {let { width, fill, hide } = _ref2;
          toggleClass(this.wrapper, this.clsHide, hide);
          attr(this.wrapper, this.attrFill, new Array(width).join(fill));
        },

        events: ['resize'] } };

    const active = [];

    var Modal = {
      mixins: [Class, Container, Togglable],

      props: {
        selPanel: String,
        selClose: String,
        escClose: Boolean,
        bgClose: Boolean,
        stack: Boolean },


      data: {
        cls: 'uk-open',
        escClose: true,
        bgClose: true,
        overlay: true,
        stack: false },


      computed: {
        panel(_ref, $el) {let { selPanel } = _ref;
          return $(selPanel, $el);
        },

        transitionElement() {
          return this.panel;
        },

        bgClose(_ref2) {let { bgClose } = _ref2;
          return bgClose && this.panel;
        } },


      beforeDisconnect() {
        if (includes(active, this)) {
          this.toggleElement(this.$el, false, false);
        }
      },

      events: [
      {
        name: 'click',

        delegate() {
          return this.selClose;
        },

        handler(e) {
          e.preventDefault();
          this.hide();
        } },


      {
        name: 'toggle',

        self: true,

        handler(e) {
          if (e.defaultPrevented) {
            return;
          }

          e.preventDefault();

          if (this.isToggled() === includes(active, this)) {
            this.toggle();
          }
        } },


      {
        name: 'beforeshow',

        self: true,

        handler(e) {
          if (includes(active, this)) {
            return false;
          }

          if (!this.stack && active.length) {
            Promise.all(active.map((modal) => modal.hide())).then(this.show);
            e.preventDefault();
          } else {
            active.push(this);
          }
        } },


      {
        name: 'show',

        self: true,

        handler() {
          const docEl = document.documentElement;

          if (width(window) > docEl.clientWidth && this.overlay) {
            css(document.body, 'overflowY', 'scroll');
          }

          if (this.stack) {
            css(this.$el, 'zIndex', toFloat(css(this.$el, 'zIndex')) + active.length);
          }

          addClass(docEl, this.clsPage);

          if (this.bgClose) {
            once(
            this.$el,
            'hide',
            on(document, pointerDown, (_ref3) => {let { target } = _ref3;
              if (
              last(active) !== this ||
              this.overlay && !within(target, this.$el) ||
              within(target, this.panel))
              {
                return;
              }

              once(
              document,
              pointerUp + " " + pointerCancel + " scroll",
              (_ref4) => {let { defaultPrevented, type, target: newTarget } = _ref4;
                if (
                !defaultPrevented &&
                type === pointerUp &&
                target === newTarget)
                {
                  this.hide();
                }
              },
              true);

            }),
            { self: true });

          }

          if (this.escClose) {
            once(
            this.$el,
            'hide',
            on(document, 'keydown', (e) => {
              if (e.keyCode === 27 && last(active) === this) {
                this.hide();
              }
            }),
            { self: true });

          }
        } },


      {
        name: 'shown',

        self: true,

        handler() {
          if (!isFocusable(this.$el)) {
            attr(this.$el, 'tabindex', '-1');
          }

          if (!$(':focus', this.$el)) {
            this.$el.focus();
          }
        } },


      {
        name: 'hidden',

        self: true,

        handler() {
          if (includes(active, this)) {
            active.splice(active.indexOf(this), 1);
          }

          if (!active.length) {
            css(document.body, 'overflowY', '');
          }

          css(this.$el, 'zIndex', '');

          if (!active.some((modal) => modal.clsPage === this.clsPage)) {
            removeClass(document.documentElement, this.clsPage);
          }
        } }],



      methods: {
        toggle() {
          return this.isToggled() ? this.hide() : this.show();
        },

        show() {
          if (this.container && parent(this.$el) !== this.container) {
            append(this.container, this.$el);
            return new Promise((resolve) =>
            requestAnimationFrame(() => this.show().then(resolve)));

          }

          return this.toggleElement(this.$el, true, animate(this));
        },

        hide() {
          return this.toggleElement(this.$el, false, animate(this));
        } } };



    function animate(_ref5) {let { transitionElement, _toggle } = _ref5;
      return (el, show) =>
      new Promise((resolve, reject) =>
      once(el, 'show hide', () => {
        el._reject && el._reject();
        el._reject = reject;

        _toggle(el, show);

        const off = once(
        transitionElement,
        'transitionstart',
        () => {
          once(transitionElement, 'transitionend transitioncancel', resolve, {
            self: true });

          clearTimeout(timer);
        },
        { self: true });


        const timer = setTimeout(() => {
          off();
          resolve();
        }, toMs(css(transitionElement, 'transitionDuration')));
      })).
      then(() => delete el._reject);
    }

    var modal = {
      install: install$2,

      mixins: [Modal],

      data: {
        clsPage: 'uk-modal-page',
        selPanel: '.uk-modal-dialog',
        selClose:
        '.uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full' },


      events: [
      {
        name: 'show',

        self: true,

        handler() {
          if (hasClass(this.panel, 'uk-margin-auto-vertical')) {
            addClass(this.$el, 'uk-flex');
          } else {
            css(this.$el, 'display', 'block');
          }

          height(this.$el); // force reflow
        } },


      {
        name: 'hidden',

        self: true,

        handler() {
          css(this.$el, 'display', '');
          removeClass(this.$el, 'uk-flex');
        } }] };




    function install$2(_ref) {let { modal } = _ref;
      modal.dialog = function (content, options) {
        const dialog = modal("<div class=\"uk-modal\"> <div class=\"uk-modal-dialog\">" +

        content + "</div> </div>",

        options);


        dialog.show();

        on(
        dialog.$el,
        'hidden',
        async () => {
          await Promise.resolve();
          dialog.$destroy(true);
        },
        { self: true });


        return dialog;
      };

      modal.alert = function (message, options) {
        return openDialog(
        (_ref2) => {let { labels } = _ref2;return "<div class=\"uk-modal-body\">" + (
          isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-primary uk-modal-close\" autofocus>" +



          labels.ok + "</button> </div>";},


        options,
        (deferred) => deferred.resolve());

      };

      modal.confirm = function (message, options) {
        return openDialog(
        (_ref3) => {let { labels } = _ref3;return "<form> <div class=\"uk-modal-body\">" + (
          isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" +


          labels.cancel + "</button> <button class=\"uk-button uk-button-primary\" autofocus>" +

          labels.ok + "</button> </div> </form>";},


        options,
        (deferred) => deferred.reject());

      };

      modal.prompt = function (message, value, options) {
        return openDialog(
        (_ref4) => {let { labels } = _ref4;return "<form class=\"uk-form-stacked\"> <div class=\"uk-modal-body\"> <label>" + (

          isString(message) ? message : html(message)) + "</label> <input class=\"uk-input\" value=\"" + (
          value || '') + "\" autofocus> </div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" +



          labels.cancel + "</button> <button class=\"uk-button uk-button-primary\">" +

          labels.ok + "</button> </div> </form>";},


        options,
        (deferred) => deferred.resolve(null),
        (dialog) => $('input', dialog.$el).value);

      };

      modal.labels = {
        ok: 'Ok',
        cancel: 'Cancel' };


      function openDialog(tmpl, options, hideFn, submitFn) {
        options = { bgClose: false, escClose: true, labels: modal.labels, ...options };

        const dialog = modal.dialog(tmpl(options), options);
        const deferred = new Deferred();

        let resolved = false;

        on(dialog.$el, 'submit', 'form', (e) => {
          e.preventDefault();
          deferred.resolve(submitFn == null ? void 0 : submitFn(dialog));
          resolved = true;
          dialog.hide();
        });

        on(dialog.$el, 'hide', () => !resolved && hideFn(deferred));

        deferred.promise.dialog = dialog;

        return deferred.promise;
      }
    }

    var nav = {
      extends: Accordion,

      data: {
        targets: '> .uk-parent',
        toggle: '> a',
        content: '> ul' } };

    const navItem = '.uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle';

    var navbar = {
      mixins: [Class, Container],

      props: {
        dropdown: String,
        mode: 'list',
        align: String,
        offset: Number,
        boundary: Boolean,
        boundaryAlign: Boolean,
        clsDrop: String,
        delayShow: Number,
        delayHide: Number,
        dropbar: Boolean,
        dropbarAnchor: Boolean,
        duration: Number },


      data: {
        dropdown: navItem,
        align: isRtl ? 'right' : 'left',
        clsDrop: 'uk-navbar-dropdown',
        mode: undefined,
        offset: undefined,
        delayShow: undefined,
        delayHide: undefined,
        boundaryAlign: undefined,
        flip: 'x',
        boundary: true,
        dropbar: false,
        dropbarAnchor: false,
        duration: 200,
        container: false },


      computed: {
        boundary(_ref, $el) {let { boundary } = _ref;
          return boundary === true ? $el : boundary;
        },

        dropbarAnchor(_ref2, $el) {let { dropbarAnchor } = _ref2;
          return query(dropbarAnchor, $el);
        },

        pos(_ref3) {let { align } = _ref3;
          return "bottom-" + align;
        },

        dropbar: {
          get(_ref4) {let { dropbar } = _ref4;
            if (!dropbar) {
              return null;
            }

            dropbar =
            this._dropbar ||
            query(dropbar, this.$el) ||
            $('+ .uk-navbar-dropbar', this.$el);

            return dropbar ? dropbar : this._dropbar = $('<div></div>');
          },

          watch(dropbar) {
            addClass(dropbar, 'uk-navbar-dropbar');
          },

          immediate: true },


        dropContainer(_, $el) {
          return this.container || $el;
        },

        dropdowns: {
          get(_ref5, $el) {let { clsDrop } = _ref5;
            const dropdowns = $$("." + clsDrop, $el);

            if (this.dropContainer !== $el) {
              for (const el of $$("." + clsDrop, this.dropContainer)) {var _this$getDropdown;
                const target = (_this$getDropdown = this.getDropdown(el)) == null ? void 0 : _this$getDropdown.target;
                if (!includes(dropdowns, el) && target && within(target, this.$el)) {
                  dropdowns.push(el);
                }
              }
            }

            return dropdowns;
          },

          watch(dropdowns) {
            this.$create(
            'drop',
            dropdowns.filter((el) => !this.getDropdown(el)),
            {
              ...this.$props,
              boundary: this.boundary,
              pos: this.pos,
              offset: this.dropbar || this.offset });


          },

          immediate: true },


        toggles(_ref6, $el) {let { dropdown } = _ref6;
          return $$(dropdown, $el);
        } },


      disconnected() {
        this.dropbar && remove$1(this.dropbar);
        delete this._dropbar;
      },

      events: [
      {
        name: 'mouseover focusin',

        delegate() {
          return this.dropdown;
        },

        handler(_ref7) {let { current } = _ref7;
          const active = this.getActive();
          if (
          active &&
          includes(active.mode, 'hover') &&
          active.target &&
          !within(active.target, current) &&
          !active.isDelaying)
          {
            active.hide(false);
          }
        } },


      {
        name: 'keydown',

        delegate() {
          return this.dropdown;
        },

        handler(e) {
          const { current, keyCode } = e;
          const active = this.getActive();

          if (keyCode === keyMap.DOWN && hasAttr(current, 'aria-expanded')) {
            e.preventDefault();

            if (!active || active.target !== current) {
              current.click();
              once(this.dropContainer, 'show', (_ref8) => {let { target } = _ref8;return (
                  focusFirstFocusableElement(target));});

            } else {
              focusFirstFocusableElement(active.$el);
            }
          }

          handleNavItemNavigation(e, this.toggles, active);
        } },


      {
        name: 'keydown',

        el() {
          return this.dropContainer;
        },

        delegate() {
          return "." + this.clsDrop;
        },

        handler(e) {
          const { current, keyCode } = e;

          if (!includes(this.dropdowns, current)) {
            return;
          }

          const active = this.getActive();
          const elements = $$(selFocusable, current);
          const i = findIndex(elements, (el) => matches(el, ':focus'));

          if (keyCode === keyMap.UP) {
            e.preventDefault();
            if (i > 0) {
              elements[i - 1].focus();
            }
          }

          if (keyCode === keyMap.DOWN) {
            e.preventDefault();
            if (i < elements.length - 1) {
              elements[i + 1].focus();
            }
          }

          if (keyCode === keyMap.ESC) {var _active$target;
            active == null ? void 0 : (_active$target = active.target) == null ? void 0 : _active$target.focus();
          }

          handleNavItemNavigation(e, this.toggles, active);
        } },


      {
        name: 'mouseleave',

        el() {
          return this.dropbar;
        },

        filter() {
          return this.dropbar;
        },

        handler() {
          const active = this.getActive();

          if (
          active &&
          includes(active.mode, 'hover') &&
          !this.dropdowns.some((el) => matches(el, ':hover')))
          {
            active.hide();
          }
        } },


      {
        name: 'beforeshow',

        el() {
          return this.dropContainer;
        },

        filter() {
          return this.dropbar;
        },

        handler(_, _ref9) {let { $el } = _ref9;
          if (!hasClass($el, this.clsDrop)) {
            return;
          }

          if (!parent(this.dropbar)) {
            after(this.dropbarAnchor || this.$el, this.dropbar);
          }

          addClass($el, this.clsDrop + "-dropbar");
        } },


      {
        name: 'show',

        el() {
          return this.dropContainer;
        },

        filter() {
          return this.dropbar;
        },

        handler(_, _ref10) {let { $el, dir } = _ref10;
          if (!hasClass($el, this.clsDrop)) {
            return;
          }

          if (dir === 'bottom') {
            this.transitionTo(
            offset($el).bottom -
            offset(this.dropbar).top +
            toFloat(css($el, 'marginBottom')),
            $el);

          }
        } },


      {
        name: 'beforehide',

        el() {
          return this.dropContainer;
        },

        filter() {
          return this.dropbar;
        },

        handler(e, _ref11) {let { $el } = _ref11;
          const active = this.getActive();

          if (
          matches(this.dropbar, ':hover') &&
          (active == null ? void 0 : active.$el) === $el &&
          !this.toggles.some((el) => active.target !== el && matches(el, ':focus')))
          {
            e.preventDefault();
          }
        } },


      {
        name: 'hide',

        el() {
          return this.dropContainer;
        },

        filter() {
          return this.dropbar;
        },

        handler(_, _ref12) {let { $el } = _ref12;
          if (!hasClass($el, this.clsDrop)) {
            return;
          }

          const active = this.getActive();

          if (!active || (active == null ? void 0 : active.$el) === $el) {
            this.transitionTo(0);
          }
        } }],



      methods: {
        getActive() {
          return active$1 && within(active$1.target, this.$el) && active$1;
        },

        transitionTo(newHeight, el) {
          const { dropbar } = this;
          const oldHeight = isVisible(dropbar) ? height(dropbar) : 0;

          el = oldHeight < newHeight && el;

          css(el, 'clip', "rect(0," + el.offsetWidth + "px," + oldHeight + "px,0)");

          height(dropbar, oldHeight);

          Transition.cancel([el, dropbar]);
          return Promise.all([
          Transition.start(dropbar, { height: newHeight }, this.duration),
          Transition.start(
          el,
          { clip: "rect(0," + el.offsetWidth + "px," + newHeight + "px,0)" },
          this.duration)]).


          catch(noop).
          then(() => {
            css(el, { clip: '' });
            this.$update(dropbar);
          });
        },

        getDropdown(el) {
          return this.$getComponent(el, 'drop') || this.$getComponent(el, 'dropdown');
        } } };



    function handleNavItemNavigation(e, toggles, active) {
      const { current, keyCode } = e;
      const target = (active == null ? void 0 : active.target) || current;
      const i = toggles.indexOf(target);

      // Left
      if (keyCode === keyMap.LEFT && i > 0) {
        active == null ? void 0 : active.hide(false);
        toggles[i - 1].focus();
      }

      // Right
      if (keyCode === keyMap.RIGHT && i < toggles.length - 1) {
        active == null ? void 0 : active.hide(false);
        toggles[i + 1].focus();
      }

      if (keyCode === keyMap.TAB) {
        target.focus();
        active == null ? void 0 : active.hide(false);
      }
    }

    function focusFirstFocusableElement(el) {
      if (!$(':focus', el)) {var _$;
        (_$ = $(selFocusable, el)) == null ? void 0 : _$.focus();
      }
    }

    const keyMap = {
      TAB: 9,
      ESC: 27,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40 };

    var Swipe = {
      props: {
        swiping: Boolean },


      data: {
        swiping: true },


      computed: {
        swipeTarget(props, $el) {
          return $el;
        } },


      connected() {
        if (!this.swiping) {
          return;
        }

        registerEvent(this, {
          el: this.swipeTarget,
          name: pointerDown,
          passive: true,
          handler(e) {
            if (!isTouch(e)) {
              return;
            }

            // Handle Swipe Gesture
            const pos = getEventPos(e);
            const target = 'tagName' in e.target ? e.target : parent(e.target);
            once(document, pointerUp + " " + pointerCancel + " scroll", (e) => {
              const { x, y } = getEventPos(e);

              // swipe
              if (
              e.type !== 'scroll' && target && x && Math.abs(pos.x - x) > 100 ||
              y && Math.abs(pos.y - y) > 100)
              {
                setTimeout(() => {
                  trigger(target, 'swipe');
                  trigger(target, "swipe" + swipeDirection(pos.x, pos.y, x, y));
                });
              }
            });
          } });

      } };


    function swipeDirection(x1, y1, x2, y2) {
      return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ?
      x1 - x2 > 0 ?
      'Left' :
      'Right' :
      y1 - y2 > 0 ?
      'Up' :
      'Down';
    }

    var offcanvas = {
      mixins: [Modal, Swipe],

      args: 'mode',

      props: {
        mode: String,
        flip: Boolean,
        overlay: Boolean },


      data: {
        mode: 'slide',
        flip: false,
        overlay: false,
        clsPage: 'uk-offcanvas-page',
        clsContainer: 'uk-offcanvas-container',
        selPanel: '.uk-offcanvas-bar',
        clsFlip: 'uk-offcanvas-flip',
        clsContainerAnimation: 'uk-offcanvas-container-animation',
        clsSidebarAnimation: 'uk-offcanvas-bar-animation',
        clsMode: 'uk-offcanvas',
        clsOverlay: 'uk-offcanvas-overlay',
        selClose: '.uk-offcanvas-close',
        container: false },


      computed: {
        clsFlip(_ref) {let { flip, clsFlip } = _ref;
          return flip ? clsFlip : '';
        },

        clsOverlay(_ref2) {let { overlay, clsOverlay } = _ref2;
          return overlay ? clsOverlay : '';
        },

        clsMode(_ref3) {let { mode, clsMode } = _ref3;
          return clsMode + "-" + mode;
        },

        clsSidebarAnimation(_ref4) {let { mode, clsSidebarAnimation } = _ref4;
          return mode === 'none' || mode === 'reveal' ? '' : clsSidebarAnimation;
        },

        clsContainerAnimation(_ref5) {let { mode, clsContainerAnimation } = _ref5;
          return mode !== 'push' && mode !== 'reveal' ? '' : clsContainerAnimation;
        },

        transitionElement(_ref6) {let { mode } = _ref6;
          return mode === 'reveal' ? parent(this.panel) : this.panel;
        } },


      update: {
        read() {
          if (this.isToggled() && !isVisible(this.$el)) {
            this.hide();
          }
        },

        events: ['resize'] },


      events: [
      {
        name: 'click',

        delegate() {
          return 'a[href^="#"]';
        },

        handler(_ref7) {let { current: { hash }, defaultPrevented } = _ref7;
          if (!defaultPrevented && hash && $(hash, document.body)) {
            this.hide();
          }
        } },


      {
        name: 'touchstart',

        passive: true,

        el() {
          return this.panel;
        },

        handler(_ref8) {let { targetTouches } = _ref8;
          if (targetTouches.length === 1) {
            this.clientY = targetTouches[0].clientY;
          }
        } },


      {
        name: 'touchmove',

        self: true,
        passive: false,

        filter() {
          return this.overlay;
        },

        handler(e) {
          e.cancelable && e.preventDefault();
        } },


      {
        name: 'touchmove',

        passive: false,

        el() {
          return this.panel;
        },

        handler(e) {
          if (e.targetTouches.length !== 1) {
            return;
          }

          const clientY = e.targetTouches[0].clientY - this.clientY;
          const { scrollTop, scrollHeight, clientHeight } = this.panel;

          if (
          clientHeight >= scrollHeight ||
          scrollTop === 0 && clientY > 0 ||
          scrollHeight - scrollTop <= clientHeight && clientY < 0)
          {
            e.cancelable && e.preventDefault();
          }
        } },


      {
        name: 'show',

        self: true,

        handler() {
          if (this.mode === 'reveal' && !hasClass(parent(this.panel), this.clsMode)) {
            wrapAll(this.panel, '<div>');
            addClass(parent(this.panel), this.clsMode);
          }

          css(document.documentElement, 'overflowY', this.overlay ? 'hidden' : '');
          addClass(document.body, this.clsContainer, this.clsFlip);
          css(document.body, 'touch-action', 'pan-y pinch-zoom');
          css(this.$el, 'display', 'block');
          addClass(this.$el, this.clsOverlay);
          addClass(
          this.panel,
          this.clsSidebarAnimation,
          this.mode !== 'reveal' ? this.clsMode : '');


          height(document.body); // force reflow
          addClass(document.body, this.clsContainerAnimation);

          this.clsContainerAnimation && suppressUserScale();
        } },


      {
        name: 'hide',

        self: true,

        handler() {
          removeClass(document.body, this.clsContainerAnimation);
          css(document.body, 'touch-action', '');
        } },


      {
        name: 'hidden',

        self: true,

        handler() {
          this.clsContainerAnimation && resumeUserScale();

          if (this.mode === 'reveal') {
            unwrap(this.panel);
          }

          removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);
          removeClass(this.$el, this.clsOverlay);
          css(this.$el, 'display', '');
          removeClass(document.body, this.clsContainer, this.clsFlip);

          css(document.documentElement, 'overflowY', '');
        } },


      {
        name: 'swipeLeft swipeRight',

        handler(e) {
          if (this.isToggled() && endsWith(e.type, 'Left') ^ this.flip) {
            this.hide();
          }
        } }] };




    // Chrome in responsive mode zooms page upon opening offcanvas
    function suppressUserScale() {
      getViewport().content += ',user-scalable=0';
    }

    function resumeUserScale() {
      const viewport = getViewport();
      viewport.content = viewport.content.replace(/,user-scalable=0$/, '');
    }

    function getViewport() {
      return (
        $('meta[name="viewport"]', document.head) || append(document.head, '<meta name="viewport">'));

    }

    var overflowAuto = {
      mixins: [Class, Resize],

      props: {
        selContainer: String,
        selContent: String,
        minHeight: Number },


      data: {
        selContainer: '.uk-modal',
        selContent: '.uk-modal-dialog',
        minHeight: 150 },


      computed: {
        container(_ref, $el) {let { selContainer } = _ref;
          return closest($el, selContainer);
        },

        content(_ref2, $el) {let { selContent } = _ref2;
          return closest($el, selContent);
        } },


      resizeTargets() {
        return [this.container, this.content];
      },

      update: {
        read() {
          if (!this.content || !this.container || !isVisible(this.$el)) {
            return false;
          }

          return {
            max: Math.max(
            this.minHeight,
            height(this.container) - (dimensions$1(this.content).height - height(this.$el))) };


        },

        write(_ref3) {let { max } = _ref3;
          css(this.$el, { minHeight: this.minHeight, maxHeight: max });
        },

        events: ['resize'] } };

    var responsive = {
      mixins: [Resize],

      props: ['width', 'height'],

      resizeTargets() {
        return [this.$el, parent(this.$el)];
      },

      connected() {
        addClass(this.$el, 'uk-responsive-width');
      },

      update: {
        read() {
          return isVisible(this.$el) && this.width && this.height ?
          { width: width(parent(this.$el)), height: this.height } :
          false;
        },

        write(dim) {
          height(
          this.$el,
          Dimensions.contain(
          {
            height: this.height,
            width: this.width },

          dim).
          height);

        },

        events: ['resize'] } };

    var scroll = {
      props: {
        offset: Number },


      data: {
        offset: 0 },


      methods: {
        async scrollTo(el) {
          el = el && $(el) || document.body;

          if (trigger(this.$el, 'beforescroll', [this, el])) {
            await scrollIntoView(el, { offset: this.offset });
            trigger(this.$el, 'scrolled', [this, el]);
          }
        } },


      events: {
        click(e) {
          if (e.defaultPrevented) {
            return;
          }

          e.preventDefault();
          this.scrollTo(getTargetElement(this.$el));
        } } };



    function getTargetElement(el) {
      return document.getElementById(decodeURIComponent(el.hash).substring(1));
    }

    var scrollspy = {
      mixins: [Scroll],

      args: 'cls',

      props: {
        cls: String,
        target: String,
        hidden: Boolean,
        offsetTop: Number,
        offsetLeft: Number,
        repeat: Boolean,
        delay: Number },


      data: () => ({
        cls: '',
        target: false,
        hidden: true,
        offsetTop: 0,
        offsetLeft: 0,
        repeat: false,
        delay: 0,
        inViewClass: 'uk-scrollspy-inview' }),


      computed: {
        elements: {
          get(_ref, $el) {let { target } = _ref;
            return target ? $$(target, $el) : [$el];
          },

          watch(elements, prev) {
            if (this.hidden) {
              css(filter$1(elements, ":not(." + this.inViewClass + ")"), 'visibility', 'hidden');
            }

            if (prev) {
              this.$reset();
            }
          },

          immediate: true } },



      connected() {
        this._data.elements = new Map();
        this.registerObserver(
        observeIntersection(
        this.elements,
        (records) => {
          const elements = this._data.elements;
          for (const { target: el, isIntersecting } of records) {
            if (!elements.has(el)) {
              elements.set(el, {
                cls: data(el, 'uk-scrollspy-class') || this.cls });

            }

            const state = elements.get(el);
            if (!this.repeat && state.show) {
              continue;
            }

            state.show = isIntersecting;
          }

          this.$emit();
        },
        {
          rootMargin: toPx(this.offsetTop, 'height') - 1 + "px " + (
          toPx(this.offsetLeft, 'width') - 1) + "px" },


        false));


      },

      disconnected() {
        for (const [el, state] of this._data.elements.entries()) {
          removeClass(el, this.inViewClass, (state == null ? void 0 : state.cls) || '');
        }
      },

      update: [
      {
        write(data) {
          for (const [el, state] of data.elements.entries()) {
            if (state.show && !state.inview && !state.queued) {
              state.queued = true;

              data.promise = (data.promise || Promise.resolve()).
              then(() => new Promise((resolve) => setTimeout(resolve, this.delay))).
              then(() => {
                this.toggle(el, true);
                setTimeout(() => {
                  state.queued = false;
                  this.$emit();
                }, 300);
              });
            } else if (!state.show && state.inview && !state.queued && this.repeat) {
              this.toggle(el, false);
            }
          }
        } }],



      methods: {
        toggle(el, inview) {
          const state = this._data.elements.get(el);

          state.off == null ? void 0 : state.off();

          css(el, 'visibility', !inview && this.hidden ? 'hidden' : '');

          toggleClass(el, this.inViewClass, inview);
          toggleClass(el, state.cls);

          if (/\buk-animation-/.test(state.cls)) {
            const removeAnimationClasses = () => removeClasses(el, 'uk-animation-[\\w-]+');
            if (inview) {
              state.off = once(el, 'animationcancel animationend', removeAnimationClasses);
            } else {
              removeAnimationClasses();
            }
          }

          trigger(el, inview ? 'inview' : 'outview');

          state.inview = inview;

          this.$update(el);
        } } };

    var scrollspyNav = {
      mixins: [Scroll],

      props: {
        cls: String,
        closest: String,
        scroll: Boolean,
        overflow: Boolean,
        offset: Number },


      data: {
        cls: 'uk-active',
        closest: false,
        scroll: false,
        overflow: true,
        offset: 0 },


      computed: {
        links: {
          get(_, $el) {
            return $$('a[href^="#"]', $el).filter((el) => el.hash);
          },

          watch(links) {
            if (this.scroll) {
              this.$create('scroll', links, { offset: this.offset || 0 });
            }
          },

          immediate: true },


        elements(_ref) {let { closest: selector } = _ref;
          return closest(this.links, selector || '*');
        } },


      update: [
      {
        read() {
          const targets = this.links.map(getTargetElement).filter(Boolean);

          const { length } = targets;

          if (!length || !isVisible(this.$el)) {
            return false;
          }

          const [scrollElement] = scrollParents(targets, /auto|scroll/, true);
          const { scrollTop, scrollHeight } = scrollElement;
          const max = scrollHeight - getViewportClientHeight(scrollElement);
          let active = false;

          if (scrollTop === max) {
            active = length - 1;
          } else {
            for (const i in targets) {
              if (
              offset(targets[i]).top -
              offset(getViewport$1(scrollElement)).top -
              this.offset >
              0)
              {
                break;
              }
              active = +i;
            }

            if (active === false && this.overflow) {
              active = 0;
            }
          }

          return { active };
        },

        write(_ref2) {let { active } = _ref2;
          const changed = active !== false && !hasClass(this.elements[active], this.cls);

          this.links.forEach((el) => el.blur());
          for (const i in this.elements) {
            toggleClass(this.elements[i], this.cls, +i === active);
          }

          if (changed) {
            trigger(this.$el, 'active', [active, this.elements[active]]);
          }
        },

        events: ['scroll', 'resize'] }] };

    var sticky = {
      mixins: [Class, Media, Resize, Scroll],

      props: {
        position: String,
        top: null,
        bottom: Boolean,
        offset: String,
        animation: String,
        clsActive: String,
        clsInactive: String,
        clsFixed: String,
        clsBelow: String,
        selTarget: String,
        showOnUp: Boolean,
        targetOffset: Number },


      data: {
        position: 'top',
        top: 0,
        bottom: false,
        offset: 0,
        animation: '',
        clsActive: 'uk-active',
        clsInactive: '',
        clsFixed: 'uk-sticky-fixed',
        clsBelow: 'uk-sticky-below',
        selTarget: '',
        showOnUp: false,
        targetOffset: false },


      computed: {
        selTarget(_ref, $el) {let { selTarget } = _ref;
          return selTarget && $(selTarget, $el) || $el;
        } },


      resizeTargets() {
        return document.documentElement;
      },

      connected() {
        this.placeholder =
        $('+ .uk-sticky-placeholder', this.$el) ||
        $('<div class="uk-sticky-placeholder"></div>');
        this.isFixed = false;
        this.setActive(false);
      },

      disconnected() {
        if (this.isFixed) {
          this.hide();
          removeClass(this.selTarget, this.clsInactive);
        }

        remove$1(this.placeholder);
        this.placeholder = null;
      },

      events: [
      {
        name: 'load hashchange popstate',

        el() {
          return window;
        },

        filter() {
          return this.targetOffset !== false;
        },

        handler() {
          if (!location.hash || scrollTop(window) === 0) {
            return;
          }

          fastdom.read(() => {
            const targetOffset = offset($(location.hash));
            const elOffset = offset(this.$el);

            if (this.isFixed && intersectRect(targetOffset, elOffset)) {
              scrollTop(
              window,
              targetOffset.top -
              elOffset.height -
              toPx(this.targetOffset, 'height') -
              toPx(this.offset, 'height'));

            }
          });
        } }],



      update: [
      {
        read(_ref2, types) {let { height: height$1, margin } = _ref2;
          this.inactive = !this.matchMedia || !isVisible(this.$el);

          if (this.inactive) {
            return false;
          }

          const hide = this.active && types.has('resize');
          if (hide) {
            css(this.selTarget, 'transition', '0s');
            this.hide();
          }

          if (!this.active) {
            height$1 = offset(this.$el).height;
            margin = css(this.$el, 'margin');
          }

          if (hide) {
            this.show();
            fastdom.write(() => css(this.selTarget, 'transition', ''));
          }

          const referenceElement = this.isFixed ? this.placeholder : this.$el;
          const windowHeight = height(window);

          let position = this.position;
          if (position === 'auto' && height$1 > windowHeight) {
            position = 'bottom';
          }

          let offset$1 = toPx(this.offset, 'height', referenceElement);
          if (position === 'bottom') {
            offset$1 += windowHeight - height$1;
          }

          const overflow = Math.max(0, height$1 + offset$1 - windowHeight);
          const topOffset = offset(referenceElement).top;

          const top = parseProp(this.top, this.$el, topOffset);
          const bottom = parseProp(this.bottom, this.$el, topOffset + height$1, true);

          const start = Math.max(top, topOffset) - offset$1;
          const end = bottom ?
          bottom - offset(this.$el).height + overflow - offset$1 :
          getScrollingElement(this.$el).scrollHeight - windowHeight;

          return {
            start,
            end,
            offset: offset$1,
            overflow,
            topOffset,
            height: height$1,
            margin,
            width: dimensions$1(referenceElement).width,
            top: offsetPosition(referenceElement)[0] };

        },

        write(_ref3) {let { height, margin } = _ref3;
          const { placeholder } = this;

          css(placeholder, { height, margin });

          if (!within(placeholder, document)) {
            after(this.$el, placeholder);
            placeholder.hidden = true;
          }
        },

        events: ['resize'] },


      {
        read(_ref4)






        {let { scroll: prevScroll = 0, dir: prevDir = 'down', overflow, overflowScroll = 0, start, end } = _ref4;
          const scroll = scrollTop(window);
          const dir = prevScroll <= scroll ? 'down' : 'up';

          return {
            dir,
            prevDir,
            scroll,
            prevScroll,
            offsetParentTop: offset(this.$el.offsetParent).top,
            overflowScroll: clamp(
            overflowScroll + clamp(scroll, start, end) - clamp(prevScroll, start, end),
            0,
            overflow) };


        },

        write(data, types) {
          const isScrollUpdate = types.has('scroll');
          const {
            initTimestamp = 0,
            dir,
            prevDir,
            scroll,
            prevScroll = 0,
            top,
            start,
            topOffset,
            height } =
          data;

          if (
          scroll < 0 ||
          scroll === prevScroll && isScrollUpdate ||
          this.showOnUp && !isScrollUpdate && !this.isFixed)
          {
            return;
          }

          const now = Date.now();
          if (now - initTimestamp > 300 || dir !== prevDir) {
            data.initScroll = scroll;
            data.initTimestamp = now;
          }

          if (
          this.showOnUp &&
          !this.isFixed &&
          Math.abs(data.initScroll - scroll) <= 30 &&
          Math.abs(prevScroll - scroll) <= 10)
          {
            return;
          }

          if (
          this.inactive ||
          scroll < start ||
          this.showOnUp && (
          scroll <= start ||
          dir === 'down' && isScrollUpdate ||
          dir === 'up' && !this.isFixed && scroll <= topOffset + height))
          {
            if (!this.isFixed) {
              if (Animation.inProgress(this.$el) && top > scroll) {
                Animation.cancel(this.$el);
                this.hide();
              }

              return;
            }

            this.isFixed = false;

            if (this.animation && scroll > topOffset) {
              Animation.cancel(this.$el);
              Animation.out(this.$el, this.animation).then(() => this.hide(), noop);
            } else {
              this.hide();
            }
          } else if (this.isFixed) {
            this.update();
          } else if (this.animation && scroll > topOffset) {
            Animation.cancel(this.$el);
            this.show();
            Animation.in(this.$el, this.animation).catch(noop);
          } else {
            this.show();
          }
        },

        events: ['resize', 'scroll'] }],



      methods: {
        show() {
          this.isFixed = true;
          this.update();
          this.placeholder.hidden = false;
        },

        hide() {
          this.setActive(false);
          removeClass(this.$el, this.clsFixed, this.clsBelow);
          css(this.$el, { position: '', top: '', width: '' });
          this.placeholder.hidden = true;
        },

        update() {
          let {
            width,
            scroll = 0,
            overflow,
            overflowScroll = 0,
            start,
            end,
            offset,
            topOffset,
            height,
            offsetParentTop } =
          this._data;
          const active = start !== 0 || scroll > start;
          let position = 'fixed';

          if (scroll > end) {
            offset += end - offsetParentTop;
            position = 'absolute';
          }

          if (overflow) {
            offset -= overflowScroll;
          }

          css(this.$el, {
            position,
            top: offset + "px",
            width });


          this.setActive(active);
          toggleClass(this.$el, this.clsBelow, scroll > topOffset + height);
          addClass(this.$el, this.clsFixed);
        },

        setActive(active) {
          const prev = this.active;
          this.active = active;
          if (active) {
            replaceClass(this.selTarget, this.clsInactive, this.clsActive);
            prev !== active && trigger(this.$el, 'active');
          } else {
            replaceClass(this.selTarget, this.clsActive, this.clsInactive);
            prev !== active && trigger(this.$el, 'inactive');
          }
        } } };



    function parseProp(value, el, propOffset, padding) {
      if (!value) {
        return 0;
      }

      if (isString(value) && value.match(/^-?\d/)) {
        return propOffset + toPx(value);
      } else {
        const refElement = value === true ? parent(el) : query(value, el);
        return (
          offset(refElement).bottom - (
          padding && refElement && within(el, refElement) ?
          toFloat(css(refElement, 'paddingBottom')) :
          0));

      }
    }

    var Switcher = {
      mixins: [Lazyload, Swipe, Togglable],

      args: 'connect',

      props: {
        connect: String,
        toggle: String,
        itemNav: String,
        active: Number },


      data: {
        connect: '~.uk-switcher',
        toggle: '> * > :first-child',
        itemNav: false,
        active: 0,
        cls: 'uk-active',
        attrItem: 'uk-switcher-item' },


      computed: {
        connects: {
          get(_ref, $el) {let { connect } = _ref;
            return queryAll(connect, $el);
          },

          watch(connects) {
            if (this.swiping) {
              css(connects, 'touch-action', 'pan-y pinch-zoom');
            }

            const index = this.index();
            this.connects.forEach((el) =>
            children(el).forEach((child, i) => toggleClass(child, this.cls, i === index)));

          },

          immediate: true },


        toggles: {
          get(_ref2, $el) {let { toggle } = _ref2;
            return $$(toggle, $el).filter(
            (el) => !matches(el, '.uk-disabled *, .uk-disabled, [disabled]'));

          },

          watch(toggles) {
            const active = this.index();
            this.show(~active ? active : toggles[this.active] || toggles[0]);
          },

          immediate: true },


        children() {
          return children(this.$el).filter((child) =>
          this.toggles.some((toggle) => within(toggle, child)));

        },

        swipeTarget() {
          return this.connects;
        } },


      connected() {
        this.lazyload(this.$el, this.connects);

        // check for connects
        ready(() => this.$emit());
      },

      events: [
      {
        name: 'click',

        delegate() {
          return this.toggle;
        },

        handler(e) {
          e.preventDefault();
          this.show(e.current);
        } },


      {
        name: 'click',

        el() {
          return this.connects.concat(this.itemNav ? queryAll(this.itemNav, this.$el) : []);
        },

        delegate() {
          return "[" + this.attrItem + "],[data-" + this.attrItem + "]";
        },

        handler(e) {
          e.preventDefault();
          this.show(data(e.current, this.attrItem));
        } },


      {
        name: 'swipeRight swipeLeft',

        filter() {
          return this.swiping;
        },

        el() {
          return this.connects;
        },

        handler(_ref3) {let { type } = _ref3;
          this.show(endsWith(type, 'Left') ? 'next' : 'previous');
        } }],



      methods: {
        index() {
          return findIndex(this.children, (el) => hasClass(el, this.cls));
        },

        show(item) {
          const prev = this.index();
          const next = getIndex(item, this.toggles, prev);
          const active = getIndex(this.children[next], children(this.$el));
          children(this.$el).forEach((child, i) => {
            toggleClass(child, this.cls, active === i);
            attr(this.toggles[i], 'aria-expanded', active === i);
          });

          const animate = prev >= 0 && prev !== next;
          this.connects.forEach(async (_ref4) => {let { children } = _ref4;
            await this.toggleElement(
            toNodes(children).filter((child) => hasClass(child, this.cls)),
            false,
            animate);

            await this.toggleElement(children[active], true, animate);
          });
        } } };

    var tab = {
      mixins: [Class],

      extends: Switcher,

      props: {
        media: Boolean },


      data: {
        media: 960,
        attrItem: 'uk-tab-item' },


      connected() {
        const cls = hasClass(this.$el, 'uk-tab-left') ?
        'uk-tab-left' :
        hasClass(this.$el, 'uk-tab-right') ?
        'uk-tab-right' :
        false;

        if (cls) {
          this.$create('toggle', this.$el, { cls, mode: 'media', media: this.media });
        }
      } };

    const KEY_SPACE = 32;

    var toggle = {
      mixins: [Lazyload, Media, Togglable],

      args: 'target',

      props: {
        href: String,
        target: null,
        mode: 'list',
        queued: Boolean },


      data: {
        href: false,
        target: false,
        mode: 'click',
        queued: true },


      computed: {
        target: {
          get(_ref, $el) {let { href, target } = _ref;
            target = queryAll(target || href, $el);
            return target.length && target || [$el];
          },

          watch() {
            this.updateAria();
          },

          immediate: true } },



      connected() {
        if (!includes(this.mode, 'media') && !isFocusable(this.$el)) {
          attr(this.$el, 'tabindex', '0');
        }

        this.lazyload(this.$el, this.target);

        // check for target
        ready(() => this.$emit());
      },

      events: [
      {
        name: pointerDown,

        filter() {
          return includes(this.mode, 'hover');
        },

        handler(e) {
          if (!isTouch(e) || this._showState) {
            return;
          }

          // Clicking a button does not give it focus on all browsers and platforms
          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus
          trigger(this.$el, 'focus');
          once(
          document,
          pointerDown,
          () => trigger(this.$el, 'blur'),
          true,
          (e) => !within(e.target, this.$el));


          // Prevent initial click to prevent double toggle through focus + click
          if (includes(this.mode, 'click')) {
            this._preventClick = true;
          }
        } },


      {
        name: pointerEnter + " " + pointerLeave + " focus blur",

        filter() {
          return includes(this.mode, 'hover');
        },

        handler(e) {
          if (isTouch(e)) {
            return;
          }

          const show = includes([pointerEnter, 'focus'], e.type);
          const expanded = attr(this.$el, 'aria-expanded');

          // Skip hide if still hovered or focused
          if (
          !show && (
          e.type === pointerLeave && matches(this.$el, ':focus') ||
          e.type === 'blur' && matches(this.$el, ':hover')))
          {
            return;
          }

          // Skip if state does not change e.g. hover + focus received
          if (this._showState && show && expanded !== this._showState) {
            // Ensure reset if state has changed through click
            if (!show) {
              this._showState = null;
            }
            return;
          }

          this._showState = show ? expanded : null;

          this.toggle("toggle" + (show ? 'show' : 'hide'));
        } },


      {
        name: 'keydown',

        filter() {
          return includes(this.mode, 'click') && !isTag(this.$el, 'input');
        },

        handler(e) {
          if (e.keyCode === KEY_SPACE) {
            e.preventDefault();
            this.$el.click();
          }
        } },


      {
        name: 'click',

        filter() {
          return includes(this.mode, 'click');
        },

        handler(e) {
          if (this._preventClick) {
            return this._preventClick = null;
          }

          let link;
          if (
          closest(e.target, 'a[href="#"], a[href=""]') ||
          (link = closest(e.target, 'a[href]')) && (
          attr(this.$el, 'aria-expanded') !== 'true' ||
          link.hash && matches(this.target, link.hash)))
          {
            e.preventDefault();
          }

          this.toggle();
        } },


      {
        name: 'toggled',

        self: true,

        el() {
          return this.target;
        },

        handler(e, toggled) {
          if (e.target === this.target[0]) {
            this.updateAria(toggled);
          }
        } },


      {
        name: 'mediachange',

        filter() {
          return includes(this.mode, 'media');
        },

        el() {
          return this.target;
        },

        handler(e, mediaObj) {
          if (mediaObj.matches ^ this.isToggled(this.target)) {
            this.toggle();
          }
        } }],



      methods: {
        async toggle(type) {
          if (!trigger(this.target, type || 'toggle', [this])) {
            return;
          }

          if (!this.queued) {
            return this.toggleElement(this.target);
          }

          const leaving = this.target.filter((el) => hasClass(el, this.clsLeave));

          if (leaving.length) {
            for (const el of this.target) {
              const isLeaving = includes(leaving, el);
              this.toggleElement(el, isLeaving, isLeaving);
            }
            return;
          }

          const toggled = this.target.filter(this.isToggled);
          await this.toggleElement(toggled, false);
          await this.toggleElement(
          this.target.filter((el) => !includes(toggled, el)),
          true);

        },

        updateAria(toggled) {
          if (includes(this.mode, 'media')) {
            return;
          }

          attr(
          this.$el,
          'aria-expanded',
          isBoolean(toggled) ? toggled : this.isToggled(this.target));

        } } };

    var components$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Accordion: Accordion,
        Alert: alert,
        Cover: cover,
        Drop: drop,
        Dropdown: drop,
        FormCustom: formCustom,
        Grid: grid,
        HeightMatch: heightMatch,
        HeightViewport: heightViewport,
        Icon: Icon,
        Img: img,
        Leader: leader,
        Margin: Margin,
        Modal: modal,
        Nav: nav,
        Navbar: navbar,
        Offcanvas: offcanvas,
        OverflowAuto: overflowAuto,
        Responsive: responsive,
        Scroll: scroll,
        Scrollspy: scrollspy,
        ScrollspyNav: scrollspyNav,
        Sticky: sticky,
        Svg: SVG,
        Switcher: Switcher,
        Tab: tab,
        Toggle: toggle,
        Video: Video,
        Close: Close,
        Spinner: Spinner,
        SlidenavNext: Slidenav,
        SlidenavPrevious: Slidenav,
        SearchIcon: Search,
        Marker: IconComponent,
        NavbarToggleIcon: IconComponent,
        OverlayIcon: IconComponent,
        PaginationNext: IconComponent,
        PaginationPrevious: IconComponent,
        Totop: IconComponent
    });

    // register components
    each(components$1, (component, name) => UIkit.component(name, component));

    // core functionality
    UIkit.use(Core);

    boot(UIkit);

    const units = ['days', 'hours', 'minutes', 'seconds'];

    var countdown = {
      mixins: [Class],

      props: {
        date: String,
        clsWrapper: String },


      data: {
        date: '',
        clsWrapper: '.uk-countdown-%unit%' },


      connected() {
        this.date = Date.parse(this.$props.date);
        this.start();
      },

      disconnected() {
        this.stop();
      },

      events: [
      {
        name: 'visibilitychange',

        el() {
          return document;
        },

        handler() {
          if (document.hidden) {
            this.stop();
          } else {
            this.start();
          }
        } }],



      methods: {
        start() {
          this.stop();
          this.update();
          this.timer = setInterval(this.update, 1000);
        },

        stop() {
          clearInterval(this.timer);
        },

        update() {
          const timespan = getTimeSpan(this.date);

          if (!this.date || timespan.total <= 0) {
            this.stop();

            timespan.days = timespan.hours = timespan.minutes = timespan.seconds = 0;
          }

          for (const unit of units) {
            const el = $(this.clsWrapper.replace('%unit%', unit), this.$el);

            if (!el) {
              continue;
            }

            let digits = String(Math.trunc(timespan[unit]));

            digits = digits.length < 2 ? "0" + digits : digits;

            if (el.textContent !== digits) {
              digits = digits.split('');

              if (digits.length !== el.children.length) {
                html(el, digits.map(() => '<span></span>').join(''));
              }

              digits.forEach((digit, i) => el.children[i].textContent = digit);
            }
          }
        } } };



    function getTimeSpan(date) {
      const total = date - Date.now();

      return {
        total,
        seconds: total / 1000 % 60,
        minutes: total / 1000 / 60 % 60,
        hours: total / 1000 / 60 / 60 % 24,
        days: total / 1000 / 60 / 60 / 24 };

    }

    const clsLeave = 'uk-transition-leave';
    const clsEnter = 'uk-transition-enter';

    function fade(action, target, duration, stagger) {if (stagger === void 0) {stagger = 0;}
      const index = transitionIndex(target, true);
      const propsIn = { opacity: 1 };
      const propsOut = { opacity: 0 };

      const wrapIndexFn = (fn) => () => index === transitionIndex(target) ? fn() : Promise.reject();

      const leaveFn = wrapIndexFn(() => {
        addClass(target, clsLeave);

        return Promise.all(
        getTransitionNodes(target).map(
        (child, i) =>
        new Promise((resolve) =>
        setTimeout(
        () =>
        Transition.start(child, propsOut, duration / 2, 'ease').then(
        resolve),

        i * stagger)))).



        then(() => removeClass(target, clsLeave));
      });

      const enterFn = wrapIndexFn(() => {
        const oldHeight = height(target);

        addClass(target, clsEnter);
        action();

        css(children(target), { opacity: 0 });

        // Ensure UIkit updates have propagated
        return new Promise((resolve) =>
        requestAnimationFrame(() => {
          const nodes = children(target);
          const newHeight = height(target);

          // Ensure Grid cells do not stretch when height is applied
          css(target, 'alignContent', 'flex-start');
          height(target, oldHeight);

          const transitionNodes = getTransitionNodes(target);
          css(nodes, propsOut);

          const transitions = transitionNodes.map(
          (child, i) =>
          new Promise((resolve) =>
          setTimeout(
          () =>
          Transition.start(child, propsIn, duration / 2, 'ease').then(
          resolve),

          i * stagger)));




          if (oldHeight !== newHeight) {
            transitions.push(
            Transition.start(
            target,
            { height: newHeight },
            duration / 2 + transitionNodes.length * stagger,
            'ease'));


          }

          Promise.all(transitions).then(() => {
            removeClass(target, clsEnter);
            if (index === transitionIndex(target)) {
              css(target, { height: '', alignContent: '' });
              css(nodes, { opacity: '' });
              delete target.dataset.transition;
            }
            resolve();
          });
        }));

      });

      return hasClass(target, clsLeave) ?
      waitTransitionend(target).then(enterFn) :
      hasClass(target, clsEnter) ?
      waitTransitionend(target).then(leaveFn).then(enterFn) :
      leaveFn().then(enterFn);
    }

    function transitionIndex(target, next) {
      if (next) {
        target.dataset.transition = 1 + transitionIndex(target);
      }

      return toNumber(target.dataset.transition) || 0;
    }

    function waitTransitionend(target) {
      return Promise.all(
      children(target).
      filter(Transition.inProgress).
      map(
      (el) =>
      new Promise((resolve) => once(el, 'transitionend transitioncanceled', resolve))));


    }

    function getTransitionNodes(target) {
      return getRows(children(target)).reduce(
      (nodes, row) =>
      nodes.concat(
      sortBy$1(
      row.filter((el) => isInView(el)),
      'offsetLeft')),


      []);

    }

    function slide (action, target, duration) {
      return new Promise((resolve) =>
      requestAnimationFrame(() => {
        let nodes = children(target);

        // Get current state
        const currentProps = nodes.map((el) => getProps(el, true));
        const targetProps = css(target, ['height', 'padding']);

        // Cancel previous animations
        Transition.cancel(target);
        nodes.forEach(Transition.cancel);
        reset(target);

        // Adding, sorting, removing nodes
        action();

        // Find new nodes
        nodes = nodes.concat(children(target).filter((el) => !includes(nodes, el)));

        // Wait for update to propagate
        Promise.resolve().then(() => {
          // Force update
          fastdom.flush();

          // Get new state
          const targetPropsTo = css(target, ['height', 'padding']);
          const [propsTo, propsFrom] = getTransitionProps(target, nodes, currentProps);

          // Reset to previous state
          nodes.forEach((el, i) => propsFrom[i] && css(el, propsFrom[i]));
          css(target, { display: 'block', ...targetProps });

          // Start transitions on next frame
          requestAnimationFrame(() => {
            const transitions = nodes.
            map(
            (el, i) =>
            parent(el) === target &&
            Transition.start(el, propsTo[i], duration, 'ease')).

            concat(Transition.start(target, targetPropsTo, duration, 'ease'));

            Promise.all(transitions).
            then(() => {
              nodes.forEach(
              (el, i) =>
              parent(el) === target &&
              css(el, 'display', propsTo[i].opacity === 0 ? 'none' : ''));

              reset(target);
            }, noop).
            then(resolve);
          });
        });
      }));

    }

    function getProps(el, opacity) {
      const zIndex = css(el, 'zIndex');

      return isVisible(el) ?
      {
        display: '',
        opacity: opacity ? css(el, 'opacity') : '0',
        pointerEvents: 'none',
        position: 'absolute',
        zIndex: zIndex === 'auto' ? index(el) : zIndex,
        ...getPositionWithMargin(el) } :

      false;
    }

    function getTransitionProps(target, nodes, currentProps) {
      const propsTo = nodes.map((el, i) =>
      parent(el) && i in currentProps ?
      currentProps[i] ?
      isVisible(el) ?
      getPositionWithMargin(el) :
      { opacity: 0 } :
      { opacity: isVisible(el) ? 1 : 0 } :
      false);


      const propsFrom = propsTo.map((props, i) => {
        const from = parent(nodes[i]) === target && (currentProps[i] || getProps(nodes[i]));

        if (!from) {
          return false;
        }

        if (!props) {
          delete from.opacity;
        } else if (!('opacity' in props)) {
          const { opacity } = from;

          if (opacity % 1) {
            props.opacity = 1;
          } else {
            delete from.opacity;
          }
        }

        return from;
      });

      return [propsTo, propsFrom];
    }

    function reset(el) {
      css(el.children, {
        height: '',
        left: '',
        opacity: '',
        pointerEvents: '',
        position: '',
        top: '',
        marginTop: '',
        marginLeft: '',
        transform: '',
        width: '',
        zIndex: '' });

      css(el, { height: '', display: '', padding: '' });
    }

    function getPositionWithMargin(el) {
      const { height, width } = offset(el);
      const { top, left } = position(el);
      const { marginLeft, marginTop } = css(el, ['marginTop', 'marginLeft']);

      return { top, left, height, width, marginLeft, marginTop, transform: '' };
    }

    var Animate = {
      props: {
        duration: Number,
        animation: Boolean },


      data: {
        duration: 150,
        animation: 'slide' },


      methods: {
        animate(action, target) {if (target === void 0) {target = this.$el;}
          const name = this.animation;
          const animationFn =
          name === 'fade' ?
          fade :
          name === 'delayed-fade' ?
          function () {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}return fade(...args, 40);} :
          name ?
          slide :
          () => {
            action();
            return Promise.resolve();
          };

          return animationFn(action, target, this.duration).then(
          () => this.$update(target, 'resize'),
          noop);

        } } };

    var filter = {
      mixins: [Animate],

      args: 'target',

      props: {
        target: Boolean,
        selActive: Boolean },


      data: {
        target: null,
        selActive: false,
        attrItem: 'uk-filter-control',
        cls: 'uk-active',
        duration: 250 },


      computed: {
        toggles: {
          get(_ref, $el) {let { attrItem } = _ref;
            return $$("[" + attrItem + "],[data-" + attrItem + "]", $el);
          },

          watch() {
            this.updateState();

            if (this.selActive !== false) {
              const actives = $$(this.selActive, this.$el);
              this.toggles.forEach((el) => toggleClass(el, this.cls, includes(actives, el)));
            }
          },

          immediate: true },


        children: {
          get(_ref2, $el) {let { target } = _ref2;
            return $$(target + " > *", $el);
          },

          watch(list, old) {
            if (old && !isEqualList(list, old)) {
              this.updateState();
            }
          },

          immediate: true } },



      events: [
      {
        name: 'click',

        delegate() {
          return "[" + this.attrItem + "],[data-" + this.attrItem + "]";
        },

        handler(e) {
          e.preventDefault();
          this.apply(e.current);
        } }],



      methods: {
        apply(el) {
          const prevState = this.getState();
          const newState = mergeState(el, this.attrItem, this.getState());

          if (!isEqualState(prevState, newState)) {
            this.setState(newState);
          }
        },

        getState() {
          return this.toggles.
          filter((item) => hasClass(item, this.cls)).
          reduce((state, el) => mergeState(el, this.attrItem, state), {
            filter: { '': '' },
            sort: [] });

        },

        setState(state, animate) {if (animate === void 0) {animate = true;}
          state = { filter: { '': '' }, sort: [], ...state };

          trigger(this.$el, 'beforeFilter', [this, state]);

          this.toggles.forEach((el) =>
          toggleClass(el, this.cls, !!matchFilter(el, this.attrItem, state)));


          Promise.all(
          $$(this.target, this.$el).map((target) => {
            const filterFn = () => {
              applyState(state, target, children(target));
              this.$update(this.$el);
            };
            return animate ? this.animate(filterFn, target) : filterFn();
          })).
          then(() => trigger(this.$el, 'afterFilter', [this]));
        },

        updateState() {
          fastdom.write(() => this.setState(this.getState(), false));
        } } };



    function getFilter(el, attr) {
      return parseOptions(data(el, attr), ['filter']);
    }

    function isEqualState(stateA, stateB) {
      return ['filter', 'sort'].every((prop) => isEqual(stateA[prop], stateB[prop]));
    }

    function applyState(state, target, children) {
      const selector = getSelector(state);

      children.forEach((el) => css(el, 'display', selector && !matches(el, selector) ? 'none' : ''));

      const [sort, order] = state.sort;

      if (sort) {
        const sorted = sortItems(children, sort, order);
        if (!isEqual(sorted, children)) {
          append(target, sorted);
        }
      }
    }

    function mergeState(el, attr, state) {
      const filterBy = getFilter(el, attr);
      const { filter, group, sort, order = 'asc' } = filterBy;

      if (filter || isUndefined(sort)) {
        if (group) {
          if (filter) {
            delete state.filter[''];
            state.filter[group] = filter;
          } else {
            delete state.filter[group];

            if (isEmpty(state.filter) || '' in state.filter) {
              state.filter = { '': filter || '' };
            }
          }
        } else {
          state.filter = { '': filter || '' };
        }
      }

      if (!isUndefined(sort)) {
        state.sort = [sort, order];
      }

      return state;
    }

    function matchFilter(
    el,
    attr, _ref3)

    {let { filter: stateFilter = { '': '' }, sort: [stateSort, stateOrder] } = _ref3;
      const { filter = '', group = '', sort, order = 'asc' } = getFilter(el, attr);

      return isUndefined(sort) ?
      group in stateFilter && filter === stateFilter[group] ||
      !filter && group && !(group in stateFilter) && !stateFilter[''] :
      stateSort === sort && stateOrder === order;
    }

    function isEqualList(listA, listB) {
      return listA.length === listB.length && listA.every((el) => ~listB.indexOf(el));
    }

    function getSelector(_ref4) {let { filter } = _ref4;
      let selector = '';
      each(filter, (value) => selector += value || '');
      return selector;
    }

    function sortItems(nodes, sort, order) {
      return [...nodes].sort(
      (a, b) =>
      data(a, sort).localeCompare(data(b, sort), undefined, { numeric: true }) * (
      order === 'asc' || -1));

    }

    var Animations$2 = {
      slide: {
        show(dir) {
          return [{ transform: translate(dir * -100) }, { transform: translate() }];
        },

        percent(current) {
          return translated(current);
        },

        translate(percent, dir) {
          return [
          { transform: translate(dir * -100 * percent) },
          { transform: translate(dir * 100 * (1 - percent)) }];

        } } };



    function translated(el) {
      return Math.abs(css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;
    }

    function translate(value, unit) {if (value === void 0) {value = 0;}if (unit === void 0) {unit = '%';}
      value += value ? unit : '';
      return "translate3d(" + value + ", 0, 0)";
    }

    function scale3d(value) {
      return "scale3d(" + value + ", " + value + ", 1)";
    }

    var Animations$1 = {
      ...Animations$2,
      fade: {
        show() {
          return [{ opacity: 0 }, { opacity: 1 }];
        },

        percent(current) {
          return 1 - css(current, 'opacity');
        },

        translate(percent) {
          return [{ opacity: 1 - percent }, { opacity: percent }];
        } },


      scale: {
        show() {
          return [
          { opacity: 0, transform: scale3d(1 - 0.2) },
          { opacity: 1, transform: scale3d(1) }];

        },

        percent(current) {
          return 1 - css(current, 'opacity');
        },

        translate(percent) {
          return [
          { opacity: 1 - percent, transform: scale3d(1 - 0.2 * percent) },
          { opacity: percent, transform: scale3d(1 - 0.2 + 0.2 * percent) }];

        } } };

    function Transitioner$1(prev, next, dir, _ref) {let { animation, easing } = _ref;
      const { percent, translate, show = noop } = animation;
      const props = show(dir);
      const deferred = new Deferred();

      return {
        dir,

        show(duration, percent, linear) {if (percent === void 0) {percent = 0;}
          const timing = linear ? 'linear' : easing;
          duration -= Math.round(duration * clamp(percent, -1, 1));

          this.translate(percent);

          triggerUpdate$1(next, 'itemin', { percent, duration, timing, dir });
          triggerUpdate$1(prev, 'itemout', { percent: 1 - percent, duration, timing, dir });

          Promise.all([
          Transition.start(next, props[1], duration, timing),
          Transition.start(prev, props[0], duration, timing)]).
          then(() => {
            this.reset();
            deferred.resolve();
          }, noop);

          return deferred.promise;
        },

        cancel() {
          Transition.cancel([next, prev]);
        },

        reset() {
          for (const prop in props[0]) {
            css([next, prev], prop, '');
          }
        },

        forward(duration, percent) {if (percent === void 0) {percent = this.percent();}
          Transition.cancel([next, prev]);
          return this.show(duration, percent, true);
        },

        translate(percent) {
          this.reset();

          const props = translate(percent, dir);
          css(next, props[1]);
          css(prev, props[0]);
          triggerUpdate$1(next, 'itemtranslatein', { percent, dir });
          triggerUpdate$1(prev, 'itemtranslateout', { percent: 1 - percent, dir });
        },

        percent() {
          return percent(prev || next, next, dir);
        },

        getDistance() {
          return prev == null ? void 0 : prev.offsetWidth;
        } };

    }

    function triggerUpdate$1(el, type, data) {
      trigger(el, createEvent(type, false, false, data));
    }

    var SliderAutoplay = {
      props: {
        autoplay: Boolean,
        autoplayInterval: Number,
        pauseOnHover: Boolean },


      data: {
        autoplay: false,
        autoplayInterval: 7000,
        pauseOnHover: true },


      connected() {
        this.autoplay && this.startAutoplay();
      },

      disconnected() {
        this.stopAutoplay();
      },

      update() {
        attr(this.slides, 'tabindex', '-1');
      },

      events: [
      {
        name: 'visibilitychange',

        el() {
          return document;
        },

        filter() {
          return this.autoplay;
        },

        handler() {
          if (document.hidden) {
            this.stopAutoplay();
          } else {
            this.startAutoplay();
          }
        } }],



      methods: {
        startAutoplay() {
          this.stopAutoplay();

          this.interval = setInterval(
          () =>
          (!this.draggable || !$(':focus', this.$el)) && (
          !this.pauseOnHover || !matches(this.$el, ':hover')) &&
          !this.stack.length &&
          this.show('next'),
          this.autoplayInterval);

        },

        stopAutoplay() {
          this.interval && clearInterval(this.interval);
        } } };

    var SliderDrag = {
      props: {
        draggable: Boolean },


      data: {
        draggable: true,
        threshold: 10 },


      created() {
        for (const key of ['start', 'move', 'end']) {
          const fn = this[key];
          this[key] = (e) => {
            const pos = getEventPos(e).x * (isRtl ? -1 : 1);

            this.prevPos = pos === this.pos ? this.prevPos : this.pos;
            this.pos = pos;

            fn(e);
          };
        }
      },

      events: [
      {
        name: pointerDown,

        delegate() {
          return this.selSlides;
        },

        handler(e) {
          if (
          !this.draggable ||
          !isTouch(e) && hasTextNodesOnly(e.target) ||
          closest(e.target, selInput) ||
          e.button > 0 ||
          this.length < 2)
          {
            return;
          }

          this.start(e);
        } },


      {
        name: 'dragstart',

        handler(e) {
          e.preventDefault();
        } }],



      methods: {
        start() {
          this.drag = this.pos;

          if (this._transitioner) {
            this.percent = this._transitioner.percent();
            this.drag += this._transitioner.getDistance() * this.percent * this.dir;

            this._transitioner.cancel();
            this._transitioner.translate(this.percent);

            this.dragging = true;

            this.stack = [];
          } else {
            this.prevIndex = this.index;
          }

          on(document, pointerMove, this.move, { passive: false });

          // 'input' event is triggered by video controls
          on(document, pointerUp + " " + pointerCancel + " input", this.end, true);

          css(this.list, 'userSelect', 'none');
        },

        move(e) {
          const distance = this.pos - this.drag;

          if (
          distance === 0 ||
          this.prevPos === this.pos ||
          !this.dragging && Math.abs(distance) < this.threshold)
          {
            return;
          }

          // prevent click event
          css(this.list, 'pointerEvents', 'none');

          e.cancelable && e.preventDefault();

          this.dragging = true;
          this.dir = distance < 0 ? 1 : -1;

          const { slides } = this;
          let { prevIndex } = this;
          let dis = Math.abs(distance);
          let nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
          let width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;

          while (nextIndex !== prevIndex && dis > width) {
            this.drag -= width * this.dir;

            prevIndex = nextIndex;
            dis -= width;
            nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
            width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;
          }

          this.percent = dis / width;

          const prev = slides[prevIndex];
          const next = slides[nextIndex];
          const changed = this.index !== nextIndex;
          const edge = prevIndex === nextIndex;

          let itemShown;

          [this.index, this.prevIndex].
          filter((i) => !includes([nextIndex, prevIndex], i)).
          forEach((i) => {
            trigger(slides[i], 'itemhidden', [this]);

            if (edge) {
              itemShown = true;
              this.prevIndex = prevIndex;
            }
          });

          if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {
            trigger(slides[this.index], 'itemshown', [this]);
          }

          if (changed) {
            this.prevIndex = prevIndex;
            this.index = nextIndex;

            !edge && trigger(prev, 'beforeitemhide', [this]);
            trigger(next, 'beforeitemshow', [this]);
          }

          this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);

          if (changed) {
            !edge && trigger(prev, 'itemhide', [this]);
            trigger(next, 'itemshow', [this]);
          }
        },

        end() {
          off(document, pointerMove, this.move, { passive: false });
          off(document, pointerUp + " " + pointerCancel + " input", this.end, true);

          if (this.dragging) {
            this.dragging = null;

            if (this.index === this.prevIndex) {
              this.percent = 1 - this.percent;
              this.dir *= -1;
              this._show(false, this.index, true);
              this._transitioner = null;
            } else {
              const dirChange =
              (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 ===
              this.prevPos > this.pos;
              this.index = dirChange ? this.index : this.prevIndex;

              if (dirChange) {
                this.percent = 1 - this.percent;
              }

              this.show(
              this.dir > 0 && !dirChange || this.dir < 0 && dirChange ?
              'next' :
              'previous',
              true);

            }
          }

          css(this.list, { userSelect: '', pointerEvents: '' });

          this.drag = this.percent = null;
        } } };



    function hasTextNodesOnly(el) {
      return !el.children.length && el.childNodes.length;
    }

    var SliderNav = {
      data: {
        selNav: false },


      computed: {
        nav(_ref, $el) {let { selNav } = _ref;
          return $(selNav, $el);
        },

        selNavItem(_ref2) {let { attrItem } = _ref2;
          return "[" + attrItem + "],[data-" + attrItem + "]";
        },

        navItems(_, $el) {
          return $$(this.selNavItem, $el);
        } },


      update: {
        write() {
          if (this.nav && this.length !== this.nav.children.length) {
            html(
            this.nav,
            this.slides.
            map((_, i) => "<li " + this.attrItem + "=\"" + i + "\"><a href></a></li>").
            join(''));

          }

          this.navItems.concat(this.nav).forEach((el) => el && (el.hidden = !this.maxIndex));

          this.updateNav();
        },

        events: ['resize'] },


      events: [
      {
        name: 'click',

        delegate() {
          return this.selNavItem;
        },

        handler(e) {
          e.preventDefault();
          this.show(data(e.current, this.attrItem));
        } },


      {
        name: 'itemshow',
        handler: 'updateNav' }],



      methods: {
        updateNav() {
          const i = this.getValidIndex();
          for (const el of this.navItems) {
            const cmd = data(el, this.attrItem);

            toggleClass(el, this.clsActive, toNumber(cmd) === i);
            toggleClass(
            el,
            'uk-invisible',
            this.finite && (
            cmd === 'previous' && i === 0 || cmd === 'next' && i >= this.maxIndex));

          }
        } } };

    var Slider = {
      mixins: [SliderAutoplay, SliderDrag, SliderNav, Resize],

      props: {
        clsActivated: Boolean,
        easing: String,
        index: Number,
        finite: Boolean,
        velocity: Number,
        selSlides: String },


      data: () => ({
        easing: 'ease',
        finite: false,
        velocity: 1,
        index: 0,
        prevIndex: -1,
        stack: [],
        percent: 0,
        clsActive: 'uk-active',
        clsActivated: false,
        Transitioner: false,
        transitionOptions: {} }),


      connected() {
        this.prevIndex = -1;
        this.index = this.getValidIndex(this.$props.index);
        this.stack = [];
      },

      disconnected() {
        removeClass(this.slides, this.clsActive);
      },

      computed: {
        duration(_ref, $el) {let { velocity } = _ref;
          return speedUp($el.offsetWidth / velocity);
        },

        list(_ref2, $el) {let { selList } = _ref2;
          return $(selList, $el);
        },

        maxIndex() {
          return this.length - 1;
        },

        selSlides(_ref3) {let { selList, selSlides } = _ref3;
          return selList + " " + (selSlides || '> *');
        },

        slides: {
          get() {
            return $$(this.selSlides, this.$el);
          },

          watch() {
            this.$reset();
          } },


        length() {
          return this.slides.length;
        } },


      methods: {
        show(index, force) {if (force === void 0) {force = false;}
          if (this.dragging || !this.length) {
            return;
          }

          const { stack } = this;
          const queueIndex = force ? 0 : stack.length;
          const reset = () => {
            stack.splice(queueIndex, 1);

            if (stack.length) {
              this.show(stack.shift(), true);
            }
          };

          stack[force ? 'unshift' : 'push'](index);

          if (!force && stack.length > 1) {
            if (stack.length === 2) {
              this._transitioner.forward(Math.min(this.duration, 200));
            }

            return;
          }

          const prevIndex = this.getIndex(this.index);
          const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];
          const nextIndex = this.getIndex(index, this.index);
          const next = this.slides[nextIndex];

          if (prev === next) {
            reset();
            return;
          }

          this.dir = getDirection(index, prevIndex);
          this.prevIndex = prevIndex;
          this.index = nextIndex;

          if (
          prev && !trigger(prev, 'beforeitemhide', [this]) ||
          !trigger(next, 'beforeitemshow', [this, prev]))
          {
            this.index = this.prevIndex;
            reset();
            return;
          }

          const promise = this._show(prev, next, force).then(() => {
            prev && trigger(prev, 'itemhidden', [this]);
            trigger(next, 'itemshown', [this]);

            return new Promise((resolve) => {
              fastdom.write(() => {
                stack.shift();
                if (stack.length) {
                  this.show(stack.shift(), true);
                } else {
                  this._transitioner = null;
                }
                resolve();
              });
            });
          });

          prev && trigger(prev, 'itemhide', [this]);
          trigger(next, 'itemshow', [this]);

          return promise;
        },

        getIndex(index, prev) {if (index === void 0) {index = this.index;}if (prev === void 0) {prev = this.index;}
          return clamp(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);
        },

        getValidIndex(index, prevIndex) {if (index === void 0) {index = this.index;}if (prevIndex === void 0) {prevIndex = this.prevIndex;}
          return this.getIndex(index, prevIndex);
        },

        _show(prev, next, force) {
          this._transitioner = this._getTransitioner(prev, next, this.dir, {
            easing: force ?
            next.offsetWidth < 600 ?
            'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */ :
            'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */ :
            this.easing,
            ...this.transitionOptions });


          if (!force && !prev) {
            this._translate(1);
            return Promise.resolve();
          }

          const { length } = this.stack;
          return this._transitioner[length > 1 ? 'forward' : 'show'](
          length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration,
          this.percent);

        },

        _getDistance(prev, next) {
          return this._getTransitioner(prev, prev !== next && next).getDistance();
        },

        _translate(percent, prev, next) {if (prev === void 0) {prev = this.prevIndex;}if (next === void 0) {next = this.index;}
          const transitioner = this._getTransitioner(prev !== next ? prev : false, next);
          transitioner.translate(percent);
          return transitioner;
        },

        _getTransitioner(
        prev,
        next,
        dir,
        options)
        {if (prev === void 0) {prev = this.prevIndex;}if (next === void 0) {next = this.index;}if (dir === void 0) {dir = this.dir || 1;}if (options === void 0) {options = this.transitionOptions;}
          return new this.Transitioner(
          isNumber(prev) ? this.slides[prev] : prev,
          isNumber(next) ? this.slides[next] : next,
          dir * (isRtl ? -1 : 1),
          options);

        } } };



    function getDirection(index, prevIndex) {
      return index === 'next' ? 1 : index === 'previous' ? -1 : index < prevIndex ? -1 : 1;
    }

    function speedUp(x) {
      return 0.5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)
    }

    var Slideshow = {
      mixins: [Slider],

      props: {
        animation: String },


      data: {
        animation: 'slide',
        clsActivated: 'uk-transition-active',
        Animations: Animations$2,
        Transitioner: Transitioner$1 },


      computed: {
        animation(_ref) {let { animation, Animations } = _ref;
          return { ...(Animations[animation] || Animations.slide), name: animation };
        },

        transitionOptions() {
          return { animation: this.animation };
        } },


      events: {
        beforeitemshow(_ref2) {let { target } = _ref2;
          addClass(target, this.clsActive);
        },

        itemshown(_ref3) {let { target } = _ref3;
          addClass(target, this.clsActivated);
        },

        itemhidden(_ref4) {let { target } = _ref4;
          removeClass(target, this.clsActive, this.clsActivated);
        } } };

    var LightboxPanel = {
      mixins: [Container, Modal, Togglable, Slideshow],

      functional: true,

      props: {
        delayControls: Number,
        preload: Number,
        videoAutoplay: Boolean,
        template: String },


      data: () => ({
        preload: 1,
        videoAutoplay: false,
        delayControls: 3000,
        items: [],
        cls: 'uk-open',
        clsPage: 'uk-lightbox-page',
        selList: '.uk-lightbox-items',
        attrItem: 'uk-lightbox-item',
        selClose: '.uk-close-large',
        selCaption: '.uk-lightbox-caption',
        pauseOnHover: false,
        velocity: 2,
        Animations: Animations$1,
        template: "<div class=\"uk-lightbox uk-overflow-hidden\"> <ul class=\"uk-lightbox-items\"></ul> <div class=\"uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque\"> <button class=\"uk-lightbox-toolbar-icon uk-close-large\" type=\"button\" uk-close></button> </div> <a class=\"uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade\" href uk-slidenav-previous uk-lightbox-item=\"previous\"></a> <a class=\"uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade\" href uk-slidenav-next uk-lightbox-item=\"next\"></a> <div class=\"uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque\"></div> </div>" }),










      created() {
        const $el = $(this.template);
        const list = $(this.selList, $el);
        this.items.forEach(() => append(list, '<li>'));

        this.$mount(append(this.container, $el));
      },

      computed: {
        caption(_ref, $el) {let { selCaption } = _ref;
          return $(selCaption, $el);
        } },


      events: [
      {
        name: pointerMove + " " + pointerDown + " keydown",

        handler: 'showControls' },


      {
        name: 'click',

        self: true,

        delegate() {
          return this.selSlides;
        },

        handler(e) {
          if (e.defaultPrevented) {
            return;
          }

          this.hide();
        } },


      {
        name: 'shown',

        self: true,

        handler() {
          this.showControls();
        } },


      {
        name: 'hide',

        self: true,

        handler() {
          this.hideControls();

          removeClass(this.slides, this.clsActive);
          Transition.stop(this.slides);
        } },


      {
        name: 'hidden',

        self: true,

        handler() {
          this.$destroy(true);
        } },


      {
        name: 'keyup',

        el() {
          return document;
        },

        handler(e) {
          if (!this.isToggled(this.$el) || !this.draggable) {
            return;
          }

          switch (e.keyCode) {
            case 37:
              this.show('previous');
              break;
            case 39:
              this.show('next');
              break;}

        } },


      {
        name: 'beforeitemshow',

        handler(e) {
          if (this.isToggled()) {
            return;
          }

          this.draggable = false;

          e.preventDefault();

          this.toggleElement(this.$el, true, false);

          this.animation = Animations$1['scale'];
          removeClass(e.target, this.clsActive);
          this.stack.splice(1, 0, this.index);
        } },


      {
        name: 'itemshow',

        handler() {
          html(this.caption, this.getItem().caption || '');

          for (let j = -this.preload; j <= this.preload; j++) {
            this.loadItem(this.index + j);
          }
        } },


      {
        name: 'itemshown',

        handler() {
          this.draggable = this.$props.draggable;
        } },


      {
        name: 'itemload',

        async handler(_, item) {
          const { source: src, type, alt = '', poster, attrs = {} } = item;

          this.setItem(item, '<span uk-spinner></span>');

          if (!src) {
            return;
          }

          let matches;
          const iframeAttrs = {
            frameborder: '0',
            allow: 'autoplay',
            allowfullscreen: '',
            style: 'max-width: 100%; box-sizing: border-box;',
            'uk-responsive': '',
            'uk-video': "" + this.videoAutoplay };


          // Image
          if (
          type === 'image' ||
          src.match(/\.(avif|jpe?g|jfif|a?png|gif|svg|webp)($|\?)/i))
          {
            try {
              const { width, height } = await getImage(src, attrs.srcset, attrs.size);
              this.setItem(item, createEl('img', { src, width, height, alt, ...attrs }));
            } catch (e) {
              this.setError(item);
            }

            // Video
          } else if (type === 'video' || src.match(/\.(mp4|webm|ogv)($|\?)/i)) {
            const video = createEl('video', {
              src,
              poster,
              controls: '',
              playsinline: '',
              'uk-video': "" + this.videoAutoplay,
              ...attrs });


            on(video, 'loadedmetadata', () => {
              attr(video, { width: video.videoWidth, height: video.videoHeight });
              this.setItem(item, video);
            });
            on(video, 'error', () => this.setError(item));

            // Iframe
          } else if (type === 'iframe' || src.match(/\.(html|php)($|\?)/i)) {
            this.setItem(
            item,
            createEl('iframe', {
              src,
              frameborder: '0',
              allowfullscreen: '',
              class: 'uk-lightbox-iframe',
              ...attrs }));



            // YouTube
          } else if (
          matches = src.match(
          /\/\/(?:.*?youtube(-nocookie)?\..*?[?&]v=|youtu\.be\/)([\w-]{11})[&?]?(.*)?/))

          {
            this.setItem(
            item,
            createEl('iframe', {
              src: "https://www.youtube" + (matches[1] || '') + ".com/embed/" + matches[2] + (
              matches[3] ? "?" + matches[3] : ''),

              width: 1920,
              height: 1080,
              ...iframeAttrs,
              ...attrs }));



            // Vimeo
          } else if (matches = src.match(/\/\/.*?vimeo\.[a-z]+\/(\d+)[&?]?(.*)?/)) {
            try {
              const { height, width } = await (
              await fetch("https://vimeo.com/api/oembed.json?maxwidth=1920&url=" +
              encodeURI(
              src),

              {
                credentials: 'omit' })).


              json();

              this.setItem(
              item,
              createEl('iframe', {
                src: "https://player.vimeo.com/video/" + matches[1] + (
                matches[2] ? "?" + matches[2] : ''),

                width,
                height,
                ...iframeAttrs,
                ...attrs }));


            } catch (e) {
              this.setError(item);
            }
          }
        } }],



      methods: {
        loadItem(index) {if (index === void 0) {index = this.index;}
          const item = this.getItem(index);

          if (!this.getSlide(item).childElementCount) {
            trigger(this.$el, 'itemload', [item]);
          }
        },

        getItem(index) {if (index === void 0) {index = this.index;}
          return this.items[getIndex(index, this.slides)];
        },

        setItem(item, content) {
          trigger(this.$el, 'itemloaded', [this, html(this.getSlide(item), content)]);
        },

        getSlide(item) {
          return this.slides[this.items.indexOf(item)];
        },

        setError(item) {
          this.setItem(item, '<span uk-icon="icon: bolt; ratio: 2"></span>');
        },

        showControls() {
          clearTimeout(this.controlsTimer);
          this.controlsTimer = setTimeout(this.hideControls, this.delayControls);

          addClass(this.$el, 'uk-active', 'uk-transition-active');
        },

        hideControls() {
          removeClass(this.$el, 'uk-active', 'uk-transition-active');
        } } };



    function createEl(tag, attrs) {
      const el = fragment("<" + tag + ">");
      attr(el, attrs);
      return el;
    }

    var lightbox = {
      install: install$1,

      props: { toggle: String },

      data: { toggle: 'a' },

      computed: {
        toggles: {
          get(_ref, $el) {let { toggle } = _ref;
            return $$(toggle, $el);
          },

          watch() {
            this.hide();
          } } },



      disconnected() {
        this.hide();
      },

      events: [
      {
        name: 'click',

        delegate() {
          return this.toggle + ":not(.uk-disabled)";
        },

        handler(e) {
          e.preventDefault();
          this.show(e.current);
        } }],



      methods: {
        show(index) {
          const items = uniqueBy(this.toggles.map(toItem), 'source');

          if (isElement(index)) {
            const { source } = toItem(index);
            index = findIndex(items, (_ref2) => {let { source: src } = _ref2;return source === src;});
          }

          this.panel = this.panel || this.$create('lightboxPanel', { ...this.$props, items });

          on(this.panel.$el, 'hidden', () => this.panel = false);

          return this.panel.show(index);
        },

        hide() {var _this$panel;
          return (_this$panel = this.panel) == null ? void 0 : _this$panel.hide();
        } } };



    function install$1(UIkit, Lightbox) {
      if (!UIkit.lightboxPanel) {
        UIkit.component('lightboxPanel', LightboxPanel);
      }

      assign(Lightbox.props, UIkit.component('lightboxPanel').options.props);
    }

    function toItem(el) {
      const item = {};

      for (const attr of ['href', 'caption', 'type', 'poster', 'alt', 'attrs']) {
        item[attr === 'href' ? 'source' : attr] = data(el, attr);
      }

      item.attrs = parseOptions(item.attrs);

      return item;
    }

    var notification = {
      mixins: [Container],

      functional: true,

      args: ['message', 'status'],

      data: {
        message: '',
        status: '',
        timeout: 5000,
        group: null,
        pos: 'top-center',
        clsContainer: 'uk-notification',
        clsClose: 'uk-notification-close',
        clsMsg: 'uk-notification-message' },


      install,

      computed: {
        marginProp(_ref) {let { pos } = _ref;
          return "margin" + (startsWith(pos, 'top') ? 'Top' : 'Bottom');
        },

        startProps() {
          return { opacity: 0, [this.marginProp]: -this.$el.offsetHeight };
        } },


      created() {
        const container =
        $("." + this.clsContainer + "-" + this.pos, this.container) ||
        append(
        this.container, "<div class=\"" +
        this.clsContainer + " " + this.clsContainer + "-" + this.pos + "\" style=\"display: block\"></div>");


        this.$mount(
        append(
        container, "<div class=\"" +
        this.clsMsg + (this.status ? " " + this.clsMsg + "-" + this.status : '') + "\"> <a href class=\"" +
        this.clsClose + "\" data-uk-close></a> <div>" +
        this.message + "</div> </div>"));



      },

      async connected() {
        const margin = toFloat(css(this.$el, this.marginProp));
        await Transition.start(css(this.$el, this.startProps), {
          opacity: 1,
          [this.marginProp]: margin });


        if (this.timeout) {
          this.timer = setTimeout(this.close, this.timeout);
        }
      },

      events: {
        click(e) {
          if (closest(e.target, 'a[href="#"],a[href=""]')) {
            e.preventDefault();
          }
          this.close();
        },

        [pointerEnter]() {
          if (this.timer) {
            clearTimeout(this.timer);
          }
        },

        [pointerLeave]() {
          if (this.timeout) {
            this.timer = setTimeout(this.close, this.timeout);
          }
        } },


      methods: {
        async close(immediate) {
          const removeFn = (el) => {
            const container = parent(el);

            trigger(el, 'close', [this]);
            remove$1(el);

            if (!(container != null && container.hasChildNodes())) {
              remove$1(container);
            }
          };

          if (this.timer) {
            clearTimeout(this.timer);
          }

          if (!immediate) {
            await Transition.start(this.$el, this.startProps);
          }

          removeFn(this.$el);
        } } };



    function install(UIkit) {
      UIkit.notification.closeAll = function (group, immediate) {
        apply(document.body, (el) => {
          const notification = UIkit.getComponent(el, 'notification');
          if (notification && (!group || group === notification.group)) {
            notification.close(immediate);
          }
        });
      };
    }

    const props = {
      x: transformFn,
      y: transformFn,
      rotate: transformFn,
      scale: transformFn,
      color: colorFn,
      backgroundColor: colorFn,
      borderColor: colorFn,
      blur: filterFn,
      hue: filterFn,
      fopacity: filterFn,
      grayscale: filterFn,
      invert: filterFn,
      saturate: filterFn,
      sepia: filterFn,
      opacity: cssPropFn,
      stroke: strokeFn,
      bgx: backgroundFn,
      bgy: backgroundFn };


    const { keys } = Object;

    var Parallax = {
      mixins: [Media],

      props: fillObject(keys(props), 'list'),

      data: fillObject(keys(props), undefined),

      computed: {
        props(properties, $el) {
          return keys(props).reduce((result, prop) => {
            if (!isUndefined(properties[prop])) {
              result[prop] = props[prop](prop, $el, properties[prop].slice());
            }
            return result;
          }, {});
        } },


      events: {
        load() {
          this.$emit();
        } },


      methods: {
        reset() {
          each(this.getCss(0), (_, prop) => css(this.$el, prop, ''));
        },

        getCss(percent) {
          const css = { transform: '', filter: '' };
          for (const prop in this.props) {
            this.props[prop](css, percent);
          }
          return css;
        } } };



    function transformFn(prop, el, stops) {
      const unit = getUnit(stops) || { x: 'px', y: 'px', rotate: 'deg' }[prop] || '';
      let transformFn;

      if (prop === 'x' || prop === 'y') {
        prop = "translate" + ucfirst(prop);
        transformFn = (stop) => toFloat(toFloat(stop).toFixed(unit === 'px' ? 0 : 6));
      }

      if (stops.length === 1) {
        stops.unshift(prop === 'scale' ? 1 : 0);
      }

      stops = parseStops(stops, transformFn);

      return (css, percent) => {
        css.transform += " " + prop + "(" + getValue(stops, percent) + unit + ")";
      };
    }

    function colorFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(getCssValue(el, prop, ''));
      }

      stops = parseStops(stops, (stop) => parseColor(el, stop));

      return (css, percent) => {
        const [start, end, p] = getStop(stops, percent);
        const value = start.
        map((value, i) => {
          value += p * (end[i] - value);
          return i === 3 ? toFloat(value) : parseInt(value, 10);
        }).
        join(',');
        css[prop] = "rgba(" + value + ")";
      };
    }

    function parseColor(el, color) {
      return getCssValue(el, 'color', color).
      split(/[(),]/g).
      slice(1, -1).
      concat(1).
      slice(0, 4).
      map(toFloat);
    }

    function filterFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(0);
      }

      const unit = getUnit(stops) || { blur: 'px', hue: 'deg' }[prop] || '%';
      prop = { fopacity: 'opacity', hue: 'hue-rotate' }[prop] || prop;
      stops = parseStops(stops);

      return (css, percent) => {
        const value = getValue(stops, percent);
        css.filter += " " + prop + "(" + (value + unit) + ")";
      };
    }

    function cssPropFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(getCssValue(el, prop, ''));
      }

      stops = parseStops(stops);

      return (css, percent) => {
        css[prop] = getValue(stops, percent);
      };
    }

    function strokeFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(0);
      }

      const unit = getUnit(stops);
      const length = getMaxPathLength(el);
      stops = parseStops(stops.reverse(), (stop) => {
        stop = toFloat(stop);
        return unit === '%' ? stop * length / 100 : stop;
      });

      if (!stops.some((_ref) => {let [value] = _ref;return value;})) {
        return noop;
      }

      css(el, 'strokeDasharray', length);

      return (css, percent) => {
        css.strokeDashoffset = getValue(stops, percent);
      };
    }

    function backgroundFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(0);
      }

      prop = prop.substr(-1);
      const attr = prop === 'y' ? 'height' : 'width';
      stops = parseStops(stops, (stop) => toPx(stop, attr, el));

      const bgPos = getCssValue(el, "background-position-" + prop, '');

      return getCssValue(el, 'backgroundSize', '') === 'cover' ?
      backgroundCoverFn(prop, el, stops, bgPos, attr) :
      setBackgroundPosFn(prop, stops, bgPos);
    }

    function backgroundCoverFn(prop, el, stops, bgPos, attr) {
      const dimImage = getBackgroundImageDimensions(el);

      if (!dimImage.width) {
        return noop;
      }

      const values = stops.map((_ref2) => {let [value] = _ref2;return value;});
      const min = Math.min(...values);
      const max = Math.max(...values);
      const down = values.indexOf(min) < values.indexOf(max);

      const diff = max - min;
      let pos = (down ? -diff : 0) - (down ? min : max);

      const dimEl = {
        width: el.offsetWidth,
        height: el.offsetHeight };


      const baseDim = Dimensions.cover(dimImage, dimEl);
      const span = baseDim[attr] - dimEl[attr];

      if (span < diff) {
        dimEl[attr] = baseDim[attr] + diff - span;
      } else if (span > diff) {
        const posPercentage = dimEl[attr] / toPx(bgPos, attr, el, true);

        if (posPercentage) {
          pos -= (span - diff) / posPercentage;
        }
      }

      const dim = Dimensions.cover(dimImage, dimEl);

      const fn = setBackgroundPosFn(prop, stops, pos + "px");
      return (css, percent) => {
        fn(css, percent);
        css.backgroundSize = dim.width + "px " + dim.height + "px";
        css.backgroundRepeat = 'no-repeat';
      };
    }

    function setBackgroundPosFn(prop, stops, pos) {
      return function (css, percent) {
        css["background-position-" + prop] = "calc(" + pos + " + " + getValue(stops, percent) + "px)";
      };
    }

    const dimensions = {};
    function getBackgroundImageDimensions(el) {
      const src = css(el, 'backgroundImage').replace(/^none|url\(["']?(.+?)["']?\)$/, '$1');

      if (dimensions[src]) {
        return dimensions[src];
      }

      const image = new Image();
      if (src) {
        image.src = src;

        if (!image.naturalWidth) {
          image.onload = () => {
            dimensions[src] = toDimensions(image);
            trigger(el, createEvent('load', false));
          };
          return toDimensions(image);
        }
      }

      return dimensions[src] = toDimensions(image);
    }

    function toDimensions(image) {
      return {
        width: image.naturalWidth,
        height: image.naturalHeight };

    }

    function parseStops(stops, fn) {if (fn === void 0) {fn = toFloat;}
      const result = [];
      const { length } = stops;
      let nullIndex = 0;
      for (let i = 0; i < length; i++) {
        let [value, percent] = isString(stops[i]) ? stops[i].trim().split(' ') : [stops[i]];
        value = fn(value);
        percent = percent ? toFloat(percent) / 100 : null;

        if (i === 0) {
          if (percent === null) {
            percent = 0;
          } else if (percent) {
            result.push([value, 0]);
          }
        } else if (i === length - 1) {
          if (percent === null) {
            percent = 1;
          } else if (percent !== 1) {
            result.push([value, percent]);
            percent = 1;
          }
        }

        result.push([value, percent]);

        if (percent === null) {
          nullIndex++;
        } else if (nullIndex) {
          const leftPercent = result[i - nullIndex - 1][1];
          const p = (percent - leftPercent) / (nullIndex + 1);
          for (let j = nullIndex; j > 0; j--) {
            result[i - j][1] = leftPercent + p * (nullIndex - j + 1);
          }

          nullIndex = 0;
        }
      }

      return result;
    }

    function getStop(stops, percent) {
      const index = findIndex(stops.slice(1), (_ref3) => {let [, targetPercent] = _ref3;return percent <= targetPercent;}) + 1;
      return [
      stops[index - 1][0],
      stops[index][0],
      (percent - stops[index - 1][1]) / (stops[index][1] - stops[index - 1][1])];

    }

    function getValue(stops, percent) {
      const [start, end, p] = getStop(stops, percent);
      return isNumber(start) ? start + Math.abs(start - end) * p * (start < end ? 1 : -1) : +end;
    }

    const unitRe = /^-?\d+([^\s]*)/;
    function getUnit(stops, defaultUnit) {
      for (const stop of stops) {
        const match = stop.match == null ? void 0 : stop.match(unitRe);
        if (match) {
          return match[1];
        }
      }
      return defaultUnit;
    }

    function getCssValue(el, prop, value) {
      const prev = el.style[prop];
      const val = css(css(el, prop, value), prop);
      el.style[prop] = prev;
      return val;
    }

    function fillObject(keys, value) {
      return keys.reduce((data, prop) => {
        data[prop] = value;
        return data;
      }, {});
    }

    var parallax = {
      mixins: [Parallax, Resize, Scroll],

      props: {
        target: String,
        viewport: Number, // Deprecated
        easing: Number,
        start: String,
        end: String },


      data: {
        target: false,
        viewport: 1,
        easing: 1,
        start: 0,
        end: 0 },


      computed: {
        target(_ref, $el) {let { target } = _ref;
          return getOffsetElement(target && query(target, $el) || $el);
        },

        start(_ref2) {let { start } = _ref2;
          return toPx(start, 'height', this.target, true);
        },

        end(_ref3) {let { end, viewport } = _ref3;
          return toPx(
          end || (viewport = (1 - viewport) * 100) && viewport + "vh+" + viewport + "%",
          'height',
          this.target,
          true);

        } },


      update: {
        read(_ref4, types) {let { percent } = _ref4;
          if (!types.has('scroll')) {
            percent = false;
          }

          if (!this.matchMedia) {
            return;
          }

          const prev = percent;
          percent = ease(scrolledOver(this.target, this.start, this.end), this.easing);

          return {
            percent,
            style: prev === percent ? false : this.getCss(percent) };

        },

        write(_ref5) {let { style } = _ref5;
          if (!this.matchMedia) {
            this.reset();
            return;
          }

          style && css(this.$el, style);
        },

        events: ['scroll', 'resize'] } };



    function ease(percent, easing) {
      return easing >= 0 ? Math.pow(percent, easing + 1) : 1 - Math.pow(1 - percent, -easing + 1);
    }

    // SVG elements do not inherit from HTMLElement
    function getOffsetElement(el) {
      return el ? 'offsetTop' in el ? el : getOffsetElement(parent(el)) : document.documentElement;
    }

    var SliderReactive = {
      update: {
        write() {
          if (this.stack.length || this.dragging) {
            return;
          }

          const index = this.getValidIndex(this.index);

          if (!~this.prevIndex || this.index !== index) {
            this.show(index);
          }
        },

        events: ['resize'] } };

    var SliderPreload = {
      mixins: [Lazyload],

      connected() {
        this.lazyload(this.slides, this.getAdjacentSlides);
      } };

    function Transitioner (prev, next, dir, _ref) {let { center, easing, list } = _ref;
      const deferred = new Deferred();

      const from = prev ?
      getLeft(prev, list, center) :
      getLeft(next, list, center) + dimensions$1(next).width * dir;
      const to = next ?
      getLeft(next, list, center) :
      from + dimensions$1(prev).width * dir * (isRtl ? -1 : 1);

      return {
        dir,

        show(duration, percent, linear) {if (percent === void 0) {percent = 0;}
          const timing = linear ? 'linear' : easing;
          duration -= Math.round(duration * clamp(percent, -1, 1));

          this.translate(percent);

          percent = prev ? percent : clamp(percent, 0, 1);
          triggerUpdate(this.getItemIn(), 'itemin', { percent, duration, timing, dir });
          prev &&
          triggerUpdate(this.getItemIn(true), 'itemout', {
            percent: 1 - percent,
            duration,
            timing,
            dir });


          Transition.start(
          list,
          { transform: translate(-to * (isRtl ? -1 : 1), 'px') },
          duration,
          timing).
          then(deferred.resolve, noop);

          return deferred.promise;
        },

        cancel() {
          Transition.cancel(list);
        },

        reset() {
          css(list, 'transform', '');
        },

        forward(duration, percent) {if (percent === void 0) {percent = this.percent();}
          Transition.cancel(list);
          return this.show(duration, percent, true);
        },

        translate(percent) {
          const distance = this.getDistance() * dir * (isRtl ? -1 : 1);

          css(
          list,
          'transform',
          translate(
          clamp(
          -to + (distance - distance * percent),
          -getWidth(list),
          dimensions$1(list).width) * (
          isRtl ? -1 : 1),
          'px'));



          const actives = this.getActives();
          const itemIn = this.getItemIn();
          const itemOut = this.getItemIn(true);

          percent = prev ? clamp(percent, -1, 1) : 0;

          for (const slide of children(list)) {
            const isActive = includes(actives, slide);
            const isIn = slide === itemIn;
            const isOut = slide === itemOut;
            const translateIn =
            isIn ||
            !isOut && (
            isActive ||
            dir * (isRtl ? -1 : 1) === -1 ^
            getElLeft(slide, list) > getElLeft(prev || next));

            triggerUpdate(slide, "itemtranslate" + (translateIn ? 'in' : 'out'), {
              dir,
              percent: isOut ? 1 - percent : isIn ? percent : isActive ? 1 : 0 });

          }
        },

        percent() {
          return Math.abs(
          (css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));

        },

        getDistance() {
          return Math.abs(to - from);
        },

        getItemIn(out) {if (out === void 0) {out = false;}
          let actives = this.getActives();
          let nextActives = inView(list, getLeft(next || prev, list, center));

          if (out) {
            const temp = actives;
            actives = nextActives;
            nextActives = temp;
          }

          return nextActives[findIndex(nextActives, (el) => !includes(actives, el))];
        },

        getActives() {
          return inView(list, getLeft(prev || next, list, center));
        } };

    }

    function getLeft(el, list, center) {
      const left = getElLeft(el, list);

      return center ? left - centerEl(el, list) : Math.min(left, getMax(list));
    }

    function getMax(list) {
      return Math.max(0, getWidth(list) - dimensions$1(list).width);
    }

    function getWidth(list) {
      return children(list).reduce((right, el) => dimensions$1(el).width + right, 0);
    }

    function centerEl(el, list) {
      return dimensions$1(list).width / 2 - dimensions$1(el).width / 2;
    }

    function getElLeft(el, list) {
      return (
        el &&
        (position(el).left + (isRtl ? dimensions$1(el).width - dimensions$1(list).width : 0)) * (
        isRtl ? -1 : 1) ||
        0);

    }

    function inView(list, listLeft) {
      listLeft -= 1;
      const listWidth = dimensions$1(list).width;
      const listRight = listLeft + listWidth + 2;

      return children(list).filter((slide) => {
        const slideLeft = getElLeft(slide, list);
        const slideRight = slideLeft + Math.min(dimensions$1(slide).width, listWidth);

        return slideLeft >= listLeft && slideRight <= listRight;
      });
    }

    function triggerUpdate(el, type, data) {
      trigger(el, createEvent(type, false, false, data));
    }

    var slider = {
      mixins: [Class, Slider, SliderReactive, SliderPreload],

      props: {
        center: Boolean,
        sets: Boolean },


      data: {
        center: false,
        sets: false,
        attrItem: 'uk-slider-item',
        selList: '.uk-slider-items',
        selNav: '.uk-slider-nav',
        clsContainer: 'uk-slider-container',
        Transitioner },


      computed: {
        avgWidth() {
          return getWidth(this.list) / this.length;
        },

        finite(_ref) {let { finite } = _ref;
          return (
            finite ||
            Math.ceil(getWidth(this.list)) <
            Math.trunc(dimensions$1(this.list).width + getMaxElWidth(this.list) + this.center));

        },

        maxIndex() {
          if (!this.finite || this.center && !this.sets) {
            return this.length - 1;
          }

          if (this.center) {
            return last(this.sets);
          }

          let lft = 0;
          const max = getMax(this.list);
          const index = findIndex(this.slides, (el) => {
            if (lft >= max) {
              return true;
            }

            lft += dimensions$1(el).width;
          });

          return ~index ? index : this.length - 1;
        },

        sets(_ref2) {let { sets: enabled } = _ref2;
          if (!enabled) {
            return;
          }

          let left = 0;
          const sets = [];
          const width = dimensions$1(this.list).width;
          for (let i in this.slides) {
            const slideWidth = dimensions$1(this.slides[i]).width;

            if (left + slideWidth > width) {
              left = 0;
            }

            if (this.center) {
              if (
              left < width / 2 &&
              left + slideWidth + dimensions$1(this.slides[+i + 1]).width / 2 > width / 2)
              {
                sets.push(+i);
                left = width / 2 - slideWidth / 2;
              }
            } else if (left === 0) {
              sets.push(Math.min(+i, this.maxIndex));
            }

            left += slideWidth;
          }

          if (sets.length) {
            return sets;
          }
        },

        transitionOptions() {
          return {
            center: this.center,
            list: this.list };

        } },


      connected() {
        toggleClass(this.$el, this.clsContainer, !$("." + this.clsContainer, this.$el));
      },

      update: {
        write() {
          for (const el of this.navItems) {
            const index = toNumber(data(el, this.attrItem));
            if (index !== false) {
              el.hidden =
              !this.maxIndex ||
              index > this.maxIndex ||
              this.sets && !includes(this.sets, index);
            }
          }

          if (this.length && !this.dragging && !this.stack.length) {
            this.reorder();
            this._translate(1);
          }

          this.updateActiveClasses();
        },

        events: ['resize'] },


      events: {
        beforeitemshow(e) {
          if (
          !this.dragging &&
          this.sets &&
          this.stack.length < 2 &&
          !includes(this.sets, this.index))
          {
            this.index = this.getValidIndex();
          }

          const diff = Math.abs(
          this.index -
          this.prevIndex + (
          this.dir > 0 && this.index < this.prevIndex ||
          this.dir < 0 && this.index > this.prevIndex ?
          (this.maxIndex + 1) * this.dir :
          0));


          if (!this.dragging && diff > 1) {
            for (let i = 0; i < diff; i++) {
              this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');
            }

            e.preventDefault();
            return;
          }

          const index =
          this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex;
          this.duration =
          speedUp(this.avgWidth / this.velocity) * (
          dimensions$1(this.slides[index]).width / this.avgWidth);

          this.reorder();
        },

        itemshow() {
          if (~this.prevIndex) {
            addClass(this._getTransitioner().getItemIn(), this.clsActive);
          }
        },

        itemshown() {
          this.updateActiveClasses();
        } },


      methods: {
        reorder() {
          if (this.finite) {
            css(this.slides, 'order', '');
            return;
          }

          const index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;

          this.slides.forEach((slide, i) =>
          css(
          slide,
          'order',
          this.dir > 0 && i < index ? 1 : this.dir < 0 && i >= this.index ? -1 : ''));



          if (!this.center) {
            return;
          }

          const next = this.slides[index];
          let width = dimensions$1(this.list).width / 2 - dimensions$1(next).width / 2;
          let j = 0;

          while (width > 0) {
            const slideIndex = this.getIndex(--j + index, index);
            const slide = this.slides[slideIndex];

            css(slide, 'order', slideIndex > index ? -2 : -1);
            width -= dimensions$1(slide).width;
          }
        },

        updateActiveClasses() {
          const actives = this._getTransitioner(this.index).getActives();
          const activeClasses = [
          this.clsActive,
          (!this.sets || includes(this.sets, toFloat(this.index))) && this.clsActivated ||
          ''];

          for (const slide of this.slides) {
            toggleClass(slide, activeClasses, includes(actives, slide));
          }
        },

        getValidIndex(index, prevIndex) {if (index === void 0) {index = this.index;}if (prevIndex === void 0) {prevIndex = this.prevIndex;}
          index = this.getIndex(index, prevIndex);

          if (!this.sets) {
            return index;
          }

          let prev;

          do {
            if (includes(this.sets, index)) {
              return index;
            }

            prev = index;
            index = this.getIndex(index + this.dir, prevIndex);
          } while (index !== prev);

          return index;
        },

        getAdjacentSlides() {
          const { width } = dimensions$1(this.list);
          const left = -width;
          const right = width * 2;
          const slideWidth = dimensions$1(this.slides[this.index]).width;
          const slideLeft = this.center ? width / 2 - slideWidth / 2 : 0;
          const slides = new Set();
          for (const i of [-1, 1]) {
            let currentLeft = slideLeft + (i > 0 ? slideWidth : 0);
            let j = 0;
            do {
              const slide = this.slides[this.getIndex(this.index + i + j++ * i)];
              currentLeft += dimensions$1(slide).width * i;
              slides.add(slide);
            } while (this.slides.length > j && currentLeft > left && currentLeft < right);
          }
          return Array.from(slides);
        } } };



    function getMaxElWidth(list) {
      return Math.max(0, ...children(list).map((el) => dimensions$1(el).width));
    }

    var sliderParallax = {
      mixins: [Parallax],

      data: {
        selItem: '!li' },


      beforeConnect() {
        this.item = query(this.selItem, this.$el);
      },

      disconnected() {
        this.item = null;
      },

      events: [
      {
        name: 'itemin itemout',

        self: true,

        el() {
          return this.item;
        },

        handler(_ref) {let { type, detail: { percent, duration, timing, dir } } = _ref;
          fastdom.read(() => {
            const propsFrom = this.getCss(getCurrentPercent(type, dir, percent));
            const propsTo = this.getCss(isIn(type) ? 0.5 : dir > 0 ? 1 : 0);
            fastdom.write(() => {
              css(this.$el, propsFrom);
              Transition.start(this.$el, propsTo, duration, timing).catch(noop);
            });
          });
        } },


      {
        name: 'transitioncanceled transitionend',

        self: true,

        el() {
          return this.item;
        },

        handler() {
          Transition.cancel(this.$el);
        } },


      {
        name: 'itemtranslatein itemtranslateout',

        self: true,

        el() {
          return this.item;
        },

        handler(_ref2) {let { type, detail: { percent, dir } } = _ref2;
          fastdom.read(() => {
            const props = this.getCss(getCurrentPercent(type, dir, percent));
            fastdom.write(() => css(this.$el, props));
          });
        } }] };




    function isIn(type) {
      return endsWith(type, 'in');
    }

    function getCurrentPercent(type, dir, percent) {
      percent /= 2;

      return isIn(type) ^ dir < 0 ? percent : 1 - percent;
    }

    var Animations = {
      ...Animations$2,
      fade: {
        show() {
          return [{ opacity: 0, zIndex: 0 }, { zIndex: -1 }];
        },

        percent(current) {
          return 1 - css(current, 'opacity');
        },

        translate(percent) {
          return [{ opacity: 1 - percent, zIndex: 0 }, { zIndex: -1 }];
        } },


      scale: {
        show() {
          return [{ opacity: 0, transform: scale3d(1 + 0.5), zIndex: 0 }, { zIndex: -1 }];
        },

        percent(current) {
          return 1 - css(current, 'opacity');
        },

        translate(percent) {
          return [
          { opacity: 1 - percent, transform: scale3d(1 + 0.5 * percent), zIndex: 0 },
          { zIndex: -1 }];

        } },


      pull: {
        show(dir) {
          return dir < 0 ?
          [
          { transform: translate(30), zIndex: -1 },
          { transform: translate(), zIndex: 0 }] :

          [
          { transform: translate(-100), zIndex: 0 },
          { transform: translate(), zIndex: -1 }];

        },

        percent(current, next, dir) {
          return dir < 0 ? 1 - translated(next) : translated(current);
        },

        translate(percent, dir) {
          return dir < 0 ?
          [
          { transform: translate(30 * percent), zIndex: -1 },
          { transform: translate(-100 * (1 - percent)), zIndex: 0 }] :

          [
          { transform: translate(-percent * 100), zIndex: 0 },
          { transform: translate(30 * (1 - percent)), zIndex: -1 }];

        } },


      push: {
        show(dir) {
          return dir < 0 ?
          [
          { transform: translate(100), zIndex: 0 },
          { transform: translate(), zIndex: -1 }] :

          [
          { transform: translate(-30), zIndex: -1 },
          { transform: translate(), zIndex: 0 }];

        },

        percent(current, next, dir) {
          return dir > 0 ? 1 - translated(next) : translated(current);
        },

        translate(percent, dir) {
          return dir < 0 ?
          [
          { transform: translate(percent * 100), zIndex: 0 },
          { transform: translate(-30 * (1 - percent)), zIndex: -1 }] :

          [
          { transform: translate(-30 * percent), zIndex: -1 },
          { transform: translate(100 * (1 - percent)), zIndex: 0 }];

        } } };

    var slideshow = {
      mixins: [Class, Slideshow, SliderReactive, SliderPreload],

      props: {
        ratio: String,
        minHeight: Number,
        maxHeight: Number },


      data: {
        ratio: '16:9',
        minHeight: false,
        maxHeight: false,
        selList: '.uk-slideshow-items',
        attrItem: 'uk-slideshow-item',
        selNav: '.uk-slideshow-nav',
        Animations },


      update: {
        read() {
          if (!this.list) {
            return false;
          }

          let [width, height] = this.ratio.split(':').map(Number);

          height = height * this.list.offsetWidth / width || 0;

          if (this.minHeight) {
            height = Math.max(this.minHeight, height);
          }

          if (this.maxHeight) {
            height = Math.min(this.maxHeight, height);
          }

          return { height: height - boxModelAdjust(this.list, 'height', 'content-box') };
        },

        write(_ref) {let { height } = _ref;
          height > 0 && css(this.list, 'minHeight', height);
        },

        events: ['resize'] },


      methods: {
        getAdjacentSlides() {
          return [1, -1].map((i) => this.slides[this.getIndex(this.index + i)]);
        } } };

    var sortable = {
      mixins: [Class, Animate],

      props: {
        group: String,
        threshold: Number,
        clsItem: String,
        clsPlaceholder: String,
        clsDrag: String,
        clsDragState: String,
        clsBase: String,
        clsNoDrag: String,
        clsEmpty: String,
        clsCustom: String,
        handle: String },


      data: {
        group: false,
        threshold: 5,
        clsItem: 'uk-sortable-item',
        clsPlaceholder: 'uk-sortable-placeholder',
        clsDrag: 'uk-sortable-drag',
        clsDragState: 'uk-drag',
        clsBase: 'uk-sortable',
        clsNoDrag: 'uk-sortable-nodrag',
        clsEmpty: 'uk-sortable-empty',
        clsCustom: '',
        handle: false,
        pos: {} },


      created() {
        for (const key of ['init', 'start', 'move', 'end']) {
          const fn = this[key];
          this[key] = (e) => {
            assign(this.pos, getEventPos(e));
            fn(e);
          };
        }
      },

      events: {
        name: pointerDown,
        passive: false,
        handler: 'init' },


      computed: {
        target() {
          return (this.$el.tBodies || [this.$el])[0];
        },

        items() {
          return children(this.target);
        },

        isEmpty: {
          get() {
            return isEmpty(this.items);
          },

          watch(empty) {
            toggleClass(this.target, this.clsEmpty, empty);
          },

          immediate: true },


        handles: {
          get(_ref, el) {let { handle } = _ref;
            return handle ? $$(handle, el) : this.items;
          },

          watch(handles, prev) {
            css(prev, { touchAction: '', userSelect: '' });
            css(handles, { touchAction: hasTouch ? 'none' : '', userSelect: 'none' }); // touchAction set to 'none' causes a performance drop in Chrome 80
          },

          immediate: true } },



      update: {
        write(data) {
          if (!this.drag || !parent(this.placeholder)) {
            return;
          }

          const {
            pos: { x, y },
            origin: { offsetTop, offsetLeft },
            placeholder } =
          this;

          css(this.drag, {
            top: y - offsetTop,
            left: x - offsetLeft });


          const sortable = this.getSortable(document.elementFromPoint(x, y));

          if (!sortable) {
            return;
          }

          const { items } = sortable;

          if (items.some(Transition.inProgress)) {
            return;
          }

          const target = findTarget(items, { x, y });

          if (items.length && (!target || target === placeholder)) {
            return;
          }

          const previous = this.getSortable(placeholder);
          const insertTarget = findInsertTarget(
          sortable.target,
          target,
          placeholder,
          x,
          y,
          sortable === previous && data.moved !== target);


          if (insertTarget === false) {
            return;
          }

          if (insertTarget && placeholder === insertTarget) {
            return;
          }

          if (sortable !== previous) {
            previous.remove(placeholder);
            data.moved = target;
          } else {
            delete data.moved;
          }

          sortable.insert(placeholder, insertTarget);

          this.touched.add(sortable);
        },

        events: ['move'] },


      methods: {
        init(e) {
          const { target, button, defaultPrevented } = e;
          const [placeholder] = this.items.filter((el) => within(target, el));

          if (
          !placeholder ||
          defaultPrevented ||
          button > 0 ||
          isInput(target) ||
          within(target, "." + this.clsNoDrag) ||
          this.handle && !within(target, this.handle))
          {
            return;
          }

          e.preventDefault();

          this.touched = new Set([this]);
          this.placeholder = placeholder;
          this.origin = { target, index: index(placeholder), ...this.pos };

          on(document, pointerMove, this.move);
          on(document, pointerUp, this.end);

          if (!this.threshold) {
            this.start(e);
          }
        },

        start(e) {
          this.drag = appendDrag(this.$container, this.placeholder);
          const { left, top } = this.placeholder.getBoundingClientRect();
          assign(this.origin, { offsetLeft: this.pos.x - left, offsetTop: this.pos.y - top });

          addClass(this.drag, this.clsDrag, this.clsCustom);
          addClass(this.placeholder, this.clsPlaceholder);
          addClass(this.items, this.clsItem);
          addClass(document.documentElement, this.clsDragState);

          trigger(this.$el, 'start', [this, this.placeholder]);

          trackScroll(this.pos);

          this.move(e);
        },

        move(e) {
          if (this.drag) {
            this.$emit('move');
          } else if (
          Math.abs(this.pos.x - this.origin.x) > this.threshold ||
          Math.abs(this.pos.y - this.origin.y) > this.threshold)
          {
            this.start(e);
          }
        },

        end() {
          off(document, pointerMove, this.move);
          off(document, pointerUp, this.end);

          if (!this.drag) {
            return;
          }

          untrackScroll();

          const sortable = this.getSortable(this.placeholder);

          if (this === sortable) {
            if (this.origin.index !== index(this.placeholder)) {
              trigger(this.$el, 'moved', [this, this.placeholder]);
            }
          } else {
            trigger(sortable.$el, 'added', [sortable, this.placeholder]);
            trigger(this.$el, 'removed', [this, this.placeholder]);
          }

          trigger(this.$el, 'stop', [this, this.placeholder]);

          remove$1(this.drag);
          this.drag = null;

          for (const { clsPlaceholder, clsItem } of this.touched) {
            for (const sortable of this.touched) {
              removeClass(sortable.items, clsPlaceholder, clsItem);
            }
          }
          this.touched = null;
          removeClass(document.documentElement, this.clsDragState);
        },

        insert(element, target) {
          addClass(this.items, this.clsItem);

          const insert = () => target ? before(target, element) : append(this.target, element);

          this.animate(insert);
        },

        remove(element) {
          if (!within(element, this.target)) {
            return;
          }

          this.animate(() => remove$1(element));
        },

        getSortable(element) {
          do {
            const sortable = this.$getComponent(element, 'sortable');

            if (
            sortable && (
            sortable === this || this.group !== false && sortable.group === this.group))
            {
              return sortable;
            }
          } while (element = parent(element));
        } } };



    let trackTimer;
    function trackScroll(pos) {
      let last = Date.now();
      trackTimer = setInterval(() => {
        let { x, y } = pos;
        y += scrollTop(window);

        const dist = (Date.now() - last) * 0.3;
        last = Date.now();

        scrollParents(document.elementFromPoint(x, pos.y), /auto|scroll/).
        reverse().
        some((scrollEl) => {
          let { scrollTop: scroll, scrollHeight } = scrollEl;

          const { top, bottom, height } = offset(getViewport$1(scrollEl));

          if (top < y && top + 35 > y) {
            scroll -= dist;
          } else if (bottom > y && bottom - 35 < y) {
            scroll += dist;
          } else {
            return;
          }

          if (scroll > 0 && scroll < scrollHeight - height) {
            scrollTop(scrollEl, scroll);
            return true;
          }
        });
      }, 15);
    }

    function untrackScroll() {
      clearInterval(trackTimer);
    }

    function appendDrag(container, element) {
      const clone = append(
      container,
      element.outerHTML.replace(/(^<)(?:li|tr)|(?:li|tr)(\/>$)/g, '$1div$2'));


      css(clone, 'margin', '0', 'important');
      css(clone, {
        boxSizing: 'border-box',
        width: element.offsetWidth,
        height: element.offsetHeight,
        padding: css(element, 'padding') });


      height(clone.firstElementChild, height(element.firstElementChild));

      return clone;
    }

    function findTarget(items, point) {
      return items[findIndex(items, (item) => pointInRect(point, item.getBoundingClientRect()))];
    }

    function findInsertTarget(list, target, placeholder, x, y, sameList) {
      if (!children(list).length) {
        return;
      }

      const rect = target.getBoundingClientRect();
      if (!sameList) {
        if (!isHorizontal(list, placeholder)) {
          return y < rect.top + rect.height / 2 ? target : target.nextElementSibling;
        }

        return target;
      }

      const placeholderRect = placeholder.getBoundingClientRect();
      const sameRow = linesIntersect(
      [rect.top, rect.bottom],
      [placeholderRect.top, placeholderRect.bottom]);


      const pointerPos = sameRow ? x : y;
      const lengthProp = sameRow ? 'width' : 'height';
      const startProp = sameRow ? 'left' : 'top';
      const endProp = sameRow ? 'right' : 'bottom';

      const diff =
      placeholderRect[lengthProp] < rect[lengthProp] ?
      rect[lengthProp] - placeholderRect[lengthProp] :
      0;

      if (placeholderRect[startProp] < rect[startProp]) {
        if (diff && pointerPos < rect[startProp] + diff) {
          return false;
        }

        return target.nextElementSibling;
      }

      if (diff && pointerPos > rect[endProp] - diff) {
        return false;
      }

      return target;
    }

    function isHorizontal(list, placeholder) {
      const single = children(list).length === 1;

      if (single) {
        append(list, placeholder);
      }

      const items = children(list);
      const isHorizontal = items.some((el, i) => {
        const rectA = el.getBoundingClientRect();
        return items.slice(i + 1).some((el) => {
          const rectB = el.getBoundingClientRect();
          return !linesIntersect([rectA.left, rectA.right], [rectB.left, rectB.right]);
        });
      });

      if (single) {
        remove$1(placeholder);
      }

      return isHorizontal;
    }

    function linesIntersect(lineA, lineB) {
      return lineA[1] > lineB[0] && lineB[1] > lineA[0];
    }

    var tooltip = {
      mixins: [Container, Togglable, Position],

      args: 'title',

      props: {
        delay: Number,
        title: String },


      data: {
        pos: 'top',
        title: '',
        delay: 0,
        animation: ['uk-animation-scale-up'],
        duration: 100,
        cls: 'uk-active' },


      beforeConnect() {
        this._hasTitle = hasAttr(this.$el, 'title');
        attr(this.$el, 'title', '');
        this.updateAria(false);
        makeFocusable(this.$el);
      },

      disconnected() {
        this.hide();
        attr(this.$el, 'title', this._hasTitle ? this.title : null);
      },

      methods: {
        show() {
          if (this.isToggled(this.tooltip || null) || !this.title) {
            return;
          }

          this._unbind = once(
          document, "show keydown " +
          pointerDown,
          this.hide,
          false,
          (e) =>
          e.type === pointerDown && !within(e.target, this.$el) ||
          e.type === 'keydown' && e.keyCode === 27 ||
          e.type === 'show' && e.detail[0] !== this && e.detail[0].$name === this.$name);


          clearTimeout(this.showTimer);
          this.showTimer = setTimeout(this._show, this.delay);
        },

        async hide() {
          if (matches(this.$el, 'input:focus')) {
            return;
          }

          clearTimeout(this.showTimer);

          if (!this.isToggled(this.tooltip || null)) {
            return;
          }

          await this.toggleElement(this.tooltip, false, false);
          remove$1(this.tooltip);
          this.tooltip = null;
          this._unbind();
        },

        _show() {
          this.tooltip = append(
          this.container, "<div class=\"uk-" +
          this.$options.name + "\"> <div class=\"uk-" +
          this.$options.name + "-inner\">" + this.title + "</div> </div>");



          on(this.tooltip, 'toggled', (e, toggled) => {
            this.updateAria(toggled);

            if (!toggled) {
              return;
            }

            this.positionAt(this.tooltip, this.$el);

            this.origin =
            this.getAxis() === 'y' ?
            flipPosition(this.dir) + "-" + this.align :
            this.align + "-" + flipPosition(this.dir);
          });

          this.toggleElement(this.tooltip, true);
        },

        updateAria(toggled) {
          attr(this.$el, 'aria-expanded', toggled);
        } },


      events: {
        focus: 'show',
        blur: 'hide',

        [pointerEnter + " " + pointerLeave](e) {
          if (!isTouch(e)) {
            this[e.type === pointerEnter ? 'show' : 'hide']();
          }
        },

        // Clicking a button does not give it focus on all browsers and platforms
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus
        [pointerDown](e) {
          if (isTouch(e)) {
            this.show();
          }
        } } };



    function makeFocusable(el) {
      if (!isFocusable(el)) {
        attr(el, 'tabindex', '0');
      }
    }

    var upload = {
      props: {
        allow: String,
        clsDragover: String,
        concurrent: Number,
        maxSize: Number,
        method: String,
        mime: String,
        msgInvalidMime: String,
        msgInvalidName: String,
        msgInvalidSize: String,
        multiple: Boolean,
        name: String,
        params: Object,
        type: String,
        url: String },


      data: {
        allow: false,
        clsDragover: 'uk-dragover',
        concurrent: 1,
        maxSize: 0,
        method: 'POST',
        mime: false,
        msgInvalidMime: 'Invalid File Type: %s',
        msgInvalidName: 'Invalid File Name: %s',
        msgInvalidSize: 'Invalid File Size: %s Kilobytes Max',
        multiple: false,
        name: 'files[]',
        params: {},
        type: '',
        url: '',
        abort: noop,
        beforeAll: noop,
        beforeSend: noop,
        complete: noop,
        completeAll: noop,
        error: noop,
        fail: noop,
        load: noop,
        loadEnd: noop,
        loadStart: noop,
        progress: noop },


      events: {
        change(e) {
          if (!matches(e.target, 'input[type="file"]')) {
            return;
          }

          e.preventDefault();

          if (e.target.files) {
            this.upload(e.target.files);
          }

          e.target.value = '';
        },

        drop(e) {
          stop(e);

          const transfer = e.dataTransfer;

          if (!(transfer != null && transfer.files)) {
            return;
          }

          removeClass(this.$el, this.clsDragover);

          this.upload(transfer.files);
        },

        dragenter(e) {
          stop(e);
        },

        dragover(e) {
          stop(e);
          addClass(this.$el, this.clsDragover);
        },

        dragleave(e) {
          stop(e);
          removeClass(this.$el, this.clsDragover);
        } },


      methods: {
        async upload(files) {
          files = toArray(files);

          if (!files.length) {
            return;
          }

          trigger(this.$el, 'upload', [files]);

          for (const file of files) {
            if (this.maxSize && this.maxSize * 1000 < file.size) {
              this.fail(this.msgInvalidSize.replace('%s', this.maxSize));
              return;
            }

            if (this.allow && !match(this.allow, file.name)) {
              this.fail(this.msgInvalidName.replace('%s', this.allow));
              return;
            }

            if (this.mime && !match(this.mime, file.type)) {
              this.fail(this.msgInvalidMime.replace('%s', this.mime));
              return;
            }
          }

          if (!this.multiple) {
            files = files.slice(0, 1);
          }

          this.beforeAll(this, files);

          const chunks = chunk(files, this.concurrent);
          const upload = async (files) => {
            const data = new FormData();

            files.forEach((file) => data.append(this.name, file));

            for (const key in this.params) {
              data.append(key, this.params[key]);
            }

            try {
              const xhr = await ajax(this.url, {
                data,
                method: this.method,
                responseType: this.type,
                beforeSend: (env) => {
                  const { xhr } = env;
                  xhr.upload && on(xhr.upload, 'progress', this.progress);
                  for (const type of ['loadStart', 'load', 'loadEnd', 'abort']) {
                    on(xhr, type.toLowerCase(), this[type]);
                  }

                  return this.beforeSend(env);
                } });


              this.complete(xhr);

              if (chunks.length) {
                await upload(chunks.shift());
              } else {
                this.completeAll(xhr);
              }
            } catch (e) {
              this.error(e);
            }
          };

          await upload(chunks.shift());
        } } };



    function match(pattern, path) {
      return path.match(
      new RegExp("^" +
      pattern.
      replace(/\//g, '\\/').
      replace(/\*\*/g, '(\\/[^\\/]+)*').
      replace(/\*/g, '[^\\/]+').
      replace(/((?!\\))\?/g, '$1.') + "$",
      'i'));


    }

    function chunk(files, size) {
      const chunks = [];
      for (let i = 0; i < files.length; i += size) {
        chunks.push(files.slice(i, i + size));
      }
      return chunks;
    }

    function stop(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    var components = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Countdown: countdown,
        Filter: filter,
        Lightbox: lightbox,
        LightboxPanel: LightboxPanel,
        Notification: notification,
        Parallax: parallax,
        Slider: slider,
        SliderParallax: sliderParallax,
        Slideshow: slideshow,
        SlideshowParallax: sliderParallax,
        Sortable: sortable,
        Tooltip: tooltip,
        Upload: upload
    });

    each(components, (component, name) => UIkit.component(name, component));

    return UIkit;

}));

},{}]},{},[7])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJtYWluL3NyYy90cy9ibG9ja3MudHMiLCJtYWluL3NyYy90cy9ibG9ja3MvUGFnZUJsb2NrLnRzIiwibWFpbi9zcmMvdHMvYmxvY2tzL3NpZ25pbi50cyIsIm1haW4vc3JjL3RzL2Jsb2Nrcy9zaWdudXAudHMiLCJtYWluL3NyYy90cy9saWJzLnRzIiwibWFpbi9zcmMvdHMvbGlicy91aWtpdC50cyIsIm1haW4vc3JjL3RzL21haW4udHMiLCJub2RlX21vZHVsZXMvdWlraXQvZGlzdC9qcy91aWtpdC1pY29ucy5qcyIsIm5vZGVfbW9kdWxlcy91aWtpdC9kaXN0L2pzL3Vpa2l0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUNBQSw2REFBcUM7QUFDckMsNkRBQXFDO0FBRXJDLGtCQUFlLEdBQUcsRUFBRTtJQUNoQixJQUFJLGdCQUFNLEVBQUUsQ0FBQztJQUNiLElBQUksZ0JBQU0sRUFBRSxDQUFDO0FBQ2pCLENBQUMsQ0FBQzs7OztBQ05GLE1BQThCLFNBQVM7SUFDbkM7UUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ2QsT0FBTztTQUNWO1FBRUQsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2pCLENBQUM7Q0FJSjtBQVhELDRCQVdDOzs7Ozs7O0FDWEQsNERBQW9DO0FBRXBDLE1BQXFCLE1BQU8sU0FBUSxtQkFBUztJQUMvQixJQUFJO1FBQ1YsSUFBSSxRQUFRLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ25DLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBRVMsS0FBSztRQUNYLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLENBQUM7UUFFM0QsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQzVDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUN2QixZQUFZO1lBQ1osTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBRXBFLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0NBQ0o7QUFwQkQseUJBb0JDOzs7Ozs7O0FDdEJELDREQUFvQztBQUVwQyxNQUFxQixNQUFPLFNBQVEsbUJBQVM7SUFDL0IsSUFBSTtRQUNWLElBQUksUUFBUSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUNuQyxPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVTLEtBQUs7UUFDWCxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRTNELFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUM1QyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDdkIsWUFBWTtZQUNaLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUVwRSxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUNKO0FBcEJELHlCQW9CQzs7Ozs7OztBQ3RCRCx5REFBcUM7QUFFckMsa0JBQWUsR0FBUyxFQUFFO0lBQ3RCLElBQUEsZUFBUyxHQUFFLENBQUM7QUFDaEIsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIRiw2Q0FBK0I7QUFDL0IsYUFBYTtBQUNiLDRFQUE4QztBQUU5QyxrQkFBZSxHQUFHLEVBQUU7SUFDaEIsYUFBYTtJQUNiLE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBRXJCLGFBQWE7SUFDYixLQUFLLENBQUMsR0FBRyxDQUFDLHFCQUFLLENBQUMsQ0FBQztBQUNyQixDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWRixrREFBOEI7QUFDOUIsc0RBQXdDO0FBRXhDLE1BQU0sSUFBSSxHQUFHLEdBQVMsRUFBRTtJQUNwQixJQUFBLGNBQVEsR0FBRSxDQUFDO0lBQ1gsSUFBQSxnQkFBZ0IsR0FBRSxDQUFDO0FBQ3ZCLENBQUMsQ0FBQSxDQUFDO0FBRUYsSUFBSSxFQUFFLENBQUM7O0FDVFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJpbXBvcnQgc2lnbmluIGZyb20gJy4vYmxvY2tzL3NpZ25pbic7XHJcbmltcG9ydCBzaWdudXAgZnJvbSAnLi9ibG9ja3Mvc2lnbnVwJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0ICgpID0+IHtcclxuICAgIG5ldyBzaWduaW4oKTtcclxuICAgIG5ldyBzaWdudXAoKTtcclxufTsiLCJleHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBQYWdlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGluaXQoKTogYm9vbGVhblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHN0YXJ0KCk6IHZvaWRcclxufSIsImltcG9ydCBQYWdlQmxvY2sgZnJvbSAnLi9QYWdlQmxvY2snO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mgc2lnbmluIGV4dGVuZHMgUGFnZUJsb2NrIHtcclxuICAgIHByb3RlY3RlZCBpbml0KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2lnbmluJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHNpZ25pbkZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnNpZ25pbl9fZm9ybVwiKTtcclxuXHJcbiAgICAgICAgc2lnbmluRm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBPYmplY3QuZnJvbUVudHJpZXMobmV3IEZvcm1EYXRhKHNpZ25pbkZvcm0pLmVudHJpZXMoKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSIsImltcG9ydCBQYWdlQmxvY2sgZnJvbSAnLi9QYWdlQmxvY2snO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mgc2lnbnVwIGV4dGVuZHMgUGFnZUJsb2NrIHtcclxuICAgIHByb3RlY3RlZCBpbml0KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2lnbnVwJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHNpZ251cEZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnNpZ251cF9fZm9ybVwiKTtcclxuXHJcbiAgICAgICAgc2lnbnVwRm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBPYmplY3QuZnJvbUVudHJpZXMobmV3IEZvcm1EYXRhKHNpZ251cEZvcm0pLmVudHJpZXMoKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSIsImltcG9ydCB1aWtpdEluaXQgZnJvbSAnLi9saWJzL3Vpa2l0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0ICgpOiB2b2lkID0+IHtcclxuICAgIHVpa2l0SW5pdCgpO1xyXG59OyIsIlxyXG5pbXBvcnQgKiBhcyBVSWtpdCBmcm9tICd1aWtpdCc7XHJcbi8vIEB0cy1pZ25vcmVcclxuaW1wb3J0IEljb25zIGZyb20gJ3Vpa2l0L2Rpc3QvanMvdWlraXQtaWNvbnMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgd2luZG93LlVJa2l0ID0gVUlraXQ7XHJcblxyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgVUlraXQudXNlKEljb25zKTtcclxufTsiLCJcclxuaW1wb3J0IGluaXRMaWJzIGZyb20gJy4vbGlicyc7XHJcbmltcG9ydCBpbml0QmxvY2tTY3JpcHRzIGZyb20gJy4vYmxvY2tzJztcclxuXHJcbmNvbnN0IG1haW4gPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpbml0TGlicygpO1xyXG4gICAgaW5pdEJsb2NrU2NyaXB0cygpO1xyXG59O1xyXG5cclxubWFpbigpOyIsIi8qISBVSWtpdCAzLjEzLjkgfCBodHRwczovL3d3dy5nZXR1aWtpdC5jb20gfCAoYykgMjAxNCAtIDIwMjIgWU9PdGhlbWUgfCBNSVQgTGljZW5zZSAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ3Vpa2l0aWNvbnMnLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLlVJa2l0SWNvbnMgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gcGx1Z2luKFVJa2l0KSB7XG4gICAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIFVJa2l0Lmljb24uYWRkKHtcbiAgICAgICAgXCI1MDBweFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTkuNjI0LDExLjg2NmMtMC4xNDEsMC4xMzIsMC40NzksMC42NTgsMC42NjIsMC40MThjMC4wNTEtMC4wNDYsMC42MDctMC42MSwwLjY2Mi0wLjY2NGMwLDAsMC43MzgsMC43MTksMC44MTQsMC43MTkgYzAuMSwwLDAuMjA3LTAuMDU1LDAuMzIyLTAuMTdjMC4yNy0wLjI2OSwwLjEzNS0wLjQxNiwwLjA2Ni0wLjQ5NWwtMC42MzEtMC42MTZsMC42NTgtMC42NjhjMC4xNDYtMC4xNTYsMC4wMjEtMC4zMTQtMC4xLTAuNDQ5IGMtMC4xODItMC4xOC0wLjM1OS0wLjIyNi0wLjQ3MS0wLjEyNWwtMC42NTYsMC42NTRsLTAuNjU0LTAuNjU0Yy0wLjAzMy0wLjAzNC0wLjA4LTAuMDQ1LTAuMTI0LTAuMDQ1IGMtMC4wNzksMC0wLjE5MSwwLjA2OC0wLjMwNywwLjE4MWMtMC4yMDIsMC4yMDItMC4yNDcsMC4zNTEtMC4xMzMsMC40NjJsMC42NjUsMC42NjVMOS42MjQsMTEuODY2elxcXCIvPjxwYXRoIGQ9XFxcIk0xMS4wNjYsMi44ODRjLTEuMDYxLDAtMi4xODUsMC4yNDgtMy4wMTEsMC42MDRjLTAuMDg3LDAuMDM0LTAuMTQxLDAuMTA2LTAuMTUsMC4yMDVDNy44OTMsMy43ODQsNy45MTksMy45MDksNy45ODIsNC4wNjYgYzAuMDUsMC4xMzYsMC4xODcsMC40NzQsMC40NTIsMC4zNzJjMC44NDQtMC4zMjYsMS43NzktMC41MDcsMi42MzMtMC41MDdjMC45NjMsMCwxLjksMC4xOTEsMi43ODEsMC41NjQgYzAuNjk1LDAuMjkyLDEuMzU3LDAuNzE5LDIuMDc4LDEuMzRjMC4wNTEsMC4wNDQsMC4xMDUsMC4wNjgsMC4xNjQsMC4wNjhjMC4xNDMsMCwwLjI3My0wLjEzNywwLjM4OS0wLjI3MSBjMC4xOTEtMC4yMTQsMC4zMjQtMC4zOTUsMC4xMzUtMC41NzVjLTAuNjg2LTAuNjU0LTEuNDM2LTEuMTM4LTIuMzYzLTEuNTMzQzEzLjI0LDMuMDk3LDEyLjE2OCwyLjg4NCwxMS4wNjYsMi44ODR6XFxcIi8+PHBhdGggZD1cXFwiTTE2LjQzLDE1Ljc0N2MtMC4wOTItMC4wMjgtMC4yNDIsMC4wNS0wLjMwOSwwLjExOWwwLDBjLTAuNjUyLDAuNjUyLTEuNDIsMS4xNjktMi4yNjgsMS41MjEgYy0wLjg3NywwLjM3MS0xLjgxNCwwLjU1MS0yLjc3OSwwLjU1MWMtMC45NjEsMC0xLjg5Ni0wLjE4OS0yLjc3NS0wLjU2NGMtMC44NDgtMC4zNi0xLjYxMi0wLjg3OS0yLjI2OC0xLjUzIGMtMC42ODItMC42ODgtMS4xOTYtMS40NTUtMS41MjktMi4yNjhjLTAuMzI1LTAuNzk5LTAuNDcxLTEuNjQzLTAuNDcxLTEuNjQzYy0wLjA0NS0wLjI0LTAuMjU4LTAuMjQ5LTAuNTY3LTAuMjAzIGMtMC4xMjgsMC4wMjEtMC41MTksMC4wNzktMC40ODMsMC4zNnYwLjAxYzAuMTA1LDAuNjQ0LDAuMjg5LDEuMjg0LDAuNTQ1LDEuODk1YzAuNDE3LDAuOTY5LDEuMDAyLDEuODQ5LDEuNzU2LDIuNjA0IGMwLjc1NywwLjc1NCwxLjYzNiwxLjM0LDIuNjA0LDEuNzU3QzguOTAxLDE4Ljc4NSw5Ljk3LDE5LDExLjA4OCwxOWMxLjEwNCwwLDIuMTg2LTAuMjE1LDMuMTg4LTAuNjQ1IGMxLjgzOC0wLjg5NiwyLjYwNC0xLjc1NywyLjYwNC0xLjc1N2MwLjE4Mi0wLjIwNCwwLjIyNy0wLjMxNy0wLjEtMC42NDNDMTYuNzc5LDE1Ljk1NiwxNi41MjUsMTUuNzc0LDE2LjQzLDE1Ljc0N3pcXFwiLz48cGF0aCBkPVxcXCJNNS42MzMsMTMuMjg3YzAuMjkzLDAuNzEsMC43MjMsMS4zNDEsMS4yNjIsMS44ODJjMC41NCwwLjU0LDEuMTcyLDAuOTcxLDEuODgyLDEuMjY0YzAuNzMxLDAuMzAzLDEuNTA5LDAuNDYxLDIuMjk4LDAuNDYxIGMwLjgwMSwwLDEuNTc4LTAuMTU4LDIuMjk3LTAuNDYxYzAuNzExLTAuMjkzLDEuMzQ0LTAuNzI0LDEuODgzLTEuMjY0YzAuNTQzLTAuNTQxLDAuOTcxLTEuMTcyLDEuMjY0LTEuODgyIGMwLjMxNC0wLjcyMSwwLjQ2My0xLjUsMC40NjMtMi4yOThjMC0wLjc5LTAuMTQ4LTEuNTY5LTAuNDYzLTIuMjg5Yy0wLjI5My0wLjY5OS0wLjcyMS0xLjMyOS0xLjI2NC0xLjg4MSBjLTAuNTM5LTAuNTQxLTEuMTcyLTAuOTU5LTEuODY3LTEuMjYzYy0wLjcyMS0wLjMwMy0xLjUtMC40NjEtMi4yOTktMC40NjFjLTAuODAyLDAtMS42MTMsMC4xNTktMi4zMjIsMC40NjEgYy0wLjU3NywwLjI1LTEuNTQ0LDAuODY3LTIuMTE5LDEuNDU0djAuMDEyVjIuMTA4aDguMTZDMTUuMSwyLjEwNCwxNS4xLDEuNjksMTUuMSwxLjU1MkMxNS4xLDEuNDE3LDE1LjEsMSwxNC44MDksMUg1LjkxNSBDNS42NzYsMSw1LjUyNywxLjE5Miw1LjUyNywxLjM4NHY2Ljg0YzAsMC4yMTQsMC4yNzMsMC4zNzIsMC41MjksMC40MjhjMC41LDAuMTA1LDAuNjE0LTAuMDU2LDAuNzM3LTAuMjI0bDAsMCBjMC4xOC0wLjI3MywwLjc3Ni0wLjg4NCwwLjc4Ny0wLjg5NGMwLjkwMS0wLjkwNSwyLjExNy0xLjQwOCwzLjQxNi0xLjQwOGMxLjI4NSwwLDIuNSwwLjUwMSwzLjQxMiwxLjQwOCBjMC45MTQsMC45MTQsMS40MDgsMi4xMjIsMS40MDgsMy40MDVjMCwxLjI4OC0wLjUwOCwyLjQ5Ni0xLjQwOCwzLjQwNWMtMC45LDAuODk2LTIuMTUyLDEuNDA2LTMuNDM4LDEuNDA2IGMtMC44NzcsMC0xLjcxMS0wLjIyOS0yLjQzMy0wLjY3MXYtNC4xNThjMC0wLjU1MywwLjIzNy0xLjE1MSwwLjY0My0xLjYxNGMwLjQ2Mi0wLjUxOSwxLjA5NC0wLjc5OSwxLjc4Mi0wLjc5OSBjMC42NjQsMCwxLjI5MywwLjI1MywxLjc1OCwwLjcxNWMwLjQ1OSwwLjQ1OSwwLjcwOSwxLjA3MSwwLjcwOSwxLjcyM2MwLDEuMzg1LTEuMDk0LDIuNDY4LTIuNDg4LDIuNDY4IGMtMC4yNzMsMC0wLjc2OS0wLjEyMS0wLjc4MS0wLjEyNWMtMC4yODEtMC4wODctMC40MDUsMC4zMDYtMC40MzgsMC40MzZjLTAuMTU5LDAuNDk2LDAuMDc5LDAuNTg1LDAuMTIzLDAuNjA3IGMwLjQ1MiwwLjEzNywwLjc0MywwLjE1NywxLjEyOSwwLjE1N2MxLjk3MywwLDMuNTcyLTEuNiwzLjU3Mi0zLjU3YzAtMS45NjQtMS42LTMuNTUyLTMuNTcyLTMuNTUyYy0wLjk3LDAtMS44NzIsMC4zNi0yLjU0NiwxLjAzOCBjLTAuNjU2LDAuNjMxLTEuMDI3LDEuNDg3LTEuMDI3LDIuMzIydjMuNDM4di0wLjAxMWMtMC4zNzItMC40Mi0wLjczMi0xLjA0MS0wLjk4MS0xLjY4MmMtMC4xMDItMC4yNDgtMC4zMTUtMC4yMDItMC42MDctMC4xMTMgYy0wLjEzNSwwLjAzNS0wLjUxOSwwLjE1Ny0wLjQ0LDAuNDM5QzUuMzcyLDEyLjc5OSw1LjU3NywxMy4xNjQsNS42MzMsMTMuMjg3elxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImFsYnVtXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCI1XFxcIiB5PVxcXCIyXFxcIiB3aWR0aD1cXFwiMTBcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjRcXFwiIHdpZHRoPVxcXCIxNFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxLjVcXFwiIHk9XFxcIjYuNVxcXCIgd2lkdGg9XFxcIjE3XFxcIiBoZWlnaHQ9XFxcIjExXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYXJyb3ctZG93blwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMC41LDE2LjA4IDUuNjMsMTAuNjYgNi4zNywxMCAxMC41LDE0LjU4IDE0LjYzLDEwIDE1LjM3LDEwLjY2XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiMTAuNVxcXCIgeTE9XFxcIjRcXFwiIHgyPVxcXCIxMC41XFxcIiB5Mj1cXFwiMTVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJhcnJvdy1sZWZ0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjEwIDE0IDUgOS41IDEwIDVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCIxNlxcXCIgeTE9XFxcIjkuNVxcXCIgeDI9XFxcIjVcXFwiIHkyPVxcXCI5LjUyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYXJyb3ctcmlnaHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTAgNSAxNSA5LjUgMTAgMTRcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI0XFxcIiB5MT1cXFwiOS41XFxcIiB4Mj1cXFwiMTVcXFwiIHkyPVxcXCI5LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJhcnJvdy11cFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMC41LDQgMTUuMzcsOS40IDE0LjYzLDEwLjA4IDEwLjUsNS40OSA2LjM3LDEwLjA4IDUuNjMsOS40XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiMTAuNVxcXCIgeTE9XFxcIjE2XFxcIiB4Mj1cXFwiMTAuNVxcXCIgeTI9XFxcIjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJiYWdcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTcuNSw3LjVWNEEyLjQ4LDIuNDgsMCwwLDEsMTAsMS41LDIuNTQsMi41NCwwLDAsMSwxMi41LDRWNy41XFxcIi8+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjE2LjUgNy41IDMuNSA3LjUgMi41IDE4LjUgMTcuNSAxOC41IDE2LjUgNy41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYmFuXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCI5XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjRcXFwiIHkxPVxcXCIzLjVcXFwiIHgyPVxcXCIxNlxcXCIgeTI9XFxcIjE2LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJiZWhhbmNlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNOS41LDEwLjZjLTAuNC0wLjUtMC45LTAuOS0xLjYtMS4xYzEuNy0xLDIuMi0zLjIsMC43LTQuN0M3LjgsNCw2LjMsNCw1LjIsNEMzLjUsNCwxLjcsNCwwLDR2MTJjMS43LDAsMy40LDAsNS4yLDAgYzEsMCwyLjEsMCwzLjEtMC41QzEwLjIsMTQuNiwxMC41LDEyLjMsOS41LDEwLjZMOS41LDEwLjZ6IE01LjYsNi4xYzEuOCwwLDEuOCwyLjctMC4xLDIuN2MtMSwwLTIsMC0yLjksMFY2LjFINS42eiBNMi42LDEzLjh2LTMuMSBjMS4xLDAsMi4xLDAsMy4yLDBjMi4xLDAsMi4xLDMuMiwwLjEsMy4yTDIuNiwxMy44elxcXCIvPjxwYXRoIGQ9XFxcIk0xOS45LDEwLjlDMTkuNyw5LjIsMTguNyw3LjYsMTcsN2MtNC4yLTEuMy03LjMsMy40LTUuMyw3LjFjMC45LDEuNywyLjgsMi4zLDQuNywyLjFjMS43LTAuMiwyLjktMS4zLDMuNC0yLjloLTIuMiBjLTAuNCwxLjMtMi40LDEuNS0zLjUsMC42Yy0wLjQtMC40LTAuNi0xLjEtMC42LTEuN0gyMEMyMCwxMS43LDE5LjksMTAuOSwxOS45LDEwLjl6IE0xMy41LDEwLjZjMC0xLjYsMi4zLTIuNywzLjUtMS40IGMwLjQsMC40LDAuNSwwLjksMC42LDEuNEgxMy41TDEzLjUsMTAuNnpcXFwiLz48cmVjdCB4PVxcXCIxM1xcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjVcXFwiIGhlaWdodD1cXFwiMS40XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYmVsbFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE3LDE1LjUgTDMsMTUuNSBDMi45OSwxNC42MSAzLjc5LDEzLjM0IDQuMSwxMi41MSBDNC41OCwxMS4zIDQuNzIsMTAuMzUgNS4xOSw3LjAxIEM1LjU0LDQuNTMgNS44OSwzLjIgNy4yOCwyLjE2IEM4LjEzLDEuNTYgOS4zNywxLjUgOS44MSwxLjUgTDkuOTYsMS41IEM5Ljk2LDEuNSAxMS42MiwxLjQxIDEyLjY3LDIuMTcgQzE0LjA4LDMuMiAxNC40Miw0LjU0IDE0Ljc3LDcuMDIgQzE1LjI2LDEwLjM1IDE1LjQsMTEuMzEgMTUuODcsMTIuNTIgQzE2LjIsMTMuMzQgMTcuMDEsMTQuNjEgMTcsMTUuNSBMMTcsMTUuNSBaXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTIuMzksMTYgQzEyLjM5LDE3LjM3IDExLjM1LDE4LjQzIDkuOTEsMTguNDMgQzguNDgsMTguNDMgNy40MiwxNy4zNyA3LjQyLDE2XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYm9sZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTUsMTUuMyBDNS42NiwxNS4zIDUuOSwxNSA1LjksMTQuNTMgTDUuOSw1LjUgQzUuOSw0LjkyIDUuNTYsNC43IDUsNC43IEw1LDQgTDguOTUsNCBDMTIuNiw0IDEzLjcsNS4zNyAxMy43LDYuOSBDMTMuNyw3Ljg3IDEzLjE0LDkuMTcgMTAuODYsOS41OSBMMTAuODYsOS43IEMxMy4yNSw5Ljg2IDE0LjI5LDExLjI4IDE0LjMsMTIuNTQgQzE0LjMsMTQuNDcgMTIuOTQsMTYgOSwxNiBMNSwxNiBMNSwxNS4zIFogTTksOS4zIEMxMS4xOSw5LjMgMTEuOCw4LjUgMTEuODUsNyBDMTEuODUsNS42NSAxMS4zLDQuOCA5LDQuOCBMNy42Nyw0LjggTDcuNjcsOS4zIEw5LDkuMyBaIE05LjE4NSwxNS4yMiBDMTEuOTcsMTUgMTIuMzksMTQgMTIuNCwxMi41OCBDMTIuNCwxMS4xNSAxMS4zOSwxMCA5LDEwIEw3LjY3LDEwIEw3LjY3LDE1IEw5LjE4LDE1IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJib2x0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNC43NCwyMCBMNy43MywxMiBMMywxMiBMMTUuNDMsMSBMMTIuMzIsOSBMMTcuMDIsOSBMNC43NCwyMCBMNC43NCwyMCBMNC43NCwyMCBaIE05LjE4LDExIEw3LjEsMTYuMzkgTDE0LjQ3LDEwIEwxMC44NiwxMCBMMTIuOTksNC42NyBMNS42MSwxMSBMOS4xOCwxMSBMOS4xOCwxMSBMOS4xOCwxMSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYm9va21hcmtcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI1LjUgMS41IDE1LjUgMS41IDE1LjUgMTcuNSAxMC41IDEyLjUgNS41IDE3LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjYWxlbmRhclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTSAyLDMgMiwxNyAxOCwxNyAxOCwzIDIsMyBaIE0gMTcsMTYgMywxNiAzLDggMTcsOCAxNywxNiBaIE0gMTcsNyAzLDcgMyw0IDE3LDQgMTcsNyBaXFxcIi8+PHJlY3Qgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiM1xcXCIgeD1cXFwiNlxcXCIgeT1cXFwiMlxcXCIvPjxyZWN0IHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjNcXFwiIHg9XFxcIjEzXFxcIiB5PVxcXCIyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2FtZXJhXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwLjhcXFwiIHI9XFxcIjMuOFxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTEsNC41IEMwLjcsNC41IDAuNSw0LjcgMC41LDUgTDAuNSwxNyBDMC41LDE3LjMgMC43LDE3LjUgMSwxNy41IEwxOSwxNy41IEMxOS4zLDE3LjUgMTkuNSwxNy4zIDE5LjUsMTcgTDE5LjUsNSBDMTkuNSw0LjcgMTkuMyw0LjUgMTksNC41IEwxMy41LDQuNSBMMTMuNSwyLjkgQzEzLjUsMi42IDEzLjMsMi41IDEzLDIuNSBMNywyLjUgQzYuNywyLjUgNi41LDIuNiA2LjUsMi45IEw2LjUsNC41IEwxLDQuNSBMMSw0LjUgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNhcnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjcuM1xcXCIgY3k9XFxcIjE3LjNcXFwiIHI9XFxcIjEuNFxcXCIvPjxjaXJjbGUgY3g9XFxcIjEzLjNcXFwiIGN5PVxcXCIxNy4zXFxcIiByPVxcXCIxLjRcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjAgMiAzLjIgNCA1LjMgMTIuNSAxNiAxMi41IDE4IDYuNSA4IDYuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNoZWNrXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgcG9pbnRzPVxcXCI0LDEwIDgsMTUgMTcsNFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNoZXZyb24tZG91YmxlLWxlZnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgcG9pbnRzPVxcXCIxMCAxNCA2IDEwIDEwIDZcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiMTQgMTQgMTAgMTAgMTQgNlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNoZXZyb24tZG91YmxlLXJpZ2h0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiMTAgNiAxNCAxMCAxMCAxNFxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgcG9pbnRzPVxcXCI2IDYgMTAgMTAgNiAxNFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNoZXZyb24tZG93blwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBwb2ludHM9XFxcIjE2IDcgMTAgMTMgNCA3XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi1sZWZ0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiMTMgMTYgNyAxMCAxMyA0XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi1yaWdodFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBwb2ludHM9XFxcIjcgNCAxMyAxMCA3IDE2XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi11cFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBwb2ludHM9XFxcIjQgMTMgMTAgNyAxNiAxM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNsb2NrXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCI5XFxcIi8+PHJlY3QgeD1cXFwiOVxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiN1xcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMy4wMTgsMTQuMTk3IEw5LjQ0NSwxMC42MjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjbG9zZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDZcXFwiIGQ9XFxcIk0xNiwxNiBMNCw0XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDZcXFwiIGQ9XFxcIk0xNiw0IEw0LDE2XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2xvdWQtZG93bmxvYWRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk02LjUsMTQuNjEgTDMuNzUsMTQuNjEgQzEuOTYsMTQuNjEgMC41LDEzLjE3IDAuNSwxMS4zOSBDMC41LDkuNzYgMS43Miw4LjQxIDMuMyw4LjIgQzMuMzgsNS4zMSA1Ljc1LDMgOC42OCwzIEMxMS4xOSwzIDEzLjMxLDQuNzEgMTMuODksNy4wMiBDMTQuMzksNi44IDE0LjkzLDYuNjggMTUuNSw2LjY4IEMxNy43MSw2LjY4IDE5LjUsOC40NSAxOS41LDEwLjY0IEMxOS41LDEyLjgzIDE3LjcxLDE0LjYgMTUuNSwxNC42IEwxMi41LDE0LjZcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjExLjc1IDE2IDkuNSAxOC4yNSA3LjI1IDE2XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNOS41LDE4IEw5LjUsOS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2xvdWQtdXBsb2FkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNNi41LDE0LjYxIEwzLjc1LDE0LjYxIEMxLjk2LDE0LjYxIDAuNSwxMy4xNyAwLjUsMTEuMzkgQzAuNSw5Ljc2IDEuNzIsOC40MSAzLjMxLDguMiBDMy4zOCw1LjMxIDUuNzUsMyA4LjY4LDMgQzExLjE5LDMgMTMuMzEsNC43MSAxMy44OSw3LjAyIEMxNC4zOSw2LjggMTQuOTMsNi42OCAxNS41LDYuNjggQzE3LjcxLDYuNjggMTkuNSw4LjQ1IDE5LjUsMTAuNjQgQzE5LjUsMTIuODMgMTcuNzEsMTQuNiAxNS41LDE0LjYgTDEyLjUsMTQuNlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNy4yNSAxMS43NSA5LjUgOS41IDExLjc1IDExLjc1XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNOS41LDE4IEw5LjUsOS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY29kZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAxXFxcIiBwb2ludHM9XFxcIjEzLDQgMTksMTAgMTMsMTZcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDFcXFwiIHBvaW50cz1cXFwiNyw0IDEsMTAgNywxNlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNvZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCI5Ljk5N1xcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCIzLjMxXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTguNDg4LDEyLjI4NSBMMTYuMjA1LDE2LjIzNyBDMTUuMzIyLDE1LjQ5NiAxNC4xODUsMTUuMjgxIDEzLjMwMywxNS43OTEgQzEyLjQyOCwxNi4yODkgMTIuMDQ3LDE3LjM3MyAxMi4yNDYsMTguNSBMNy43MzUsMTguNSBDNy45MzgsMTcuMzc0IDcuNTUzLDE2LjI5OSA2LjY4NCwxNS43OTEgQzUuODAxLDE1LjI3IDQuNjU1LDE1LjQ5MiAzLjc3MywxNi4yMzcgTDEuNSwxMi4yODUgQzIuNTczLDExLjg3MSAzLjMxNywxMC45OTkgMy4zMTcsOS45OTEgQzMuMzA1LDguOTggMi41NzMsOC4xMjEgMS41LDcuNzE2IEwzLjc2NSwzLjc4NCBDNC42NDUsNC41MTYgNS43OTQsNC43MzggNi42ODcsNC4yMzIgQzcuNTU1LDMuNzIyIDcuOTM5LDIuNjM3IDcuNzM1LDEuNSBMMTIuMjYzLDEuNSBDMTIuMDcyLDIuNjM3IDEyLjQ0MSwzLjcxIDEzLjMxNCw0LjIyIEMxNC4yMDYsNC43MyAxNS4zNDMsNC41MTYgMTYuMjI1LDMuNzk0IEwxOC40ODcsNy43MTQgQzE3LjQwNCw4LjExNyAxNi42NjEsOC45ODggMTYuNjcsMTAuMDA5IEMxNi42NzIsMTEuMDE4IDE3LjQxNSwxMS44OCAxOC40ODgsMTIuMjg1IEwxOC40ODgsMTIuMjg1IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjb21tZW50XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNiwxOC43MSBMNiwxNCBMMSwxNCBMMSwxIEwxOSwxIEwxOSwxNCBMMTAuNzEsMTQgTDYsMTguNzEgTDYsMTguNzEgWiBNMiwxMyBMNywxMyBMNywxNi4yOSBMMTAuMjksMTMgTDE4LDEzIEwxOCwyIEwyLDIgTDIsMTMgTDIsMTMgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNvbW1lbnRpbmdcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIxLjUsMS41IDE4LjUsMS41IDE4LjUsMTMuNSAxMC41LDEzLjUgNi41LDE3LjUgNi41LDEzLjUgMS41LDEzLjVcXFwiLz48Y2lyY2xlIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjhcXFwiIHI9XFxcIjFcXFwiLz48Y2lyY2xlIGN4PVxcXCI2XFxcIiBjeT1cXFwiOFxcXCIgcj1cXFwiMVxcXCIvPjxjaXJjbGUgY3g9XFxcIjE0XFxcIiBjeT1cXFwiOFxcXCIgcj1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNvbW1lbnRzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjIgMC41IDE5LjUgMC41IDE5LjUgMTNcXFwiLz48cGF0aCBkPVxcXCJNNSwxOS43MSBMNSwxNSBMMCwxNSBMMCwyIEwxOCwyIEwxOCwxNSBMOS43MSwxNSBMNSwxOS43MSBMNSwxOS43MSBMNSwxOS43MSBaIE0xLDE0IEw2LDE0IEw2LDE3LjI5IEw5LjI5LDE0IEwxNywxNCBMMTcsMyBMMSwzIEwxLDE0IEwxLDE0IEwxLDE0IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjb3B5XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiMi41XFxcIiB3aWR0aD1cXFwiMTJcXFwiIGhlaWdodD1cXFwiMTZcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjUgMC41IDE3LjUgMC41IDE3LjUgMTdcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjcmVkaXQtY2FyZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxLjVcXFwiIHk9XFxcIjQuNVxcXCIgd2lkdGg9XFxcIjE3XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiN1xcXCIgd2lkdGg9XFxcIjE4XFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJkYXRhYmFzZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGVsbGlwc2UgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCI0LjY0XFxcIiByeD1cXFwiNy41XFxcIiByeT1cXFwiMy4xNFxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTE3LjUsOC4xMSBDMTcuNSw5Ljg1IDE0LjE0LDExLjI1IDEwLDExLjI1IEM1Ljg2LDExLjI1IDIuNSw5Ljg0IDIuNSw4LjExXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTcuNSwxMS4yNSBDMTcuNSwxMi45OSAxNC4xNCwxNC4zOSAxMCwxNC4zOSBDNS44NiwxNC4zOSAyLjUsMTIuOTggMi41LDExLjI1XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTcuNDksNC42NCBMMTcuNSwxNC4zNiBDMTcuNSwxNi4xIDE0LjE0LDE3LjUgMTAsMTcuNSBDNS44NiwxNy41IDIuNSwxNi4wOSAyLjUsMTQuMzYgTDIuNSw0LjY0XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZGVza3RvcFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiOFxcXCIgeT1cXFwiMTVcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB4PVxcXCIxMVxcXCIgeT1cXFwiMTVcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB4PVxcXCI1XFxcIiB5PVxcXCIxNlxcXCIgd2lkdGg9XFxcIjEwXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjEuNVxcXCIgeT1cXFwiMy41XFxcIiB3aWR0aD1cXFwiMTdcXFwiIGhlaWdodD1cXFwiMTFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJkaXNjb3JkXCI6IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIj48cGF0aCBkPVxcXCJNMTYuMDc0LDQuMzYxYTE0LjI0MywxNC4yNDMsMCwwLDAtMy42MS0xLjEzNCwxMC42MSwxMC42MSwwLDAsMC0uNDYzLjk2LDEzLjIxOSwxMy4yMTksMCwwLDAtNCwwLDEwLjEzOCwxMC4xMzgsMCwwLDAtLjQ2OC0uOTZBMTQuMjA2LDE0LjIwNiwwLDAsMCwzLjkxOSw0LjM2NCwxNS4xNDYsMTUuMTQ2LDAsMCwwLDEuMzI0LDE0LjVhMTQuNDM1LDE0LjQzNSwwLDAsMCw0LjQyOCwyLjI2OUExMC45ODIsMTAuOTgyLDAsMCwwLDYuNywxNS4yMWE5LjI5NCw5LjI5NCwwLDAsMS0xLjQ5NC0uNzI3Yy4xMjUtLjA5My4yNDgtLjE5LjM2Ni0uMjg5YTEwLjIxMiwxMC4yMTIsMCwwLDAsOC44NTQsMGMuMTE5LjEuMjQyLjIuMzY2LjI4OWE5LjI3NCw5LjI3NCwwLDAsMS0xLjUuNzI4LDEwLjgsMTAuOCwwLDAsMCwuOTQ4LDEuNTYyLDE0LjQxOSwxNC40MTksMCwwLDAsNC40MzEtMi4yN0ExNS4xMjgsMTUuMTI4LDAsMCwwLDE2LjA3NCw0LjM2MVptLTguOTgxLDguMWExLjcsMS43LDAsMCwxLTEuNTczLTEuNzlBMS42ODksMS42ODksMCwwLDEsNy4wOTMsOC44ODFhMS42NzksMS42NzksMCwwLDEsMS41NzMsMS43OTFBMS42ODcsMS42ODcsMCwwLDEsNy4wOTMsMTIuNDYyWm01LjgxNCwwYTEuNywxLjcsMCwwLDEtMS41NzMtMS43OSwxLjY4OSwxLjY4OSwwLDAsMSwxLjU3My0xLjc5MSwxLjY3OSwxLjY3OSwwLDAsMSwxLjU3MywxLjc5MUExLjY4OCwxLjY4OCwwLDAsMSwxMi45MDcsMTIuNDYyWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImRvd25sb2FkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjE0LDEwIDkuNSwxNC41IDUsMTBcXFwiLz48cmVjdCB4PVxcXCIzXFxcIiB5PVxcXCIxN1xcXCIgd2lkdGg9XFxcIjEzXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI5LjVcXFwiIHkxPVxcXCIxMy45MVxcXCIgeDI9XFxcIjkuNVxcXCIgeTI9XFxcIjNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJkcmliYmJsZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgZD1cXFwiTTEuMyw4LjljMCwwLDUsMC4xLDguNi0xYzEuNC0wLjQsMi42LTAuOSw0LTEuOSBjMS40LTEuMSwyLjUtMi41LDIuNS0yLjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiBkPVxcXCJNMy45LDE2LjZjMCwwLDEuNy0yLjgsMy41LTQuMiBjMS44LTEuMyw0LTIsNS43LTIuMkMxNiwxMCwxOSwxMC42LDE5LDEwLjZcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiBkPVxcXCJNNi45LDEuNmMwLDAsMy4zLDQuNiw0LjIsNi44IGMwLjQsMC45LDEuMywzLjEsMS45LDUuMmMwLjYsMiwwLjksNC40LDAuOSw0LjRcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCI5XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZXRzeVwiOiBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCI+PHBhdGggZD1cXFwiTTgsNC4yNkM4LDQuMDcsOCw0LDguMzEsNGg0LjQ2Yy43OSwwLDEuMjIuNjcsMS41MywxLjkxbC4yNSwxaC43NmMuMTQtMi44Mi4yNi00LC4yNi00UzEzLjY1LDMsMTIuNTIsM0g2LjgxTDMuNzUsMi45MnYuODRsMSwuMmMuNzMuMTEuOS4yNywxLDEsMCwwLC4wNiwyLC4wNiw1LjE3cy0uMDYsNS4xNC0uMDYsNS4xNGMwLC41OS0uMjMuODEtMSwuOTRsLTEsLjJ2Ljg0bDMuMDYtLjFoNS4xMWMxLjE1LDAsMy44Mi4xLDMuODIuMSwwLS43LjQ1LTMuODguNTEtNC4yMmgtLjczbC0uNzYsMS42OWEyLjI1LDIuMjUsMCwwLDEtMi40NSwxLjQ3SDkuNGMtMSwwLTEuNDQtLjQtMS40NC0xLjI0VjEwLjQ0czIuMTYsMCwyLjg2LjA2Yy41NSwwLC44NS4xOSwxLjA2LDFsLjIzLDFIMTNMMTIuOSw5Ljk0LDEzLDcuNDFoLS44NWwtLjI4LDEuMTNjLS4xNi43NC0uMjguODQtMSwxLTEsLjEtMi44OS4wOS0yLjg5LjA5WlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImV4cGFuZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMyAyIDE4IDIgMTggNyAxNyA3IDE3IDMgMTMgM1xcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiMiAxMyAzIDEzIDMgMTcgNyAxNyA3IDE4IDIgMThcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTEsOSBMMTcsM1xcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0zLDE3IEw5LDExXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZmFjZWJvb2tcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xMSwxMGgyLjZsMC40LTNIMTFWNS4zYzAtMC45LDAuMi0xLjUsMS41LTEuNUgxNFYxLjFjLTAuMywwLTEtMC4xLTIuMS0wLjFDOS42LDEsOCwyLjQsOCw1djJINS41djNIOHY4aDNWMTB6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZmlsZS1lZGl0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xOC42NSwxLjY4IEMxOC40MSwxLjQ1IDE4LjEwOSwxLjMzIDE3LjgxLDEuMzMgQzE3LjQ5OSwxLjMzIDE3LjIwOSwxLjQ1IDE2Ljk4LDEuNjggTDguOTIsOS43NiBMOCwxMi4zMyBMMTAuNTUsMTEuNDEgTDE4LjY1MSwzLjM0IEMxOS4xMiwyLjg3IDE5LjEyLDIuMTUgMTguNjUsMS42OCBMMTguNjUsMS42OCBMMTguNjUsMS42OCBaXFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIxNi41IDguNDgyIDE2LjUgMTguNSAzLjUgMTguNSAzLjUgMS41IDE0LjIxMSAxLjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmaWxlLXBkZlwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB3aWR0aD1cXFwiMTNcXFwiIGhlaWdodD1cXFwiMTdcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiMS41XFxcIi8+PHBhdGggZD1cXFwiTTE0LjY1IDExLjY3Yy0uNDguMy0xLjM3LS4xOS0xLjc5LS4zN2E0LjY1IDQuNjUgMCAwIDEgMS40OS4wNmMuMzUuMS4zNi4yOC4zLjMxem0tNi4zLjA2bC40My0uNzlhMTQuNyAxNC43IDAgMCAwIC43NS0xLjY0IDUuNDggNS40OCAwIDAgMCAxLjI1IDEuNTVsLjIuMTVhMTYuMzYgMTYuMzYgMCAwIDAtMi42My43M3pNOS41IDUuMzJjLjIgMCAuMzIuNS4zMi45N2ExLjk5IDEuOTkgMCAwIDEtLjIzIDEuMDQgNS4wNSA1LjA1IDAgMCAxLS4xNy0xLjNzMC0uNzEuMDgtLjcxem0tMy45IDlhNC4zNSA0LjM1IDAgMCAxIDEuMjEtMS40NmwuMjQtLjIyYTQuMzUgNC4zNSAwIDAgMS0xLjQ2IDEuNjh6bTkuMjMtMy4zYTIuMDUgMi4wNSAwIDAgMC0xLjMyLS4zIDExLjA3IDExLjA3IDAgMCAwLTEuNTguMTEgNC4wOSA0LjA5IDAgMCAxLS43NC0uNSA1LjM5IDUuMzkgMCAwIDEtMS4zMi0yLjA2IDEwLjM3IDEwLjM3IDAgMCAwIC4yOC0yLjYyIDEuODMgMS44MyAwIDAgMC0uMDctLjI1LjU3LjU3IDAgMCAwLS41Mi0uNEg5LjRhLjU5LjU5IDAgMCAwLS42LjM4IDYuOTUgNi45NSAwIDAgMCAuMzcgMy4xNGMtLjI2LjYzLTEgMi4xMi0xIDIuMTItLjMuNTgtLjU3IDEuMDgtLjgyIDEuNWwtLjguNDRBMy4xMSAzLjExIDAgMCAwIDUgMTQuMTZhLjM5LjM5IDAgMCAwIC4xNS40MmwuMjQuMTNjMS4xNS41NiAyLjI4LTEuNzQgMi42Ni0yLjQyYTIzLjEgMjMuMSAwIDAgMSAzLjU5LS44NSA0LjU2IDQuNTYgMCAwIDAgMi45MS44LjUuNSAwIDAgMCAuMy0uMjEgMS4xIDEuMSAwIDAgMCAuMTItLjc1Ljg0Ljg0IDAgMCAwLS4xNC0uMjV6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZmlsZS10ZXh0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHdpZHRoPVxcXCIxM1xcXCIgaGVpZ2h0PVxcXCIxN1xcXCIgeD1cXFwiMy41XFxcIiB5PVxcXCIxLjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI2XFxcIiB4Mj1cXFwiMTJcXFwiIHkxPVxcXCIxMi41XFxcIiB5Mj1cXFwiMTIuNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjZcXFwiIHgyPVxcXCIxNFxcXCIgeTE9XFxcIjguNVxcXCIgeTI9XFxcIjguNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjZcXFwiIHgyPVxcXCIxNFxcXCIgeTE9XFxcIjYuNVxcXCIgeTI9XFxcIjYuNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjZcXFwiIHgyPVxcXCIxNFxcXCIgeTE9XFxcIjEwLjVcXFwiIHkyPVxcXCIxMC41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZmlsZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIzLjVcXFwiIHk9XFxcIjEuNVxcXCIgd2lkdGg9XFxcIjEzXFxcIiBoZWlnaHQ9XFxcIjE3XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZmxpY2tyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCI1LjVcXFwiIGN5PVxcXCI5LjVcXFwiIHI9XFxcIjMuNVxcXCIvPjxjaXJjbGUgY3g9XFxcIjE0LjVcXFwiIGN5PVxcXCI5LjVcXFwiIHI9XFxcIjMuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZvbGRlclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjkuNSA1LjUgOC41IDMuNSAxLjUgMy41IDEuNSAxNi41IDE4LjUgMTYuNSAxOC41IDUuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZvcndhcmRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0yLjQ3LDEzLjExIEM0LjAyLDEwLjAyIDYuMjcsNy44NSA5LjA0LDYuNjEgQzkuNDgsNi40MSAxMC4yNyw2LjEzIDExLDUuOTEgTDExLDIgTDE4Ljg5LDkgTDExLDE2IEwxMSwxMi4xMyBDOS4yNSwxMi40NyA3LjU4LDEzLjE5IDYuMDIsMTQuMjUgQzMuMDMsMTYuMjggMS42MywxOC41NCAxLjYzLDE4LjU0IEMxLjYzLDE4LjU0IDEuMzgsMTUuMjggMi40NywxMy4xMSBMMi40NywxMy4xMSBaIE01LjMsMTMuNTMgQzYuOTIsMTIuNCA5LjA0LDExLjQgMTIsMTAuOTIgTDEyLDEzLjYzIEwxNy4zNiw5IEwxMiw0LjI1IEwxMiw2LjggQzExLjcxLDYuODYgMTAuODYsNy4wMiA5LjY3LDcuNDkgQzYuNzksOC42NSA0LjU4LDEwLjk2IDMuNDksMTMuMDggQzMuMTgsMTMuNyAyLjY4LDE0Ljg3IDIuNDksMTYgQzMuMjgsMTUuMDUgNC40LDE0LjE1IDUuMywxMy41MyBMNS4zLDEzLjUzIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmb3Vyc3F1YXJlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTUuMjMsMiBDMTUuOTYsMiAxNi40LDIuNDEgMTYuNSwyLjg2IEMxNi41NywzLjE1IDE2LjU2LDMuNDQgMTYuNTEsMy43MyBDMTYuNDYsNC4wNCAxNC44NiwxMS43MiAxNC43NSwxMi4wMyBDMTQuNTYsMTIuNTYgMTQuMTYsMTIuODIgMTMuNjEsMTIuODMgQzEzLjAzLDEyLjg0IDExLjA5LDEyLjUxIDEwLjY5LDEzIEMxMC4zOCwxMy4zOCA3Ljc5LDE2LjM5IDYuODEsMTcuNTMgQzYuNjEsMTcuNzYgNi40LDE3Ljk2IDYuMDgsMTcuOTkgQzUuNjgsMTguMDQgNS4yOSwxNy44NyA1LjE3LDE3LjQ1IEM1LjEyLDE3LjI4IDUuMSwxNy4wOSA1LjEsMTYuOTEgQzUuMSwxMi40IDQuODYsNy44MSA1LjExLDMuMzEgQzUuMTcsMi41IDUuODEsMi4xMiA2LjUzLDIgTDE1LjIzLDIgTDE1LjIzLDIgWiBNOS43NiwxMS40MiBDOS45NCwxMS4xOSAxMC4xNywxMS4xIDEwLjQ1LDExLjEgTDEyLjg2LDExLjEgQzEzLjEyLDExLjEgMTMuMzEsMTAuOTQgMTMuMzYsMTAuNjkgQzEzLjM3LDEwLjY0IDEzLjYyLDkuNDEgMTMuNzQsOC44MyBDMTMuODEsOC41MiAxMy41Myw4LjI4IDEzLjI3LDguMjggQzEyLjM1LDguMjkgMTEuNDIsOC4yOCAxMC41LDguMjggQzkuODQsOC4yOCA5LjgzLDcuNjkgOS44Miw3LjIxIEM5LjgsNi44NSAxMC4xMyw2LjU1IDEwLjUsNi41NSBDMTEuNTksNi41NiAxMi42Nyw2LjU1IDEzLjc2LDYuNTUgQzE0LjAzLDYuNTUgMTQuMjMsNi40IDE0LjI4LDYuMTQgQzE0LjM0LDUuODcgMTQuNjcsNC4yOSAxNC42Nyw0LjI5IEMxNC42Nyw0LjI5IDE0LjgyLDMuNzQgMTQuMTksMy43NCBMNy4zNCwzLjc0IEM3LDMuNzUgNi44NCw0LjAyIDYuODQsNC4zMyBDNi44NCw3LjU4IDYuODUsMTQuOTUgNi44NSwxNC45OSBDNi44NywxNSA4Ljg5LDEyLjUxIDkuNzYsMTEuNDIgTDkuNzYsMTEuNDIgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZ1dHVyZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIHBvaW50cz1cXFwiMTkgMiAxOCAyIDE4IDYgMTQgNiAxNCA3IDE5IDcgMTkgMlxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xOCw2LjU0OCBDMTYuNzA5LDMuMjkgMTMuMzU0LDEgOS42LDEgQzQuNiwxIDAuNiw1IDAuNiwxMCBDMC42LDE1IDQuNiwxOSA5LjYsMTkgQzE0LjYsMTkgMTguNiwxNSAxOC42LDEwXFxcIi8+PHJlY3QgeD1cXFwiOVxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiN1xcXCIvPjxwYXRoIGQ9XFxcIk0xMy4wMTgsMTQuMTk3IEw5LjQ0NSwxMC42MjVcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJnaXQtYnJhbmNoXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIGN4PVxcXCI3XFxcIiBjeT1cXFwiM1xcXCIgcj1cXFwiMlxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgY3g9XFxcIjE0XFxcIiBjeT1cXFwiNlxcXCIgcj1cXFwiMlxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgY3g9XFxcIjdcXFwiIGN5PVxcXCIxN1xcXCIgcj1cXFwiMlxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIiBkPVxcXCJNMTQsOCBDMTQsMTAuNDEgMTIuNDMsMTAuODcgMTAuNTYsMTEuMjUgQzkuMDksMTEuNTQgNywxMi4wNiA3LDE1IEw3LDVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJnaXQtZm9ya1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBjeD1cXFwiNS43OVxcXCIgY3k9XFxcIjIuNzlcXFwiIHI9XFxcIjEuNzlcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIGN4PVxcXCIxNC4xOVxcXCIgY3k9XFxcIjIuNzlcXFwiIHI9XFxcIjEuNzlcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIGN4PVxcXCIxMC4wM1xcXCIgY3k9XFxcIjE2Ljc5XFxcIiByPVxcXCIxLjc5XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjJcXFwiIGQ9XFxcIk01Ljc5LDQuNTcgTDUuNzksNi41NiBDNS43OSw5LjE5IDEwLjAzLDEwLjIyIDEwLjAzLDEzLjMxIEMxMC4wMywxNC44NiAxMC4wNCwxNC41NSAxMC4wNCwxNC41NSBDMTAuMDQsMTQuMzcgMTAuMDQsMTQuODYgMTAuMDQsMTMuMzEgQzEwLjA0LDEwLjIyIDE0LjIsOS4xOSAxNC4yLDYuNTYgTDE0LjIsNC41N1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImdpdGh1Yi1hbHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xMCwwLjUgQzQuNzUsMC41IDAuNSw0Ljc2IDAuNSwxMC4wMSBDMC41LDE1LjI2IDQuNzUsMTkuNTEgMTAsMTkuNTEgQzE1LjI0LDE5LjUxIDE5LjUsMTUuMjYgMTkuNSwxMC4wMSBDMTkuNSw0Ljc2IDE1LjI1LDAuNSAxMCwwLjUgTDEwLDAuNSBaIE0xMi44MSwxNy42OSBDMTIuODEsMTcuNjkgMTIuODEsMTcuNyAxMi43OSwxNy42OSBDMTIuNDcsMTcuNzUgMTIuMzUsMTcuNTkgMTIuMzUsMTcuMzYgTDEyLjM1LDE2LjE3IEMxMi4zNSwxNS40NSAxMi4wOSwxNC45MiAxMS41OCwxNC41NiBDMTIuMiwxNC41MSAxMi43NywxNC4zOSAxMy4yNiwxNC4yMSBDMTMuODcsMTMuOTggMTQuMzYsMTMuNjkgMTQuNzQsMTMuMjkgQzE1LjQyLDEyLjU5IDE1Ljc2LDExLjU1IDE1Ljc2LDEwLjE3IEMxNS43Niw5LjI1IDE1LjQ1LDguNDYgMTQuODMsNy44IEMxNS4xLDcuMDggMTUuMDcsNi4yOSAxNC43NSw1LjQ0IEwxNC41MSw1LjQyIEMxNC4zNCw1LjQgMTQuMDYsNS40NiAxMy42Nyw1LjYxIEMxMy4yNSw1Ljc4IDEyLjc5LDYuMDMgMTIuMzEsNi4zNSBDMTEuNTUsNi4xNiAxMC44MSw2LjA1IDEwLjA5LDYuMDUgQzkuMzYsNi4wNSA4LjYxLDYuMTUgNy44OCw2LjM1IEM3LjI4LDUuOTYgNi43NSw1LjY4IDYuMjYsNS41NCBDNi4wNyw1LjQ3IDUuOSw1LjQ0IDUuNzgsNS40NCBMNS40Miw1LjQ0IEM1LjA2LDYuMjkgNS4wNCw3LjA4IDUuMzIsNy44IEM0LjcsOC40NiA0LjQsOS4yNSA0LjQsMTAuMTcgQzQuNCwxMS45NCA0Ljk2LDEzLjE2IDYuMDgsMTMuODQgQzYuNTMsMTQuMTMgNy4wNSwxNC4zMiA3LjY5LDE0LjQzIEM4LjAzLDE0LjUgOC4zMiwxNC41NCA4LjU1LDE0LjU1IEM4LjA3LDE0Ljg5IDcuODIsMTUuNDIgNy44MiwxNi4xNiBMNy44MiwxNy41MSBDNy44LDE3LjY5IDcuNywxNy44IDcuNTEsMTcuOCBDNC4yMSwxNi43NCAxLjgyLDEzLjY1IDEuODIsMTAuMDEgQzEuODIsNS41IDUuNDksMS44MyAxMCwxLjgzIEMxNC41LDEuODMgMTguMTcsNS41IDE4LjE3LDEwLjAxIEMxOC4xOCwxMy41MyAxNS45NCwxNi41NCAxMi44MSwxNy42OSBMMTIuODEsMTcuNjkgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImdpdGh1YlwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEwLDEgQzUuMDMsMSAxLDUuMDMgMSwxMCBDMSwxMy45OCAzLjU4LDE3LjM1IDcuMTYsMTguNTQgQzcuNjEsMTguNjIgNy43NywxOC4zNCA3Ljc3LDE4LjExIEM3Ljc3LDE3LjkgNy43NiwxNy4zMyA3Ljc2LDE2LjU4IEM1LjI2LDE3LjEyIDQuNzMsMTUuMzcgNC43MywxNS4zNyBDNC4zMiwxNC4zMyAzLjczLDE0LjA1IDMuNzMsMTQuMDUgQzIuOTEsMTMuNSAzLjc5LDEzLjUgMy43OSwxMy41IEM0LjY5LDEzLjU2IDUuMTcsMTQuNDMgNS4xNywxNC40MyBDNS45NywxNS44IDcuMjgsMTUuNDEgNy43OSwxNS4xOCBDNy44NywxNC42IDguMSwxNC4yIDguMzYsMTMuOTggQzYuMzYsMTMuNzUgNC4yNiwxMi45OCA0LjI2LDkuNTMgQzQuMjYsOC41NSA0LjYxLDcuNzQgNS4xOSw3LjExIEM1LjEsNi44OCA0Ljc5LDUuOTcgNS4yOCw0LjczIEM1LjI4LDQuNzMgNi4wNCw0LjQ5IDcuNzUsNS42NSBDOC40Nyw1LjQ1IDkuMjQsNS4zNSAxMCw1LjM1IEMxMC43Niw1LjM1IDExLjUzLDUuNDUgMTIuMjUsNS42NSBDMTMuOTcsNC40OCAxNC43Miw0LjczIDE0LjcyLDQuNzMgQzE1LjIxLDUuOTcgMTQuOSw2Ljg4IDE0LjgxLDcuMTEgQzE1LjM5LDcuNzQgMTUuNzMsOC41NCAxNS43Myw5LjUzIEMxNS43MywxMi45OSAxMy42MywxMy43NSAxMS42MiwxMy45NyBDMTEuOTQsMTQuMjUgMTIuMjMsMTQuOCAxMi4yMywxNS42NCBDMTIuMjMsMTYuODQgMTIuMjIsMTcuODEgMTIuMjIsMTguMTEgQzEyLjIyLDE4LjM1IDEyLjM4LDE4LjYzIDEyLjg0LDE4LjU0IEMxNi40MiwxNy4zNSAxOSwxMy45OCAxOSwxMCBDMTksNS4wMyAxNC45NywxIDEwLDEgTDEwLDEgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImdpdHRlclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiMy41XFxcIiB5PVxcXCIxXFxcIiB3aWR0aD1cXFwiMS41MzFcXFwiIGhlaWdodD1cXFwiMTEuNDcxXFxcIi8+PHJlY3QgeD1cXFwiNy4zMjRcXFwiIHk9XFxcIjQuMDU5XFxcIiB3aWR0aD1cXFwiMS41MjlcXFwiIGhlaWdodD1cXFwiMTUuMjk0XFxcIi8+PHJlY3QgeD1cXFwiMTEuMTQ4XFxcIiB5PVxcXCI0LjA1OVxcXCIgd2lkdGg9XFxcIjEuNTI3XFxcIiBoZWlnaHQ9XFxcIjE1LjI5NFxcXCIvPjxyZWN0IHg9XFxcIjE0Ljk3MVxcXCIgeT1cXFwiNC4wNTlcXFwiIHdpZHRoPVxcXCIxLjUyOVxcXCIgaGVpZ2h0PVxcXCI4LjQxMlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImdvb2dsZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE3Ljg2LDkuMDkgQzE4LjQ2LDEyLjEyIDE3LjE0LDE2LjA1IDEzLjgxLDE3LjU2IEM5LjQ1LDE5LjUzIDQuMTMsMTcuNjggMi40NywxMi44NyBDMC42OCw3LjY4IDQuMjIsMi40MiA5LjUsMi4wMyBDMTEuNTcsMS44OCAxMy40MiwyLjM3IDE1LjA1LDMuNjUgQzE1LjIyLDMuNzggMTUuMzcsMy45MyAxNS42MSw0LjE0IEMxNC45LDQuODEgMTQuMjMsNS40NSAxMy41LDYuMTQgQzEyLjI3LDUuMDggMTAuODQsNC43MiA5LjI4LDQuOTggQzguMTIsNS4xNyA3LjE2LDUuNzYgNi4zNyw2LjYzIEM0Ljg4LDguMjcgNC42MiwxMC44NiA1Ljc2LDEyLjgyIEM2Ljk1LDE0Ljg3IDkuMTcsMTUuOCAxMS41NywxNS4yNSBDMTMuMjcsMTQuODcgMTQuNzYsMTMuMzMgMTQuODksMTEuNzUgTDEwLjUxLDExLjc1IEwxMC41MSw5LjA5IEwxNy44Niw5LjA5IEwxNy44Niw5LjA5IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJncmlkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCIyXFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiOFxcXCIgeT1cXFwiMlxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjE0XFxcIiB5PVxcXCIyXFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiOFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjhcXFwiIHk9XFxcIjhcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCIxNFxcXCIgeT1cXFwiOFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjE0XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiOFxcXCIgeT1cXFwiMTRcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCIxNFxcXCIgeT1cXFwiMTRcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJoYXBweVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBjeD1cXFwiMTNcXFwiIGN5PVxcXCI3XFxcIiByPVxcXCIxXFxcIi8+PGNpcmNsZSBjeD1cXFwiN1xcXCIgY3k9XFxcIjdcXFwiIHI9XFxcIjFcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjguNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTE0LjYsMTEuNCBDMTMuOSwxMy4zIDEyLjEsMTQuNSAxMCwxNC41IEM3LjksMTQuNSA2LjEsMTMuMyA1LjQsMTEuNFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImhhc2h0YWdcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNS40MzEsOCBMMTUuNjYxLDcgTDEyLjkxMSw3IEwxMy44MzEsMyBMMTIuOTAxLDMgTDExLjk4LDcgTDkuMjksNyBMMTAuMjEsMyBMOS4yODEsMyBMOC4zNjEsNyBMNS4yMyw3IEw1LDggTDguMTMsOCBMNy4yMSwxMiBMNC4yMywxMiBMNCwxMyBMNi45OCwxMyBMNi4wNjEsMTcgTDYuOTkxLDE3IEw3LjkxMSwxMyBMMTAuNjAxLDEzIEw5LjY4MSwxNyBMMTAuNjExLDE3IEwxMS41MzEsMTMgTDE0LjQzMSwxMyBMMTQuNjYxLDEyIEwxMS43NiwxMiBMMTIuNjgxLDggTDE1LjQzMSw4IFogTTEwLjgzMSwxMiBMOC4xNDEsMTIgTDkuMDYxLDggTDExLjc1LDggTDEwLjgzMSwxMiBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaGVhcnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBkPVxcXCJNMTAsNCBDMTAsNCA4LjEsMiA1Ljc0LDIgQzMuMzgsMiAxLDMuNTUgMSw2LjczIEMxLDguODQgMi42NywxMC40NCAyLjY3LDEwLjQ0IEwxMCwxOCBMMTcuMzMsMTAuNDQgQzE3LjMzLDEwLjQ0IDE5LDguODQgMTksNi43MyBDMTksMy41NSAxNi42MiwyIDE0LjI2LDIgQzExLjksMiAxMCw0IDEwLDQgTDEwLDQgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImhpc3RvcnlcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjEgMiAyIDIgMiA2IDYgNiA2IDcgMSA3IDEgMlxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0yLjEsNi41NDggQzMuMzkxLDMuMjkgNi43NDYsMSAxMC41LDEgQzE1LjUsMSAxOS41LDUgMTkuNSwxMCBDMTkuNSwxNSAxNS41LDE5IDEwLjUsMTkgQzUuNSwxOSAxLjUsMTUgMS41LDEwXFxcIi8+PHJlY3QgeD1cXFwiOVxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiN1xcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMy4wMTgsMTQuMTk3IEw5LjQ0NSwxMC42MjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJob21lXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjE4LjY1IDExLjM1IDEwIDIuNzEgMS4zNSAxMS4zNSAwLjY1IDEwLjY1IDEwIDEuMjkgMTkuMzUgMTAuNjVcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjE1IDQgMTggNCAxOCA3IDE3IDcgMTcgNSAxNSA1XFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCIzIDExIDQgMTEgNCAxOCA3IDE4IDcgMTIgMTIgMTIgMTIgMTggMTYgMTggMTYgMTEgMTcgMTEgMTcgMTkgMTEgMTkgMTEgMTMgOCAxMyA4IDE5IDMgMTlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJpbWFnZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBjeD1cXFwiMTYuMVxcXCIgY3k9XFxcIjYuMVxcXCIgcj1cXFwiMS4xXFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIuNVxcXCIgeT1cXFwiMi41XFxcIiB3aWR0aD1cXFwiMTlcXFwiIGhlaWdodD1cXFwiMTVcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDFcXFwiIHBvaW50cz1cXFwiNCwxMyA4LDkgMTMsMTRcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDFcXFwiIHBvaW50cz1cXFwiMTEsMTIgMTIuNSwxMC41IDE2LDE0XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaW5mb1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEyLjEzLDExLjU5IEMxMS45NywxMi44NCAxMC4zNSwxNC4xMiA5LjEsMTQuMTYgQzYuMTcsMTQuMiA5Ljg5LDkuNDYgOC43NCw4LjM3IEM5LjMsOC4xNiAxMC42Miw3LjgzIDEwLjYyLDguODEgQzEwLjYyLDkuNjMgMTAuMTIsMTAuNTUgOS44OCwxMS4zMiBDOC42NiwxNS4xNiAxMi4xMywxMS4xNSAxMi4xNCwxMS4xOCBDMTIuMTYsMTEuMjEgMTIuMTYsMTEuMzUgMTIuMTMsMTEuNTkgQzEyLjA4LDExLjk1IDEyLjE2LDExLjM1IDEyLjEzLDExLjU5IEwxMi4xMywxMS41OSBaIE0xMS41Niw1LjY3IEMxMS41Niw2LjY3IDkuMzYsNy4xNSA5LjM2LDYuMDMgQzkuMzYsNSAxMS41Niw0LjU0IDExLjU2LDUuNjcgTDExLjU2LDUuNjcgWlxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJpbnN0YWdyYW1cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xMy41NSwxSDYuNDZDMy40NSwxLDEsMy40NCwxLDYuNDR2Ny4xMmMwLDMsMi40NSw1LjQ0LDUuNDYsNS40NGg3LjA4YzMuMDIsMCw1LjQ2LTIuNDQsNS40Ni01LjQ0VjYuNDQgQzE5LjAxLDMuNDQsMTYuNTYsMSwxMy41NSwxeiBNMTcuNSwxNGMwLDEuOTMtMS41NywzLjUtMy41LDMuNUg2Yy0xLjkzLDAtMy41LTEuNTctMy41LTMuNVY2YzAtMS45MywxLjU3LTMuNSwzLjUtMy41aDggYzEuOTMsMCwzLjUsMS41NywzLjUsMy41VjE0elxcXCIvPjxjaXJjbGUgY3g9XFxcIjE0Ljg3XFxcIiBjeT1cXFwiNS4yNlxcXCIgcj1cXFwiMS4wOVxcXCIvPjxwYXRoIGQ9XFxcIk0xMC4wMyw1LjQ1Yy0yLjU1LDAtNC42MywyLjA2LTQuNjMsNC42YzAsMi41NSwyLjA3LDQuNjEsNC42Myw0LjYxYzIuNTYsMCw0LjYzLTIuMDYxLDQuNjMtNC42MSBDMTQuNjUsNy41MSwxMi41OCw1LjQ1LDEwLjAzLDUuNDVMMTAuMDMsNS40NUwxMC4wMyw1LjQ1eiBNMTAuMDgsMTNjLTEuNjYsMC0zLTEuMzQtMy0yLjk5YzAtMS42NSwxLjM0LTIuOTksMy0yLjk5czMsMS4zNCwzLDIuOTkgQzEzLjA4LDExLjY2LDExLjc0LDEzLDEwLjA4LDEzTDEwLjA4LDEzTDEwLjA4LDEzelxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIml0YWxpY1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEyLjYzLDUuNDggTDEwLjE1LDE0LjUyIEMxMCwxNS4wOCAxMC4zNywxNS4yNSAxMS45MiwxNS4zIEwxMS43MiwxNiBMNiwxNiBMNi4yLDE1LjMxIEM3Ljc4LDE1LjI2IDguMTksMTUuMDkgOC4zNCwxNC41MyBMMTAuODIsNS40OSBDMTAuOTcsNC45MiAxMC42Myw0Ljc2IDkuMDksNC43MSBMOS4yOCw0IEwxNSw0IEwxNC44MSw0LjY5IEMxMy4yMyw0Ljc1IDEyLjc4LDQuOTEgMTIuNjMsNS40OCBMMTIuNjMsNS40OCBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiam9vbWxhXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNy44LDEzLjRsMS43LTEuN0w1LjksOGMtMC42LTAuNS0wLjYtMS41LDAtMmMwLjYtMC42LDEuNC0wLjYsMiwwbDEuNy0xLjdjLTEtMS0yLjMtMS4zLTMuNi0xQzUuOCwyLjIsNC44LDEuNCwzLjcsMS40IGMtMS4zLDAtMi4zLDEtMi4zLDIuM2MwLDEuMSwwLjgsMiwxLjgsMi4zYy0wLjQsMS4zLTAuMSwyLjgsMSwzLjhMNy44LDEzLjRMNy44LDEzLjR6XFxcIi8+PHBhdGggZD1cXFwiTTEwLjIsNC4zYzEtMSwyLjUtMS40LDMuOC0xYzAuMi0xLjEsMS4xLTIsMi4zLTJjMS4zLDAsMi4zLDEsMi4zLDIuM2MwLDEuMi0wLjksMi4yLTIsMi4zYzAuNCwxLjMsMCwyLjgtMSwzLjhMMTMuOSw4IGMwLjYtMC41LDAuNi0xLjUsMC0yYy0wLjUtMC42LTEuNS0wLjYtMiwwTDguMiw5LjdMNi41LDhcXFwiLz48cGF0aCBkPVxcXCJNMTQuMSwxNi44Yy0xLjMsMC40LTIuOCwwLjEtMy44LTFsMS43LTEuN2MwLjYsMC42LDEuNSwwLjYsMiwwYzAuNS0wLjYsMC42LTEuNSwwLTJsLTMuNy0zLjdMMTIsNi43bDMuNywzLjcgYzEsMSwxLjMsMi40LDEsMy42YzEuMSwwLjIsMiwxLjEsMiwyLjNjMCwxLjMtMSwyLjMtMi4zLDIuM0MxNS4yLDE4LjYsMTQuMywxNy44LDE0LjEsMTYuOFxcXCIvPjxwYXRoIGQ9XFxcIk0xMy4yLDEyLjJsLTMuNywzLjdjLTEsMS0yLjQsMS4zLTMuNiwxYy0wLjIsMS0xLjIsMS44LTIuMiwxLjhjLTEuMywwLTIuMy0xLTIuMy0yLjNjMC0xLjEsMC44LTIsMS44LTIuMyBjLTAuMy0xLjMsMC0yLjcsMS0zLjdsMS43LDEuN2MtMC42LDAuNi0wLjYsMS41LDAsMmMwLjYsMC42LDEuNCwwLjYsMiwwbDMuNy0zLjdcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJsYXB0b3BcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHk9XFxcIjE2XFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMi41XFxcIiB5PVxcXCI0LjVcXFwiIHdpZHRoPVxcXCIxNVxcXCIgaGVpZ2h0PVxcXCIxMFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImxpZmVzYXZlclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEwLDAuNSBDNC43NiwwLjUgMC41LDQuNzYgMC41LDEwIEMwLjUsMTUuMjQgNC43NiwxOS41IDEwLDE5LjUgQzE1LjI0LDE5LjUgMTkuNSwxNS4yNCAxOS41LDEwIEMxOS41LDQuNzYgMTUuMjQsMC41IDEwLDAuNSBMMTAsMC41IFogTTEwLDEuNSBDMTEuNDksMS41IDEyLjg5LDEuODggMTQuMTEsMi41NiBMMTEuODUsNC44MiBDMTEuMjcsNC42MSAxMC42NSw0LjUgMTAsNC41IEM5LjIxLDQuNSA4LjQ3LDQuNjcgNy43OSw0Ljk2IEw1LjU4LDIuNzUgQzYuODcsMS45NSA4LjM4LDEuNSAxMCwxLjUgTDEwLDEuNSBaIE00Ljk2LDcuOCBDNC42Nyw4LjQ4IDQuNSw5LjIxIDQuNSwxMCBDNC41LDEwLjY1IDQuNjEsMTEuMjcgNC44MywxMS44NSBMMi41NiwxNC4xMSBDMS44OCwxMi44OSAxLjUsMTEuNDkgMS41LDEwIEMxLjUsOC4zOCAxLjk1LDYuODcgMi43NSw1LjU4IEw0Ljk2LDcuNzkgTDQuOTYsNy44IEw0Ljk2LDcuOCBaIE0xMCwxOC41IEM4LjI1LDE4LjUgNi42MiwxNy45NyA1LjI3LDE3LjA2IEw3LjQ2LDE0Ljg3IEM4LjIyLDE1LjI3IDkuMDgsMTUuNSAxMCwxNS41IEMxMC43OSwxNS41IDExLjUzLDE1LjMzIDEyLjIxLDE1LjA0IEwxNC40MiwxNy4yNSBDMTMuMTMsMTguMDUgMTEuNjIsMTguNSAxMCwxOC41IEwxMCwxOC41IFogTTEwLDE0LjUgQzcuNTIsMTQuNSA1LjUsMTIuNDggNS41LDEwIEM1LjUsNy41MiA3LjUyLDUuNSAxMCw1LjUgQzEyLjQ4LDUuNSAxNC41LDcuNTIgMTQuNSwxMCBDMTQuNSwxMi40OCAxMi40OCwxNC41IDEwLDE0LjUgTDEwLDE0LjUgWiBNMTUuMDQsMTIuMjEgQzE1LjMzLDExLjUzIDE1LjUsMTAuNzkgMTUuNSwxMCBDMTUuNSw5LjA4IDE1LjI3LDguMjIgMTQuODcsNy40NiBMMTcuMDYsNS4yNyBDMTcuOTcsNi42MiAxOC41LDguMjUgMTguNSwxMCBDMTguNSwxMS42MiAxOC4wNSwxMy4xMyAxNy4yNSwxNC40MiBMMTUuMDQsMTIuMjEgTDE1LjA0LDEyLjIxIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJsaW5rXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTAuNjI1LDEyLjM3NSBMNy41MjUsMTUuNDc1IEM2LjgyNSwxNi4xNzUgNS45MjUsMTYuMTc1IDUuMjI1LDE1LjQ3NSBMNC41MjUsMTQuNzc1IEMzLjgyNSwxNC4wNzQgMy44MjUsMTMuMTc1IDQuNTI1LDEyLjQ3NSBMNy42MjUsOS4zNzVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNOS4zMjUsNy4zNzUgTDEyLjQyNSw0LjI3NSBDMTMuMTI1LDMuNTc1IDE0LjAyNSwzLjU3NSAxNC43MjQsNC4yNzUgTDE1LjQyNSw0Ljk3NSBDMTYuMTI1LDUuNjc1IDE2LjEyNSw2LjU3NSAxNS40MjUsNy4yNzUgTDEyLjMyNSwxMC4zNzVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNNy45MjUsMTEuODc1IEwxMS45MjUsNy45NzVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJsaW5rZWRpblwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTUuNzcsMTcuODkgTDUuNzcsNy4xNyBMMi4yMSw3LjE3IEwyLjIxLDE3Ljg5IEw1Ljc3LDE3Ljg5IEw1Ljc3LDE3Ljg5IFogTTMuOTksNS43MSBDNS4yMyw1LjcxIDYuMDEsNC44OSA2LjAxLDMuODYgQzUuOTksMi44IDUuMjQsMiA0LjAyLDIgQzIuOCwyIDIsMi44IDIsMy44NSBDMiw0Ljg4IDIuNzcsNS43IDMuOTcsNS43IEwzLjk5LDUuNyBMMy45OSw1LjcxIEwzLjk5LDUuNzEgWlxcXCIvPjxwYXRoIGQ9XFxcIk03Ljc1LDE3Ljg5IEwxMS4zMSwxNy44OSBMMTEuMzEsMTEuOSBDMTEuMzEsMTEuNTggMTEuMzMsMTEuMjYgMTEuNDMsMTEuMDMgQzExLjY5LDEwLjM5IDEyLjI3LDkuNzMgMTMuMjYsOS43MyBDMTQuNTUsOS43MyAxNS4wNiwxMC43MSAxNS4wNiwxMi4xNSBMMTUuMDYsMTcuODkgTDE4LjYyLDE3Ljg5IEwxOC42MiwxMS43NCBDMTguNjIsOC40NSAxNi44Niw2LjkyIDE0LjUyLDYuOTIgQzEyLjYsNi45MiAxMS43NSw3Ljk5IDExLjI4LDguNzMgTDExLjMsOC43MyBMMTEuMyw3LjE3IEw3Ljc1LDcuMTcgQzcuNzksOC4xNyA3Ljc1LDE3Ljg5IDcuNzUsMTcuODkgTDcuNzUsMTcuODkgTDcuNzUsMTcuODkgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImxpc3RcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjZcXFwiIHk9XFxcIjRcXFwiIHdpZHRoPVxcXCIxMlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiNlxcXCIgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjEyXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCI2XFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjEyXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiMlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjJcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjE0XFxcIiB3aWR0aD1cXFwiMlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibG9jYXRpb25cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAxXFxcIiBkPVxcXCJNMTAsMC41IEM2LjQxLDAuNSAzLjUsMy4zOSAzLjUsNi45OCBDMy41LDExLjgzIDEwLDE5IDEwLDE5IEMxMCwxOSAxNi41LDExLjgzIDE2LjUsNi45OCBDMTYuNSwzLjM5IDEzLjU5LDAuNSAxMCwwLjUgTDEwLDAuNSBaXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjYuOFxcXCIgcj1cXFwiMi4zXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibG9ja1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBoZWlnaHQ9XFxcIjEwXFxcIiB3aWR0aD1cXFwiMTNcXFwiIHk9XFxcIjguNVxcXCIgeD1cXFwiMy41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNNi41LDggTDYuNSw0Ljg4IEM2LjUsMy4wMSA4LjA3LDEuNSAxMCwxLjUgQzExLjkzLDEuNSAxMy41LDMuMDEgMTMuNSw0Ljg4IEwxMy41LDhcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtYWlsXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjEuNCw2LjUgMTAsMTEgMTguNiw2LjVcXFwiLz48cGF0aCBkPVxcXCJNIDEsNCAxLDE2IDE5LDE2IDE5LDQgMSw0IFogTSAxOCwxNSAyLDE1IDIsNSAxOCw1IDE4LDE1IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtZW51XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiMTZcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjlcXFwiIHdpZHRoPVxcXCIxNlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiMTRcXFwiIHdpZHRoPVxcXCIxNlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibWljcm9waG9uZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiMTBcXFwiIHgyPVxcXCIxMFxcXCIgeTE9XFxcIjE2LjQ0XFxcIiB5Mj1cXFwiMTguNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjdcXFwiIHgyPVxcXCIxM1xcXCIgeTE9XFxcIjE4LjVcXFwiIHkyPVxcXCIxOC41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEzLjUgNC44OXY1Ljg3YTMuNSAzLjUgMCAwIDEtNyAwVjQuODlhMy41IDMuNSAwIDAgMSA3IDB6XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE1LjUgMTAuMzZWMTFhNS41IDUuNSAwIDAgMS0xMSAwdi0uNlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1pbnVzLWNpcmNsZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiOS41XFxcIiBjeT1cXFwiOS41XFxcIiByPVxcXCI5XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiNVxcXCIgeTE9XFxcIjkuNVxcXCIgeDI9XFxcIjE0XFxcIiB5Mj1cXFwiOS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibWludXNcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IGhlaWdodD1cXFwiMVxcXCIgd2lkdGg9XFxcIjE4XFxcIiB5PVxcXCI5XFxcIiB4PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibW9yZS12ZXJ0aWNhbFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBjeD1cXFwiMTBcXFwiIGN5PVxcXCIzXFxcIiByPVxcXCIyXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiMlxcXCIvPjxjaXJjbGUgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTdcXFwiIHI9XFxcIjJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtb3JlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIzXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjJcXFwiLz48Y2lyY2xlIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCIyXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTdcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiMlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1vdmVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiNCw1IDEsNSAxLDkgMiw5IDIsNiA0LDZcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjEsMTYgMiwxNiAyLDE4IDQsMTggNCwxOSAxLDE5XFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCIxNCwxNiAxNCwxOSAxMSwxOSAxMSwxOCAxMywxOCAxMywxNlxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiNS41XFxcIiB5PVxcXCIxLjVcXFwiIHdpZHRoPVxcXCIxM1xcXCIgaGVpZ2h0PVxcXCIxM1xcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjExXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiNlxcXCIgeT1cXFwiMThcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJudXRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIyLjUsNS43IDEwLDEuMyAxNy41LDUuNyAxNy41LDE0LjMgMTAsMTguNyAyLjUsMTQuM1xcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiMy41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGFnZWtpdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIzLDEgMTcsMSAxNywxNiAxMCwxNiAxMCwxMyAxNCwxMyAxNCw0IDYsNCA2LDE2IDEwLDE2IDEwLDE5IDMsMTlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwYWludC1idWNrZXRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xMC4yMSwxIEwwLDExLjIxIEw4LjEsMTkuMzEgTDE4LjMxLDkuMSBMMTAuMjEsMSBMMTAuMjEsMSBaIE0xNi44OSw5LjEgTDE1LDExIEwxLjcsMTEgTDEwLjIxLDIuNDIgTDE2Ljg5LDkuMSBaXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTYuNDIsMi4zMyBMMTEuNyw3LjYxXFxcIi8+PHBhdGggZD1cXFwiTTE4LjQ5LDEyIEMxOC40OSwxMiAyMCwxNC4wNiAyMCwxNS4zNiBDMjAsMTYuMjggMTkuMjQsMTcgMTguNDksMTcgTDE4LjQ5LDE3IEMxNy43NCwxNyAxNywxNi4yOCAxNywxNS4zNiBDMTcsMTQuMDYgMTguNDksMTIgMTguNDksMTIgTDE4LjQ5LDEyIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwZW5jaWxcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTE3LjI1LDYuMDEgTDcuMTIsMTYuMSBMMy44MiwxNy4yIEw1LjAyLDEzLjkgTDE1LjEyLDMuODggQzE1LjcxLDMuMjkgMTYuNjYsMy4yOSAxNy4yNSwzLjg4IEMxNy44Myw0LjQ3IDE3LjgzLDUuNDIgMTcuMjUsNi4wMSBMMTcuMjUsNi4wMSBaXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTUuOTgsNy4yNjggTDEzLjg1MSw1LjE0OFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBob25lLWxhbmRzY2FwZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTcsNS41IEMxNy44LDUuNSAxOC41LDYuMiAxOC41LDcgTDE4LjUsMTQgQzE4LjUsMTQuOCAxNy44LDE1LjUgMTcsMTUuNSBMMywxNS41IEMyLjIsMTUuNSAxLjUsMTQuOCAxLjUsMTQgTDEuNSw3IEMxLjUsNi4yIDIuMiw1LjUgMyw1LjUgTDE3LDUuNSBMMTcsNS41IEwxNyw1LjUgWlxcXCIvPjxjaXJjbGUgY3g9XFxcIjMuOFxcXCIgY3k9XFxcIjEwLjVcXFwiIHI9XFxcIi44XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGhvbmVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTE1LjUsMTcgQzE1LjUsMTcuOCAxNC44LDE4LjUgMTQsMTguNSBMNywxOC41IEM2LjIsMTguNSA1LjUsMTcuOCA1LjUsMTcgTDUuNSwzIEM1LjUsMi4yIDYuMiwxLjUgNywxLjUgTDE0LDEuNSBDMTQuOCwxLjUgMTUuNSwyLjIgMTUuNSwzIEwxNS41LDE3IEwxNS41LDE3IEwxNS41LDE3IFpcXFwiLz48Y2lyY2xlIGN4PVxcXCIxMC41XFxcIiBjeT1cXFwiMTYuNVxcXCIgcj1cXFwiLjhcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwaW50ZXJlc3RcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xMC4yMSwxIEM1LjUsMSAzLDQuMTYgMyw3LjYxIEMzLDkuMjEgMy44NSwxMS4yIDUuMjIsMTEuODQgQzUuNDMsMTEuOTQgNS41NCwxMS44OSA1LjU4LDExLjY5IEM1LjYyLDExLjU0IDUuOCwxMC44IDUuODgsMTAuNDUgQzUuOTEsMTAuMzQgNS44OSwxMC4yNCA1LjgsMTAuMTQgQzUuMzYsOS41OSA1LDguNTggNSw3LjY1IEM1LDUuMjQgNi44MiwyLjkxIDkuOTMsMi45MSBDMTIuNjEsMi45MSAxNC40OSw0Ljc0IDE0LjQ5LDcuMzUgQzE0LjQ5LDEwLjMgMTMsMTIuMzUgMTEuMDYsMTIuMzUgQzkuOTksMTIuMzUgOS4xOSwxMS40NyA5LjQ0LDEwLjM4IEM5Ljc1LDkuMDggMTAuMzUsNy42OCAxMC4zNSw2Ljc1IEMxMC4zNSw1LjkxIDkuOSw1LjIxIDguOTcsNS4yMSBDNy44Nyw1LjIxIDYuOTksNi4zNCA2Ljk5LDcuODYgQzYuOTksOC44MyA3LjMyLDkuNDggNy4zMiw5LjQ4IEM3LjMyLDkuNDggNi4yNCwxNC4wNiA2LjA0LDE0LjkxIEM1LjcsMTYuMzUgNi4wOCwxOC43IDYuMTIsMTguOSBDNi4xNCwxOS4wMSA2LjI2LDE5LjA1IDYuMzMsMTguOTUgQzYuNDQsMTguODEgNy43NCwxNi44NSA4LjExLDE1LjQ0IEM4LjI0LDE0LjkzIDguNzksMTIuODQgOC43OSwxMi44NCBDOS4xNSwxMy41MiAxMC4xOSwxNC4wOSAxMS4yOSwxNC4wOSBDMTQuNTgsMTQuMDkgMTYuOTYsMTEuMDYgMTYuOTYsNy4zIEMxNi45NCwzLjcgMTQsMSAxMC4yMSwxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGxheS1jaXJjbGVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHBvaW50cz1cXFwiOC41IDcgMTMuNSAxMCA4LjUgMTNcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCI5XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGxheVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjYuNSw1IDE0LjUsMTAgNi41LDE1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGx1cy1jaXJjbGVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjkuNVxcXCIgY3k9XFxcIjkuNVxcXCIgcj1cXFwiOVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjkuNVxcXCIgeTE9XFxcIjVcXFwiIHgyPVxcXCI5LjVcXFwiIHkyPVxcXCIxNFxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjVcXFwiIHkxPVxcXCI5LjVcXFwiIHgyPVxcXCIxNFxcXCIgeTI9XFxcIjkuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBsdXNcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjlcXFwiIHk9XFxcIjFcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjE3XFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjE3XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwcmludFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI0LjUgMTMuNSAxLjUgMTMuNSAxLjUgNi41IDE4LjUgNi41IDE4LjUgMTMuNSAxNS41IDEzLjVcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjE1LjUgNi41IDE1LjUgMi41IDQuNSAyLjUgNC41IDYuNVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgd2lkdGg9XFxcIjExXFxcIiBoZWlnaHQ9XFxcIjZcXFwiIHg9XFxcIjQuNVxcXCIgeT1cXFwiMTEuNVxcXCIvPjxyZWN0IHdpZHRoPVxcXCI4XFxcIiBoZWlnaHQ9XFxcIjFcXFwiIHg9XFxcIjZcXFwiIHk9XFxcIjEzXFxcIi8+PHJlY3Qgd2lkdGg9XFxcIjhcXFwiIGhlaWdodD1cXFwiMVxcXCIgeD1cXFwiNlxcXCIgeT1cXFwiMTVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwdWxsXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjYuODUsOCA5LjUsMTAuNiAxMi4xNSw4IDEyLjg1LDguNyA5LjUsMTIgNi4xNSw4LjdcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI5LjVcXFwiIHkxPVxcXCIxMVxcXCIgeDI9XFxcIjkuNVxcXCIgeTI9XFxcIjJcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjYsNS41IDMuNSw1LjUgMy41LDE4LjUgMTUuNSwxOC41IDE1LjUsNS41IDEzLDUuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInB1c2hcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiMTIuMTUsNCA5LjUsMS40IDYuODUsNCA2LjE1LDMuMyA5LjUsMCAxMi44NSwzLjNcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI5LjVcXFwiIHkxPVxcXCIxMFxcXCIgeDI9XFxcIjkuNVxcXCIgeTI9XFxcIjFcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjYgNS41IDMuNSA1LjUgMy41IDE4LjUgMTUuNSAxOC41IDE1LjUgNS41IDEzIDUuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInF1ZXN0aW9uXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCI5XFxcIi8+PGNpcmNsZSBjeD1cXFwiMTAuNDRcXFwiIGN5PVxcXCIxNC40MlxcXCIgcj1cXFwiMS4wNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIGQ9XFxcIk04LjE3LDcuNzkgQzguMTcsNC43NSAxMi43Miw0LjczIDEyLjcyLDcuNzIgQzEyLjcyLDguNjcgMTEuODEsOS4xNSAxMS4yMyw5Ljc1IEMxMC43NSwxMC4yNCAxMC41MSwxMC43MyAxMC40NSwxMS40IEMxMC40NCwxMS41MyAxMC40MywxMS42NCAxMC40MywxMS43NVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInF1b3RlLXJpZ2h0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTcuMjcsNy43OSBDMTcuMjcsOS40NSAxNi45NywxMC40MyAxNS45OSwxMi4wMiBDMTQuOTgsMTMuNjQgMTMsMTUuMjMgMTEuNTYsMTUuOTcgTDExLjEsMTUuMDggQzEyLjM0LDE0LjIgMTMuMTQsMTMuNTEgMTQuMDIsMTEuODIgQzE0LjI3LDExLjM0IDE0LjQxLDEwLjkyIDE0LjQ5LDEwLjU0IEMxNC4zLDEwLjU4IDE0LjA5LDEwLjYgMTMuODgsMTAuNiBDMTIuMDYsMTAuNiAxMC41OSw5LjEyIDEwLjU5LDcuMyBDMTAuNTksNS40OCAxMi4wNiw0IDEzLjg4LDQgQzE1LjM5LDQgMTYuNjcsNS4wMiAxNy4wNSw2LjQyIEMxNy4xOSw2LjgyIDE3LjI3LDcuMjcgMTcuMjcsNy43OSBMMTcuMjcsNy43OSBaXFxcIi8+PHBhdGggZD1cXFwiTTguNjgsNy43OSBDOC42OCw5LjQ1IDguMzgsMTAuNDMgNy40LDEyLjAyIEM2LjM5LDEzLjY0IDQuNDEsMTUuMjMgMi45NywxNS45NyBMMi41MSwxNS4wOCBDMy43NSwxNC4yIDQuNTUsMTMuNTEgNS40MywxMS44MiBDNS42OCwxMS4zNCA1LjgyLDEwLjkyIDUuOSwxMC41NCBDNS43MSwxMC41OCA1LjUsMTAuNiA1LjI5LDEwLjYgQzMuNDcsMTAuNiAyLDkuMTIgMiw3LjMgQzIsNS40OCAzLjQ3LDQgNS4yOSw0IEM2LjgsNCA4LjA4LDUuMDIgOC40Niw2LjQyIEM4LjYsNi44MiA4LjY4LDcuMjcgOC42OCw3Ljc5IEw4LjY4LDcuNzkgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInJlY2VpdmVyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wMVxcXCIgZD1cXFwiTTYuMTg5LDEzLjYxMUM4LjEzNCwxNS41MjUgMTEuMDk3LDE4LjIzOSAxMy44NjcsMTguMjU3QzE2LjQ3LDE4LjI3NSAxOC4yLDE2LjI0MSAxOC4yLDE2LjI0MUwxNC41MDksMTIuNTUxTDExLjUzOSwxMy42MzlMNi4xODksOC4yOUw3LjMxMyw1LjM1NUwzLjc2LDEuOEMzLjc2LDEuOCAxLjczMiwzLjUzNyAxLjcsNi4wOTJDMS42NjcsOC44MDkgNC4zNDcsMTEuNzM4IDYuMTg5LDEzLjYxMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInJlZGRpdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE5IDkuMDVhMi41NiAyLjU2IDAgMCAwLTIuNTYtMi41NiAyLjU5IDIuNTkgMCAwIDAtMS44OC44MiAxMC42MyAxMC42MyAwIDAgMC00LjE0LTF2LS4wOGMuNTgtMS42MiAxLjU4LTMuODkgMi43LTQuMS4zOC0uMDguNzcuMTIgMS4xOS41N2ExLjE1IDEuMTUgMCAwIDAtLjA2LjM3IDEuNDggMS40OCAwIDEgMCAxLjUxLTEuNDUgMS40MyAxLjQzIDAgMCAwLS43Ni4xOUEyLjI5IDIuMjkgMCAwIDAgMTIuOTEgMWMtMi4xMS40My0zLjM5IDQuMzgtMy42MyA1LjE5IDAgMCAwIC4xMS0uMDYuMTFhMTAuNjUgMTAuNjUgMCAwIDAtMy43NSAxQTIuNTYgMi41NiAwIDAgMCAxIDkuMDVhMi40MiAyLjQyIDAgMCAwIC43MiAxLjc2QTUuMTggNS4xOCAwIDAgMCAxLjI0IDEzYzAgMy42NiAzLjkyIDYuNjQgOC43MyA2LjY0czguNzQtMyA4Ljc0LTYuNjRhNS4yMyA1LjIzIDAgMCAwLS40Ni0yLjEzQTIuNTggMi41OCAwIDAgMCAxOSA5LjA1em0tMTYuODggMGExLjQ0IDEuNDQgMCAwIDEgMi4yNy0xLjE5IDcuNjggNy42OCAwIDAgMC0yLjA3IDEuOTEgMS4zMyAxLjMzIDAgMCAxLS4yLS43MnpNMTAgMTguNGMtNC4xNyAwLTcuNTUtMi40LTcuNTUtNS40UzUuODMgNy41MyAxMCA3LjUzIDE3LjUgMTAgMTcuNSAxM3MtMy4zOCA1LjQtNy41IDUuNHptNy42OS04LjYxYTcuNjIgNy42MiAwIDAgMC0yLjA5LTEuOTEgMS40MSAxLjQxIDAgMCAxIC44NC0uMjggMS40NyAxLjQ3IDAgMCAxIDEuNDQgMS40NSAxLjM0IDEuMzQgMCAwIDEtLjIxLjcyelxcXCIvPjxwYXRoIGQ9XFxcIk02LjY5IDEyLjU4YTEuMzkgMS4zOSAwIDEgMSAxLjM5LTEuMzkgMS4zOCAxLjM4IDAgMCAxLTEuMzggMS4zOXpcXFwiLz48cGF0aCBkPVxcXCJNMTQuMjYgMTEuMmExLjM5IDEuMzkgMCAxIDEtMS4zOS0xLjM5IDEuMzkgMS4zOSAwIDAgMSAxLjM5IDEuMzl6XFxcIi8+PHBhdGggZD1cXFwiTTEzLjA5IDE0Ljg4YS41NC41NCAwIDAgMS0uMDkuNzcgNS4zIDUuMyAwIDAgMS0zLjI2IDEuMTkgNS42MSA1LjYxIDAgMCAxLTMuNC0xLjIyLjU1LjU1IDAgMSAxIC43My0uODMgNC4wOSA0LjA5IDAgMCAwIDUuMjUgMCAuNTYuNTYgMCAwIDEgLjc3LjA5elxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInJlZnJlc2hcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xNy4wOCwxMS4xNSBDMTcuMDksMTEuMzEgMTcuMSwxMS40NyAxNy4xLDExLjY0IEMxNy4xLDE1LjUzIDEzLjk0LDE4LjY5IDEwLjA1LDE4LjY5IEM2LjE2LDE4LjY4IDMsMTUuNTMgMywxMS42MyBDMyw3Ljc0IDYuMTYsNC41OCAxMC4wNSw0LjU4IEMxMC45LDQuNTggMTEuNzEsNC43MyAxMi40Niw1XFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI5LjkgMiAxMi43OSA0Ljg5IDkuNzkgNy45XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicmVwbHlcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNy43LDEzLjExIEMxNi4xMiwxMC4wMiAxMy44NCw3Ljg1IDExLjAyLDYuNjEgQzEwLjU3LDYuNDEgOS43NSw2LjEzIDksNS45MSBMOSwyIEwxLDkgTDksMTYgTDksMTIuMTMgQzEwLjc4LDEyLjQ3IDEyLjUsMTMuMTkgMTQuMDksMTQuMjUgQzE3LjEzLDE2LjI4IDE4LjU2LDE4LjU0IDE4LjU2LDE4LjU0IEMxOC41NiwxOC41NCAxOC44MSwxNS4yOCAxNy43LDEzLjExIEwxNy43LDEzLjExIFogTTE0LjgyLDEzLjUzIEMxMy4xNywxMi40IDExLjAxLDExLjQgOCwxMC45MiBMOCwxMy42MyBMMi41NSw5IEw4LDQuMjUgTDgsNi44IEM4LjMsNi44NiA5LjE2LDcuMDIgMTAuMzcsNy40OSBDMTMuMyw4LjY1IDE1LjU0LDEwLjk2IDE2LjY1LDEzLjA4IEMxNi45NywxMy43IDE3LjQ4LDE0Ljg2IDE3LjY4LDE2IEMxNi44NywxNS4wNSAxNS43MywxNC4xNSAxNC44MiwxMy41MyBMMTQuODIsMTMuNTMgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInJzc1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBjeD1cXFwiMy4xMlxcXCIgY3k9XFxcIjE2LjhcXFwiIHI9XFxcIjEuODVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMS41LDguMiBDMS43OCw4LjE4IDIuMDYsOC4xNiAyLjM1LDguMTYgQzcuNTcsOC4xNiAxMS44MSwxMi4zNyAxMS44MSwxNy41NyBDMTEuODEsMTcuODkgMTEuNzksMTguMTkgMTEuNzYsMTguNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xLjUsMi41MiBDMS43OCwyLjUxIDIuMDYsMi41IDIuMzUsMi41IEMxMC43MiwyLjUgMTcuNSw5LjI0IDE3LjUsMTcuNTcgQzE3LjUsMTcuODkgMTcuNDksMTguMTkgMTcuNDcsMTguNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInNlYXJjaFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiOVxcXCIgY3k9XFxcIjlcXFwiIHI9XFxcIjdcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTQsMTQgTDE4LDE4IEwxNCwxNCBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic2VydmVyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCIzXFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeD1cXFwiNVxcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjdcXFwiIHk9XFxcIjNcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB4PVxcXCIxNlxcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjE2XFxcIiB5PVxcXCIxMFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiOS45XFxcIiBjeT1cXFwiMTcuNFxcXCIgcj1cXFwiMS40XFxcIi8+PHJlY3QgeD1cXFwiM1xcXCIgeT1cXFwiMTBcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB4PVxcXCI1XFxcIiB5PVxcXCIxMFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjkuNVxcXCIgeT1cXFwiMTRcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB4PVxcXCIzXFxcIiB5PVxcXCIxN1xcXCIgd2lkdGg9XFxcIjZcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjExXFxcIiB5PVxcXCIxN1xcXCIgd2lkdGg9XFxcIjZcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMS41XFxcIiB5PVxcXCIxLjVcXFwiIHdpZHRoPVxcXCIxN1xcXCIgaGVpZ2h0PVxcXCI1XFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxLjVcXFwiIHk9XFxcIjguNVxcXCIgd2lkdGg9XFxcIjE3XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzZXR0aW5nc1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGVsbGlwc2UgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiNi4xMVxcXCIgY3k9XFxcIjMuNTVcXFwiIHJ4PVxcXCIyLjExXFxcIiByeT1cXFwiMi4xNVxcXCIvPjxlbGxpcHNlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjYuMTFcXFwiIGN5PVxcXCIxNS41NVxcXCIgcng9XFxcIjIuMTFcXFwiIHJ5PVxcXCIyLjE1XFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCIxMy4xNVxcXCIgY3k9XFxcIjkuNTVcXFwiIHI9XFxcIjIuMTVcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMTBcXFwiIHk9XFxcIjNcXFwiIHdpZHRoPVxcXCI4XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMTVcXFwiIHk9XFxcIjlcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCIxNVxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjEwXFxcIiB5PVxcXCIxNVxcXCIgd2lkdGg9XFxcIjhcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInNocmlua1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMSA0IDEyIDQgMTIgOCAxNiA4IDE2IDkgMTEgOVxcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiNCAxMSA5IDExIDkgMTYgOCAxNiA4IDEyIDQgMTJcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTIsOCBMMTgsMlxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0yLDE4IEw4LDEyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic2lnbi1pblwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCI3IDIgMTcgMiAxNyAxNyA3IDE3IDcgMTYgMTYgMTYgMTYgMyA3IDNcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjkuMSAxMy40IDguNSAxMi44IDExLjI4IDEwIDQgMTAgNCA5IDExLjI4IDkgOC41IDYuMiA5LjEgNS42MiAxMyA5LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzaWduLW91dFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMy4xIDEzLjQgMTIuNSAxMi44IDE1LjI4IDEwIDggMTAgOCA5IDE1LjI4IDkgMTIuNSA2LjIgMTMuMSA1LjYyIDE3IDkuNVxcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiMTMgMiAzIDIgMyAxNyAxMyAxNyAxMyAxNiA0IDE2IDQgMyAxMyAzXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic29jaWFsXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiMTMuNFxcXCIgeTE9XFxcIjE0XFxcIiB4Mj1cXFwiNi4zXFxcIiB5Mj1cXFwiMTAuN1xcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHgxPVxcXCIxMy41XFxcIiB5MT1cXFwiNS41XFxcIiB4Mj1cXFwiNi41XFxcIiB5Mj1cXFwiOC44XFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiMTUuNVxcXCIgY3k9XFxcIjQuNlxcXCIgcj1cXFwiMi4zXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiMTUuNVxcXCIgY3k9XFxcIjE0LjhcXFwiIHI9XFxcIjIuM1xcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjQuNVxcXCIgY3k9XFxcIjkuOFxcXCIgcj1cXFwiMi4zXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic291bmRjbG91ZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE3LjIsOS40Yy0wLjQsMC0wLjgsMC4xLTEuMTAxLDAuMmMtMC4xOTktMi41LTIuMzk5LTQuNS01LTQuNWMtMC42LDAtMS4yLDAuMS0xLjcsMC4zQzkuMiw1LjUsOS4xLDUuNiw5LjEsNS42VjE1aDggYzEuNjAxLDAsMi44MDEtMS4yLDIuODAxLTIuOEMyMCwxMC43LDE4LjcsOS40LDE3LjIsOS40TDE3LjIsOS40elxcXCIvPjxyZWN0IHg9XFxcIjZcXFwiIHk9XFxcIjYuNVxcXCIgd2lkdGg9XFxcIjEuNVxcXCIgaGVpZ2h0PVxcXCI4LjVcXFwiLz48cmVjdCB4PVxcXCIzXFxcIiB5PVxcXCI4XFxcIiB3aWR0aD1cXFwiMS41XFxcIiBoZWlnaHQ9XFxcIjdcXFwiLz48cmVjdCB5PVxcXCIxMFxcXCIgd2lkdGg9XFxcIjEuNVxcXCIgaGVpZ2h0PVxcXCI1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic3RhclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDFcXFwiIHBvaW50cz1cXFwiMTAgMiAxMi42MyA3LjI3IDE4LjUgOC4xMiAxNC4yNSAxMi4yMiAxNS4yNSAxOCAxMCAxNS4yNyA0Ljc1IDE4IDUuNzUgMTIuMjIgMS41IDguMTIgNy4zNyA3LjI3XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic3RyaWtldGhyb3VnaFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTYsMTMuMDIgTDYuNjUsMTMuMDIgQzcuNjQsMTUuMTYgOC44NiwxNi4xMiAxMC40MSwxNi4xMiBDMTIuMjIsMTYuMTIgMTIuOTIsMTQuOTMgMTIuOTIsMTMuODkgQzEyLjkyLDEyLjU1IDExLjk5LDEyLjAzIDkuNzQsMTEuMjMgQzguMDUsMTAuNjQgNi4yMywxMC4xMSA2LjIzLDcuODMgQzYuMjMsNS41IDguMDksNC4wOSAxMC40LDQuMDkgQzExLjQ0LDQuMDkgMTIuMTMsNC4zMSAxMi43Miw0LjU0IEwxMy4zMyw0IEwxMy44MSw0IEwxMy44MSw3LjU5IEwxMy4xNiw3LjU5IEMxMi41NSw1Ljg4IDExLjUyLDQuODkgMTAuMDcsNC44OSBDOC44NCw0Ljg5IDcuODksNS42OSA3Ljg5LDcuMDMgQzcuODksOC4yOSA4Ljg5LDguNzggMTAuODgsOS40NSBDMTIuNTcsMTAuMDMgMTQuMzgsMTAuNiAxNC4zOCwxMi45MSBDMTQuMzgsMTQuNzUgMTMuMjcsMTYuOTMgMTAuMTgsMTYuOTMgQzkuMTgsMTYuOTMgOC4xNywxNi42OSA3LjQ2LDE2LjM5IEw2LjUyLDE3IEw2LDE3IEw2LDEzLjAyIEw2LDEzLjAyIFpcXFwiLz48cmVjdCB4PVxcXCIzXFxcIiB5PVxcXCIxMFxcXCIgd2lkdGg9XFxcIjE1XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0YWJsZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjE4XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCI3XFxcIiB3aWR0aD1cXFwiMThcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjExXFxcIiB3aWR0aD1cXFwiMThcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjE1XFxcIiB3aWR0aD1cXFwiMThcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRhYmxldC1sYW5kc2NhcGVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTEuNSw1IEMxLjUsNC4yIDIuMiwzLjUgMywzLjUgTDE3LDMuNSBDMTcuOCwzLjUgMTguNSw0LjIgMTguNSw1IEwxOC41LDE2IEMxOC41LDE2LjggMTcuOCwxNy41IDE3LDE3LjUgTDMsMTcuNSBDMi4yLDE3LjUgMS41LDE2LjggMS41LDE2IEwxLjUsNSBMMS41LDUgTDEuNSw1IFpcXFwiLz48Y2lyY2xlIGN4PVxcXCIzLjdcXFwiIGN5PVxcXCIxMC41XFxcIiByPVxcXCIuOFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRhYmxldFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNNSwxOC41IEM0LjIsMTguNSAzLjUsMTcuOCAzLjUsMTcgTDMuNSwzIEMzLjUsMi4yIDQuMiwxLjUgNSwxLjUgTDE2LDEuNSBDMTYuOCwxLjUgMTcuNSwyLjIgMTcuNSwzIEwxNy41LDE3IEMxNy41LDE3LjggMTYuOCwxOC41IDE2LDE4LjUgTDUsMTguNSBMNSwxOC41IEw1LDE4LjUgWlxcXCIvPjxjaXJjbGUgY3g9XFxcIjEwLjVcXFwiIGN5PVxcXCIxNi4zXFxcIiByPVxcXCIuOFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRhZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE3LjUsMy43MSBMMTcuNSw3LjcyIEMxNy41LDcuOTYgMTcuNCw4LjIgMTcuMjEsOC4zOSBMOC4zOSwxNy4yIEM3Ljk5LDE3LjYgNy4zMywxNy42IDYuOTMsMTcuMiBMMi44LDEzLjA3IEMyLjQsMTIuNjcgMi40LDEyLjAxIDIuOCwxMS42MSBMMTEuNjEsMi44IEMxMS44MSwyLjYgMTIuMDgsMi41IDEyLjM0LDIuNSBMMTYuMTksMi41IEMxNi41MiwyLjUgMTYuODYsMi42MyAxNy4xMSwyLjg4IEMxNy4zNSwzLjExIDE3LjQ4LDMuNCAxNy41LDMuNzEgTDE3LjUsMy43MSBaXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTRcXFwiIGN5PVxcXCI2XFxcIiByPVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidGh1bWJuYWlsc1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIzLjVcXFwiIHk9XFxcIjMuNVxcXCIgd2lkdGg9XFxcIjVcXFwiIGhlaWdodD1cXFwiNVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMTEuNVxcXCIgeT1cXFwiMy41XFxcIiB3aWR0aD1cXFwiNVxcXCIgaGVpZ2h0PVxcXCI1XFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxMS41XFxcIiB5PVxcXCIxMS41XFxcIiB3aWR0aD1cXFwiNVxcXCIgaGVpZ2h0PVxcXCI1XFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIzLjVcXFwiIHk9XFxcIjExLjVcXFwiIHdpZHRoPVxcXCI1XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0aWt0b2tcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNy4yNCw2VjguODJhNi43OSw2Ljc5LDAsMCwxLTQtMS4yOHY1LjgxQTUuMjYsNS4yNiwwLDEsMSw4LDguMWE0LjM2LDQuMzYsMCwwLDEsLjcyLjA1djIuOUEyLjU3LDIuNTcsMCwwLDAsNy42NCwxMWEyLjQsMi40LDAsMSwwLDIuNzcsMi4zOFYyaDIuODZhNCw0LDAsMCwwLDEuODQsMy4zOEE0LDQsMCwwLDAsMTcuMjQsNlpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0cmFzaFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI2LjUgMyA2LjUgMS41IDEzLjUgMS41IDEzLjUgM1xcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNC41IDQgNC41IDE4LjUgMTUuNSAxOC41IDE1LjUgNFxcXCIvPjxyZWN0IHg9XFxcIjhcXFwiIHk9XFxcIjdcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjlcXFwiLz48cmVjdCB4PVxcXCIxMVxcXCIgeT1cXFwiN1xcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiOVxcXCIvPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjNcXFwiIHdpZHRoPVxcXCIxNlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHJpYW5nbGUtZG93blwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCI1IDcgMTUgNyAxMCAxMlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRyaWFuZ2xlLWxlZnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiMTIgNSA3IDEwIDEyIDE1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHJpYW5nbGUtcmlnaHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiOCA1IDEzIDEwIDggMTVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0cmlhbmdsZS11cFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCI1IDEzIDEwIDggMTUgMTNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0cmlwYWR2aXNvclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE5LjAyMSw3Ljg2NkMxOS4yNTYsNi44NjIsMjAsNS44NTQsMjAsNS44NTRoLTMuMzQ2QzE0Ljc4MSw0LjY0MSwxMi41MDQsNCw5Ljk4LDRDNy4zNjMsNCw0Ljk5OSw0LjY1MSwzLjEzNSw1Ljg3NkgwXFx0YzAsMCwwLjczOCwwLjk4NywwLjk3NiwxLjk4OGMtMC42MTEsMC44MzctMC45NzMsMS44NTItMC45NzMsMi45NjRjMCwyLjc2MywyLjI0OSw1LjAwOSw1LjAxMSw1LjAwOVxcdGMxLjU3NiwwLDIuOTc2LTAuNzM3LDMuOTAxLTEuODc5bDEuMDYzLDEuNTk5bDEuMDc1LTEuNjE1YzAuNDc1LDAuNjExLDEuMSwxLjExMSwxLjgzOCwxLjQ1MWMxLjIxMywwLjU0NywyLjU3NCwwLjYxMiwzLjgyNSwwLjE1XFx0YzIuNTg5LTAuOTYzLDMuOTEzLTMuODUyLDIuOTY0LTYuNDM5Yy0wLjE3NS0wLjQ2My0wLjQtMC44NzYtMC42NzUtMS4yMzhIMTkuMDIxeiBNMTYuMzgsMTQuNTk0XFx0Yy0xLjAwMiwwLjM3MS0yLjA4OCwwLjMyOC0zLjA2LTAuMTE5Yy0wLjY4OC0wLjMxNy0xLjI1Mi0wLjgxNy0xLjY1Ny0xLjQzOGMtMC4xNjQtMC4yNS0wLjMxMy0wLjUyLTAuNDE3LTAuODExXFx0Yy0wLjEyNC0wLjMyOC0wLjE4Ni0wLjY2OC0wLjIxNy0xLjAxNGMtMC4wNjMtMC42ODksMC4wMzctMS4zOTYsMC4zMzktMi4wNDNjMC40NDgtMC45NzEsMS4yNTEtMS43MSwyLjI1LTIuMDc5XFx0YzIuMDc1LTAuNzY1LDQuMzc1LDAuMyw1LjE0LDIuMzY2YzAuNzYyLDIuMDY2LTAuMzAxLDQuMzctMi4zNjMsNS4xMzRMMTYuMzgsMTQuNTk0TDE2LjM4LDE0LjU5NHogTTguMzIyLDEzLjA2NlxcdGMtMC43MiwxLjA1OS0xLjkzNSwxLjc2LTMuMzA5LDEuNzZjLTIuMjA3LDAtNC4wMDEtMS43OTctNC4wMDEtMy45OTZjMC0yLjIwMywxLjc5NS00LjAwMiw0LjAwMS00LjAwMlxcdGMyLjIwNCwwLDMuOTk5LDEuOCwzLjk5OSw0LjAwMmMwLDAuMTM3LTAuMDI0LDAuMjYxLTAuMDQsMC4zOTZjLTAuMDY3LDAuNjc4LTAuMjg0LDEuMzEzLTAuNjQ4LDEuODUzdi0wLjAxM0g4LjMyMnogTTIuNDcyLDEwLjc3NVxcdGMwLDEuMzY3LDEuMTEyLDIuNDc5LDIuNDc2LDIuNDc5YzEuMzYzLDAsMi40NzItMS4xMSwyLjQ3Mi0yLjQ3OWMwLTEuMzU5LTEuMTEtMi40NjgtMi40NzItMi40NjhcXHRDMy41ODQsOC4zMDYsMi40NzMsOS40MTYsMi40NzIsMTAuNzc1TDIuNDcyLDEwLjc3NXogTTEyLjUxNCwxMC43NzVjMCwxLjM2NywxLjEwNCwyLjQ3OSwyLjQ3MSwyLjQ3OVxcdGMxLjM2MywwLDIuNDc0LTEuMTA4LDIuNDc0LTIuNDc5YzAtMS4zNTktMS4xMS0yLjQ2OC0yLjQ3NC0yLjQ2OGMtMS4zNjQsMC0yLjQ3NywxLjEwOS0yLjQ3NywyLjQ2OEgxMi41MTR6IE0zLjMyNCwxMC43NzVcXHRjMC0wLjg5MywwLjcyNi0xLjYxOCwxLjYxNC0xLjYxOGMwLjg4OSwwLDEuNjI1LDAuNzI3LDEuNjI1LDEuNjE4YzAsMC44OTgtMC43MjUsMS42MjctMS42MjUsMS42MjdcXHRjLTAuOTAxLDAtMS42MjUtMC43MjktMS42MjUtMS42MjdIMy4zMjR6IE0xMy4zNTQsMTAuNzc1YzAtMC44OTMsMC43MjYtMS42MTgsMS42MjctMS42MThjMC44ODYsMCwxLjYxLDAuNzI3LDEuNjEsMS42MThcXHRjMCwwLjg5OC0wLjcyNiwxLjYyNy0xLjYyNiwxLjYyN3MtMS42MjUtMC43MjktMS42MjUtMS42MjdIMTMuMzU0eiBNOS45NzcsNC44NzVjMS43OTgsMCwzLjQyNSwwLjMyNCw0Ljg0OSwwLjk2OFxcdGMtMC41MzUsMC4wMTUtMS4wNjEsMC4xMDgtMS41ODYsMC4zYy0xLjI2NCwwLjQ2My0yLjI2NCwxLjM4OC0yLjgxNSwyLjYwNGMtMC4yNjIsMC41NTEtMC4zOTgsMS4xMzMtMC40NDgsMS43MlxcdEM5Ljc5LDcuOTA1LDcuNjc3LDUuODczLDUuMDc2LDUuODJDNi41MDEsNS4yMDgsOC4xNTMsNC44NzUsOS45NCw0Ljg3NUg5Ljk3N3pcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0dW1ibHJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk02Ljg4NSw4LjU5OGMwLDAsMCwzLjM5MywwLDQuOTk2YzAsMC4yODIsMCwwLjY2LDAuMDk0LDAuOTQyYzAuMzc3LDEuNTA5LDEuMTMxLDIuNTQ1LDIuNTQ1LDMuMTEgYzEuMzE5LDAuNDcyLDIuMzU2LDAuNDcyLDMuNjc2LDBjMC41NjUtMC4xODgsMS4xMzItMC42NTksMS4xMzItMC42NTlsLTAuODQ5LTIuMjYzYzAsMC0xLjAzNiwwLjM3OC0xLjYwMywwLjI4MyBjLTAuNTY1LTAuMDk0LTEuMjI2LTAuNjYtMS4yMjYtMS41MDhjMC0xLjYwMywwLTQuOTAyLDAtNC45MDJoMi44MjhWNS43NzFoLTIuODI4VjJIOC4yMDVjMCwwLTAuMDk0LDAuNjYtMC4xODgsMC45NDIgQzcuODI4LDMuNzkxLDcuMjYyLDQuNzMzLDYuNjAzLDUuMzk0QzUuODQ4LDYuMTQ3LDUsNi40Myw1LDYuNDN2Mi4xNjhINi44ODV6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHZcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjdcXFwiIHk9XFxcIjE2XFxcIiB3aWR0aD1cXFwiNlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIuNVxcXCIgeT1cXFwiMy41XFxcIiB3aWR0aD1cXFwiMTlcXFwiIGhlaWdodD1cXFwiMTFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0d2l0Y2hcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk01LjIzLDEsMiw0LjIzVjE1Ljg1SDUuODh2My4yM0w5LjEsMTUuODVoMi41OUwxNy41LDEwVjFabTExLDguNEwxMy42MiwxMkgxMUw4Ljc4LDE0LjI0VjEySDUuODhWMi4yOUgxNi4yMVpcXFwiLz48cmVjdCB4PVxcXCIxMi45OFxcXCIgeT1cXFwiNC41NVxcXCIgd2lkdGg9XFxcIjEuMjlcXFwiIGhlaWdodD1cXFwiMy44OFxcXCIvPjxyZWN0IHg9XFxcIjkuNDNcXFwiIHk9XFxcIjQuNTVcXFwiIHdpZHRoPVxcXCIxLjI5XFxcIiBoZWlnaHQ9XFxcIjMuODhcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0d2l0dGVyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTksNC43NCBDMTguMzM5LDUuMDI5IDE3LjYyNiw1LjIyOSAxNi44ODEsNS4zMiBDMTcuNjQ0LDQuODYgMTguMjI3LDQuMTM5IDE4LjUwMywzLjI4IEMxNy43OSwzLjcgMTcuMDAxLDQuMDA5IDE2LjE1OSw0LjE3IEMxNS40ODUsMy40NSAxNC41MjYsMyAxMy40NjQsMyBDMTEuNDIzLDMgOS43NzEsNC42NiA5Ljc3MSw2LjcgQzkuNzcxLDYuOTkgOS44MDQsNy4yNjkgOS44NjgsNy41MzkgQzYuNzk1LDcuMzggNC4wNzYsNS45MTkgMi4yNTQsMy42NzkgQzEuOTM2LDQuMjE5IDEuNzU0LDQuODYgMS43NTQsNS41MzkgQzEuNzU0LDYuODIgMi40MDUsNy45NSAzLjM5Nyw4LjYxIEMyLjc5LDguNTg5IDIuMjIsOC40MjkgMS43MjMsOC4xNDkgTDEuNzIzLDguMTg5IEMxLjcyMyw5Ljk3OCAyLjk5NywxMS40NzggNC42ODYsMTEuODIgQzQuMzc2LDExLjg5OSA0LjA0OSwxMS45MzkgMy43MTMsMTEuOTM5IEMzLjQ3NSwxMS45MzkgMy4yNDUsMTEuOTE5IDMuMDE4LDExLjg4IEMzLjQ5LDEzLjM0OSA0Ljg1MiwxNC40MTkgNi40NjksMTQuNDQ5IEM1LjIwNSwxNS40MjkgMy42MTIsMTYuMDE5IDEuODgyLDE2LjAxOSBDMS41ODMsMTYuMDE5IDEuMjksMTYuMDA5IDEsMTUuOTY5IEMyLjYzNSwxNy4wMTkgNC41NzYsMTcuNjI5IDYuNjYyLDE3LjYyOSBDMTMuNDU0LDE3LjYyOSAxNy4xNywxMiAxNy4xNyw3LjEyOSBDMTcuMTcsNi45NjkgMTcuMTY2LDYuODA5IDE3LjE1Nyw2LjY0OSBDMTcuODc5LDYuMTI5IDE4LjUwNCw1LjQ3OCAxOSw0Ljc0XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidWlraXRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiMTQuNCwzLjEgMTEuMyw1LjEgMTUsNy4zIDE1LDEyLjkgMTAsMTUuNyA1LDEyLjkgNSw4LjUgMiw2LjggMiwxNC44IDkuOSwxOS41IDE4LDE0LjggMTgsNS4zXFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCI5LjgsNC4yIDYuNywyLjQgOS44LDAuNCAxMi45LDIuM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInVubG9ja1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIzLjVcXFwiIHk9XFxcIjguNVxcXCIgd2lkdGg9XFxcIjEzXFxcIiBoZWlnaHQ9XFxcIjEwXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNNi41LDguNSBMNi41LDQuOSBDNi41LDMgOC4xLDEuNSAxMCwxLjUgQzExLjksMS41IDEzLjUsMyAxMy41LDQuOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInVwbG9hZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI1IDggOS41IDMuNSAxNCA4XFxcIi8+PHJlY3QgeD1cXFwiM1xcXCIgeT1cXFwiMTdcXFwiIHdpZHRoPVxcXCIxM1xcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiOS41XFxcIiB5MT1cXFwiMTVcXFwiIHgyPVxcXCI5LjVcXFwiIHkyPVxcXCI0XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidXNlclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiOS45XFxcIiBjeT1cXFwiNi40XFxcIiByPVxcXCI0LjRcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMS41LDE5IEMyLjMsMTQuNSA1LjgsMTEuMiAxMCwxMS4yIEMxNC4yLDExLjIgMTcuNywxNC42IDE4LjUsMTkuMlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInVzZXJzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI3LjdcXFwiIGN5PVxcXCI4LjZcXFwiIHI9XFxcIjMuNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xLDE4LjEgQzEuNywxNC42IDQuNCwxMi4xIDcuNiwxMi4xIEMxMC45LDEyLjEgMTMuNywxNC44IDE0LjMsMTguM1xcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMS40LDQgQzEyLjgsMi40IDE1LjQsMi44IDE2LjMsNC43IEMxNy4yLDYuNiAxNS43LDguOSAxMy42LDguOSBDMTYuNSw4LjkgMTguOCwxMS4zIDE5LjIsMTQuMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInZpZGVvLWNhbWVyYVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjE3LjUgNi45IDE3LjUgMTMuMSAxMy41IDEwLjQgMTMuNSAxNC41IDIuNSAxNC41IDIuNSA1LjUgMTMuNSA1LjUgMTMuNSA5LjYgMTcuNSA2LjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ2aW1lb1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTIuMDY1LDcuNTlDMS44NCw3LjM2NywxLjY1NCw3LjA4MiwxLjQ2OCw2LjgzOGMtMC4zMzItMC40Mi0wLjEzNy0wLjQxMSwwLjI3NC0wLjc3MmMxLjAyNi0wLjkxLDIuMDA0LTEuODk2LDMuMTI3LTIuNjg4IGMxLjAxNy0wLjcxMywyLjM2NS0xLjE3MywzLjI4Ni0wLjAzOWMwLjg0OSwxLjA0NSwwLjg2OSwyLjYyOSwxLjA4NCwzLjg5MWMwLjIxNSwxLjMwOSwwLjQyMSwyLjY0OCwwLjg4LDMuOTAxIGMwLjEyNywwLjM1MiwwLjM3LDEuMDE4LDAuODEsMS4wNzRjMC41NjcsMC4wNzgsMS4xNDUtMC45MTcsMS40MDgtMS4yODljMC42ODQtMC45ODcsMS42MTEtMi4zMTcsMS40OTQtMy41ODcgYy0wLjExNS0xLjM0OS0xLjU3Mi0xLjA5NS0yLjQ4Mi0wLjc3M2MwLjE0Ni0xLjUxNCwxLjU1NS0zLjIxNiwyLjkxMi0zLjc5MmMxLjQzOS0wLjU5NywzLjU3OS0wLjU4Nyw0LjMwMiwxLjAzNiBjMC43NzIsMS43NTksMC4wNzgsMy44MDItMC43NjMsNS4zOTZjLTAuOTE4LDEuNzMxLTIuMSwzLjMzMy0zLjM2Myw0LjgyOWMtMS4xMTQsMS4zMjktMi40MzIsMi43ODctNC4wOTMsMy40MjIgYy0xLjg5NywwLjcyMy0zLjAyMS0wLjY4Ni0zLjY2Ny0yLjMxOGMtMC43MDUtMS43NzctMS4wNTYtMy43NzEtMS41NjUtNS42MjFDNC44OTgsOC43MjYsNC42NDQsNy44MzYsNC4xMzYsNy4xOTEgQzMuNDczLDYuMzU4LDIuNzIsNy4xNDEsMi4wNjUsNy41OUMxLjk3Nyw3LjUwMiwyLjExNSw3LjU1MSwyLjA2NSw3LjU5TDIuMDY1LDcuNTl6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwid2FybmluZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxNFxcXCIgcj1cXFwiMVxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48cGF0aCBkPVxcXCJNMTAuOTcsNy43MiBDMTAuODUsOS41NCAxMC41NiwxMS4yOSAxMC41NiwxMS4yOSBDMTAuNTEsMTEuODcgMTAuMjcsMTIgOS45OSwxMiBDOS42OSwxMiA5LjQ5LDExLjg3IDkuNDMsMTEuMjkgQzkuNDMsMTEuMjkgOS4xNiw5LjU0IDkuMDMsNy43MiBDOC45Niw2LjU0IDkuMDMsNiA5LjAzLDYgQzkuMDMsNS40NSA5LjQ2LDUuMDIgOS45OSw1IEMxMC41Myw1LjAxIDEwLjk3LDUuNDQgMTAuOTcsNiBDMTAuOTcsNiAxMS4wNCw2LjU0IDEwLjk3LDcuNzIgTDEwLjk3LDcuNzIgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIndoYXRzYXBwXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTYuNywzLjNjLTEuOC0xLjgtNC4xLTIuOC02LjctMi44Yy01LjIsMC05LjQsNC4yLTkuNCw5LjRjMCwxLjcsMC40LDMuMywxLjMsNC43bC0xLjMsNC45bDUtMS4zYzEuNCwwLjgsMi45LDEuMiw0LjUsMS4yIGwwLDBsMCwwYzUuMiwwLDkuNC00LjIsOS40LTkuNEMxOS41LDcuNCwxOC41LDUsMTYuNywzLjMgTTEwLjEsMTcuN0wxMC4xLDE3LjdjLTEuNCwwLTIuOC0wLjQtNC0xLjFsLTAuMy0wLjJsLTMsMC44bDAuOC0yLjkgbC0wLjItMC4zYy0wLjgtMS4yLTEuMi0yLjctMS4yLTQuMmMwLTQuMywzLjUtNy44LDcuOC03LjhjMi4xLDAsNC4xLDAuOCw1LjUsMi4zYzEuNSwxLjUsMi4zLDMuNCwyLjMsNS41IEMxNy45LDE0LjIsMTQuNCwxNy43LDEwLjEsMTcuNyBNMTQuNCwxMS45Yy0wLjItMC4xLTEuNC0wLjctMS42LTAuOGMtMC4yLTAuMS0wLjQtMC4xLTAuNSwwLjFjLTAuMiwwLjItMC42LDAuOC0wLjgsMC45IGMtMC4xLDAuMi0wLjMsMC4yLTAuNSwwLjFjLTAuMi0wLjEtMS0wLjQtMS45LTEuMmMtMC43LTAuNi0xLjItMS40LTEuMy0xLjZjLTAuMS0wLjIsMC0wLjQsMC4xLTAuNUM4LDguOCw4LjEsOC43LDguMiw4LjUgYzAuMS0wLjEsMC4yLTAuMiwwLjItMC40YzAuMS0wLjIsMC0wLjMsMC0wLjRDOC40LDcuNiw3LjksNi41LDcuNyw2QzcuNSw1LjUsNy4zLDUuNiw3LjIsNS42Yy0wLjEsMC0wLjMsMC0wLjQsMCBjLTAuMiwwLTAuNCwwLjEtMC42LDAuM2MtMC4yLDAuMi0wLjgsMC44LTAuOCwyYzAsMS4yLDAuOCwyLjMsMSwyLjRjMC4xLDAuMiwxLjcsMi41LDQsMy41YzAuNiwwLjIsMSwwLjQsMS4zLDAuNSBjMC42LDAuMiwxLjEsMC4yLDEuNSwwLjFjMC41LTAuMSwxLjQtMC42LDEuNi0xLjFjMC4yLTAuNSwwLjItMSwwLjEtMS4xQzE0LjgsMTIuMSwxNC42LDEyLDE0LjQsMTEuOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIndvcmRwcmVzc1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEwLDAuNWMtNS4yLDAtOS41LDQuMy05LjUsOS41czQuMyw5LjUsOS41LDkuNWM1LjIsMCw5LjUtNC4zLDkuNS05LjVTMTUuMiwwLjUsMTAsMC41TDEwLDAuNUwxMCwwLjV6IE0xNS42LDMuOWgtMC4xIGMtMC44LDAtMS40LDAuNy0xLjQsMS41YzAsMC43LDAuNCwxLjMsMC44LDEuOWMwLjMsMC42LDAuNywxLjMsMC43LDIuM2MwLDAuNy0wLjMsMS41LTAuNiwyLjdMMTQuMSwxNWwtMy04LjkgYzAuNSwwLDAuOS0wLjEsMC45LTAuMUMxMi41LDYsMTIuNSw1LjMsMTIsNS40YzAsMC0xLjMsMC4xLTIuMiwwLjFDOSw1LjUsNy43LDUuNCw3LjcsNS40QzcuMiw1LjMsNy4yLDYsNy42LDZjMCwwLDAuNCwwLjEsMC45LDAuMSBsMS4zLDMuNUw4LDE1TDUsNi4xQzUuNSw2LjEsNS45LDYsNS45LDZDNi40LDYsNi4zLDUuMyw1LjksNS40YzAsMC0xLjMsMC4xLTIuMiwwLjFjLTAuMiwwLTAuMywwLTAuNSwwYzEuNS0yLjIsNC0zLjcsNi45LTMuNyBDMTIuMiwxLjcsMTQuMSwyLjYsMTUuNiwzLjlMMTUuNiwzLjlMMTUuNiwzLjl6IE0yLjUsNi42bDMuOSwxMC44Yy0yLjctMS4zLTQuNi00LjItNC42LTcuNEMxLjgsOC44LDIsNy42LDIuNSw2LjZMMi41LDYuNkwyLjUsNi42IHogTTEwLjIsMTAuN2wyLjUsNi45YzAsMCwwLDAuMSwwLjEsMC4xQzExLjksMTgsMTEsMTguMiwxMCwxOC4yYy0wLjgsMC0xLjYtMC4xLTIuMy0wLjNMMTAuMiwxMC43TDEwLjIsMTAuN0wxMC4yLDEwLjd6IE0xNC4yLDE3LjEgbDIuNS03LjNjMC41LTEuMiwwLjYtMi4xLDAuNi0yLjljMC0wLjMsMC0wLjYtMC4xLTAuOGMwLjYsMS4yLDEsMi41LDEsNEMxOC4zLDEzLDE2LjYsMTUuNywxNC4yLDE3LjFMMTQuMiwxNy4xTDE0LjIsMTcuMXpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ3b3JsZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMSwxMC41IEwxOSwxMC41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMi4zNSwxNS41IEwxNy42NSwxNS41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMi4zNSw1LjUgTDE3LjUyMyw1LjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xMCwxOS40NiBMOS45OCwxOS40NiBDNy4zMSwxNy4zMyA1LjYxLDE0LjE0MSA1LjYxLDEwLjU4IEM1LjYxLDcuMDIgNy4zMywzLjgzIDEwLDEuNyBDMTAuMDEsMS43IDkuOTksMS43IDEwLDEuNyBMMTAsMS43IEMxMi42NywzLjgzIDE0LjQsNy4wMiAxNC40LDEwLjU4IEMxNC40LDE0LjE0MSAxMi42NywxNy4zMyAxMCwxOS40NiBMMTAsMTkuNDYgTDEwLDE5LjQ2IEwxMCwxOS40NiBaXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwLjVcXFwiIHI9XFxcIjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ4aW5nXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNC40LDQuNTYgQzQuMjQsNC41NiA0LjExLDQuNjEgNC4wNSw0LjcyIEMzLjk4LDQuODMgMy45OSw0Ljk3IDQuMDcsNS4xMiBMNS44Miw4LjE2IEw1LjgyLDguMTcgTDMuMDYsMTMuMDQgQzIuOTksMTMuMTggMi45OSwxMy4zMyAzLjA2LDEzLjQ0IEMzLjEyLDEzLjU1IDMuMjQsMTMuNjIgMy40LDEzLjYyIEw2LDEzLjYyIEM2LjM5LDEzLjYyIDYuNTcsMTMuMzYgNi43MSwxMy4xMiBDNi43MSwxMy4xMiA5LjQxLDguMzUgOS41MSw4LjE2IEM5LjQ5LDguMTQgNy43Miw1LjA0IDcuNzIsNS4wNCBDNy41OCw0LjgxIDcuMzksNC41NiA2Ljk5LDQuNTYgTDQuNCw0LjU2IEw0LjQsNC41NiBaXFxcIi8+PHBhdGggZD1cXFwiTTE1LjMsMSBDMTQuOTEsMSAxNC43NCwxLjI1IDE0LjYsMS41IEMxNC42LDEuNSA5LjAxLDExLjQyIDguODIsMTEuNzQgQzguODMsMTEuNzYgMTIuNTEsMTguNTEgMTIuNTEsMTguNTEgQzEyLjY0LDE4Ljc0IDEyLjg0LDE5IDEzLjIzLDE5IEwxNS44MiwxOSBDMTUuOTgsMTkgMTYuMSwxOC45NCAxNi4xNiwxOC44MyBDMTYuMjMsMTguNzIgMTYuMjMsMTguNTcgMTYuMTYsMTguNDMgTDEyLjUsMTEuNzQgTDEyLjUsMTEuNzIgTDE4LjI1LDEuNTYgQzE4LjMyLDEuNDIgMTguMzIsMS4yNyAxOC4yNSwxLjE2IEMxOC4yMSwxLjA2IDE4LjA4LDEgMTcuOTMsMSBMMTUuMywxIEwxNS4zLDEgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInllbHBcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNy4xNzUsMTQuOTcxYy0wLjExMiwwLjc3LTEuNjg2LDIuNzY3LTIuNDA2LDMuMDU0Yy0wLjI0NiwwLjEtMC40ODcsMC4wNzYtMC42NzUtMC4wNjlcXHRjLTAuMTIyLTAuMDk2LTIuNDQ2LTMuODU5LTIuNDQ2LTMuODU5Yy0wLjE5NC0wLjI5My0wLjE1Ny0wLjY4MiwwLjA4My0wLjk3OGMwLjIzNC0wLjI4NCwwLjU4MS0wLjM5MywwLjg4MS0wLjI3NlxcdGMwLjAxNiwwLjAxLDQuMjEsMS4zOTQsNC4zMzIsMS40ODJjMC4xNzgsMC4xNDgsMC4yNjMsMC4zNzksMC4yMjUsMC42NDZMMTcuMTc1LDE0Ljk3MUwxNy4xNzUsMTQuOTcxeiBNMTEuNDY0LDEwLjc4OVxcdGMtMC4yMDMtMC4zMDctMC4xOTktMC42NjYsMC4wMDktMC45MTZjMCwwLDIuNjI1LTMuNTc0LDIuNzQ1LTMuNjU3YzAuMjAzLTAuMTM1LDAuNDUyLTAuMTQxLDAuNjktMC4wMjVcXHRjMC42OTEsMC4zMzUsMi4wODUsMi40MDUsMi4xNjcsMy4xOTl2MC4wMjdjMC4wMjQsMC4yNzEtMC4wODIsMC40OTEtMC4yNzMsMC42MjNjLTAuMTMyLDAuMDgzLTQuNDMsMS4xNTUtNC40MywxLjE1NVxcdGMtMC4zMjIsMC4wOTYtMC42OC0wLjA2LTAuODgyLTAuMzgxTDExLjQ2NCwxMC43ODl6IE05LjQ3NSw5LjU2M0M5LjMyLDkuNjA5LDguODQ4LDkuNzU3LDguMjY5LDguODE3YzAsMC0zLjkxNi02LjE2LTQuMDA3LTYuMzUxXFx0Yy0wLjA1Ny0wLjIxMiwwLjAxMS0wLjQ1NSwwLjIwMi0wLjY1QzUuMDQ3LDEuMjExLDguMjEsMC4zMjcsOS4wMzcsMC41MjljMC4yNywwLjA2OSwwLjQ1NywwLjIzOCwwLjUyMiwwLjQ3OVxcdGMwLjA0NywwLjI2NiwwLjQzMyw1Ljk4MiwwLjQ4OCw3LjI2NEMxMC4wOTgsOS4zNjgsOS42MjksOS41MTcsOS40NzUsOS41NjN6IE05LjkyNywxOS4wNjZjLTAuMDgzLDAuMjI1LTAuMjczLDAuMzczLTAuNTQsMC40MjFcXHRjLTAuNzYyLDAuMTMtMy4xNS0wLjc1MS0zLjY0Ny0xLjM0MmMtMC4wOTYtMC4xMzEtMC4xNTUtMC4yNjItMC4xNjctMC4zOTRjLTAuMDExLTAuMDk1LDAtMC4xODksMC4wMzYtMC4yNzJcXHRjMC4wNjEtMC4xNTUsMi45MTctMy41MzgsMi45MTctMy41MzhjMC4yMTQtMC4yNzIsMC41OTUtMC4zNTUsMC45NTItMC4yMTNjMC4zNDUsMC4xMywwLjU2LDAuNDI4LDAuNTM2LDAuNzQ5XFx0QzEwLjAxNCwxNC40NzksOS45NzcsMTguOTIzLDkuOTI3LDE5LjA2NnogTTMuNDk1LDEzLjkxMmMtMC4yMzUtMC4wMDktMC40NDQtMC4xNDgtMC41NjgtMC4zODJjLTAuMDg5LTAuMTctMC4xNTEtMC40NTMtMC4xOS0wLjc5NFxcdEMyLjYzLDExLjcwMSwyLjc2MSwxMC4xNDQsMy4wNyw5LjY0OGMwLjE0NS0wLjIyNiwwLjM1Ny0wLjM0NSwwLjU5Mi0wLjMzNmMwLjE1NCwwLDQuMjU1LDEuNjY3LDQuMjU1LDEuNjY3XFx0YzAuMzIxLDAuMTE4LDAuNTIxLDAuNDUzLDAuNSwwLjgzM2MtMC4wMjMsMC4zNy0wLjIzNiwwLjY1NS0wLjU1MSwwLjczOEwzLjQ5NSwxMy45MTJ6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwieW91dHViZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE1LDQuMWMxLDAuMSwyLjMsMCwzLDAuOGMwLjgsMC44LDAuOSwyLjEsMC45LDMuMUMxOSw5LjIsMTksMTAuOSwxOSwxMmMtMC4xLDEuMSwwLDIuNC0wLjUsMy40Yy0wLjUsMS4xLTEuNCwxLjUtMi41LDEuNiBjLTEuMiwwLjEtOC42LDAuMS0xMSwwYy0xLjEtMC4xLTIuNC0wLjEtMy4yLTFjLTAuNy0wLjgtMC43LTItMC44LTNDMSwxMS44LDEsMTAuMSwxLDguOWMwLTEuMSwwLTIuNCwwLjUtMy40QzIsNC41LDMsNC4zLDQuMSw0LjIgQzUuMyw0LjEsMTIuNiw0LDE1LDQuMXogTTgsNy41djZsNS41LTNMOCw3LjV6XFxcIi8+PC9zdmc+XCIgfSk7XG5cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlVJa2l0KSB7XG4gICAgICB3aW5kb3cuVUlraXQudXNlKHBsdWdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbjtcblxufSkpO1xuIiwiLyohIFVJa2l0IDMuMTMuOSB8IGh0dHBzOi8vd3d3LmdldHVpa2l0LmNvbSB8IChjKSAyMDE0IC0gMjAyMiBZT090aGVtZSB8IE1JVCBMaWNlbnNlICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgndWlraXQnLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLlVJa2l0ID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IHsgaGFzT3duUHJvcGVydHksIHRvU3RyaW5nIH0gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gICAgfVxuXG4gICAgY29uc3QgaHlwaGVuYXRlUmUgPSAvXFxCKFtBLVpdKS9nO1xuXG4gICAgY29uc3QgaHlwaGVuYXRlID0gbWVtb2l6ZSgoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSZSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgY29uc3QgY2FtZWxpemVSZSA9IC8tKFxcdykvZztcblxuICAgIGNvbnN0IGNhbWVsaXplID0gbWVtb2l6ZSgoc3RyKSA9PiBzdHIucmVwbGFjZShjYW1lbGl6ZVJlLCB0b1VwcGVyKSk7XG5cbiAgICBjb25zdCB1Y2ZpcnN0ID0gbWVtb2l6ZSgoc3RyKSA9PlxuICAgIHN0ci5sZW5ndGggPyB0b1VwcGVyKG51bGwsIHN0ci5jaGFyQXQoMCkpICsgc3RyLnNsaWNlKDEpIDogJycpO1xuXG5cbiAgICBmdW5jdGlvbiB0b1VwcGVyKF8sIGMpIHtcbiAgICAgIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCkge1xuICAgICAgcmV0dXJuIHN0ciA9PSBudWxsID8gdm9pZCAwIDogc3RyLnN0YXJ0c1dpdGggPT0gbnVsbCA/IHZvaWQgMCA6IHN0ci5zdGFydHNXaXRoKHNlYXJjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gpIHtcbiAgICAgIHJldHVybiBzdHIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ci5lbmRzV2l0aCA9PSBudWxsID8gdm9pZCAwIDogc3RyLmVuZHNXaXRoKHNlYXJjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMob2JqLCBzZWFyY2gpIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9iai5pbmNsdWRlcyA9PSBudWxsID8gdm9pZCAwIDogb2JqLmluY2x1ZGVzKHNlYXJjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gdm9pZCAwIDogYXJyYXkuZmluZEluZGV4ID09IG51bGwgPyB2b2lkIDAgOiBhcnJheS5maW5kSW5kZXgocHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGlzQXJyYXksIGZyb206IHRvQXJyYXkgfSA9IEFycmF5O1xuICAgIGNvbnN0IHsgYXNzaWduIH0gPSBPYmplY3Q7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcbiAgICAgIHJldHVybiBpc09iamVjdChvYmopICYmIG9iaiA9PT0gb2JqLndpbmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RvY3VtZW50KG9iaikge1xuICAgICAgcmV0dXJuIG5vZGVUeXBlKG9iaikgPT09IDk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOb2RlKG9iaikge1xuICAgICAgcmV0dXJuIG5vZGVUeXBlKG9iaikgPj0gMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gICAgICByZXR1cm4gbm9kZVR5cGUob2JqKSA9PT0gMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub2RlVHlwZShvYmopIHtcbiAgICAgIHJldHVybiAhaXNXaW5kb3cob2JqKSAmJiBpc09iamVjdChvYmopICYmIG9iai5ub2RlVHlwZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSB8fCBpc1N0cmluZyh2YWx1ZSkgJiYgIWlzTmFOKHZhbHVlIC0gcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgICByZXR1cm4gIShpc0FycmF5KG9iaikgPyBvYmoubGVuZ3RoIDogaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoIDogZmFsc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0Jvb2xlYW4odmFsdWUpID9cbiAgICAgIHZhbHVlIDpcbiAgICAgIHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICcxJyB8fCB2YWx1ZSA9PT0gJycgP1xuICAgICAgdHJ1ZSA6XG4gICAgICB2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJzAnID9cbiAgICAgIGZhbHNlIDpcbiAgICAgIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBjb25zdCBudW1iZXIgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIGlzTmFOKG51bWJlcikgPyBmYWxzZSA6IG51bWJlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vZGUoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudClbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob2RlcyhlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudCAmJiAoaXNOb2RlKGVsZW1lbnQpID8gW2VsZW1lbnRdIDogQXJyYXkuZnJvbShlbGVtZW50KS5maWx0ZXIoaXNOb2RlKSkgfHwgW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9XaW5kb3coZWxlbWVudCkge3ZhciBfZWxlbWVudDtcbiAgICAgIGlmIChpc1dpbmRvdyhlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gaXNEb2N1bWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiAoX2VsZW1lbnQgPSBlbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQub3duZXJEb2N1bWVudDtcblxuICAgICAgcmV0dXJuIChkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b01zKHRpbWUpIHtcbiAgICAgIHJldHVybiB0aW1lID8gZW5kc1dpdGgodGltZSwgJ21zJykgPyB0b0Zsb2F0KHRpbWUpIDogdG9GbG9hdCh0aW1lKSAqIDEwMDAgOiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2YWx1ZSA9PT0gb3RoZXIgfHxcbiAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgIGlzT2JqZWN0KG90aGVyKSAmJlxuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhvdGhlcikubGVuZ3RoICYmXG4gICAgICAgIGVhY2godmFsdWUsICh2YWwsIGtleSkgPT4gdmFsID09PSBvdGhlcltrZXldKSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzd2FwKHZhbHVlLCBhLCBiKSB7XG4gICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKGEgKyBcInxcIiArIGIsICdnJyksIChtYXRjaCkgPT4gbWF0Y2ggPT09IGEgPyBiIDogYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhY2gob2JqLCBjYikge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gY2Iob2JqW2tleV0sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnRCeSQxKGFycmF5LCBwcm9wKSB7XG4gICAgICByZXR1cm4gYXJyYXkuXG4gICAgICBzbGljZSgpLlxuICAgICAgc29ydCgoX3JlZiwgX3JlZjIpID0+IHtsZXQgeyBbcHJvcF06IHByb3BBID0gMCB9ID0gX3JlZjtsZXQgeyBbcHJvcF06IHByb3BCID0gMCB9ID0gX3JlZjI7cmV0dXJuIChcbiAgICAgICAgICBwcm9wQSA+IHByb3BCID8gMSA6IHByb3BCID4gcHJvcEEgPyAtMSA6IDApO30pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5pcXVlQnkoYXJyYXksIHByb3ApIHtcbiAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKChfcmVmMykgPT4ge2xldCB7IFtwcm9wXTogY2hlY2sgfSA9IF9yZWYzO3JldHVybiBzZWVuLmhhcyhjaGVjaykgPyBmYWxzZSA6IHNlZW4uYWRkKGNoZWNrKTt9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIG1pbiwgbWF4KSB7aWYgKG1pbiA9PT0gdm9pZCAwKSB7bWluID0gMDt9aWYgKG1heCA9PT0gdm9pZCAwKSB7bWF4ID0gMTt9XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodG9OdW1iZXIobnVtYmVyKSB8fCAwLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0UmVjdCgpIHtmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVjdHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7cmVjdHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07fVxuICAgICAgcmV0dXJuIFtcbiAgICAgIFsnYm90dG9tJywgJ3RvcCddLFxuICAgICAgWydyaWdodCcsICdsZWZ0J11dLlxuICAgICAgZXZlcnkoXG4gICAgICAoX3JlZjQpID0+IHtsZXQgW21pblByb3AsIG1heFByb3BdID0gX3JlZjQ7cmV0dXJuIChcbiAgICAgICAgICBNYXRoLm1pbiguLi5yZWN0cy5tYXAoKF9yZWY1KSA9PiB7bGV0IHsgW21pblByb3BdOiBtaW4gfSA9IF9yZWY1O3JldHVybiBtaW47fSkpIC1cbiAgICAgICAgICBNYXRoLm1heCguLi5yZWN0cy5tYXAoKF9yZWY2KSA9PiB7bGV0IHsgW21heFByb3BdOiBtYXggfSA9IF9yZWY2O3JldHVybiBtYXg7fSkpID5cbiAgICAgICAgICAwKTt9KTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50SW5SZWN0KHBvaW50LCByZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwb2ludC54IDw9IHJlY3QucmlnaHQgJiZcbiAgICAgICAgcG9pbnQueCA+PSByZWN0LmxlZnQgJiZcbiAgICAgICAgcG9pbnQueSA8PSByZWN0LmJvdHRvbSAmJlxuICAgICAgICBwb2ludC55ID49IHJlY3QudG9wKTtcblxuICAgIH1cblxuICAgIGNvbnN0IERpbWVuc2lvbnMgPSB7XG4gICAgICByYXRpbyhkaW1lbnNpb25zLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBhUHJvcCA9IHByb3AgPT09ICd3aWR0aCcgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbYVByb3BdOiBkaW1lbnNpb25zW3Byb3BdID9cbiAgICAgICAgICBNYXRoLnJvdW5kKHZhbHVlICogZGltZW5zaW9uc1thUHJvcF0gLyBkaW1lbnNpb25zW3Byb3BdKSA6XG4gICAgICAgICAgZGltZW5zaW9uc1thUHJvcF0sXG4gICAgICAgICAgW3Byb3BdOiB2YWx1ZSB9O1xuXG4gICAgICB9LFxuXG4gICAgICBjb250YWluKGRpbWVuc2lvbnMsIG1heERpbWVuc2lvbnMpIHtcbiAgICAgICAgZGltZW5zaW9ucyA9IHsgLi4uZGltZW5zaW9ucyB9O1xuXG4gICAgICAgIGVhY2goXG4gICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgIChfLCBwcm9wKSA9PlxuICAgICAgICBkaW1lbnNpb25zID1cbiAgICAgICAgZGltZW5zaW9uc1twcm9wXSA+IG1heERpbWVuc2lvbnNbcHJvcF0gP1xuICAgICAgICB0aGlzLnJhdGlvKGRpbWVuc2lvbnMsIHByb3AsIG1heERpbWVuc2lvbnNbcHJvcF0pIDpcbiAgICAgICAgZGltZW5zaW9ucyk7XG5cblxuICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICAgIH0sXG5cbiAgICAgIGNvdmVyKGRpbWVuc2lvbnMsIG1heERpbWVuc2lvbnMpIHtcbiAgICAgICAgZGltZW5zaW9ucyA9IHRoaXMuY29udGFpbihkaW1lbnNpb25zLCBtYXhEaW1lbnNpb25zKTtcblxuICAgICAgICBlYWNoKFxuICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAoXywgcHJvcCkgPT5cbiAgICAgICAgZGltZW5zaW9ucyA9XG4gICAgICAgIGRpbWVuc2lvbnNbcHJvcF0gPCBtYXhEaW1lbnNpb25zW3Byb3BdID9cbiAgICAgICAgdGhpcy5yYXRpbyhkaW1lbnNpb25zLCBwcm9wLCBtYXhEaW1lbnNpb25zW3Byb3BdKSA6XG4gICAgICAgIGRpbWVuc2lvbnMpO1xuXG5cbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gICAgICB9IH07XG5cblxuICAgIGZ1bmN0aW9uIGdldEluZGV4KGksIGVsZW1lbnRzLCBjdXJyZW50LCBmaW5pdGUpIHtpZiAoY3VycmVudCA9PT0gdm9pZCAwKSB7Y3VycmVudCA9IDA7fWlmIChmaW5pdGUgPT09IHZvaWQgMCkge2Zpbml0ZSA9IGZhbHNlO31cbiAgICAgIGVsZW1lbnRzID0gdG9Ob2RlcyhlbGVtZW50cyk7XG5cbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBlbGVtZW50cztcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBpID0gaXNOdW1lcmljKGkpID9cbiAgICAgIHRvTnVtYmVyKGkpIDpcbiAgICAgIGkgPT09ICduZXh0JyA/XG4gICAgICBjdXJyZW50ICsgMSA6XG4gICAgICBpID09PSAncHJldmlvdXMnID9cbiAgICAgIGN1cnJlbnQgLSAxIDpcbiAgICAgIGVsZW1lbnRzLmluZGV4T2YodG9Ob2RlKGkpKTtcblxuICAgICAgaWYgKGZpbml0ZSkge1xuICAgICAgICByZXR1cm4gY2xhbXAoaSwgMCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGkgJT0gbGVuZ3RoO1xuXG4gICAgICByZXR1cm4gaSA8IDAgPyBpICsgbGVuZ3RoIDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gKGtleSkgPT4gY2FjaGVba2V5XSB8fCAoY2FjaGVba2V5XSA9IGZuKGtleSkpO1xuICAgIH1cblxuICAgIGNsYXNzIERlZmVycmVkIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICB9fVxuXG4gICAgZnVuY3Rpb24gYXR0cihlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5hbWUpIHtcbiAgICAgICAgICBhdHRyKGVsZW1lbnQsIGtleSwgbmFtZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHt2YXIgX3RvTm9kZTtcbiAgICAgICAgcmV0dXJuIChfdG9Ob2RlID0gdG9Ob2RlKGVsZW1lbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RvTm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRvTm9kZXMoZWxlbWVudCkpIHtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2FsbChlbCwgYXR0cihlbCwgbmFtZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQXR0cihlbGVtZW50LCBuYW1lKSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKChlbGVtZW50KSA9PiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShuYW1lKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQXR0cihlbGVtZW50LCBuYW1lKSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IHRvTm9kZXMoZWxlbWVudCk7XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBuYW1lLnNwbGl0KCcgJykpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRhdGEoZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgW2F0dHJpYnV0ZSwgXCJkYXRhLVwiICsgYXR0cmlidXRlXSkge1xuICAgICAgICBpZiAoaGFzQXR0cihlbGVtZW50LCBuYW1lKSkge1xuICAgICAgICAgIHJldHVybiBhdHRyKGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgdm9pZEVsZW1lbnRzID0ge1xuICAgICAgYXJlYTogdHJ1ZSxcbiAgICAgIGJhc2U6IHRydWUsXG4gICAgICBicjogdHJ1ZSxcbiAgICAgIGNvbDogdHJ1ZSxcbiAgICAgIGVtYmVkOiB0cnVlLFxuICAgICAgaHI6IHRydWUsXG4gICAgICBpbWc6IHRydWUsXG4gICAgICBpbnB1dDogdHJ1ZSxcbiAgICAgIGtleWdlbjogdHJ1ZSxcbiAgICAgIGxpbms6IHRydWUsXG4gICAgICBtZW51aXRlbTogdHJ1ZSxcbiAgICAgIG1ldGE6IHRydWUsXG4gICAgICBwYXJhbTogdHJ1ZSxcbiAgICAgIHNvdXJjZTogdHJ1ZSxcbiAgICAgIHRyYWNrOiB0cnVlLFxuICAgICAgd2JyOiB0cnVlIH07XG5cbiAgICBmdW5jdGlvbiBpc1ZvaWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQpID0+IHZvaWRFbGVtZW50c1tlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmlzaWJsZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKFxuICAgICAgKGVsZW1lbnQpID0+IGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgZWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG5cbiAgICB9XG5cbiAgICBjb25zdCBzZWxJbnB1dCA9ICdpbnB1dCxzZWxlY3QsdGV4dGFyZWEsYnV0dG9uJztcbiAgICBmdW5jdGlvbiBpc0lucHV0KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQpID0+IG1hdGNoZXMoZWxlbWVudCwgc2VsSW5wdXQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxGb2N1c2FibGUgPSBzZWxJbnB1dCArIFwiLGFbaHJlZl0sW3RhYmluZGV4XVwiO1xuICAgIGZ1bmN0aW9uIGlzRm9jdXNhYmxlKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzKGVsZW1lbnQsIHNlbEZvY3VzYWJsZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyZW50KGVsZW1lbnQpIHt2YXIgX3RvTm9kZTtcbiAgICAgIHJldHVybiAoX3RvTm9kZSA9IHRvTm9kZShlbGVtZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90b05vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXIkMShlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuZmlsdGVyKChlbGVtZW50KSA9PiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZSgoZWxlbWVudCkgPT4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2VzdChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgaWYgKHN0YXJ0c1dpdGgoc2VsZWN0b3IsICc+JykpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSgxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzRWxlbWVudChlbGVtZW50KSA/XG4gICAgICBlbGVtZW50LmNsb3Nlc3Qoc2VsZWN0b3IpIDpcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkuXG4gICAgICBtYXAoKGVsZW1lbnQpID0+IGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpKS5cbiAgICAgIGZpbHRlcihCb29sZWFuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aXRoaW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBpc1N0cmluZyhzZWxlY3RvcikgP1xuICAgICAgbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikgfHwgISFjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yKSA6XG4gICAgICBlbGVtZW50ID09PSBzZWxlY3RvciB8fCB0b05vZGUoc2VsZWN0b3IpLmNvbnRhaW5zKHRvTm9kZShlbGVtZW50KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyZW50cyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgICAgd2hpbGUgKGVsZW1lbnQgPSBwYXJlbnQoZWxlbWVudCkpIHtcbiAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBlbGVtZW50ID8gdG9Ob2RlcyhlbGVtZW50LmNoaWxkcmVuKSA6IFtdO1xuICAgICAgcmV0dXJuIHNlbGVjdG9yID8gZmlsdGVyJDEoY2hpbGRyZW4sIHNlbGVjdG9yKSA6IGNoaWxkcmVuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluZGV4KGVsZW1lbnQsIHJlZikge1xuICAgICAgcmV0dXJuIHJlZiA/IHRvTm9kZXMoZWxlbWVudCkuaW5kZXhPZih0b05vZGUocmVmKSkgOiBjaGlsZHJlbihwYXJlbnQoZWxlbWVudCkpLmluZGV4T2YoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBmaW5kKHNlbGVjdG9yLCBnZXRDb250ZXh0KHNlbGVjdG9yLCBjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcXVlcnlBbGwoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBmaW5kQWxsKHNlbGVjdG9yLCBnZXRDb250ZXh0KHNlbGVjdG9yLCBjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRvTm9kZShfcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQsICdxdWVyeVNlbGVjdG9yJykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRBbGwoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKF9xdWVyeShzZWxlY3RvciwgY29udGV4dCwgJ3F1ZXJ5U2VsZWN0b3JBbGwnKSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dFNlbGVjdG9yUmUgPSAvKF58W15cXFxcXSwpXFxzKlshPit+LV0vO1xuICAgIGNvbnN0IGlzQ29udGV4dFNlbGVjdG9yID0gbWVtb2l6ZSgoc2VsZWN0b3IpID0+IHNlbGVjdG9yLm1hdGNoKGNvbnRleHRTZWxlY3RvclJlKSk7XG5cbiAgICBmdW5jdGlvbiBnZXRDb250ZXh0KHNlbGVjdG9yLCBjb250ZXh0KSB7aWYgKGNvbnRleHQgPT09IHZvaWQgMCkge2NvbnRleHQgPSBkb2N1bWVudDt9XG4gICAgICByZXR1cm4gaXNTdHJpbmcoc2VsZWN0b3IpICYmIGlzQ29udGV4dFNlbGVjdG9yKHNlbGVjdG9yKSB8fCBpc0RvY3VtZW50KGNvbnRleHQpID9cbiAgICAgIGNvbnRleHQgOlxuICAgICAgY29udGV4dC5vd25lckRvY3VtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHRTYW5pdGl6ZVJlID0gLyhbIT4rfi1dKSg/PVxccytbIT4rfi1dfFxccyokKS9nO1xuICAgIGNvbnN0IHNhbmF0aXplID0gbWVtb2l6ZSgoc2VsZWN0b3IpID0+IHNlbGVjdG9yLnJlcGxhY2UoY29udGV4dFNhbml0aXplUmUsICckMSAqJykpO1xuXG4gICAgZnVuY3Rpb24gX3F1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0LCBxdWVyeUZuKSB7aWYgKGNvbnRleHQgPT09IHZvaWQgMCkge2NvbnRleHQgPSBkb2N1bWVudDt9XG4gICAgICBpZiAoIXNlbGVjdG9yIHx8ICFpc1N0cmluZyhzZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RvciA9IHNhbmF0aXplKHNlbGVjdG9yKTtcblxuICAgICAgaWYgKGlzQ29udGV4dFNlbGVjdG9yKHNlbGVjdG9yKSkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IHNwbGl0U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICBzZWxlY3RvciA9ICcnO1xuICAgICAgICBmb3IgKGxldCBzZWwgb2Ygc3BsaXQpIHtcbiAgICAgICAgICBsZXQgY3R4ID0gY29udGV4dDtcblxuICAgICAgICAgIGlmIChzZWxbMF0gPT09ICchJykge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3JzID0gc2VsLnN1YnN0cigxKS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGN0eCA9IGNsb3Nlc3QocGFyZW50KGNvbnRleHQpLCBzZWxlY3RvcnNbMF0pO1xuICAgICAgICAgICAgc2VsID0gc2VsZWN0b3JzLnNsaWNlKDEpLmpvaW4oJyAnKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXNlbC5sZW5ndGggJiYgc3BsaXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbFswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvcnMgPSBzZWwuc3Vic3RyKDEpLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IChjdHggfHwgY29udGV4dCkucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgICAgICAgIGN0eCA9IG1hdGNoZXMocHJldiwgc2VsLnN1YnN0cigxKSkgPyBwcmV2IDogbnVsbDtcbiAgICAgICAgICAgIHNlbCA9IHNlbGVjdG9ycy5zbGljZSgxKS5qb2luKCcgJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgc2VsZWN0b3IgKz0gXCJcIiArIChzZWxlY3RvciA/ICcsJyA6ICcnKSArIGRvbVBhdGgoY3R4KSArIFwiIFwiICsgc2VsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQgPSBkb2N1bWVudDtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRbcXVlcnlGbl0oc2VsZWN0b3IpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RvclJlID0gLy4qP1teXFxcXF0oPzosfCQpL2c7XG5cbiAgICBjb25zdCBzcGxpdFNlbGVjdG9yID0gbWVtb2l6ZSgoc2VsZWN0b3IpID0+XG4gICAgc2VsZWN0b3IubWF0Y2goc2VsZWN0b3JSZSkubWFwKChzZWxlY3RvcikgPT4gc2VsZWN0b3IucmVwbGFjZSgvLCQvLCAnJykudHJpbSgpKSk7XG5cblxuICAgIGZ1bmN0aW9uIGRvbVBhdGgoZWxlbWVudCkge1xuICAgICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICAgIHdoaWxlIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc3QgaWQgPSBhdHRyKGVsZW1lbnQsICdpZCcpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBuYW1lcy51bnNoaWZ0KFwiI1wiICsgZXNjYXBlKGlkKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHsgdGFnTmFtZSB9ID0gZWxlbWVudDtcbiAgICAgICAgICBpZiAodGFnTmFtZSAhPT0gJ0hUTUwnKSB7XG4gICAgICAgICAgICB0YWdOYW1lICs9IFwiOm50aC1jaGlsZChcIiArIChpbmRleChlbGVtZW50KSArIDEpICsgXCIpXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWVzLnVuc2hpZnQodGFnTmFtZSk7XG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hbWVzLmpvaW4oJyA+ICcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZShjc3MpIHtcbiAgICAgIHJldHVybiBpc1N0cmluZyhjc3MpID8gQ1NTLmVzY2FwZShjc3MpIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb24oKSB7Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7YXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTt9XG4gICAgICBsZXQgW3RhcmdldHMsIHR5cGVzLCBzZWxlY3RvciwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZV0gPSBnZXRBcmdzKGFyZ3MpO1xuXG4gICAgICBpZiAobGlzdGVuZXIubGVuZ3RoID4gMSkge1xuICAgICAgICBsaXN0ZW5lciA9IGRldGFpbChsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VDYXB0dXJlICE9IG51bGwgJiYgdXNlQ2FwdHVyZS5zZWxmKSB7XG4gICAgICAgIGxpc3RlbmVyID0gc2VsZkZpbHRlcihsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBsaXN0ZW5lciA9IGRlbGVnYXRlKHNlbGVjdG9yLCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKSA9PiBvZmYodGFyZ2V0cywgdHlwZXMsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmYoKSB7Zm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7YXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO31cbiAgICAgIGxldCBbdGFyZ2V0cywgdHlwZXMsLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSA9IGZhbHNlXSA9IGdldEFyZ3MoYXJncyk7XG4gICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uY2UoKSB7Zm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7YXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO31cbiAgICAgIGNvbnN0IFtlbGVtZW50LCB0eXBlcywgc2VsZWN0b3IsIGxpc3RlbmVyLCB1c2VDYXB0dXJlID0gZmFsc2UsIGNvbmRpdGlvbl0gPSBnZXRBcmdzKGFyZ3MpO1xuICAgICAgY29uc3Qgb2ZmID0gb24oXG4gICAgICBlbGVtZW50LFxuICAgICAgdHlwZXMsXG4gICAgICBzZWxlY3RvcixcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICFjb25kaXRpb24gfHwgY29uZGl0aW9uKGUpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgb2ZmKCk7XG4gICAgICAgICAgbGlzdGVuZXIoZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZUNhcHR1cmUpO1xuXG5cbiAgICAgIHJldHVybiBvZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXRzLCBldmVudCwgZGV0YWlsKSB7XG4gICAgICByZXR1cm4gdG9FdmVudFRhcmdldHModGFyZ2V0cykuZXZlcnkoKHRhcmdldCkgPT5cbiAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlLCBkZXRhaWwpKSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFdmVudChlLCBidWJibGVzLCBjYW5jZWxhYmxlLCBkZXRhaWwpIHtpZiAoYnViYmxlcyA9PT0gdm9pZCAwKSB7YnViYmxlcyA9IHRydWU7fWlmIChjYW5jZWxhYmxlID09PSB2b2lkIDApIHtjYW5jZWxhYmxlID0gZmFsc2U7fVxuICAgICAgaWYgKGlzU3RyaW5nKGUpKSB7XG4gICAgICAgIGUgPSBuZXcgQ3VzdG9tRXZlbnQoZSwgeyBidWJibGVzLCBjYW5jZWxhYmxlLCBkZXRhaWwgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEFyZ3MoYXJncykge1xuICAgICAgLy8gRXZlbnQgdGFyZ2V0c1xuICAgICAgYXJnc1swXSA9IHRvRXZlbnRUYXJnZXRzKGFyZ3NbMF0pO1xuXG4gICAgICAvLyBFdmVudCB0eXBlc1xuICAgICAgaWYgKGlzU3RyaW5nKGFyZ3NbMV0pKSB7XG4gICAgICAgIGFyZ3NbMV0gPSBhcmdzWzFdLnNwbGl0KCcgJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlbGVnYXRlP1xuICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnc1syXSkpIHtcbiAgICAgICAgYXJncy5zcGxpY2UoMiwgMCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxlZ2F0ZShzZWxlY3RvciwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50ID1cbiAgICAgICAgc2VsZWN0b3JbMF0gPT09ICc+JyA/XG4gICAgICAgIGZpbmRBbGwoc2VsZWN0b3IsIGUuY3VycmVudFRhcmdldCkuXG4gICAgICAgIHJldmVyc2UoKS5cbiAgICAgICAgZmlsdGVyKChlbGVtZW50KSA9PiB3aXRoaW4oZS50YXJnZXQsIGVsZW1lbnQpKVswXSA6XG4gICAgICAgIGNsb3Nlc3QoZS50YXJnZXQsIHNlbGVjdG9yKTtcblxuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgIGUuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXRhaWwobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiAoZSkgPT4gaXNBcnJheShlLmRldGFpbCkgPyBsaXN0ZW5lcihlLCAuLi5lLmRldGFpbCkgOiBsaXN0ZW5lcihlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxmRmlsdGVyKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHwgZS50YXJnZXQgPT09IGUuY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxsKG51bGwsIGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0ICYmICdhZGRFdmVudExpc3RlbmVyJyBpbiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9FdmVudFRhcmdldCh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBpc0V2ZW50VGFyZ2V0KHRhcmdldCkgPyB0YXJnZXQgOiB0b05vZGUodGFyZ2V0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0V2ZW50VGFyZ2V0cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBpc0FycmF5KHRhcmdldCkgP1xuICAgICAgdGFyZ2V0Lm1hcCh0b0V2ZW50VGFyZ2V0KS5maWx0ZXIoQm9vbGVhbikgOlxuICAgICAgaXNTdHJpbmcodGFyZ2V0KSA/XG4gICAgICBmaW5kQWxsKHRhcmdldCkgOlxuICAgICAgaXNFdmVudFRhcmdldCh0YXJnZXQpID9cbiAgICAgIFt0YXJnZXRdIDpcbiAgICAgIHRvTm9kZXModGFyZ2V0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1RvdWNoKGUpIHtcbiAgICAgIHJldHVybiBlLnBvaW50ZXJUeXBlID09PSAndG91Y2gnIHx8ICEhZS50b3VjaGVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEV2ZW50UG9zKGUpIHt2YXIgX2UkdG91Y2hlcywgX2UkY2hhbmdlZFRvdWNoZXM7XG4gICAgICBjb25zdCB7IGNsaWVudFg6IHgsIGNsaWVudFk6IHkgfSA9ICgoX2UkdG91Y2hlcyA9IGUudG91Y2hlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJHRvdWNoZXNbMF0pIHx8ICgoX2UkY2hhbmdlZFRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2UkY2hhbmdlZFRvdWNoZXNbMF0pIHx8IGU7XG5cbiAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhamF4KHVybCwgb3B0aW9ucykge1xuICAgICAgY29uc3QgZW52ID0ge1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgeGhyOiBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcbiAgICAgICAgYmVmb3JlU2VuZDogbm9vcCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnJyxcbiAgICAgICAgLi4ub3B0aW9ucyB9O1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkuXG4gICAgICB0aGVuKCgpID0+IGVudi5iZWZvcmVTZW5kKGVudikpLlxuICAgICAgdGhlbigoKSA9PiBzZW5kKHVybCwgZW52KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VuZCh1cmwsIGVudikge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgeyB4aHIgfSA9IGVudjtcblxuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gZW52KSB7XG4gICAgICAgICAgaWYgKHByb3AgaW4geGhyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB4aHJbcHJvcF0gPSBlbnZbcHJvcF07XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4aHIub3BlbihlbnYubWV0aG9kLnRvVXBwZXJDYXNlKCksIHVybCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgaW4gZW52LmhlYWRlcnMpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGVudi5oZWFkZXJzW2hlYWRlcl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb24oeGhyLCAnbG9hZCcsICgpID0+IHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCB8fCB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwIHx8IHhoci5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh4aHIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBhc3NpZ24oRXJyb3IoeGhyLnN0YXR1c1RleHQpLCB7XG4gICAgICAgICAgICAgIHhocixcbiAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzIH0pKTtcblxuXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBvbih4aHIsICdlcnJvcicsICgpID0+IHJlamVjdChhc3NpZ24oRXJyb3IoJ05ldHdvcmsgRXJyb3InKSwgeyB4aHIgfSkpKTtcbiAgICAgICAgb24oeGhyLCAndGltZW91dCcsICgpID0+IHJlamVjdChhc3NpZ24oRXJyb3IoJ05ldHdvcmsgVGltZW91dCcpLCB7IHhociB9KSkpO1xuXG4gICAgICAgIHhoci5zZW5kKGVudi5kYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEltYWdlKHNyYywgc3Jjc2V0LCBzaXplcykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgaW1nLm9uZXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2l6ZXMgJiYgKGltZy5zaXplcyA9IHNpemVzKTtcbiAgICAgICAgc3Jjc2V0ICYmIChpbWcuc3Jjc2V0ID0gc3Jjc2V0KTtcbiAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNzc051bWJlciA9IHtcbiAgICAgICdhbmltYXRpb24taXRlcmF0aW9uLWNvdW50JzogdHJ1ZSxcbiAgICAgICdjb2x1bW4tY291bnQnOiB0cnVlLFxuICAgICAgJ2ZpbGwtb3BhY2l0eSc6IHRydWUsXG4gICAgICAnZmxleC1ncm93JzogdHJ1ZSxcbiAgICAgICdmbGV4LXNocmluayc6IHRydWUsXG4gICAgICAnZm9udC13ZWlnaHQnOiB0cnVlLFxuICAgICAgJ2xpbmUtaGVpZ2h0JzogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IHRydWUsXG4gICAgICBvcmRlcjogdHJ1ZSxcbiAgICAgIG9ycGhhbnM6IHRydWUsXG4gICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IHRydWUsXG4gICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiB0cnVlLFxuICAgICAgd2lkb3dzOiB0cnVlLFxuICAgICAgJ3otaW5kZXgnOiB0cnVlLFxuICAgICAgem9vbTogdHJ1ZSB9O1xuXG5cbiAgICBmdW5jdGlvbiBjc3MoZWxlbWVudCwgcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eSkge2lmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7cHJpb3JpdHkgPSAnJzt9XG4gICAgICBjb25zdCBlbGVtZW50cyA9IHRvTm9kZXMoZWxlbWVudCk7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgICAgIHByb3BlcnR5ID0gcHJvcE5hbWUocHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIGlzTnVtZXJpYyh2YWx1ZSkgJiYgIWNzc051bWJlcltwcm9wZXJ0eV0gP1xuICAgICAgICAgICAgdmFsdWUgKyBcInB4XCIgOlxuICAgICAgICAgICAgdmFsdWUgfHwgaXNOdW1iZXIodmFsdWUpID9cbiAgICAgICAgICAgIHZhbHVlIDpcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgcHJpb3JpdHkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocHJvcGVydHkpKSB7XG4gICAgICAgICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHByb3BzW3Byb3BdID0gY3NzKGVsZW1lbnQsIHByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocHJvcGVydHkpKSB7XG4gICAgICAgICAgcHJpb3JpdHkgPSB2YWx1ZTtcbiAgICAgICAgICBlYWNoKHByb3BlcnR5LCAodmFsdWUsIHByb3BlcnR5KSA9PiBjc3MoZWxlbWVudCwgcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudHNbMF07XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcGVydHlSZSA9IC9eXFxzKihbXCInXSk/KC4qPylcXDFcXHMqJC87XG4gICAgZnVuY3Rpb24gZ2V0Q3NzVmFyKG5hbWUsIGVsZW1lbnQpIHtpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7ZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDt9XG4gICAgICByZXR1cm4gY3NzKGVsZW1lbnQsIFwiLS11ay1cIiArIG5hbWUpLnJlcGxhY2UocHJvcGVydHlSZSwgJyQyJyk7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNkb20tY3Nzc3R5bGVkZWNsYXJhdGlvbi1zZXRwcm9wZXJ0eVxuICAgIGNvbnN0IHByb3BOYW1lID0gbWVtb2l6ZSgobmFtZSkgPT4gdmVuZG9yUHJvcE5hbWUobmFtZSkpO1xuXG4gICAgY29uc3QgY3NzUHJlZml4ZXMgPSBbJ3dlYmtpdCcsICdtb3onXTtcblxuICAgIGZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lWzBdID09PSAnLScpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIG5hbWUgPSBoeXBoZW5hdGUobmFtZSk7XG5cbiAgICAgIGNvbnN0IHsgc3R5bGUgfSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgaWYgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gY3NzUHJlZml4ZXMubGVuZ3RoLFxuICAgICAgcHJlZml4ZWROYW1lO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHByZWZpeGVkTmFtZSA9IFwiLVwiICsgY3NzUHJlZml4ZXNbaV0gKyBcIi1cIiArIG5hbWU7XG4gICAgICAgIGlmIChwcmVmaXhlZE5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ZWROYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCkge2ZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHthcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTt9XG4gICAgICBhcHBseSQxKGVsZW1lbnQsIGFyZ3MsICdhZGQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50KSB7Zm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHthcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO31cbiAgICAgIGFwcGx5JDEoZWxlbWVudCwgYXJncywgJ3JlbW92ZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoZWxlbWVudCwgY2xzKSB7XG4gICAgICBhdHRyKGVsZW1lbnQsICdjbGFzcycsICh2YWx1ZSkgPT4gKHZhbHVlIHx8ICcnKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgY2xzICsgXCJcXFxcYlwiLCAnZycpLCAnJykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VDbGFzcyhlbGVtZW50KSB7XG4gICAgICAoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdKSAmJiByZW1vdmVDbGFzcyhlbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0pO1xuICAgICAgKGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSkgJiYgYWRkQ2xhc3MoZWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbHMpIHtcbiAgICAgIFtjbHNdID0gZ2V0Q2xhc3NlcyhjbHMpO1xuICAgICAgcmV0dXJuICEhY2xzICYmIHRvTm9kZXMoZWxlbWVudCkuc29tZSgobm9kZSkgPT4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoY2xzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xzLCBmb3JjZSkge1xuICAgICAgY29uc3QgY2xhc3NlcyA9IGdldENsYXNzZXMoY2xzKTtcblxuICAgICAgaWYgKCFpc1VuZGVmaW5lZChmb3JjZSkpIHtcbiAgICAgICAgZm9yY2UgPSAhIWZvcmNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdG9Ob2RlcyhlbGVtZW50KSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNscyBvZiBjbGFzc2VzKSB7XG4gICAgICAgICAgbm9kZS5jbGFzc0xpc3QudG9nZ2xlKGNscywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkkMShlbGVtZW50LCBhcmdzLCBmbikge1xuICAgICAgYXJncyA9IGFyZ3MucmVkdWNlKChhcmdzLCBhcmcpID0+IGFyZ3MuY29uY2F0KGdldENsYXNzZXMoYXJnKSksIFtdKTtcblxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRvTm9kZXMoZWxlbWVudCkpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3RbZm5dKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENsYXNzZXMoc3RyKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHN0cikuc3BsaXQoL1xcc3wsLykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb24oZWxlbWVudCwgcHJvcHMsIGR1cmF0aW9uLCB0aW1pbmcpIHtpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge2R1cmF0aW9uID0gNDAwO31pZiAodGltaW5nID09PSB2b2lkIDApIHt0aW1pbmcgPSAnbGluZWFyJzt9XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICB0b05vZGVzKGVsZW1lbnQpLm1hcChcbiAgICAgIChlbGVtZW50KSA9PlxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNzcyhlbGVtZW50LCBuYW1lKTtcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICBjc3MoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0cmlnZ2VyKGVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJyksIGR1cmF0aW9uKTtcblxuICAgICAgICBvbmNlKFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICAndHJhbnNpdGlvbmVuZCB0cmFuc2l0aW9uY2FuY2VsZWQnLFxuICAgICAgICAoX3JlZikgPT4ge2xldCB7IHR5cGUgfSA9IF9yZWY7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCAndWstdHJhbnNpdGlvbicpO1xuICAgICAgICAgIGNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAnJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogJycgfSk7XG5cbiAgICAgICAgICB0eXBlID09PSAndHJhbnNpdGlvbmNhbmNlbGVkJyA/IHJlamVjdCgpIDogcmVzb2x2ZShlbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBzZWxmOiB0cnVlIH0pO1xuXG5cbiAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgJ3VrLXRyYW5zaXRpb24nKTtcbiAgICAgICAgY3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IE9iamVjdC5rZXlzKHByb3BzKS5tYXAocHJvcE5hbWUpLmpvaW4oJywnKSxcbiAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGR1cmF0aW9uICsgXCJtc1wiLFxuICAgICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogdGltaW5nLFxuICAgICAgICAgIC4uLnByb3BzIH0pO1xuXG4gICAgICB9KSkpO1xuXG5cbiAgICB9XG5cbiAgICBjb25zdCBUcmFuc2l0aW9uID0ge1xuICAgICAgc3RhcnQ6IHRyYW5zaXRpb24sXG5cbiAgICAgIHN0b3AoZWxlbWVudCkge1xuICAgICAgICB0cmlnZ2VyKGVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH0sXG5cbiAgICAgIGNhbmNlbChlbGVtZW50KSB7XG4gICAgICAgIHRyaWdnZXIoZWxlbWVudCwgJ3RyYW5zaXRpb25jYW5jZWxlZCcpO1xuICAgICAgfSxcblxuICAgICAgaW5Qcm9ncmVzcyhlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBoYXNDbGFzcyhlbGVtZW50LCAndWstdHJhbnNpdGlvbicpO1xuICAgICAgfSB9O1xuXG5cbiAgICBjb25zdCBhbmltYXRpb25QcmVmaXggPSAndWstYW5pbWF0aW9uLSc7XG5cbiAgICBmdW5jdGlvbiBhbmltYXRlJDEoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luLCBvdXQpIHtpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge2R1cmF0aW9uID0gMjAwO31cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKFxuICAgICAgKGVsZW1lbnQpID0+XG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyaWdnZXIoZWxlbWVudCwgJ2FuaW1hdGlvbmNhbmNlbGVkJyk7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0cmlnZ2VyKGVsZW1lbnQsICdhbmltYXRpb25lbmQnKSwgZHVyYXRpb24pO1xuXG4gICAgICAgIG9uY2UoXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgICdhbmltYXRpb25lbmQgYW5pbWF0aW9uY2FuY2VsZWQnLFxuICAgICAgICAoX3JlZjIpID0+IHtsZXQgeyB0eXBlIH0gPSBfcmVmMjtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgICAgdHlwZSA9PT0gJ2FuaW1hdGlvbmNhbmNlbGVkJyA/IHJlamVjdCgpIDogcmVzb2x2ZShlbGVtZW50KTtcblxuICAgICAgICAgIGNzcyhlbGVtZW50LCAnYW5pbWF0aW9uRHVyYXRpb24nLCAnJyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3NlcyhlbGVtZW50LCBhbmltYXRpb25QcmVmaXggKyBcIlxcXFxTKlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBzZWxmOiB0cnVlIH0pO1xuXG5cbiAgICAgICAgY3NzKGVsZW1lbnQsICdhbmltYXRpb25EdXJhdGlvbicsIGR1cmF0aW9uICsgXCJtc1wiKTtcbiAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgYW5pbWF0aW9uLCBhbmltYXRpb25QcmVmaXggKyAob3V0ID8gJ2xlYXZlJyA6ICdlbnRlcicpKTtcblxuICAgICAgICBpZiAoc3RhcnRzV2l0aChhbmltYXRpb24sIGFuaW1hdGlvblByZWZpeCkpIHtcbiAgICAgICAgICBvcmlnaW4gJiYgYWRkQ2xhc3MoZWxlbWVudCwgXCJ1ay10cmFuc2Zvcm0tb3JpZ2luLVwiICsgb3JpZ2luKTtcbiAgICAgICAgICBvdXQgJiYgYWRkQ2xhc3MoZWxlbWVudCwgYW5pbWF0aW9uUHJlZml4ICsgXCJyZXZlcnNlXCIpO1xuICAgICAgICB9XG4gICAgICB9KSkpO1xuXG5cbiAgICB9XG5cbiAgICBjb25zdCBpblByb2dyZXNzID0gbmV3IFJlZ0V4cChhbmltYXRpb25QcmVmaXggKyBcIihlbnRlcnxsZWF2ZSlcIik7XG4gICAgY29uc3QgQW5pbWF0aW9uID0ge1xuICAgICAgaW46IGFuaW1hdGUkMSxcblxuICAgICAgb3V0KGVsZW1lbnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0ZSQxKGVsZW1lbnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIG9yaWdpbiwgdHJ1ZSk7XG4gICAgICB9LFxuXG4gICAgICBpblByb2dyZXNzKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGluUHJvZ3Jlc3MudGVzdChhdHRyKGVsZW1lbnQsICdjbGFzcycpKTtcbiAgICAgIH0sXG5cbiAgICAgIGNhbmNlbChlbGVtZW50KSB7XG4gICAgICAgIHRyaWdnZXIoZWxlbWVudCwgJ2FuaW1hdGlvbmNhbmNlbGVkJyk7XG4gICAgICB9IH07XG5cbiAgICBjb25zdCBkaXJzJDEgPSB7XG4gICAgICB3aWR0aDogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICBoZWlnaHQ6IFsndG9wJywgJ2JvdHRvbSddIH07XG5cblxuICAgIGZ1bmN0aW9uIGRpbWVuc2lvbnMkMShlbGVtZW50KSB7XG4gICAgICBjb25zdCByZWN0ID0gaXNFbGVtZW50KGVsZW1lbnQpID9cbiAgICAgIHRvTm9kZShlbGVtZW50KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6XG4gICAgICB7IGhlaWdodDogaGVpZ2h0KGVsZW1lbnQpLCB3aWR0aDogd2lkdGgoZWxlbWVudCksIHRvcDogMCwgbGVmdDogMCB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgICBib3R0b206IHJlY3QudG9wICsgcmVjdC5oZWlnaHQsXG4gICAgICAgIHJpZ2h0OiByZWN0LmxlZnQgKyByZWN0LndpZHRoIH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXQoZWxlbWVudCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRPZmZzZXQgPSBkaW1lbnNpb25zJDEoZWxlbWVudCk7XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsWSwgc2Nyb2xsWCB9ID0gdG9XaW5kb3coZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IG9mZnNldEJ5ID0geyBoZWlnaHQ6IHNjcm9sbFksIHdpZHRoOiBzY3JvbGxYIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBkaXIgaW4gZGlycyQxKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGRpcnMkMVtkaXJdKSB7XG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0W3Byb3BdICs9IG9mZnNldEJ5W2Rpcl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvcyA9IGNzcyhlbGVtZW50LCAncG9zaXRpb24nKTtcblxuICAgICAgZWFjaChjc3MoZWxlbWVudCwgWydsZWZ0JywgJ3RvcCddKSwgKHZhbHVlLCBwcm9wKSA9PlxuICAgICAgY3NzKFxuICAgICAgZWxlbWVudCxcbiAgICAgIHByb3AsXG4gICAgICBjb29yZGluYXRlc1twcm9wXSAtXG4gICAgICBjdXJyZW50T2Zmc2V0W3Byb3BdICtcbiAgICAgIHRvRmxvYXQocG9zID09PSAnYWJzb2x1dGUnICYmIHZhbHVlID09PSAnYXV0bycgPyBwb3NpdGlvbihlbGVtZW50KVtwcm9wXSA6IHZhbHVlKSkpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbihlbGVtZW50KSB7XG4gICAgICBsZXQgeyB0b3AsIGxlZnQgfSA9IG9mZnNldChlbGVtZW50KTtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBvd25lckRvY3VtZW50OiB7IGJvZHksIGRvY3VtZW50RWxlbWVudCB9LFxuICAgICAgICBvZmZzZXRQYXJlbnQgfSA9XG4gICAgICB0b05vZGUoZWxlbWVudCk7XG4gICAgICBsZXQgcGFyZW50ID0gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblxuICAgICAgd2hpbGUgKFxuICAgICAgcGFyZW50ICYmIChcbiAgICAgIHBhcmVudCA9PT0gYm9keSB8fCBwYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCkgJiZcbiAgICAgIGNzcyhwYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJylcbiAgICAgIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VsZW1lbnQocGFyZW50KSkge1xuICAgICAgICBjb25zdCBwYXJlbnRPZmZzZXQgPSBvZmZzZXQocGFyZW50KTtcbiAgICAgICAgdG9wIC09IHBhcmVudE9mZnNldC50b3AgKyB0b0Zsb2F0KGNzcyhwYXJlbnQsICdib3JkZXJUb3BXaWR0aCcpKTtcbiAgICAgICAgbGVmdCAtPSBwYXJlbnRPZmZzZXQubGVmdCArIHRvRmxvYXQoY3NzKHBhcmVudCwgJ2JvcmRlckxlZnRXaWR0aCcpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0b3AgLSB0b0Zsb2F0KGNzcyhlbGVtZW50LCAnbWFyZ2luVG9wJykpLFxuICAgICAgICBsZWZ0OiBsZWZ0IC0gdG9GbG9hdChjc3MoZWxlbWVudCwgJ21hcmdpbkxlZnQnKSkgfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldFBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IFswLCAwXTtcblxuICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcblxuICAgICAgZG8ge1xuICAgICAgICBvZmZzZXRbMF0gKz0gZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgICAgIG9mZnNldFsxXSArPSBlbGVtZW50Lm9mZnNldExlZnQ7XG5cbiAgICAgICAgaWYgKGNzcyhlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgIGNvbnN0IHdpbiA9IHRvV2luZG93KGVsZW1lbnQpO1xuICAgICAgICAgIG9mZnNldFswXSArPSB3aW4uc2Nyb2xsWTtcbiAgICAgICAgICBvZmZzZXRbMV0gKz0gd2luLnNjcm9sbFg7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50KTtcblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBjb25zdCBoZWlnaHQgPSBkaW1lbnNpb24oJ2hlaWdodCcpO1xuICAgIGNvbnN0IHdpZHRoID0gZGltZW5zaW9uKCd3aWR0aCcpO1xuXG4gICAgZnVuY3Rpb24gZGltZW5zaW9uKHByb3ApIHtcbiAgICAgIGNvbnN0IHByb3BOYW1lID0gdWNmaXJzdChwcm9wKTtcbiAgICAgIHJldHVybiAoZWxlbWVudCwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChpc1dpbmRvdyhlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRbXCJpbm5lclwiICsgcHJvcE5hbWVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0RvY3VtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBlbGVtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChkb2NbXCJvZmZzZXRcIiArIHByb3BOYW1lXSwgZG9jW1wic2Nyb2xsXCIgKyBwcm9wTmFtZV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnQgPSB0b05vZGUoZWxlbWVudCk7XG5cbiAgICAgICAgICB2YWx1ZSA9IGNzcyhlbGVtZW50LCBwcm9wKTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSAnYXV0bycgPyBlbGVtZW50W1wib2Zmc2V0XCIgKyBwcm9wTmFtZV0gOiB0b0Zsb2F0KHZhbHVlKSB8fCAwO1xuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlIC0gYm94TW9kZWxBZGp1c3QoZWxlbWVudCwgcHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNzcyhcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHByb3AsXG4gICAgICAgICAgIXZhbHVlICYmIHZhbHVlICE9PSAwID8gJycgOiArdmFsdWUgKyBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wKSArICdweCcpO1xuXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYm94TW9kZWxBZGp1c3QoZWxlbWVudCwgcHJvcCwgc2l6aW5nKSB7aWYgKHNpemluZyA9PT0gdm9pZCAwKSB7c2l6aW5nID0gJ2JvcmRlci1ib3gnO31cbiAgICAgIHJldHVybiBjc3MoZWxlbWVudCwgJ2JveFNpemluZycpID09PSBzaXppbmcgP1xuICAgICAgZGlycyQxW3Byb3BdLlxuICAgICAgbWFwKHVjZmlyc3QpLlxuICAgICAgcmVkdWNlKFxuICAgICAgKHZhbHVlLCBwcm9wKSA9PlxuICAgICAgdmFsdWUgK1xuICAgICAgdG9GbG9hdChjc3MoZWxlbWVudCwgXCJwYWRkaW5nXCIgKyBwcm9wKSkgK1xuICAgICAgdG9GbG9hdChjc3MoZWxlbWVudCwgXCJib3JkZXJcIiArIHByb3AgKyBcIldpZHRoXCIpKSxcbiAgICAgIDApIDpcblxuICAgICAgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbGlwUG9zaXRpb24ocG9zKSB7XG4gICAgICBmb3IgKGNvbnN0IGRpciBpbiBkaXJzJDEpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIGluIGRpcnMkMVtkaXJdKSB7XG4gICAgICAgICAgaWYgKGRpcnMkMVtkaXJdW2ldID09PSBwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXJzJDFbZGlyXVsxIC0gaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvUHgodmFsdWUsIHByb3BlcnR5LCBlbGVtZW50LCBvZmZzZXREaW0pIHtpZiAocHJvcGVydHkgPT09IHZvaWQgMCkge3Byb3BlcnR5ID0gJ3dpZHRoJzt9aWYgKGVsZW1lbnQgPT09IHZvaWQgMCkge2VsZW1lbnQgPSB3aW5kb3c7fWlmIChvZmZzZXREaW0gPT09IHZvaWQgMCkge29mZnNldERpbSA9IGZhbHNlO31cbiAgICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0b0Zsb2F0KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlQ2FsYyh2YWx1ZSkucmVkdWNlKChyZXN1bHQsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuaXQgPSBwYXJzZVVuaXQodmFsdWUpO1xuICAgICAgICBpZiAodW5pdCkge1xuICAgICAgICAgIHZhbHVlID0gcGVyY2VudChcbiAgICAgICAgICB1bml0ID09PSAndmgnID9cbiAgICAgICAgICBoZWlnaHQodG9XaW5kb3coZWxlbWVudCkpIDpcbiAgICAgICAgICB1bml0ID09PSAndncnID9cbiAgICAgICAgICB3aWR0aCh0b1dpbmRvdyhlbGVtZW50KSkgOlxuICAgICAgICAgIG9mZnNldERpbSA/XG4gICAgICAgICAgZWxlbWVudFtcIm9mZnNldFwiICsgdWNmaXJzdChwcm9wZXJ0eSldIDpcbiAgICAgICAgICBkaW1lbnNpb25zJDEoZWxlbWVudClbcHJvcGVydHldLFxuICAgICAgICAgIHZhbHVlKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHRvRmxvYXQodmFsdWUpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgY29uc3QgY2FsY1JlID0gLy0/XFxkKyg/OlxcLlxcZCspPyg/OnZbd2hdfCV8cHgpPy9nO1xuICAgIGNvbnN0IHBhcnNlQ2FsYyA9IG1lbW9pemUoKGNhbGMpID0+IGNhbGMudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMvZywgJycpLm1hdGNoKGNhbGNSZSkgfHwgW10pO1xuICAgIGNvbnN0IHVuaXRSZSQxID0gLyg/OnZbaHddfCUpJC87XG4gICAgY29uc3QgcGFyc2VVbml0ID0gbWVtb2l6ZSgoc3RyKSA9PiAoc3RyLm1hdGNoKHVuaXRSZSQxKSB8fCBbXSlbMF0pO1xuXG4gICAgZnVuY3Rpb24gcGVyY2VudChiYXNlLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2UgKiB0b0Zsb2F0KHZhbHVlKSAvIDEwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkeShmbikge1xuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICBmbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9uY2UoZG9jdW1lbnQsICdET01Db250ZW50TG9hZGVkJywgZm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVGFnKGVsZW1lbnQsIHRhZ05hbWUpIHt2YXIgX2VsZW1lbnQkdGFnTmFtZTtcbiAgICAgIHJldHVybiAoZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogKF9lbGVtZW50JHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCR0YWdOYW1lLnRvTG93ZXJDYXNlKCkpID09PSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1wdHkoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHJlcGxhY2VDaGlsZHJlbihlbGVtZW50LCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHRtbChwYXJlbnQsIGh0bWwpIHtcbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZChodG1sKSA/ICQocGFyZW50KS5pbm5lckhUTUwgOiByZXBsYWNlQ2hpbGRyZW4ocGFyZW50LCBodG1sKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXBsYWNlQ2hpbGRyZW4gPSBhcHBseUZuKCdyZXBsYWNlQ2hpbGRyZW4nKTtcbiAgICBjb25zdCBwcmVwZW5kID0gYXBwbHlGbigncHJlcGVuZCcpO1xuICAgIGNvbnN0IGFwcGVuZCA9IGFwcGx5Rm4oJ2FwcGVuZCcpO1xuICAgIGNvbnN0IGJlZm9yZSA9IGFwcGx5Rm4oJ2JlZm9yZScpO1xuICAgIGNvbnN0IGFmdGVyID0gYXBwbHlGbignYWZ0ZXInKTtcblxuICAgIGZ1bmN0aW9uIGFwcGx5Rm4oZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocmVmLCBlbGVtZW50KSB7dmFyIF8kO1xuICAgICAgICBjb25zdCBub2RlcyA9IHRvTm9kZXMoaXNTdHJpbmcoZWxlbWVudCkgPyBmcmFnbWVudChlbGVtZW50KSA6IGVsZW1lbnQpO1xuICAgICAgICAoXyQgPSAkKHJlZikpID09IG51bGwgPyB2b2lkIDAgOiBfJFtmbl0oLi4ubm9kZXMpO1xuICAgICAgICByZXR1cm4gdW53cmFwU2luZ2xlKG5vZGVzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlJDEoZWxlbWVudCkge1xuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5mb3JFYWNoKChlbGVtZW50KSA9PiBlbGVtZW50LnJlbW92ZSgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwQWxsKGVsZW1lbnQsIHN0cnVjdHVyZSkge1xuICAgICAgc3RydWN0dXJlID0gdG9Ob2RlKGJlZm9yZShlbGVtZW50LCBzdHJ1Y3R1cmUpKTtcblxuICAgICAgd2hpbGUgKHN0cnVjdHVyZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHN0cnVjdHVyZSA9IHN0cnVjdHVyZS5maXJzdENoaWxkO1xuICAgICAgfVxuXG4gICAgICBhcHBlbmQoc3RydWN0dXJlLCBlbGVtZW50KTtcblxuICAgICAgcmV0dXJuIHN0cnVjdHVyZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwSW5uZXIoZWxlbWVudCwgc3RydWN0dXJlKSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKChlbGVtZW50KSA9PlxuICAgICAgZWxlbWVudC5oYXNDaGlsZE5vZGVzKCkgP1xuICAgICAgd3JhcEFsbCh0b05vZGVzKGVsZW1lbnQuY2hpbGROb2RlcyksIHN0cnVjdHVyZSkgOlxuICAgICAgYXBwZW5kKGVsZW1lbnQsIHN0cnVjdHVyZSkpKTtcblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW53cmFwKGVsZW1lbnQpIHtcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkuXG4gICAgICBtYXAocGFyZW50KS5cbiAgICAgIGZpbHRlcigodmFsdWUsIGluZGV4LCBzZWxmKSA9PiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleCkuXG4gICAgICBmb3JFYWNoKChwYXJlbnQpID0+IHBhcmVudC5yZXBsYWNlV2l0aCguLi5wYXJlbnQuY2hpbGROb2RlcykpO1xuICAgIH1cblxuICAgIGNvbnN0IGZyYWdtZW50UmUgPSAvXlxccyo8KFxcdyt8ISlbXj5dKj4vO1xuICAgIGNvbnN0IHNpbmdsZVRhZ1JlID0gL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT4pPyQvO1xuXG4gICAgZnVuY3Rpb24gZnJhZ21lbnQoaHRtbCkge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IHNpbmdsZVRhZ1JlLmV4ZWMoaHRtbCk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChtYXRjaGVzWzFdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpZiAoZnJhZ21lbnRSZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGh0bWwudHJpbSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci50ZXh0Q29udGVudCA9IGh0bWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bndyYXBTaW5nbGUoY29udGFpbmVyLmNoaWxkTm9kZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVud3JhcFNpbmdsZShub2Rlcykge1xuICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDEgPyBub2RlcyA6IG5vZGVzWzBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5KG5vZGUsIGZuKSB7XG4gICAgICBpZiAoIWlzRWxlbWVudChub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZuKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGFwcGx5KG5vZGUsIGZuKTtcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGlzSHRtbChzZWxlY3RvcikgPyB0b05vZGUoZnJhZ21lbnQoc2VsZWN0b3IpKSA6IGZpbmQoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gaXNIdG1sKHNlbGVjdG9yKSA/IHRvTm9kZXMoZnJhZ21lbnQoc2VsZWN0b3IpKSA6IGZpbmRBbGwoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSHRtbChzdHIpIHtcbiAgICAgIHJldHVybiBpc1N0cmluZyhzdHIpICYmIHN0YXJ0c1dpdGgoc3RyLnRyaW0oKSwgJzwnKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgICBjb25zdCBpc1J0bCA9IGluQnJvd3NlciAmJiBhdHRyKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ2RpcicpID09PSAncnRsJztcblxuICAgIGNvbnN0IGhhc1RvdWNoID0gaW5Ccm93c2VyICYmICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcbiAgICBjb25zdCBoYXNQb2ludGVyRXZlbnRzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5Qb2ludGVyRXZlbnQ7XG5cbiAgICBjb25zdCBwb2ludGVyRG93biA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcmRvd24nIDogaGFzVG91Y2ggPyAndG91Y2hzdGFydCcgOiAnbW91c2Vkb3duJztcbiAgICBjb25zdCBwb2ludGVyTW92ZSA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcm1vdmUnIDogaGFzVG91Y2ggPyAndG91Y2htb3ZlJyA6ICdtb3VzZW1vdmUnO1xuICAgIGNvbnN0IHBvaW50ZXJVcCA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcnVwJyA6IGhhc1RvdWNoID8gJ3RvdWNoZW5kJyA6ICdtb3VzZXVwJztcbiAgICBjb25zdCBwb2ludGVyRW50ZXIgPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJlbnRlcicgOiBoYXNUb3VjaCA/ICcnIDogJ21vdXNlZW50ZXInO1xuICAgIGNvbnN0IHBvaW50ZXJMZWF2ZSA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcmxlYXZlJyA6IGhhc1RvdWNoID8gJycgOiAnbW91c2VsZWF2ZSc7XG4gICAgY29uc3QgcG9pbnRlckNhbmNlbCA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcmNhbmNlbCcgOiAndG91Y2hjYW5jZWwnO1xuXG4gICAgLypcbiAgICAgICAgQmFzZWQgb246XG4gICAgICAgIENvcHlyaWdodCAoYykgMjAxNiBXaWxzb24gUGFnZSB3aWxzb25wYWdlQG1lLmNvbVxuICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vd2lsc29ucGFnZS9mYXN0ZG9tXG4gICAgKi9cblxuICAgIGNvbnN0IGZhc3Rkb20gPSB7XG4gICAgICByZWFkczogW10sXG4gICAgICB3cml0ZXM6IFtdLFxuXG4gICAgICByZWFkKHRhc2spIHtcbiAgICAgICAgdGhpcy5yZWFkcy5wdXNoKHRhc2spO1xuICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgfSxcblxuICAgICAgd3JpdGUodGFzaykge1xuICAgICAgICB0aGlzLndyaXRlcy5wdXNoKHRhc2spO1xuICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgfSxcblxuICAgICAgY2xlYXIodGFzaykge1xuICAgICAgICByZW1vdmUodGhpcy5yZWFkcywgdGFzayk7XG4gICAgICAgIHJlbW92ZSh0aGlzLndyaXRlcywgdGFzayk7XG4gICAgICB9LFxuXG4gICAgICBmbHVzaCB9O1xuXG5cbiAgICBmdW5jdGlvbiBmbHVzaChyZWN1cnNpb24pIHtcbiAgICAgIHJ1blRhc2tzKGZhc3Rkb20ucmVhZHMpO1xuICAgICAgcnVuVGFza3MoZmFzdGRvbS53cml0ZXMuc3BsaWNlKDApKTtcblxuICAgICAgZmFzdGRvbS5zY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGZhc3Rkb20ucmVhZHMubGVuZ3RoIHx8IGZhc3Rkb20ud3JpdGVzLmxlbmd0aCkge1xuICAgICAgICBzY2hlZHVsZUZsdXNoKHJlY3Vyc2lvbiArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDQ7XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVGbHVzaChyZWN1cnNpb24pIHtcbiAgICAgIGlmIChmYXN0ZG9tLnNjaGVkdWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZhc3Rkb20uc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIGlmIChyZWN1cnNpb24gJiYgcmVjdXJzaW9uIDwgUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZmx1c2gocmVjdXJzaW9uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZmx1c2goMSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1blRhc2tzKHRhc2tzKSB7XG4gICAgICBsZXQgdGFzaztcbiAgICAgIHdoaWxlICh0YXNrID0gdGFza3Muc2hpZnQoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIGl0ZW0pIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICAgIHJldHVybiB+aW5kZXggJiYgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNb3VzZVRyYWNrZXIoKSB7fVxuXG4gICAgTW91c2VUcmFja2VyLnByb3RvdHlwZSA9IHtcbiAgICAgIHBvc2l0aW9uczogW10sXG5cbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gW107XG5cbiAgICAgICAgbGV0IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLnVuYmluZCA9IG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgKGUpID0+IHBvc2l0aW9uID0gZ2V0RXZlbnRQb3MoZSkpO1xuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9ucy5sZW5ndGggPiA1KSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTApO1xuICAgICAgfSxcblxuICAgICAgY2FuY2VsKCkge3ZhciBfdGhpcyR1bmJpbmQ7XG4gICAgICAgIChfdGhpcyR1bmJpbmQgPSB0aGlzLnVuYmluZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHVuYmluZC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICB9LFxuXG4gICAgICBtb3Zlc1RvKHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHAgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSBwO1xuXG4gICAgICAgIGNvbnN0IFtwcmV2UG9zaXRpb25dID0gdGhpcy5wb3NpdGlvbnM7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbGFzdCh0aGlzLnBvc2l0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBbcHJldlBvc2l0aW9uLCBwb3NpdGlvbl07XG5cbiAgICAgICAgaWYgKHBvaW50SW5SZWN0KHBvc2l0aW9uLCBwKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRpYWdvbmFscyA9IFtcbiAgICAgICAgW1xuICAgICAgICB7IHg6IGxlZnQsIHk6IHRvcCB9LFxuICAgICAgICB7IHg6IHJpZ2h0LCB5OiBib3R0b20gfV0sXG5cbiAgICAgICAgW1xuICAgICAgICB7IHg6IGxlZnQsIHk6IGJvdHRvbSB9LFxuICAgICAgICB7IHg6IHJpZ2h0LCB5OiB0b3AgfV1dO1xuXG5cblxuICAgICAgICByZXR1cm4gZGlhZ29uYWxzLnNvbWUoKGRpYWdvbmFsKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0KHBhdGgsIGRpYWdvbmFsKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uICYmIHBvaW50SW5SZWN0KGludGVyc2VjdGlvbiwgcCk7XG4gICAgICAgIH0pO1xuICAgICAgfSB9O1xuXG5cbiAgICAvLyBJbnNwaXJlZCBieSBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZ2VvbWV0cnkvcG9pbnRsaW5lcGxhbmUvXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0KF9yZWYsIF9yZWYyKSB7bGV0IFt7IHg6IHgxLCB5OiB5MSB9LCB7IHg6IHgyLCB5OiB5MiB9XSA9IF9yZWY7bGV0IFt7IHg6IHgzLCB5OiB5MyB9LCB7IHg6IHg0LCB5OiB5NCB9XSA9IF9yZWYyO1xuICAgICAgY29uc3QgZGVub21pbmF0b3IgPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG5cbiAgICAgIC8vIExpbmVzIGFyZSBwYXJhbGxlbFxuICAgICAgaWYgKGRlbm9taW5hdG9yID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdWEgPSAoKHg0IC0geDMpICogKHkxIC0geTMpIC0gKHk0IC0geTMpICogKHgxIC0geDMpKSAvIGRlbm9taW5hdG9yO1xuXG4gICAgICBpZiAodWEgPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgIHJldHVybiB7IHg6IHgxICsgdWEgKiAoeDIgLSB4MSksIHk6IHkxICsgdWEgKiAoeTIgLSB5MSkgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvYnNlcnZlSW50ZXJzZWN0aW9uKHRhcmdldHMsIGNiLCBvcHRpb25zLCBpbnRlcnNlY3RpbmcpIHtpZiAoaW50ZXJzZWN0aW5nID09PSB2b2lkIDApIHtpbnRlcnNlY3RpbmcgPSB0cnVlO31cbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgaW50ZXJzZWN0aW5nID9cbiAgICAgIChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICBpZiAoZW50cmllcy5zb21lKChlbnRyeSkgPT4gZW50cnkuaXNJbnRlcnNlY3RpbmcpKSB7XG4gICAgICAgICAgY2IoZW50cmllcywgb2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9IDpcbiAgICAgIGNiLFxuICAgICAgb3B0aW9ucyk7XG5cbiAgICAgIGZvciAoY29uc3QgZWwgb2YgdG9Ob2Rlcyh0YXJnZXRzKSkge1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc1Jlc2l6ZU9ic2VydmVyID0gaW5Ccm93c2VyICYmIHdpbmRvdy5SZXNpemVPYnNlcnZlcjtcbiAgICBmdW5jdGlvbiBvYnNlcnZlUmVzaXplKHRhcmdldHMsIGNiLCBvcHRpb25zKSB7aWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge29wdGlvbnMgPSB7IGJveDogJ2JvcmRlci1ib3gnIH07fVxuICAgICAgaWYgKGhhc1Jlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZlKFJlc2l6ZU9ic2VydmVyLCB0YXJnZXRzLCBjYiwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZhbGxiYWNrIFNhZmFyaSA8IDEzLjFcbiAgICAgIGluaXRSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgbGlzdGVuZXJzLmFkZChjYik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShjYik7XG4gICAgICAgIH0gfTtcblxuICAgIH1cblxuICAgIGxldCBsaXN0ZW5lcnM7XG4gICAgZnVuY3Rpb24gaW5pdFJlc2l6ZUxpc3RlbmVyKCkge1xuICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gdGhyb3R0bGUgJ3Jlc2l6ZSdcbiAgICAgIGxldCBwZW5kaW5nUmVzaXplO1xuICAgICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICBpZiAocGVuZGluZ1Jlc2l6ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgZmFzdGRvbS5yZWFkKCgpID0+IHBlbmRpbmdSZXNpemUgPSBmYWxzZSk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgb24od2luZG93LCAnbG9hZCByZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgb24oZG9jdW1lbnQsICdsb2FkZWRtZXRhZGF0YSBsb2FkJywgaGFuZGxlUmVzaXplLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvYnNlcnZlTXV0YXRpb24odGFyZ2V0cywgY2IsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlKE11dGF0aW9uT2JzZXJ2ZXIsIHRhcmdldHMsIGNiLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvYnNlcnZlKE9ic2VydmVyLCB0YXJnZXRzLCBjYiwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIoY2IpO1xuICAgICAgZm9yIChjb25zdCBlbCBvZiB0b05vZGVzKHRhcmdldHMpKSB7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyYXRzID0ge307XG5cbiAgICBzdHJhdHMuZXZlbnRzID1cbiAgICBzdHJhdHMuY3JlYXRlZCA9XG4gICAgc3RyYXRzLmJlZm9yZUNvbm5lY3QgPVxuICAgIHN0cmF0cy5jb25uZWN0ZWQgPVxuICAgIHN0cmF0cy5iZWZvcmVEaXNjb25uZWN0ID1cbiAgICBzdHJhdHMuZGlzY29ubmVjdGVkID1cbiAgICBzdHJhdHMuZGVzdHJveSA9XG4gICAgY29uY2F0U3RyYXQ7XG5cbiAgICAvLyBhcmdzIHN0cmF0ZWd5XG4gICAgc3RyYXRzLmFyZ3MgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsICE9PSBmYWxzZSAmJiBjb25jYXRTdHJhdChjaGlsZFZhbCB8fCBwYXJlbnRWYWwpO1xuICAgIH07XG5cbiAgICAvLyB1cGRhdGUgc3RyYXRlZ3lcbiAgICBzdHJhdHMudXBkYXRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBzb3J0QnkkMShcbiAgICAgIGNvbmNhdFN0cmF0KHBhcmVudFZhbCwgaXNGdW5jdGlvbihjaGlsZFZhbCkgPyB7IHJlYWQ6IGNoaWxkVmFsIH0gOiBjaGlsZFZhbCksXG4gICAgICAnb3JkZXInKTtcblxuICAgIH07XG5cbiAgICAvLyBwcm9wZXJ0eSBzdHJhdGVneVxuICAgIHN0cmF0cy5wcm9wcyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICBpZiAoaXNBcnJheShjaGlsZFZhbCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgY2hpbGRWYWwpIHtcbiAgICAgICAgICB2YWx1ZVtrZXldID0gU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkVmFsID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJhdHMubWV0aG9kcyhwYXJlbnRWYWwsIGNoaWxkVmFsKTtcbiAgICB9O1xuXG4gICAgLy8gZXh0ZW5kIHN0cmF0ZWd5XG4gICAgc3RyYXRzLmNvbXB1dGVkID0gc3RyYXRzLm1ldGhvZHMgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsID8gcGFyZW50VmFsID8geyAuLi5wYXJlbnRWYWwsIC4uLmNoaWxkVmFsIH0gOiBjaGlsZFZhbCA6IHBhcmVudFZhbDtcbiAgICB9O1xuXG4gICAgLy8gZGF0YSBzdHJhdGVneVxuICAgIHN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gICAgICBpZiAoIXZtKSB7XG4gICAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50VmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZtKSB7XG4gICAgICAgICAgcmV0dXJuIG1lcmdlRm5EYXRhKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlRm5EYXRhKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWVyZ2VGbkRhdGEocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgICAgIHJldHVybiBzdHJhdHMuY29tcHV0ZWQoXG4gICAgICBpc0Z1bmN0aW9uKHBhcmVudFZhbCkgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pIDogcGFyZW50VmFsLFxuICAgICAgaXNGdW5jdGlvbihjaGlsZFZhbCkgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSkgOiBjaGlsZFZhbCk7XG5cbiAgICB9XG5cbiAgICAvLyBjb25jYXQgc3RyYXRlZ3lcbiAgICBmdW5jdGlvbiBjb25jYXRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICBwYXJlbnRWYWwgPSBwYXJlbnRWYWwgJiYgIWlzQXJyYXkocGFyZW50VmFsKSA/IFtwYXJlbnRWYWxdIDogcGFyZW50VmFsO1xuXG4gICAgICByZXR1cm4gY2hpbGRWYWwgP1xuICAgICAgcGFyZW50VmFsID9cbiAgICAgIHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDpcbiAgICAgIGlzQXJyYXkoY2hpbGRWYWwpID9cbiAgICAgIGNoaWxkVmFsIDpcbiAgICAgIFtjaGlsZFZhbF0gOlxuICAgICAgcGFyZW50VmFsO1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgc3RyYXRlZ3lcbiAgICBmdW5jdGlvbiBkZWZhdWx0U3RyYXQocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGNoaWxkVmFsKSA/IHBhcmVudFZhbCA6IGNoaWxkVmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLCB2bSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBtaXhpbiBvZiBjaGlsZC5taXhpbnMpIHtcbiAgICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbiwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmVudCkge1xuICAgICAgICBtZXJnZUtleShrZXkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZCkge1xuICAgICAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgICAgICBtZXJnZUtleShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1lcmdlS2V5KGtleSkge1xuICAgICAgICBvcHRpb25zW2tleV0gPSAoc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0KShwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0aW9ucywgYXJncykge2lmIChhcmdzID09PSB2b2lkIDApIHthcmdzID0gW107fVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMgP1xuICAgICAgICBzdGFydHNXaXRoKG9wdGlvbnMsICd7JykgP1xuICAgICAgICBKU09OLnBhcnNlKG9wdGlvbnMpIDpcbiAgICAgICAgYXJncy5sZW5ndGggJiYgIWluY2x1ZGVzKG9wdGlvbnMsICc6JykgP1xuICAgICAgICB7IFthcmdzWzBdXTogb3B0aW9ucyB9IDpcbiAgICAgICAgb3B0aW9ucy5zcGxpdCgnOycpLnJlZHVjZSgob3B0aW9ucywgb3B0aW9uKSA9PiB7XG4gICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gb3B0aW9uLnNwbGl0KC86KC4qKS8pO1xuICAgICAgICAgIGlmIChrZXkgJiYgIWlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgb3B0aW9uc1trZXkudHJpbSgpXSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH0sIHt9KSA6XG4gICAgICAgIHt9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGxheShlbCkge1xuICAgICAgaWYgKGlzSUZyYW1lKGVsKSkge1xuICAgICAgICBjYWxsKGVsLCB7IGZ1bmM6ICdwbGF5VmlkZW8nLCBtZXRob2Q6ICdwbGF5JyB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSFRNTDUoZWwpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZWwucGxheSgpLmNhdGNoKG5vb3ApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGF1c2UoZWwpIHtcbiAgICAgIGlmIChpc0lGcmFtZShlbCkpIHtcbiAgICAgICAgY2FsbChlbCwgeyBmdW5jOiAncGF1c2VWaWRlbycsIG1ldGhvZDogJ3BhdXNlJyB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSFRNTDUoZWwpKSB7XG4gICAgICAgIGVsLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXV0ZShlbCkge1xuICAgICAgaWYgKGlzSUZyYW1lKGVsKSkge1xuICAgICAgICBjYWxsKGVsLCB7IGZ1bmM6ICdtdXRlJywgbWV0aG9kOiAnc2V0Vm9sdW1lJywgdmFsdWU6IDAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0hUTUw1KGVsKSkge1xuICAgICAgICBlbC5tdXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWaWRlbyhlbCkge1xuICAgICAgcmV0dXJuIGlzSFRNTDUoZWwpIHx8IGlzSUZyYW1lKGVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0hUTUw1KGVsKSB7XG4gICAgICByZXR1cm4gaXNUYWcoZWwsICd2aWRlbycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSUZyYW1lKGVsKSB7XG4gICAgICByZXR1cm4gaXNUYWcoZWwsICdpZnJhbWUnKSAmJiAoaXNZb3V0dWJlKGVsKSB8fCBpc1ZpbWVvKGVsKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNZb3V0dWJlKGVsKSB7XG4gICAgICByZXR1cm4gISFlbC5zcmMubWF0Y2goXG4gICAgICAvXFwvXFwvLio/eW91dHViZSgtbm9jb29raWUpP1xcLlthLXpdK1xcLyh3YXRjaFxcP3Y9W14mXFxzXSt8ZW1iZWQpfHlvdXR1XFwuYmVcXC8uKi8pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWaW1lbyhlbCkge1xuICAgICAgcmV0dXJuICEhZWwuc3JjLm1hdGNoKC92aW1lb1xcLmNvbVxcL3ZpZGVvXFwvLiovKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjYWxsKGVsLCBjbWQpIHtcbiAgICAgIGF3YWl0IGVuYWJsZUFwaShlbCk7XG4gICAgICBwb3N0KGVsLCBjbWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3QoZWwsIGNtZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7IGV2ZW50OiAnY29tbWFuZCcsIC4uLmNtZCB9KSwgJyonKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlS2V5ID0gJ191a1BsYXllcic7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGZ1bmN0aW9uIGVuYWJsZUFwaShlbCkge1xuICAgICAgaWYgKGVsW3N0YXRlS2V5XSkge1xuICAgICAgICByZXR1cm4gZWxbc3RhdGVLZXldO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB5b3V0dWJlID0gaXNZb3V0dWJlKGVsKTtcbiAgICAgIGNvbnN0IHZpbWVvID0gaXNWaW1lbyhlbCk7XG5cbiAgICAgIGNvbnN0IGlkID0gKytjb3VudGVyO1xuICAgICAgbGV0IHBvbGxlcjtcblxuICAgICAgcmV0dXJuIGVsW3N0YXRlS2V5XSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHlvdXR1YmUgJiZcbiAgICAgICAgb25jZShlbCwgJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiBwb3N0KGVsLCB7IGV2ZW50OiAnbGlzdGVuaW5nJywgaWQgfSk7XG4gICAgICAgICAgcG9sbGVyID0gc2V0SW50ZXJ2YWwobGlzdGVuZXIsIDEwMCk7XG4gICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb25jZSh3aW5kb3csICdtZXNzYWdlJywgcmVzb2x2ZSwgZmFsc2UsIChfcmVmKSA9PiB7bGV0IHsgZGF0YSB9ID0gX3JlZjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBkYXRhICYmIChcbiAgICAgICAgICAgICAgeW91dHViZSAmJiBkYXRhLmlkID09PSBpZCAmJiBkYXRhLmV2ZW50ID09PSAnb25SZWFkeScgfHxcbiAgICAgICAgICAgICAgdmltZW8gJiYgTnVtYmVyKGRhdGEucGxheWVyX2lkKSA9PT0gaWQpKTtcblxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsLnNyYyA9IFwiXCIgKyBlbC5zcmMgKyAoaW5jbHVkZXMoZWwuc3JjLCAnPycpID8gJyYnIDogJz8nKSArIChcbiAgICAgICAgeW91dHViZSA/ICdlbmFibGVqc2FwaT0xJyA6IFwiYXBpPTEmcGxheWVyX2lkPVwiICsgaWQpO1xuXG4gICAgICB9KS50aGVuKCgpID0+IGNsZWFySW50ZXJ2YWwocG9sbGVyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJblZpZXcoZWxlbWVudCwgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0KSB7aWYgKG9mZnNldFRvcCA9PT0gdm9pZCAwKSB7b2Zmc2V0VG9wID0gMDt9aWYgKG9mZnNldExlZnQgPT09IHZvaWQgMCkge29mZnNldExlZnQgPSAwO31cbiAgICAgIGlmICghaXNWaXNpYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGludGVyc2VjdFJlY3QoXG4gICAgICAuLi5zY3JvbGxQYXJlbnRzKGVsZW1lbnQpLlxuICAgICAgbWFwKChwYXJlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSA9IG9mZnNldChnZXRWaWV3cG9ydCQxKHBhcmVudCkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiB0b3AgLSBvZmZzZXRUb3AsXG4gICAgICAgICAgbGVmdDogbGVmdCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgYm90dG9tOiBib3R0b20gKyBvZmZzZXRUb3AsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0ICsgb2Zmc2V0TGVmdCB9O1xuXG4gICAgICB9KS5cbiAgICAgIGNvbmNhdChvZmZzZXQoZWxlbWVudCkpKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjcm9sbFRvcChlbGVtZW50LCB0b3ApIHtcbiAgICAgIGlmIChpc1dpbmRvdyhlbGVtZW50KSB8fCBpc0RvY3VtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnQgPSBnZXRTY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVW5kZWZpbmVkKHRvcCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoZWxlbWVudCwgX3RlbXApIHtsZXQgeyBvZmZzZXQ6IG9mZnNldEJ5ID0gMCB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgICBjb25zdCBwYXJlbnRzID0gaXNWaXNpYmxlKGVsZW1lbnQpID8gc2Nyb2xsUGFyZW50cyhlbGVtZW50KSA6IFtdO1xuICAgICAgcmV0dXJuIHBhcmVudHMucmVkdWNlKFxuICAgICAgKGZuLCBzY3JvbGxFbGVtZW50LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIG9mZnNldEhlaWdodCB9ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgY29uc3QgbWF4U2Nyb2xsID0gc2Nyb2xsSGVpZ2h0IC0gZ2V0Vmlld3BvcnRDbGllbnRIZWlnaHQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0OiBlbEhlaWdodCwgdG9wOiBlbFRvcCB9ID0gb2Zmc2V0KHBhcmVudHNbaSAtIDFdIHx8IGVsZW1lbnQpO1xuXG4gICAgICAgIGxldCB0b3AgPSBNYXRoLmNlaWwoXG4gICAgICAgIGVsVG9wIC0gb2Zmc2V0KGdldFZpZXdwb3J0JDEoc2Nyb2xsRWxlbWVudCkpLnRvcCAtIG9mZnNldEJ5ICsgc2Nyb2xsVG9wKTtcblxuXG4gICAgICAgIGlmIChvZmZzZXRCeSA+IDAgJiYgb2Zmc2V0SGVpZ2h0IDwgZWxIZWlnaHQgKyBvZmZzZXRCeSkge1xuICAgICAgICAgIHRvcCArPSBvZmZzZXRCeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXRCeSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wID4gbWF4U2Nyb2xsKSB7XG4gICAgICAgICAgb2Zmc2V0QnkgLT0gdG9wIC0gbWF4U2Nyb2xsO1xuICAgICAgICAgIHRvcCA9IG1heFNjcm9sbDtcbiAgICAgICAgfSBlbHNlIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0QnkgLT0gdG9wO1xuICAgICAgICAgIHRvcCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKCkgPT4gc2Nyb2xsVG8oc2Nyb2xsRWxlbWVudCwgdG9wIC0gc2Nyb2xsVG9wKS50aGVuKGZuKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSkoKTtcblxuXG4gICAgICBmdW5jdGlvbiBzY3JvbGxUbyhlbGVtZW50LCB0b3ApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBnZXREdXJhdGlvbihNYXRoLmFicyh0b3ApKTtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAoZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSBlYXNlKGNsYW1wKChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24pKTtcblxuICAgICAgICAgICAgc2Nyb2xsVG9wKGVsZW1lbnQsIHNjcm9sbCArIHRvcCAqIHBlcmNlbnQpO1xuXG4gICAgICAgICAgICAvLyBzY3JvbGwgbW9yZSBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIG91ciBkZXN0aW5hdGlvblxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXREdXJhdGlvbihkaXN0KSB7XG4gICAgICAgIHJldHVybiA0MCAqIE1hdGgucG93KGRpc3QsIDAuMzc1KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWFzZShrKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsZWRPdmVyKGVsZW1lbnQsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtpZiAoc3RhcnRPZmZzZXQgPT09IHZvaWQgMCkge3N0YXJ0T2Zmc2V0ID0gMDt9aWYgKGVuZE9mZnNldCA9PT0gdm9pZCAwKSB7ZW5kT2Zmc2V0ID0gMDt9XG4gICAgICBpZiAoIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW3Njcm9sbEVsZW1lbnRdID0gc2Nyb2xsUGFyZW50cyhlbGVtZW50LCAvYXV0b3xzY3JvbGwvLCB0cnVlKTtcbiAgICAgIGNvbnN0IHsgc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUb3AgfSA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IGdldFZpZXdwb3J0Q2xpZW50SGVpZ2h0KHNjcm9sbEVsZW1lbnQpO1xuICAgICAgY29uc3QgbWF4U2Nyb2xsID0gc2Nyb2xsSGVpZ2h0IC0gdmlld3BvcnRIZWlnaHQ7XG4gICAgICBjb25zdCBlbGVtZW50T2Zmc2V0VG9wID0gb2Zmc2V0UG9zaXRpb24oZWxlbWVudClbMF0gLSBvZmZzZXRQb3NpdGlvbihzY3JvbGxFbGVtZW50KVswXTtcblxuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBlbGVtZW50T2Zmc2V0VG9wIC0gdmlld3BvcnRIZWlnaHQgKyBzdGFydE9mZnNldCk7XG4gICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihtYXhTY3JvbGwsIGVsZW1lbnRPZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGVuZE9mZnNldCk7XG5cbiAgICAgIHJldHVybiBjbGFtcCgoc2Nyb2xsVG9wIC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsUGFyZW50cyhlbGVtZW50LCBvdmVyZmxvd1JlLCBzY3JvbGxhYmxlKSB7aWYgKG92ZXJmbG93UmUgPT09IHZvaWQgMCkge292ZXJmbG93UmUgPSAvYXV0b3xzY3JvbGx8aGlkZGVuLzt9aWYgKHNjcm9sbGFibGUgPT09IHZvaWQgMCkge3Njcm9sbGFibGUgPSBmYWxzZTt9XG4gICAgICBjb25zdCBzY3JvbGxFbCA9IGdldFNjcm9sbGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgIGxldCBhbmNlc3RvcnMgPSBwYXJlbnRzKGVsZW1lbnQpLnJldmVyc2UoKTtcbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5zbGljZShhbmNlc3RvcnMuaW5kZXhPZihzY3JvbGxFbCkgKyAxKTtcblxuICAgICAgY29uc3QgZml4ZWRJbmRleCA9IGZpbmRJbmRleChhbmNlc3RvcnMsIChlbCkgPT4gY3NzKGVsLCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJyk7XG4gICAgICBpZiAofmZpeGVkSW5kZXgpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLnNsaWNlKGZpeGVkSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3Njcm9sbEVsXS5cbiAgICAgIGNvbmNhdChcbiAgICAgIGFuY2VzdG9ycy5maWx0ZXIoXG4gICAgICAocGFyZW50KSA9PlxuICAgICAgb3ZlcmZsb3dSZS50ZXN0KGNzcyhwYXJlbnQsICdvdmVyZmxvdycpKSAmJiAoXG4gICAgICAhc2Nyb2xsYWJsZSB8fCBwYXJlbnQuc2Nyb2xsSGVpZ2h0ID4gZ2V0Vmlld3BvcnRDbGllbnRIZWlnaHQocGFyZW50KSkpKS5cblxuXG4gICAgICByZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Vmlld3BvcnQkMShzY3JvbGxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gc2Nyb2xsRWxlbWVudCA9PT0gZ2V0U2Nyb2xsaW5nRWxlbWVudChzY3JvbGxFbGVtZW50KSA/IHdpbmRvdyA6IHNjcm9sbEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gaU9TIDEyIHJldHVybnMgPGJvZHk+IGFzIHNjcm9sbGluZ0VsZW1lbnRcbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydENsaWVudEhlaWdodChzY3JvbGxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgc2Nyb2xsRWxlbWVudCA9PT0gZ2V0U2Nyb2xsaW5nRWxlbWVudChzY3JvbGxFbGVtZW50KSA/XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOlxuICAgICAgc2Nyb2xsRWxlbWVudCkuXG4gICAgICBjbGllbnRIZWlnaHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KSB7XG4gICAgICBjb25zdCB7IGRvY3VtZW50IH0gPSB0b1dpbmRvdyhlbGVtZW50KTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJzID0ge1xuICAgICAgd2lkdGg6IFsneCcsICdsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICBoZWlnaHQ6IFsneScsICd0b3AnLCAnYm90dG9tJ10gfTtcblxuXG4gICAgZnVuY3Rpb24gcG9zaXRpb25BdChcbiAgICBlbGVtZW50LFxuICAgIHRhcmdldCxcbiAgICBlbEF0dGFjaCxcbiAgICB0YXJnZXRBdHRhY2gsXG4gICAgZWxPZmZzZXQsXG4gICAgdGFyZ2V0T2Zmc2V0LFxuICAgIGZsaXAsXG4gICAgYm91bmRhcnkpXG4gICAge1xuICAgICAgZWxBdHRhY2ggPSBnZXRQb3MoZWxBdHRhY2gpO1xuICAgICAgdGFyZ2V0QXR0YWNoID0gZ2V0UG9zKHRhcmdldEF0dGFjaCk7XG5cbiAgICAgIGNvbnN0IGZsaXBwZWQgPSB7IGVsZW1lbnQ6IGVsQXR0YWNoLCB0YXJnZXQ6IHRhcmdldEF0dGFjaCB9O1xuXG4gICAgICBpZiAoIWVsZW1lbnQgfHwgIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gZmxpcHBlZDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGltID0gb2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgY29uc3QgdGFyZ2V0RGltID0gb2Zmc2V0KHRhcmdldCk7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHRhcmdldERpbTtcblxuICAgICAgbW92ZVRvKHBvc2l0aW9uLCBlbEF0dGFjaCwgZGltLCAtMSk7XG4gICAgICBtb3ZlVG8ocG9zaXRpb24sIHRhcmdldEF0dGFjaCwgdGFyZ2V0RGltLCAxKTtcblxuICAgICAgZWxPZmZzZXQgPSBnZXRPZmZzZXRzKGVsT2Zmc2V0LCBkaW0ud2lkdGgsIGRpbS5oZWlnaHQpO1xuICAgICAgdGFyZ2V0T2Zmc2V0ID0gZ2V0T2Zmc2V0cyh0YXJnZXRPZmZzZXQsIHRhcmdldERpbS53aWR0aCwgdGFyZ2V0RGltLmhlaWdodCk7XG5cbiAgICAgIGVsT2Zmc2V0Wyd4J10gKz0gdGFyZ2V0T2Zmc2V0Wyd4J107XG4gICAgICBlbE9mZnNldFsneSddICs9IHRhcmdldE9mZnNldFsneSddO1xuXG4gICAgICBwb3NpdGlvbi5sZWZ0ICs9IGVsT2Zmc2V0Wyd4J107XG4gICAgICBwb3NpdGlvbi50b3AgKz0gZWxPZmZzZXRbJ3knXTtcblxuICAgICAgaWYgKGZsaXApIHtcbiAgICAgICAgbGV0IGJvdW5kYXJpZXMgPSBzY3JvbGxQYXJlbnRzKGVsZW1lbnQpLm1hcChnZXRWaWV3cG9ydCQxKTtcblxuICAgICAgICBpZiAoYm91bmRhcnkgJiYgIWluY2x1ZGVzKGJvdW5kYXJpZXMsIGJvdW5kYXJ5KSkge1xuICAgICAgICAgIGJvdW5kYXJpZXMudW5zaGlmdChib3VuZGFyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBib3VuZGFyaWVzID0gYm91bmRhcmllcy5tYXAoKGVsKSA9PiBvZmZzZXQoZWwpKTtcblxuICAgICAgICBlYWNoKGRpcnMsIChfcmVmLCBwcm9wKSA9PiB7bGV0IFtkaXIsIGFsaWduLCBhbGlnbkZsaXBdID0gX3JlZjtcbiAgICAgICAgICBpZiAoIShmbGlwID09PSB0cnVlIHx8IGluY2x1ZGVzKGZsaXAsIGRpcikpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm91bmRhcmllcy5zb21lKChib3VuZGFyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbU9mZnNldCA9XG4gICAgICAgICAgICBlbEF0dGFjaFtkaXJdID09PSBhbGlnbiA/XG4gICAgICAgICAgICAtZGltW3Byb3BdIDpcbiAgICAgICAgICAgIGVsQXR0YWNoW2Rpcl0gPT09IGFsaWduRmxpcCA/XG4gICAgICAgICAgICBkaW1bcHJvcF0gOlxuICAgICAgICAgICAgMDtcblxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID1cbiAgICAgICAgICAgIHRhcmdldEF0dGFjaFtkaXJdID09PSBhbGlnbiA/XG4gICAgICAgICAgICB0YXJnZXREaW1bcHJvcF0gOlxuICAgICAgICAgICAgdGFyZ2V0QXR0YWNoW2Rpcl0gPT09IGFsaWduRmxpcCA/XG4gICAgICAgICAgICAtdGFyZ2V0RGltW3Byb3BdIDpcbiAgICAgICAgICAgIDA7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHBvc2l0aW9uW2FsaWduXSA8IGJvdW5kYXJ5W2FsaWduXSB8fFxuICAgICAgICAgICAgcG9zaXRpb25bYWxpZ25dICsgZGltW3Byb3BdID4gYm91bmRhcnlbYWxpZ25GbGlwXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY2VudGVyT2Zmc2V0ID0gZGltW3Byb3BdIC8gMjtcbiAgICAgICAgICAgICAgY29uc3QgY2VudGVyVGFyZ2V0T2Zmc2V0ID1cbiAgICAgICAgICAgICAgdGFyZ2V0QXR0YWNoW2Rpcl0gPT09ICdjZW50ZXInID8gLXRhcmdldERpbVtwcm9wXSAvIDIgOiAwO1xuXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgZWxBdHRhY2hbZGlyXSA9PT0gJ2NlbnRlcicgJiYgKFxuICAgICAgICAgICAgICAgIGFwcGx5KGNlbnRlck9mZnNldCwgY2VudGVyVGFyZ2V0T2Zmc2V0KSB8fFxuICAgICAgICAgICAgICAgIGFwcGx5KC1jZW50ZXJPZmZzZXQsIC1jZW50ZXJUYXJnZXRPZmZzZXQpKSB8fFxuICAgICAgICAgICAgICAgIGFwcGx5KGVsZW1PZmZzZXQsIHRhcmdldE9mZnNldCkpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcGx5KGVsZW1PZmZzZXQsIHRhcmdldE9mZnNldCkge1xuICAgICAgICAgICAgICBjb25zdCBuZXdWYWwgPSB0b0Zsb2F0KFxuICAgICAgICAgICAgICAocG9zaXRpb25bYWxpZ25dICsgZWxlbU9mZnNldCArIHRhcmdldE9mZnNldCAtIGVsT2Zmc2V0W2Rpcl0gKiAyKS50b0ZpeGVkKDQpKTtcblxuXG4gICAgICAgICAgICAgIGlmIChuZXdWYWwgPj0gYm91bmRhcnlbYWxpZ25dICYmIG5ld1ZhbCArIGRpbVtwcm9wXSA8PSBib3VuZGFyeVthbGlnbkZsaXBdKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25bYWxpZ25dID0gbmV3VmFsO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBbJ2VsZW1lbnQnLCAndGFyZ2V0J10pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZsaXBwZWRbZWxdW2Rpcl0gPVxuICAgICAgICAgICAgICAgICAgICBmbGlwcGVkW2VsXVtkaXJdID09PSBkaXJzW3Byb3BdWzFdID9cbiAgICAgICAgICAgICAgICAgICAgZGlyc1twcm9wXVsyXSA6XG4gICAgICAgICAgICAgICAgICAgIGRpcnNbcHJvcF1bMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldChlbGVtZW50LCBwb3NpdGlvbik7XG5cbiAgICAgIHJldHVybiBmbGlwcGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmVUbyhwb3NpdGlvbiwgYXR0YWNoLCBkaW0sIGZhY3Rvcikge1xuICAgICAgZWFjaChkaXJzLCAoX3JlZjIsIHByb3ApID0+IHtsZXQgW2RpciwgYWxpZ24sIGFsaWduRmxpcF0gPSBfcmVmMjtcbiAgICAgICAgaWYgKGF0dGFjaFtkaXJdID09PSBhbGlnbkZsaXApIHtcbiAgICAgICAgICBwb3NpdGlvblthbGlnbl0gKz0gZGltW3Byb3BdICogZmFjdG9yO1xuICAgICAgICB9IGVsc2UgaWYgKGF0dGFjaFtkaXJdID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHBvc2l0aW9uW2FsaWduXSArPSBkaW1bcHJvcF0gKiBmYWN0b3IgLyAyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQb3MocG9zKSB7XG4gICAgICBjb25zdCB4ID0gL2xlZnR8Y2VudGVyfHJpZ2h0LztcbiAgICAgIGNvbnN0IHkgPSAvdG9wfGNlbnRlcnxib3R0b20vO1xuXG4gICAgICBwb3MgPSAocG9zIHx8ICcnKS5zcGxpdCgnICcpO1xuXG4gICAgICBpZiAocG9zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwb3MgPSB4LnRlc3QocG9zWzBdKSA/XG4gICAgICAgIHBvcy5jb25jYXQoJ2NlbnRlcicpIDpcbiAgICAgICAgeS50ZXN0KHBvc1swXSkgP1xuICAgICAgICBbJ2NlbnRlciddLmNvbmNhdChwb3MpIDpcbiAgICAgICAgWydjZW50ZXInLCAnY2VudGVyJ107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgudGVzdChwb3NbMF0pID8gcG9zWzBdIDogJ2NlbnRlcicsXG4gICAgICAgIHk6IHkudGVzdChwb3NbMV0pID8gcG9zWzFdIDogJ2NlbnRlcicgfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9mZnNldHMob2Zmc2V0cywgd2lkdGgsIGhlaWdodCkge1xuICAgICAgY29uc3QgW3gsIHldID0gKG9mZnNldHMgfHwgJycpLnNwbGl0KCcgJyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggPyB0b0Zsb2F0KHgpICogKGVuZHNXaXRoKHgsICclJykgPyB3aWR0aCAvIDEwMCA6IDEpIDogMCxcbiAgICAgICAgeTogeSA/IHRvRmxvYXQoeSkgKiAoZW5kc1dpdGgoeSwgJyUnKSA/IGhlaWdodCAvIDEwMCA6IDEpIDogMCB9O1xuXG4gICAgfVxuXG4gICAgdmFyIHV0aWwgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgYWpheDogYWpheCxcbiAgICAgICAgZ2V0SW1hZ2U6IGdldEltYWdlLFxuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuICAgICAgICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICAgICAgICBhbmltYXRlOiBhbmltYXRlJDEsXG4gICAgICAgIEFuaW1hdGlvbjogQW5pbWF0aW9uLFxuICAgICAgICBhdHRyOiBhdHRyLFxuICAgICAgICBoYXNBdHRyOiBoYXNBdHRyLFxuICAgICAgICByZW1vdmVBdHRyOiByZW1vdmVBdHRyLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBhZGRDbGFzczogYWRkQ2xhc3MsXG4gICAgICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICAgICAgcmVtb3ZlQ2xhc3NlczogcmVtb3ZlQ2xhc3NlcyxcbiAgICAgICAgcmVwbGFjZUNsYXNzOiByZXBsYWNlQ2xhc3MsXG4gICAgICAgIGhhc0NsYXNzOiBoYXNDbGFzcyxcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zJDEsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIG9mZnNldFBvc2l0aW9uOiBvZmZzZXRQb3NpdGlvbixcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgYm94TW9kZWxBZGp1c3Q6IGJveE1vZGVsQWRqdXN0LFxuICAgICAgICBmbGlwUG9zaXRpb246IGZsaXBQb3NpdGlvbixcbiAgICAgICAgdG9QeDogdG9QeCxcbiAgICAgICAgcmVhZHk6IHJlYWR5LFxuICAgICAgICBpc1RhZzogaXNUYWcsXG4gICAgICAgIGVtcHR5OiBlbXB0eSxcbiAgICAgICAgaHRtbDogaHRtbCxcbiAgICAgICAgcmVwbGFjZUNoaWxkcmVuOiByZXBsYWNlQ2hpbGRyZW4sXG4gICAgICAgIHByZXBlbmQ6IHByZXBlbmQsXG4gICAgICAgIGFwcGVuZDogYXBwZW5kLFxuICAgICAgICBiZWZvcmU6IGJlZm9yZSxcbiAgICAgICAgYWZ0ZXI6IGFmdGVyLFxuICAgICAgICByZW1vdmU6IHJlbW92ZSQxLFxuICAgICAgICB3cmFwQWxsOiB3cmFwQWxsLFxuICAgICAgICB3cmFwSW5uZXI6IHdyYXBJbm5lcixcbiAgICAgICAgdW53cmFwOiB1bndyYXAsXG4gICAgICAgIGZyYWdtZW50OiBmcmFnbWVudCxcbiAgICAgICAgYXBwbHk6IGFwcGx5LFxuICAgICAgICAkOiAkLFxuICAgICAgICAkJDogJCQsXG4gICAgICAgIGluQnJvd3NlcjogaW5Ccm93c2VyLFxuICAgICAgICBpc1J0bDogaXNSdGwsXG4gICAgICAgIGhhc1RvdWNoOiBoYXNUb3VjaCxcbiAgICAgICAgcG9pbnRlckRvd246IHBvaW50ZXJEb3duLFxuICAgICAgICBwb2ludGVyTW92ZTogcG9pbnRlck1vdmUsXG4gICAgICAgIHBvaW50ZXJVcDogcG9pbnRlclVwLFxuICAgICAgICBwb2ludGVyRW50ZXI6IHBvaW50ZXJFbnRlcixcbiAgICAgICAgcG9pbnRlckxlYXZlOiBwb2ludGVyTGVhdmUsXG4gICAgICAgIHBvaW50ZXJDYW5jZWw6IHBvaW50ZXJDYW5jZWwsXG4gICAgICAgIG9uOiBvbixcbiAgICAgICAgb2ZmOiBvZmYsXG4gICAgICAgIG9uY2U6IG9uY2UsXG4gICAgICAgIHRyaWdnZXI6IHRyaWdnZXIsXG4gICAgICAgIGNyZWF0ZUV2ZW50OiBjcmVhdGVFdmVudCxcbiAgICAgICAgdG9FdmVudFRhcmdldHM6IHRvRXZlbnRUYXJnZXRzLFxuICAgICAgICBpc1RvdWNoOiBpc1RvdWNoLFxuICAgICAgICBnZXRFdmVudFBvczogZ2V0RXZlbnRQb3MsXG4gICAgICAgIGZhc3Rkb206IGZhc3Rkb20sXG4gICAgICAgIGlzVm9pZEVsZW1lbnQ6IGlzVm9pZEVsZW1lbnQsXG4gICAgICAgIGlzVmlzaWJsZTogaXNWaXNpYmxlLFxuICAgICAgICBzZWxJbnB1dDogc2VsSW5wdXQsXG4gICAgICAgIGlzSW5wdXQ6IGlzSW5wdXQsXG4gICAgICAgIHNlbEZvY3VzYWJsZTogc2VsRm9jdXNhYmxlLFxuICAgICAgICBpc0ZvY3VzYWJsZTogaXNGb2N1c2FibGUsXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBmaWx0ZXI6IGZpbHRlciQxLFxuICAgICAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgICAgICBjbG9zZXN0OiBjbG9zZXN0LFxuICAgICAgICB3aXRoaW46IHdpdGhpbixcbiAgICAgICAgcGFyZW50czogcGFyZW50cyxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGhhc093bjogaGFzT3duLFxuICAgICAgICBoeXBoZW5hdGU6IGh5cGhlbmF0ZSxcbiAgICAgICAgY2FtZWxpemU6IGNhbWVsaXplLFxuICAgICAgICB1Y2ZpcnN0OiB1Y2ZpcnN0LFxuICAgICAgICBzdGFydHNXaXRoOiBzdGFydHNXaXRoLFxuICAgICAgICBlbmRzV2l0aDogZW5kc1dpdGgsXG4gICAgICAgIGluY2x1ZGVzOiBpbmNsdWRlcyxcbiAgICAgICAgZmluZEluZGV4OiBmaW5kSW5kZXgsXG4gICAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgICAgIGFzc2lnbjogYXNzaWduLFxuICAgICAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgICAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgICAgIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gICAgICAgIGlzV2luZG93OiBpc1dpbmRvdyxcbiAgICAgICAgaXNEb2N1bWVudDogaXNEb2N1bWVudCxcbiAgICAgICAgaXNOb2RlOiBpc05vZGUsXG4gICAgICAgIGlzRWxlbWVudDogaXNFbGVtZW50LFxuICAgICAgICBpc0Jvb2xlYW46IGlzQm9vbGVhbixcbiAgICAgICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgICAgICBpc051bWJlcjogaXNOdW1iZXIsXG4gICAgICAgIGlzTnVtZXJpYzogaXNOdW1lcmljLFxuICAgICAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgICAgICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gICAgICAgIHRvQm9vbGVhbjogdG9Cb29sZWFuLFxuICAgICAgICB0b051bWJlcjogdG9OdW1iZXIsXG4gICAgICAgIHRvRmxvYXQ6IHRvRmxvYXQsXG4gICAgICAgIHRvTm9kZTogdG9Ob2RlLFxuICAgICAgICB0b05vZGVzOiB0b05vZGVzLFxuICAgICAgICB0b1dpbmRvdzogdG9XaW5kb3csXG4gICAgICAgIHRvTXM6IHRvTXMsXG4gICAgICAgIGlzRXF1YWw6IGlzRXF1YWwsXG4gICAgICAgIHN3YXA6IHN3YXAsXG4gICAgICAgIGxhc3Q6IGxhc3QsXG4gICAgICAgIGVhY2g6IGVhY2gsXG4gICAgICAgIHNvcnRCeTogc29ydEJ5JDEsXG4gICAgICAgIHVuaXF1ZUJ5OiB1bmlxdWVCeSxcbiAgICAgICAgY2xhbXA6IGNsYW1wLFxuICAgICAgICBub29wOiBub29wLFxuICAgICAgICBpbnRlcnNlY3RSZWN0OiBpbnRlcnNlY3RSZWN0LFxuICAgICAgICBwb2ludEluUmVjdDogcG9pbnRJblJlY3QsXG4gICAgICAgIERpbWVuc2lvbnM6IERpbWVuc2lvbnMsXG4gICAgICAgIGdldEluZGV4OiBnZXRJbmRleCxcbiAgICAgICAgbWVtb2l6ZTogbWVtb2l6ZSxcbiAgICAgICAgRGVmZXJyZWQ6IERlZmVycmVkLFxuICAgICAgICBNb3VzZVRyYWNrZXI6IE1vdXNlVHJhY2tlcixcbiAgICAgICAgb2JzZXJ2ZUludGVyc2VjdGlvbjogb2JzZXJ2ZUludGVyc2VjdGlvbixcbiAgICAgICAgb2JzZXJ2ZVJlc2l6ZTogb2JzZXJ2ZVJlc2l6ZSxcbiAgICAgICAgb2JzZXJ2ZU11dGF0aW9uOiBvYnNlcnZlTXV0YXRpb24sXG4gICAgICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgICAgICBwYXJzZU9wdGlvbnM6IHBhcnNlT3B0aW9ucyxcbiAgICAgICAgcGxheTogcGxheSxcbiAgICAgICAgcGF1c2U6IHBhdXNlLFxuICAgICAgICBtdXRlOiBtdXRlLFxuICAgICAgICBpc1ZpZGVvOiBpc1ZpZGVvLFxuICAgICAgICBwb3NpdGlvbkF0OiBwb3NpdGlvbkF0LFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIHF1ZXJ5QWxsOiBxdWVyeUFsbCxcbiAgICAgICAgZmluZDogZmluZCxcbiAgICAgICAgZmluZEFsbDogZmluZEFsbCxcbiAgICAgICAgZXNjYXBlOiBlc2NhcGUsXG4gICAgICAgIGNzczogY3NzLFxuICAgICAgICBnZXRDc3NWYXI6IGdldENzc1ZhcixcbiAgICAgICAgcHJvcE5hbWU6IHByb3BOYW1lLFxuICAgICAgICBpc0luVmlldzogaXNJblZpZXcsXG4gICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogc2Nyb2xsSW50b1ZpZXcsXG4gICAgICAgIHNjcm9sbGVkT3Zlcjogc2Nyb2xsZWRPdmVyLFxuICAgICAgICBzY3JvbGxQYXJlbnRzOiBzY3JvbGxQYXJlbnRzLFxuICAgICAgICBnZXRWaWV3cG9ydDogZ2V0Vmlld3BvcnQkMSxcbiAgICAgICAgZ2V0Vmlld3BvcnRDbGllbnRIZWlnaHQ6IGdldFZpZXdwb3J0Q2xpZW50SGVpZ2h0LFxuICAgICAgICBnZXRTY3JvbGxpbmdFbGVtZW50OiBnZXRTY3JvbGxpbmdFbGVtZW50XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnbG9iYWxBUEkgKFVJa2l0KSB7XG4gICAgICBjb25zdCBEQVRBID0gVUlraXQuZGF0YTtcblxuICAgICAgVUlraXQudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsdWdpbi5jYWxsKG51bGwsIHRoaXMpO1xuICAgICAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0Lm1peGluID0gZnVuY3Rpb24gKG1peGluLCBjb21wb25lbnQpIHtcbiAgICAgICAgY29tcG9uZW50ID0gKGlzU3RyaW5nKGNvbXBvbmVudCkgPyBVSWtpdC5jb21wb25lbnQoY29tcG9uZW50KSA6IGNvbXBvbmVudCkgfHwgdGhpcztcbiAgICAgICAgY29tcG9uZW50Lm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoY29tcG9uZW50Lm9wdGlvbnMsIG1peGluKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LmV4dGVuZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGNvbnN0IFN1cGVyID0gdGhpcztcbiAgICAgICAgY29uc3QgU3ViID0gZnVuY3Rpb24gVUlraXRDb21wb25lbnQob3B0aW9ucykge1xuICAgICAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICAgICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICAgICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoU3VwZXIub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgU3ViLnN1cGVyID0gU3VwZXI7XG4gICAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG5cbiAgICAgICAgcmV0dXJuIFN1YjtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnVwZGF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBlKSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50ID8gdG9Ob2RlKGVsZW1lbnQpIDogZG9jdW1lbnQuYm9keTtcblxuICAgICAgICBmb3IgKGNvbnN0IHBhcmVudEVsIG9mIHBhcmVudHMoZWxlbWVudCkucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgdXBkYXRlKHBhcmVudEVsW0RBVEFdLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGx5KGVsZW1lbnQsIChlbGVtZW50KSA9PiB1cGRhdGUoZWxlbWVudFtEQVRBXSwgZSkpO1xuICAgICAgfTtcblxuICAgICAgbGV0IGNvbnRhaW5lcjtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSWtpdCwgJ2NvbnRhaW5lcicsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBjb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQoZWxlbWVudCkge1xuICAgICAgICAgIGNvbnRhaW5lciA9ICQoZWxlbWVudCk7XG4gICAgICAgIH0gfSk7XG5cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKGRhdGEsIGUpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YVtuYW1lXS5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBkYXRhW25hbWVdLl9jYWxsVXBkYXRlKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhvb2tzQVBJIChVSWtpdCkge1xuICAgICAgVUlraXQucHJvdG90eXBlLl9jYWxsSG9vayA9IGZ1bmN0aW9uIChob29rKSB7dmFyIF90aGlzJCRvcHRpb25zJGhvb2s7XG4gICAgICAgIChfdGhpcyQkb3B0aW9ucyRob29rID0gdGhpcy4kb3B0aW9uc1tob29rXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJCRvcHRpb25zJGhvb2suZm9yRWFjaCgoaGFuZGxlcikgPT4gaGFuZGxlci5jYWxsKHRoaXMpKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fY2FsbENvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZWQgPSB7fTtcblxuICAgICAgICB0aGlzLl9pbml0UHJvcHMoKTtcblxuICAgICAgICB0aGlzLl9jYWxsSG9vaygnYmVmb3JlQ29ubmVjdCcpO1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2luaXRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5faW5pdE9ic2VydmVycygpO1xuXG4gICAgICAgIHRoaXMuX2NhbGxIb29rKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5fY2FsbFVwZGF0ZSgpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9jYWxsRGlzY29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVEaXNjb25uZWN0Jyk7XG4gICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RPYnNlcnZlcnMoKTtcbiAgICAgICAgdGhpcy5fdW5iaW5kRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX2NhbGxIb29rKCdkaXNjb25uZWN0ZWQnKTtcblxuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3dhdGNoO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9jYWxsVXBkYXRlID0gZnVuY3Rpb24gKGUpIHtpZiAoZSA9PT0gdm9pZCAwKSB7ZSA9ICd1cGRhdGUnO31cbiAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZSA9PT0gJ3VwZGF0ZScgfHwgZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICB0aGlzLl9jYWxsV2F0Y2hlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLiRvcHRpb25zLnVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdXBkYXRlcykge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgZmFzdGRvbS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgcnVuVXBkYXRlcy5jYWxsKHRoaXMsIHRoaXMuX3VwZGF0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0ZXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVzLmFkZChlLnR5cGUgfHwgZSk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxXYXRjaGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fd2F0Y2gpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbml0aWFsID0gIWhhc093bih0aGlzLCAnX3dhdGNoJyk7XG5cbiAgICAgICAgdGhpcy5fd2F0Y2ggPSBmYXN0ZG9tLnJlYWQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJ1bldhdGNoZXMuY2FsbCh0aGlzLCBpbml0aWFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fd2F0Y2ggPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHJ1blVwZGF0ZXModHlwZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IHJlYWQsIHdyaXRlLCBldmVudHMgPSBbXSB9IG9mIHRoaXMuJG9wdGlvbnMudXBkYXRlKSB7XG4gICAgICAgICAgaWYgKCF0eXBlcy5oYXMoJ3VwZGF0ZScpICYmICFldmVudHMuc29tZSgodHlwZSkgPT4gdHlwZXMuaGFzKHR5cGUpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICBpZiAocmVhZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVhZC5jYWxsKHRoaXMsIHRoaXMuX2RhdGEsIHR5cGVzKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1BsYWluT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgYXNzaWduKHRoaXMuX2RhdGEsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdyaXRlICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZhc3Rkb20ud3JpdGUoKCkgPT4gd3JpdGUuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLCB0eXBlcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBydW5XYXRjaGVzKGluaXRpYWwpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICRvcHRpb25zOiB7IGNvbXB1dGVkIH0gfSA9XG4gICAgICAgIHRoaXM7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHsgLi4uKGluaXRpYWwgPyB7fSA6IHRoaXMuX2NvbXB1dGVkKSB9O1xuICAgICAgICB0aGlzLl9jb21wdXRlZCA9IHt9O1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29uc3QgeyB3YXRjaCwgaW1tZWRpYXRlIH0gPSBjb21wdXRlZFtrZXldO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICB3YXRjaCAmJiAoXG4gICAgICAgICAgaW5pdGlhbCAmJiBpbW1lZGlhdGUgfHxcbiAgICAgICAgICBoYXNPd24odmFsdWVzLCBrZXkpICYmICFpc0VxdWFsKHZhbHVlc1trZXldLCB0aGlzW2tleV0pKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3YXRjaC5jYWxsKHRoaXMsIHRoaXNba2V5XSwgdmFsdWVzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXRlQVBJIChVSWtpdCkge1xuICAgICAgbGV0IHVpZCA9IDA7XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLmRhdGEgPSBub3JtYWxpemVEYXRhKG9wdGlvbnMsIHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICB0aGlzLiRlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuJHByb3BzID0ge307XG5cbiAgICAgICAgdGhpcy5fdWlkID0gdWlkKys7XG4gICAgICAgIHRoaXMuX2luaXREYXRhKCk7XG4gICAgICAgIHRoaXMuX2luaXRNZXRob2RzKCk7XG4gICAgICAgIHRoaXMuX2luaXRDb21wdXRlZHMoKTtcbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2NyZWF0ZWQnKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5lbCkge1xuICAgICAgICAgIHRoaXMuJG1vdW50KG9wdGlvbnMuZWwpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB7IGRhdGEgPSB7fSB9ID0gdGhpcy4kb3B0aW9ucztcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgdGhpcy4kcHJvcHNba2V5XSA9IHRoaXNba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0TWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgeyBtZXRob2RzIH0gPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgICAgIGlmIChtZXRob2RzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICAgICAgdGhpc1trZXldID0gbWV0aG9kc1trZXldLmJpbmQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRDb21wdXRlZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHsgY29tcHV0ZWQgfSA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAgICAgdGhpcy5fY29tcHV0ZWQgPSB7fTtcblxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJDb21wdXRlZCh0aGlzLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0UHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgbGV0IGtleTtcblxuICAgICAgICBwcm9wcyA9IHByb3BzIHx8IGdldFByb3BzJDEodGhpcy4kb3B0aW9ucywgdGhpcy4kbmFtZSk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHByb3BzW2tleV0pKSB7XG4gICAgICAgICAgICB0aGlzLiRwcm9wc1trZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleGNsdWRlID0gW3RoaXMuJG9wdGlvbnMuY29tcHV0ZWQsIHRoaXMuJG9wdGlvbnMubWV0aG9kc107XG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMuJHByb3BzKSB7XG4gICAgICAgICAgaWYgKGtleSBpbiBwcm9wcyAmJiBub3RJbihleGNsdWRlLCBrZXkpKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSB0aGlzLiRwcm9wc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiB0aGlzLiRvcHRpb25zLmV2ZW50cyB8fCBbXSkge1xuICAgICAgICAgIGlmIChoYXNPd24oZXZlbnQsICdoYW5kbGVyJykpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyRXZlbnQodGhpcywgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBldmVudCkge1xuICAgICAgICAgICAgICByZWdpc3RlckV2ZW50KHRoaXMsIGV2ZW50W2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX3VuYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKHVuYmluZCkgPT4gdW5iaW5kKCkpO1xuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0T2JzZXJ2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMgPSBbaW5pdFByb3BzT2JzZXJ2ZXIodGhpcyldO1xuXG4gICAgICAgIGlmICh0aGlzLiRvcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKGluaXRDaGlsZExpc3RPYnNlcnZlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5yZWdpc3Rlck9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fZGlzY29ubmVjdE9ic2VydmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2goKG9ic2VydmVyKSA9PiBvYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogb2JzZXJ2ZXIuZGlzY29ubmVjdCgpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJvcHMkMShvcHRzLCBuYW1lKSB7XG4gICAgICBjb25zdCBkYXRhJDEgPSB7fTtcbiAgICAgIGNvbnN0IHsgYXJncyA9IFtdLCBwcm9wcyA9IHt9LCBlbCB9ID0gb3B0cztcblxuICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICByZXR1cm4gZGF0YSQxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCBwcm9wID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGRhdGEoZWwsIHByb3ApO1xuXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gcHJvcHNba2V5XSA9PT0gQm9vbGVhbiAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogY29lcmNlKHByb3BzW2tleV0sIHZhbHVlKTtcblxuICAgICAgICBpZiAocHJvcCA9PT0gJ3RhcmdldCcgJiYgKCF2YWx1ZSB8fCBzdGFydHNXaXRoKHZhbHVlLCAnXycpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YSQxW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhkYXRhKGVsLCBuYW1lKSwgYXJncyk7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIGlmIChwcm9wc1twcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGF0YSQxW3Byb3BdID0gY29lcmNlKHByb3BzW3Byb3BdLCBvcHRpb25zW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhJDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJDb21wdXRlZChjb21wb25lbnQsIGtleSwgY2IpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wb25lbnQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCB7IF9jb21wdXRlZCwgJHByb3BzLCAkZWwgfSA9IGNvbXBvbmVudDtcblxuICAgICAgICAgIGlmICghaGFzT3duKF9jb21wdXRlZCwga2V5KSkge1xuICAgICAgICAgICAgX2NvbXB1dGVkW2tleV0gPSAoY2IuZ2V0IHx8IGNiKS5jYWxsKGNvbXBvbmVudCwgJHByb3BzLCAkZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfY29tcHV0ZWRba2V5XTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB7IF9jb21wdXRlZCB9ID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgX2NvbXB1dGVkW2tleV0gPSBjYi5zZXQgPyBjYi5zZXQuY2FsbChjb21wb25lbnQsIHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKF9jb21wdXRlZFtrZXldKSkge1xuICAgICAgICAgICAgZGVsZXRlIF9jb21wdXRlZFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9KTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnQoY29tcG9uZW50LCBldmVudCwga2V5KSB7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50ID0geyBuYW1lOiBrZXksIGhhbmRsZXI6IGV2ZW50IH07XG4gICAgICB9XG5cbiAgICAgIGxldCB7IG5hbWUsIGVsLCBoYW5kbGVyLCBjYXB0dXJlLCBwYXNzaXZlLCBkZWxlZ2F0ZSwgZmlsdGVyLCBzZWxmIH0gPSBldmVudDtcbiAgICAgIGVsID0gaXNGdW5jdGlvbihlbCkgPyBlbC5jYWxsKGNvbXBvbmVudCkgOiBlbCB8fCBjb21wb25lbnQuJGVsO1xuXG4gICAgICBpZiAoaXNBcnJheShlbCkpIHtcbiAgICAgICAgZWwuZm9yRWFjaCgoZWwpID0+IHJlZ2lzdGVyRXZlbnQoY29tcG9uZW50LCB7IC4uLmV2ZW50LCBlbCB9LCBrZXkpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsIHx8IGZpbHRlciAmJiAhZmlsdGVyLmNhbGwoY29tcG9uZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudC5fZXZlbnRzLnB1c2goXG4gICAgICBvbihcbiAgICAgIGVsLFxuICAgICAgbmFtZSxcbiAgICAgIGRlbGVnYXRlID8gaXNTdHJpbmcoZGVsZWdhdGUpID8gZGVsZWdhdGUgOiBkZWxlZ2F0ZS5jYWxsKGNvbXBvbmVudCkgOiBudWxsLFxuICAgICAgaXNTdHJpbmcoaGFuZGxlcikgPyBjb21wb25lbnRbaGFuZGxlcl0gOiBoYW5kbGVyLmJpbmQoY29tcG9uZW50KSxcbiAgICAgIHsgcGFzc2l2ZSwgY2FwdHVyZSwgc2VsZiB9KSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vdEluKG9wdGlvbnMsIGtleSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoKGFycikgPT4gIWFyciB8fCAhaGFzT3duKGFyciwga2V5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29lcmNlKHR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gdG9Cb29sZWFuKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICByZXR1cm4gdG9MaXN0KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUgPyB0eXBlKHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTGlzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID9cbiAgICAgIHZhbHVlIDpcbiAgICAgIGlzU3RyaW5nKHZhbHVlKSA/XG4gICAgICB2YWx1ZS5cbiAgICAgIHNwbGl0KC8sKD8hW14oXSpcXCkpLykuXG4gICAgICBtYXAoKHZhbHVlKSA9PiBpc051bWVyaWModmFsdWUpID8gdG9OdW1iZXIodmFsdWUpIDogdG9Cb29sZWFuKHZhbHVlLnRyaW0oKSkpIDpcbiAgICAgIFt2YWx1ZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRGF0YShfcmVmLCBfcmVmMikge2xldCB7IGRhdGEgPSB7fSB9ID0gX3JlZjtsZXQgeyBhcmdzID0gW10sIHByb3BzID0ge30gfSA9IF9yZWYyO1xuICAgICAgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgYXJncy5sZW5ndGgpLnJlZHVjZSgoZGF0YSwgdmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBhc3NpZ24oZGF0YSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhW2FyZ3NbaW5kZXhdXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChkYXRhW2tleV0pKSB7XG4gICAgICAgICAgZGVsZXRlIGRhdGFba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wc1trZXldKSB7XG4gICAgICAgICAgZGF0YVtrZXldID0gY29lcmNlKHByb3BzW2tleV0sIGRhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdENoaWxkTGlzdE9ic2VydmVyKGNvbXBvbmVudCkge1xuICAgICAgY29uc3QgeyBlbCB9ID0gY29tcG9uZW50LiRvcHRpb25zO1xuXG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IGNvbXBvbmVudC4kZW1pdCgpKTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlIH0pO1xuXG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0UHJvcHNPYnNlcnZlcihjb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IHsgJG5hbWUsICRvcHRpb25zLCAkcHJvcHMgfSA9IGNvbXBvbmVudDtcbiAgICAgIGNvbnN0IHsgYXR0cnMsIHByb3BzLCBlbCB9ID0gJG9wdGlvbnM7XG5cbiAgICAgIGlmICghcHJvcHMgfHwgYXR0cnMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGlzQXJyYXkoYXR0cnMpID8gYXR0cnMgOiBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBhdHRyaWJ1dGVzLm1hcCgoa2V5KSA9PiBoeXBoZW5hdGUoa2V5KSkuY29uY2F0KCRuYW1lKTtcblxuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigocmVjb3JkcykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0UHJvcHMkMSgkb3B0aW9ucywgJG5hbWUpO1xuICAgICAgICBpZiAoXG4gICAgICAgIHJlY29yZHMuc29tZSgoX3JlZjMpID0+IHtsZXQgeyBhdHRyaWJ1dGVOYW1lIH0gPSBfcmVmMztcbiAgICAgICAgICBjb25zdCBwcm9wID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKCdkYXRhLScsICcnKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHByb3AgPT09ICRuYW1lID8gYXR0cmlidXRlcyA6IFtjYW1lbGl6ZShwcm9wKSwgY2FtZWxpemUoYXR0cmlidXRlTmFtZSldKS5cbiAgICAgICAgICBzb21lKChwcm9wKSA9PiAhaXNVbmRlZmluZWQoZGF0YVtwcm9wXSkgJiYgZGF0YVtwcm9wXSAhPT0gJHByb3BzW3Byb3BdKTtcbiAgICAgICAgfSkpXG4gICAgICAgIHtcbiAgICAgICAgICBjb21wb25lbnQuJHJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGVsLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogZmlsdGVyLmNvbmNhdChmaWx0ZXIubWFwKChrZXkpID0+IFwiZGF0YS1cIiArIGtleSkpIH0pO1xuXG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YW5jZUFQSSAoVUlraXQpIHtcbiAgICAgIGNvbnN0IERBVEEgPSBVSWtpdC5kYXRhO1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJGNyZWF0ZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFVJa2l0W2NvbXBvbmVudF0oZWxlbWVudCwgZGF0YSk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gdGhpcy4kb3B0aW9ucztcblxuICAgICAgICBpZiAoIWVsW0RBVEFdKSB7XG4gICAgICAgICAgZWxbREFUQV0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbFtEQVRBXVtuYW1lXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsW0RBVEFdW25hbWVdID0gdGhpcztcblxuICAgICAgICB0aGlzLiRlbCA9IHRoaXMuJG9wdGlvbnMuZWwgPSB0aGlzLiRvcHRpb25zLmVsIHx8IGVsO1xuXG4gICAgICAgIGlmICh3aXRoaW4oZWwsIGRvY3VtZW50KSkge1xuICAgICAgICAgIHRoaXMuX2NhbGxDb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLiRyZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2FsbERpc2Nvbm5lY3RlZCgpO1xuICAgICAgICB0aGlzLl9jYWxsQ29ubmVjdGVkKCk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlRWwpIHtpZiAocmVtb3ZlRWwgPT09IHZvaWQgMCkge3JlbW92ZUVsID0gZmFsc2U7fVxuICAgICAgICBjb25zdCB7IGVsLCBuYW1lIH0gPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIHRoaXMuX2NhbGxEaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhbGxIb29rKCdkZXN0cm95Jyk7XG5cbiAgICAgICAgaWYgKCEoZWwgIT0gbnVsbCAmJiBlbFtEQVRBXSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgZWxbREFUQV1bbmFtZV07XG5cbiAgICAgICAgaWYgKCFpc0VtcHR5KGVsW0RBVEFdKSkge1xuICAgICAgICAgIGRlbGV0ZSBlbFtEQVRBXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmVFbCkge1xuICAgICAgICAgIHJlbW92ZSQxKHRoaXMuJGVsKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fY2FsbFVwZGF0ZShlKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kdXBkYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGUpIHtpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7ZWxlbWVudCA9IHRoaXMuJGVsO31cbiAgICAgICAgVUlraXQudXBkYXRlKGVsZW1lbnQsIGUpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLiRnZXRDb21wb25lbnQgPSBVSWtpdC5nZXRDb21wb25lbnQ7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBtZW1vaXplKChuYW1lKSA9PiBVSWtpdC5wcmVmaXggKyBoeXBoZW5hdGUobmFtZSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVUlraXQucHJvdG90eXBlLCB7XG4gICAgICAgICRjb250YWluZXI6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoVUlraXQsICdjb250YWluZXInKSxcblxuICAgICAgICAkbmFtZToge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnROYW1lKHRoaXMuJG9wdGlvbnMubmFtZSk7XG4gICAgICAgICAgfSB9IH0pO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wb25lbnRBUEkgKFVJa2l0KSB7XG4gICAgICBjb25zdCBEQVRBID0gVUlraXQuZGF0YTtcblxuICAgICAgY29uc3QgY29tcG9uZW50cyA9IHt9O1xuXG4gICAgICBVSWtpdC5jb21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBpZCA9IGh5cGhlbmF0ZShuYW1lKTtcblxuICAgICAgICBuYW1lID0gY2FtZWxpemUoaWQpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGNvbXBvbmVudHNbbmFtZV0pKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzW25hbWVdID0gVUlraXQuZXh0ZW5kKGNvbXBvbmVudHNbbmFtZV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb21wb25lbnRzW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgVUlraXRbbmFtZV0gPSBmdW5jdGlvbiAoZWxlbWVudCwgZGF0YSkge1xuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IFVJa2l0LmNvbXBvbmVudChuYW1lKTtcblxuICAgICAgICAgIHJldHVybiBjb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsID9cbiAgICAgICAgICBuZXcgY29tcG9uZW50KHsgZGF0YTogaXNQbGFpbk9iamVjdChlbGVtZW50KSA/IGVsZW1lbnQgOiBbLi4uYXJndW1lbnRzXSB9KSA6XG4gICAgICAgICAgZWxlbWVudCA/XG4gICAgICAgICAgJCQoZWxlbWVudCkubWFwKGluaXQpWzBdIDpcbiAgICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpbml0KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gVUlraXQuZ2V0Q29tcG9uZW50KGVsZW1lbnQsIG5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbXBvbmVudCh7IGVsOiBlbGVtZW50LCBkYXRhIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvcHQgPSBpc1BsYWluT2JqZWN0KG9wdGlvbnMpID8geyAuLi5vcHRpb25zIH0gOiBvcHRpb25zLm9wdGlvbnM7XG5cbiAgICAgICAgb3B0Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIG9wdC5pbnN0YWxsID09IG51bGwgPyB2b2lkIDAgOiBvcHQuaW5zdGFsbChVSWtpdCwgb3B0LCBuYW1lKTtcblxuICAgICAgICBpZiAoVUlraXQuX2luaXRpYWxpemVkICYmICFvcHQuZnVuY3Rpb25hbCkge1xuICAgICAgICAgIGZhc3Rkb20ucmVhZCgoKSA9PiBVSWtpdFtuYW1lXShcIlt1ay1cIiArIGlkICsgXCJdLFtkYXRhLXVrLVwiICsgaWQgKyBcIl1cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KG9wdGlvbnMpID8gb3B0IDogb3B0aW9ucztcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LmdldENvbXBvbmVudHMgPSAoZWxlbWVudCkgPT4gKGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnRbREFUQV0pIHx8IHt9O1xuICAgICAgVUlraXQuZ2V0Q29tcG9uZW50ID0gKGVsZW1lbnQsIG5hbWUpID0+IFVJa2l0LmdldENvbXBvbmVudHMoZWxlbWVudClbbmFtZV07XG5cbiAgICAgIFVJa2l0LmNvbm5lY3QgPSAobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZVtEQVRBXSkge1xuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBub2RlW0RBVEFdKSB7XG4gICAgICAgICAgICBub2RlW0RBVEFdW25hbWVdLl9jYWxsQ29ubmVjdGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2Ygbm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoYXR0cmlidXRlLm5hbWUpO1xuXG4gICAgICAgICAgaWYgKG5hbWUgJiYgbmFtZSBpbiBjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBVSWtpdFtuYW1lXShub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LmRpc2Nvbm5lY3QgPSAobm9kZSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZVtEQVRBXSkge1xuICAgICAgICAgIG5vZGVbREFUQV1bbmFtZV0uX2NhbGxEaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRDb21wb25lbnROYW1lID0gbWVtb2l6ZSgoYXR0cmlidXRlKSA9PiB7XG4gICAgICByZXR1cm4gc3RhcnRzV2l0aChhdHRyaWJ1dGUsICd1ay0nKSB8fCBzdGFydHNXaXRoKGF0dHJpYnV0ZSwgJ2RhdGEtdWstJykgP1xuICAgICAgY2FtZWxpemUoYXR0cmlidXRlLnJlcGxhY2UoJ2RhdGEtdWstJywgJycpLnJlcGxhY2UoJ3VrLScsICcnKSkgOlxuICAgICAgZmFsc2U7XG4gICAgfSk7XG5cbiAgICBjb25zdCBVSWtpdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBVSWtpdC51dGlsID0gdXRpbDtcbiAgICBVSWtpdC5kYXRhID0gJ19fdWlraXRfXyc7XG4gICAgVUlraXQucHJlZml4ID0gJ3VrLSc7XG4gICAgVUlraXQub3B0aW9ucyA9IHt9O1xuICAgIFVJa2l0LnZlcnNpb24gPSAnMy4xMy45JztcblxuICAgIGdsb2JhbEFQSShVSWtpdCk7XG4gICAgaG9va3NBUEkoVUlraXQpO1xuICAgIHN0YXRlQVBJKFVJa2l0KTtcbiAgICBjb21wb25lbnRBUEkoVUlraXQpO1xuICAgIGluc3RhbmNlQVBJKFVJa2l0KTtcblxuICAgIGZ1bmN0aW9uIENvcmUgKCkge1xuICAgICAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgc3RhcnRlZCA9IDA7XG4gICAgICBvbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgICAgIChfcmVmKSA9PiB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmO1xuICAgICAgICBpZiAoKGNzcyh0YXJnZXQsICdhbmltYXRpb25OYW1lJykgfHwgJycpLm1hdGNoKC9edWstLioobGVmdHxyaWdodCkvKSkge1xuICAgICAgICAgIHN0YXJ0ZWQrKztcbiAgICAgICAgICBjc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnb3ZlcmZsb3dYJywgJ2hpZGRlbicpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEgLS1zdGFydGVkKSB7XG4gICAgICAgICAgICAgIGNzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdvdmVyZmxvd1gnLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdG9Ncyhjc3ModGFyZ2V0LCAnYW5pbWF0aW9uRHVyYXRpb24nKSkgKyAxMDApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJ1ZSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib290IChVSWtpdCkge1xuICAgICAgY29uc3QgeyBjb25uZWN0LCBkaXNjb25uZWN0IH0gPSBVSWtpdDtcblxuICAgICAgaWYgKCFpbkJyb3dzZXIgfHwgIXdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmFzdGRvbS5yZWFkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICBhcHBseShkb2N1bWVudC5ib2R5LCBjb25uZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKChyZWNvcmRzKSA9PiByZWNvcmRzLmZvckVhY2goYXBwbHlDaGlsZExpc3RNdXRhdGlvbikpLm9ic2VydmUoXG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgIHN1YnRyZWU6IHRydWUgfSk7XG5cblxuXG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKChyZWNvcmRzKSA9PiByZWNvcmRzLmZvckVhY2goYXBwbHlBdHRyaWJ1dGVNdXRhdGlvbikpLm9ic2VydmUoXG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICB7XG4gICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICBzdWJ0cmVlOiB0cnVlIH0pO1xuXG5cblxuICAgICAgICBVSWtpdC5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFwcGx5Q2hpbGRMaXN0TXV0YXRpb24oX3JlZikge2xldCB7IGFkZGVkTm9kZXMsIHJlbW92ZWROb2RlcyB9ID0gX3JlZjtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICAgICAgICBhcHBseShub2RlLCBjb25uZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiByZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgICBhcHBseShub2RlLCBkaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhcHBseUF0dHJpYnV0ZU11dGF0aW9uKF9yZWYyKSB7dmFyIF9VSWtpdCRnZXRDb21wb25lbnQ7bGV0IHsgdGFyZ2V0LCBhdHRyaWJ1dGVOYW1lIH0gPSBfcmVmMjtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoYXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgaWYgKCFuYW1lIHx8ICEobmFtZSBpbiBVSWtpdCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzQXR0cih0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgVUlraXRbbmFtZV0odGFyZ2V0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAoX1VJa2l0JGdldENvbXBvbmVudCA9IFVJa2l0LmdldENvbXBvbmVudCh0YXJnZXQsIG5hbWUpKSA9PSBudWxsID8gdm9pZCAwIDogX1VJa2l0JGdldENvbXBvbmVudC4kZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBDbGFzcyA9IHtcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgIWhhc0NsYXNzKHRoaXMuJGVsLCB0aGlzLiRuYW1lKSAmJiBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy4kbmFtZSk7XG4gICAgICB9IH07XG5cbiAgICB2YXIgTGF6eWxvYWQgPSB7XG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGxhenlsb2FkKG9ic2VydmVUYXJnZXRzLCB0YXJnZXRzKSB7aWYgKG9ic2VydmVUYXJnZXRzID09PSB2b2lkIDApIHtvYnNlcnZlVGFyZ2V0cyA9IHRoaXMuJGVsO31pZiAodGFyZ2V0cyA9PT0gdm9pZCAwKSB7dGFyZ2V0cyA9IHRoaXMuJGVsO31cbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoXG4gICAgICAgICAgb2JzZXJ2ZUludGVyc2VjdGlvbihvYnNlcnZlVGFyZ2V0cywgKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRvTm9kZXMoaXNGdW5jdGlvbih0YXJnZXRzKSA/IHRhcmdldHMoKSA6IHRhcmdldHMpKSB7XG4gICAgICAgICAgICAgICQkKCdbbG9hZGluZz1cImxhenlcIl0nLCBlbCkuZm9yRWFjaCgoZWwpID0+IHJlbW92ZUF0dHIoZWwsICdsb2FkaW5nJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBlbnRyaWVzLlxuICAgICAgICAgICAgZmlsdGVyKChfcmVmKSA9PiB7bGV0IHsgaXNJbnRlcnNlY3RpbmcgfSA9IF9yZWY7cmV0dXJuIGlzSW50ZXJzZWN0aW5nO30pLlxuICAgICAgICAgICAgbWFwKChfcmVmMikgPT4ge2xldCB7IHRhcmdldCB9ID0gX3JlZjI7cmV0dXJuIHRhcmdldDt9KSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcblxuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBUb2dnbGFibGUgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBjbHM6IEJvb2xlYW4sXG4gICAgICAgIGFuaW1hdGlvbjogJ2xpc3QnLFxuICAgICAgICBkdXJhdGlvbjogTnVtYmVyLFxuICAgICAgICBvcmlnaW46IFN0cmluZyxcbiAgICAgICAgdHJhbnNpdGlvbjogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjbHM6IGZhbHNlLFxuICAgICAgICBhbmltYXRpb246IFtmYWxzZV0sXG4gICAgICAgIGR1cmF0aW9uOiAyMDAsXG4gICAgICAgIG9yaWdpbjogZmFsc2UsXG4gICAgICAgIHRyYW5zaXRpb246ICdsaW5lYXInLFxuICAgICAgICBjbHNFbnRlcjogJ3VrLXRvZ2dsYWJlLWVudGVyJyxcbiAgICAgICAgY2xzTGVhdmU6ICd1ay10b2dnbGFiZS1sZWF2ZScsXG5cbiAgICAgICAgaW5pdFByb3BzOiB7XG4gICAgICAgICAgb3ZlcmZsb3c6ICcnLFxuICAgICAgICAgIGhlaWdodDogJycsXG4gICAgICAgICAgcGFkZGluZ1RvcDogJycsXG4gICAgICAgICAgcGFkZGluZ0JvdHRvbTogJycsXG4gICAgICAgICAgbWFyZ2luVG9wOiAnJyxcbiAgICAgICAgICBtYXJnaW5Cb3R0b206ICcnIH0sXG5cblxuICAgICAgICBoaWRlUHJvcHM6IHtcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIHBhZGRpbmdUb3A6IDAsXG4gICAgICAgICAgcGFkZGluZ0JvdHRvbTogMCxcbiAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgbWFyZ2luQm90dG9tOiAwIH0gfSxcblxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGhhc0FuaW1hdGlvbihfcmVmKSB7bGV0IHsgYW5pbWF0aW9uIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAhIWFuaW1hdGlvblswXTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNUcmFuc2l0aW9uKF9yZWYyKSB7bGV0IHsgYW5pbWF0aW9uIH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBbmltYXRpb24gJiYgYW5pbWF0aW9uWzBdID09PSB0cnVlO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGVFbGVtZW50KHRhcmdldHMsIHRvZ2dsZSwgYW5pbWF0ZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICB0b05vZGVzKHRhcmdldHMpLm1hcCgoZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNob3cgPSBpc0Jvb2xlYW4odG9nZ2xlKSA/IHRvZ2dsZSA6ICF0aGlzLmlzVG9nZ2xlZChlbCk7XG5cbiAgICAgICAgICAgIGlmICghdHJpZ2dlcihlbCwgXCJiZWZvcmVcIiArIChzaG93ID8gJ3Nob3cnIDogJ2hpZGUnKSwgW3RoaXNdKSkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IChcbiAgICAgICAgICAgIGlzRnVuY3Rpb24oYW5pbWF0ZSkgP1xuICAgICAgICAgICAgYW5pbWF0ZSA6XG4gICAgICAgICAgICBhbmltYXRlID09PSBmYWxzZSB8fCAhdGhpcy5oYXNBbmltYXRpb24gP1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlIDpcbiAgICAgICAgICAgIHRoaXMuaGFzVHJhbnNpdGlvbiA/XG4gICAgICAgICAgICB0b2dnbGVIZWlnaHQodGhpcykgOlxuICAgICAgICAgICAgdG9nZ2xlQW5pbWF0aW9uKHRoaXMpKShcbiAgICAgICAgICAgIGVsLCBzaG93KTtcblxuICAgICAgICAgICAgY29uc3QgY2xzID0gc2hvdyA/IHRoaXMuY2xzRW50ZXIgOiB0aGlzLmNsc0xlYXZlO1xuXG4gICAgICAgICAgICBhZGRDbGFzcyhlbCwgY2xzKTtcblxuICAgICAgICAgICAgdHJpZ2dlcihlbCwgc2hvdyA/ICdzaG93JyA6ICdoaWRlJywgW3RoaXNdKTtcblxuICAgICAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG4gICAgICAgICAgICAgIHRyaWdnZXIoZWwsIHNob3cgPyAnc2hvd24nIDogJ2hpZGRlbicsIFt0aGlzXSk7XG4gICAgICAgICAgICAgIHRoaXMuJHVwZGF0ZShlbCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZSA/XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZG9uZSwgKCkgPT4ge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSkpLlxuICAgICAgICAgIHRoZW4ocmVzb2x2ZSwgbm9vcCkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNUb2dnbGVkKGVsKSB7aWYgKGVsID09PSB2b2lkIDApIHtlbCA9IHRoaXMuJGVsO31cbiAgICAgICAgICBbZWxdID0gdG9Ob2RlcyhlbCk7XG4gICAgICAgICAgcmV0dXJuIGhhc0NsYXNzKGVsLCB0aGlzLmNsc0VudGVyKSA/XG4gICAgICAgICAgdHJ1ZSA6XG4gICAgICAgICAgaGFzQ2xhc3MoZWwsIHRoaXMuY2xzTGVhdmUpID9cbiAgICAgICAgICBmYWxzZSA6XG4gICAgICAgICAgdGhpcy5jbHMgP1xuICAgICAgICAgIGhhc0NsYXNzKGVsLCB0aGlzLmNscy5zcGxpdCgnICcpWzBdKSA6XG4gICAgICAgICAgaXNWaXNpYmxlKGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdG9nZ2xlKGVsLCB0b2dnbGVkKSB7XG4gICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvZ2dsZWQgPSBCb29sZWFuKHRvZ2dsZWQpO1xuXG4gICAgICAgICAgbGV0IGNoYW5nZWQ7XG4gICAgICAgICAgaWYgKHRoaXMuY2xzKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gaW5jbHVkZXModGhpcy5jbHMsICcgJykgfHwgdG9nZ2xlZCAhPT0gaGFzQ2xhc3MoZWwsIHRoaXMuY2xzKTtcbiAgICAgICAgICAgIGNoYW5nZWQgJiYgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzLCBpbmNsdWRlcyh0aGlzLmNscywgJyAnKSA/IHVuZGVmaW5lZCA6IHRvZ2dsZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdG9nZ2xlZCA9PT0gZWwuaGlkZGVuO1xuICAgICAgICAgICAgY2hhbmdlZCAmJiAoZWwuaGlkZGVuID0gIXRvZ2dsZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICQkKCdbYXV0b2ZvY3VzXScsIGVsKS5zb21lKChlbCkgPT4gaXNWaXNpYmxlKGVsKSA/IGVsLmZvY3VzKCkgfHwgdHJ1ZSA6IGVsLmJsdXIoKSk7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ3RvZ2dsZWQnLCBbdG9nZ2xlZCwgdGhpc10pO1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRlKGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZUhlaWdodChfcmVmMykge2xldCB7IGlzVG9nZ2xlZCwgZHVyYXRpb24sIGluaXRQcm9wcywgaGlkZVByb3BzLCB0cmFuc2l0aW9uLCBfdG9nZ2xlIH0gPSBfcmVmMztcbiAgICAgIHJldHVybiAoZWwsIHNob3cpID0+IHtcbiAgICAgICAgY29uc3QgaW5Qcm9ncmVzcyA9IFRyYW5zaXRpb24uaW5Qcm9ncmVzcyhlbCk7XG4gICAgICAgIGNvbnN0IGlubmVyID0gZWwuaGFzQ2hpbGROb2RlcygpID9cbiAgICAgICAgdG9GbG9hdChjc3MoZWwuZmlyc3RFbGVtZW50Q2hpbGQsICdtYXJnaW5Ub3AnKSkgK1xuICAgICAgICB0b0Zsb2F0KGNzcyhlbC5sYXN0RWxlbWVudENoaWxkLCAnbWFyZ2luQm90dG9tJykpIDpcbiAgICAgICAgMDtcbiAgICAgICAgY29uc3QgY3VycmVudEhlaWdodCA9IGlzVmlzaWJsZShlbCkgPyBoZWlnaHQoZWwpICsgKGluUHJvZ3Jlc3MgPyAwIDogaW5uZXIpIDogMDtcblxuICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbChlbCk7XG5cbiAgICAgICAgaWYgKCFpc1RvZ2dsZWQoZWwpKSB7XG4gICAgICAgICAgX3RvZ2dsZShlbCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBoZWlnaHQoZWwsICcnKTtcblxuICAgICAgICAvLyBVcGRhdGUgY2hpbGQgY29tcG9uZW50cyBmaXJzdFxuICAgICAgICBmYXN0ZG9tLmZsdXNoKCk7XG5cbiAgICAgICAgY29uc3QgZW5kSGVpZ2h0ID0gaGVpZ2h0KGVsKSArIChpblByb2dyZXNzID8gMCA6IGlubmVyKTtcbiAgICAgICAgaGVpZ2h0KGVsLCBjdXJyZW50SGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICBzaG93ID9cbiAgICAgICAgVHJhbnNpdGlvbi5zdGFydChcbiAgICAgICAgZWwsXG4gICAgICAgIHsgLi4uaW5pdFByb3BzLCBvdmVyZmxvdzogJ2hpZGRlbicsIGhlaWdodDogZW5kSGVpZ2h0IH0sXG4gICAgICAgIE1hdGgucm91bmQoZHVyYXRpb24gKiAoMSAtIGN1cnJlbnRIZWlnaHQgLyBlbmRIZWlnaHQpKSxcbiAgICAgICAgdHJhbnNpdGlvbikgOlxuXG4gICAgICAgIFRyYW5zaXRpb24uc3RhcnQoXG4gICAgICAgIGVsLFxuICAgICAgICBoaWRlUHJvcHMsXG4gICAgICAgIE1hdGgucm91bmQoZHVyYXRpb24gKiAoY3VycmVudEhlaWdodCAvIGVuZEhlaWdodCkpLFxuICAgICAgICB0cmFuc2l0aW9uKS5cbiAgICAgICAgdGhlbigoKSA9PiBfdG9nZ2xlKGVsLCBmYWxzZSkpKS5cbiAgICAgICAgdGhlbigoKSA9PiBjc3MoZWwsIGluaXRQcm9wcykpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVBbmltYXRpb24oY21wKSB7XG4gICAgICByZXR1cm4gKGVsLCBzaG93KSA9PiB7XG4gICAgICAgIEFuaW1hdGlvbi5jYW5jZWwoZWwpO1xuXG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBkdXJhdGlvbiwgX3RvZ2dsZSB9ID0gY21wO1xuXG4gICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgX3RvZ2dsZShlbCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIEFuaW1hdGlvbi5pbihlbCwgYW5pbWF0aW9uWzBdLCBkdXJhdGlvbiwgY21wLm9yaWdpbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uLm91dChlbCwgYW5pbWF0aW9uWzFdIHx8IGFuaW1hdGlvblswXSwgZHVyYXRpb24sIGNtcC5vcmlnaW4pLnRoZW4oKCkgPT5cbiAgICAgICAgX3RvZ2dsZShlbCwgZmFsc2UpKTtcblxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgQWNjb3JkaW9uID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIExhenlsb2FkLCBUb2dnbGFibGVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXRzOiBTdHJpbmcsXG4gICAgICAgIGFjdGl2ZTogbnVsbCxcbiAgICAgICAgY29sbGFwc2libGU6IEJvb2xlYW4sXG4gICAgICAgIG11bHRpcGxlOiBCb29sZWFuLFxuICAgICAgICB0b2dnbGU6IFN0cmluZyxcbiAgICAgICAgY29udGVudDogU3RyaW5nLFxuICAgICAgICB0cmFuc2l0aW9uOiBTdHJpbmcsXG4gICAgICAgIG9mZnNldDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXRzOiAnPiAqJyxcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgYW5pbWF0aW9uOiBbdHJ1ZV0sXG4gICAgICAgIGNvbGxhcHNpYmxlOiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgICAgIGNsc09wZW46ICd1ay1vcGVuJyxcbiAgICAgICAgdG9nZ2xlOiAnPiAudWstYWNjb3JkaW9uLXRpdGxlJyxcbiAgICAgICAgY29udGVudDogJz4gLnVrLWFjY29yZGlvbi1jb250ZW50JyxcbiAgICAgICAgdHJhbnNpdGlvbjogJ2Vhc2UnLFxuICAgICAgICBvZmZzZXQ6IDAgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIGdldChfcmVmLCAkZWwpIHtsZXQgeyB0YXJnZXRzIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuICQkKHRhcmdldHMsICRlbCkuZmlsdGVyKChlbCkgPT4gJCh0aGlzLmNvbnRlbnQsIGVsKSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGl0ZW1zLCBwcmV2KSB7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChlbCkgPT4gaGlkZSgkKHRoaXMuY29udGVudCwgZWwpLCAhaGFzQ2xhc3MoZWwsIHRoaXMuY2xzT3BlbikpKTtcblxuICAgICAgICAgICAgaWYgKHByZXYgfHwgaGFzQ2xhc3MoaXRlbXMsIHRoaXMuY2xzT3BlbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPVxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgIT09IGZhbHNlICYmIGl0ZW1zW051bWJlcih0aGlzLmFjdGl2ZSldIHx8XG4gICAgICAgICAgICAhdGhpcy5jb2xsYXBzaWJsZSAmJiBpdGVtc1swXTtcblxuICAgICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgICB0aGlzLnRvZ2dsZShhY3RpdmUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0sXG5cblxuICAgICAgICB0b2dnbGVzKF9yZWYyKSB7bGV0IHsgdG9nZ2xlIH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoKGl0ZW0pID0+ICQodG9nZ2xlLCBpdGVtKSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMubGF6eWxvYWQoKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldHMgKyBcIiBcIiArIHRoaXMuJHByb3BzLnRvZ2dsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy50b2dnbGUoaW5kZXgodGhpcy50b2dnbGVzLCBlLmN1cnJlbnQpKTtcbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdG9nZ2xlKGl0ZW0sIGFuaW1hdGUpIHtcbiAgICAgICAgICBsZXQgaXRlbXMgPSBbdGhpcy5pdGVtc1tnZXRJbmRleChpdGVtLCB0aGlzLml0ZW1zKV1dO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUl0ZW1zID0gZmlsdGVyJDEodGhpcy5pdGVtcywgXCIuXCIgKyB0aGlzLmNsc09wZW4pO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlICYmICFpbmNsdWRlcyhhY3RpdmVJdGVtcywgaXRlbXNbMF0pKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChhY3RpdmVJdGVtcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICF0aGlzLmNvbGxhcHNpYmxlICYmXG4gICAgICAgICAgYWN0aXZlSXRlbXMubGVuZ3RoIDwgMiAmJlxuICAgICAgICAgICFmaWx0ZXIkMShpdGVtcywgXCI6bm90KC5cIiArIHRoaXMuY2xzT3BlbiArIFwiKVwiKS5sZW5ndGgpXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudChlbCwgIWhhc0NsYXNzKGVsLCB0aGlzLmNsc09wZW4pLCBhc3luYyAoZWwsIHNob3cpID0+IHtcbiAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzT3Blbiwgc2hvdyk7XG4gICAgICAgICAgICAgIGF0dHIoJCh0aGlzLiRwcm9wcy50b2dnbGUsIGVsKSwgJ2FyaWEtZXhwYW5kZWQnLCBzaG93KTtcblxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gJChcIlwiICsgKGVsLl93cmFwcGVyID8gJz4gKiAnIDogJycpICsgdGhpcy5jb250ZW50LCBlbCk7XG5cbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGUgPT09IGZhbHNlIHx8ICF0aGlzLmhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBoaWRlKGNvbnRlbnQsICFzaG93KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWVsLl93cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgZWwuX3dyYXBwZXIgPSB3cmFwQWxsKGNvbnRlbnQsIFwiPGRpdlwiICsgKHNob3cgPyAnIGhpZGRlbicgOiAnJykgKyBcIj5cIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoaWRlKGNvbnRlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYXdhaXQgdG9nZ2xlSGVpZ2h0KHRoaXMpKGVsLl93cmFwcGVyLCBzaG93KTtcbiAgICAgICAgICAgICAgaGlkZShjb250ZW50LCAhc2hvdyk7XG5cbiAgICAgICAgICAgICAgZGVsZXRlIGVsLl93cmFwcGVyO1xuICAgICAgICAgICAgICB1bndyYXAoY29udGVudCk7XG5cbiAgICAgICAgICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2dnbGUgPSAkKHRoaXMuJHByb3BzLnRvZ2dsZSwgZWwpO1xuICAgICAgICAgICAgICAgIGZhc3Rkb20ucmVhZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzSW5WaWV3KHRvZ2dsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcodG9nZ2xlLCB7IG9mZnNldDogdGhpcy5vZmZzZXQgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gaGlkZShlbCwgaGlkZSkge1xuICAgICAgZWwgJiYgKGVsLmhpZGRlbiA9IGhpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbGVydCA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBUb2dnbGFibGVdLFxuXG4gICAgICBhcmdzOiAnYW5pbWF0aW9uJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xvc2U6IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBbdHJ1ZV0sXG4gICAgICAgIHNlbENsb3NlOiAnLnVrLWFsZXJ0LWNsb3NlJyxcbiAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgaGlkZVByb3BzOiB7IG9wYWNpdHk6IDAsIC4uLlRvZ2dsYWJsZS5kYXRhLmhpZGVQcm9wcyB9IH0sXG5cblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsQ2xvc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy50b2dnbGVFbGVtZW50KHRoaXMuJGVsKTtcbiAgICAgICAgICB0aGlzLiRkZXN0cm95KHRydWUpO1xuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBWaWRlbyA9IHtcbiAgICAgIGFyZ3M6ICdhdXRvcGxheScsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGF1dG9tdXRlOiBCb29sZWFuLFxuICAgICAgICBhdXRvcGxheTogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYXV0b211dGU6IGZhbHNlLFxuICAgICAgICBhdXRvcGxheTogdHJ1ZSB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0aGlzLmF1dG9wbGF5ID09PSAnaW52aWV3JztcblxuICAgICAgICBpZiAodGhpcy5pblZpZXcgJiYgIWhhc0F0dHIodGhpcy4kZWwsICdwcmVsb2FkJykpIHtcbiAgICAgICAgICB0aGlzLiRlbC5wcmVsb2FkID0gJ25vbmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYXV0b211dGUpIHtcbiAgICAgICAgICBtdXRlKHRoaXMuJGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJPYnNlcnZlcihvYnNlcnZlSW50ZXJzZWN0aW9uKHRoaXMuJGVsLCAoKSA9PiB0aGlzLiRlbWl0KCksIHt9LCBmYWxzZSkpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgaWYgKCFpc1ZpZGVvKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2aXNpYmxlOiBpc1Zpc2libGUodGhpcy4kZWwpICYmIGNzcyh0aGlzLiRlbCwgJ3Zpc2liaWxpdHknKSAhPT0gJ2hpZGRlbicsXG4gICAgICAgICAgICBpblZpZXc6IHRoaXMuaW5WaWV3ICYmIGlzSW5WaWV3KHRoaXMuJGVsKSB9O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZikge2xldCB7IHZpc2libGUsIGluVmlldyB9ID0gX3JlZjtcbiAgICAgICAgICBpZiAoIXZpc2libGUgfHwgdGhpcy5pblZpZXcgJiYgIWluVmlldykge1xuICAgICAgICAgICAgcGF1c2UodGhpcy4kZWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvcGxheSA9PT0gdHJ1ZSB8fCB0aGlzLmluVmlldyAmJiBpblZpZXcpIHtcbiAgICAgICAgICAgIHBsYXkodGhpcy4kZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgUmVzaXplID0ge1xuICAgICAgY29ubmVjdGVkKCkge3ZhciBfdGhpcyQkb3B0aW9ucyRyZXNpemU7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJPYnNlcnZlcihcbiAgICAgICAgb2JzZXJ2ZVJlc2l6ZSgoKF90aGlzJCRvcHRpb25zJHJlc2l6ZSA9IHRoaXMuJG9wdGlvbnMucmVzaXplVGFyZ2V0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJCRvcHRpb25zJHJlc2l6ZS5jYWxsKHRoaXMpKSB8fCB0aGlzLiRlbCwgKCkgPT5cbiAgICAgICAgdGhpcy4kZW1pdCgncmVzaXplJykpKTtcblxuXG4gICAgICB9IH07XG5cbiAgICB2YXIgY292ZXIgPSB7XG4gICAgICBtaXhpbnM6IFtSZXNpemUsIFZpZGVvXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgd2lkdGg6IE51bWJlcixcbiAgICAgICAgaGVpZ2h0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGF1dG9tdXRlOiB0cnVlIH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgICdsb2FkIGxvYWRlZG1ldGFkYXRhJygpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdyZXNpemUnKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy4kZWwsIHBhcmVudCh0aGlzLiRlbCldO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSB0aGlzLiRlbDtcbiAgICAgICAgICBjb25zdCB7IG9mZnNldEhlaWdodDogaGVpZ2h0LCBvZmZzZXRXaWR0aDogd2lkdGggfSA9XG4gICAgICAgICAgZ2V0UG9zaXRpb25lZFBhcmVudChlbCkgfHwgcGFyZW50KGVsKTtcbiAgICAgICAgICBjb25zdCBkaW0gPSBEaW1lbnNpb25zLmNvdmVyKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoIHx8IGVsLm5hdHVyYWxXaWR0aCB8fCBlbC52aWRlb1dpZHRoIHx8IGVsLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCB8fCBlbC5uYXR1cmFsSGVpZ2h0IHx8IGVsLnZpZGVvSGVpZ2h0IHx8IGVsLmNsaWVudEhlaWdodCB9LFxuXG4gICAgICAgICAge1xuICAgICAgICAgICAgd2lkdGg6IHdpZHRoICsgKHdpZHRoICUgMiA/IDEgOiAwKSxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgKGhlaWdodCAlIDIgPyAxIDogMCkgfSk7XG5cblxuXG4gICAgICAgICAgaWYgKCFkaW0ud2lkdGggfHwgIWRpbS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGltO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYpIHtsZXQgeyBoZWlnaHQsIHdpZHRoIH0gPSBfcmVmO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgeyBoZWlnaHQsIHdpZHRoIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFBhcmVudChlbCkge1xuICAgICAgd2hpbGUgKGVsID0gcGFyZW50KGVsKSkge1xuICAgICAgICBpZiAoY3NzKGVsLCAncG9zaXRpb24nKSAhPT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgQ29udGFpbmVyID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29udGFpbmVyOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjb250YWluZXI6IHRydWUgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBjb250YWluZXIoX3JlZikge2xldCB7IGNvbnRhaW5lciB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyID09PSB0cnVlICYmIHRoaXMuJGNvbnRhaW5lciB8fCBjb250YWluZXIgJiYgJChjb250YWluZXIpO1xuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBQb3NpdGlvbiA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHBvczogU3RyaW5nLFxuICAgICAgICBvZmZzZXQ6IG51bGwsXG4gICAgICAgIGZsaXA6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBvczogXCJib3R0b20tXCIgKyAoaXNSdGwgPyAncmlnaHQnIDogJ2xlZnQnKSxcbiAgICAgICAgZmxpcDogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0OiBmYWxzZSB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLiRwcm9wcy5wb3Muc3BsaXQoJy0nKS5jb25jYXQoJ2NlbnRlcicpLnNsaWNlKDAsIDIpO1xuICAgICAgICB0aGlzLmRpciA9IHRoaXMucG9zWzBdO1xuICAgICAgICB0aGlzLmFsaWduID0gdGhpcy5wb3NbMV07XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHBvc2l0aW9uQXQoZWxlbWVudCwgdGFyZ2V0LCBib3VuZGFyeSkge1xuICAgICAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmdldEF4aXMoKTtcbiAgICAgICAgICBjb25zdCBkaXIgPSB0aGlzLnBvc1swXTtcbiAgICAgICAgICBjb25zdCBhbGlnbiA9IHRoaXMucG9zWzFdO1xuXG4gICAgICAgICAgbGV0IHsgb2Zmc2V0OiBvZmZzZXQkMSB9ID0gdGhpcztcbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYyhvZmZzZXQkMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSAkKG9mZnNldCQxKTtcbiAgICAgICAgICAgIG9mZnNldCQxID0gbm9kZSA/XG4gICAgICAgICAgICBvZmZzZXQobm9kZSlbYXhpcyA9PT0gJ3gnID8gJ2xlZnQnIDogJ3RvcCddIC1cbiAgICAgICAgICAgIG9mZnNldCh0YXJnZXQpW2F4aXMgPT09ICd4JyA/ICdyaWdodCcgOiAnYm90dG9tJ10gOlxuICAgICAgICAgICAgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0JDEgPSB0b1B4KG9mZnNldCQxKSArIHRvUHgoZ2V0Q3NzVmFyKCdwb3NpdGlvbi1vZmZzZXQnLCBlbGVtZW50KSk7XG5cbiAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBvc2l0aW9uQXQoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgYXhpcyA9PT0gJ3gnID8gZmxpcFBvc2l0aW9uKGRpcikgKyBcIiBcIiArIGFsaWduIDogYWxpZ24gKyBcIiBcIiArIGZsaXBQb3NpdGlvbihkaXIpLFxuICAgICAgICAgIGF4aXMgPT09ICd4JyA/IGRpciArIFwiIFwiICsgYWxpZ24gOiBhbGlnbiArIFwiIFwiICsgZGlyLFxuICAgICAgICAgIGF4aXMgPT09ICd4JyA/IFwiXCIgKyAoXG4gICAgICAgICAgZGlyID09PSAnbGVmdCcgPyAtb2Zmc2V0JDEgOiBvZmZzZXQkMSkgOiBcIiBcIiArIChcbiAgICAgICAgICBkaXIgPT09ICd0b3AnID8gLW9mZnNldCQxIDogb2Zmc2V0JDEpLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdGhpcy5mbGlwLFxuICAgICAgICAgIGJvdW5kYXJ5KS5cbiAgICAgICAgICB0YXJnZXQ7XG5cbiAgICAgICAgICB0aGlzLmRpciA9IGF4aXMgPT09ICd4JyA/IHggOiB5O1xuICAgICAgICAgIHRoaXMuYWxpZ24gPSBheGlzID09PSAneCcgPyB5IDogeDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBeGlzKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRpciA9PT0gJ3RvcCcgfHwgdGhpcy5kaXIgPT09ICdib3R0b20nID8gJ3knIDogJ3gnO1xuICAgICAgICB9IH0gfTtcblxuICAgIGxldCBhY3RpdmUkMTtcblxuICAgIHZhciBkcm9wID0ge1xuICAgICAgbWl4aW5zOiBbQ29udGFpbmVyLCBMYXp5bG9hZCwgUG9zaXRpb24sIFRvZ2dsYWJsZV0sXG5cbiAgICAgIGFyZ3M6ICdwb3MnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtb2RlOiAnbGlzdCcsXG4gICAgICAgIHRvZ2dsZTogQm9vbGVhbixcbiAgICAgICAgYm91bmRhcnk6IEJvb2xlYW4sXG4gICAgICAgIGJvdW5kYXJ5QWxpZ246IEJvb2xlYW4sXG4gICAgICAgIGRlbGF5U2hvdzogTnVtYmVyLFxuICAgICAgICBkZWxheUhpZGU6IE51bWJlcixcbiAgICAgICAgY2xzRHJvcDogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBtb2RlOiBbJ2NsaWNrJywgJ2hvdmVyJ10sXG4gICAgICAgIHRvZ2dsZTogJy0gKicsXG4gICAgICAgIGJvdW5kYXJ5OiB0cnVlLFxuICAgICAgICBib3VuZGFyeUFsaWduOiBmYWxzZSxcbiAgICAgICAgZGVsYXlTaG93OiAwLFxuICAgICAgICBkZWxheUhpZGU6IDgwMCxcbiAgICAgICAgY2xzRHJvcDogZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvbjogWyd1ay1hbmltYXRpb24tZmFkZSddLFxuICAgICAgICBjbHM6ICd1ay1vcGVuJyxcbiAgICAgICAgY29udGFpbmVyOiBmYWxzZSB9LFxuXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIHRoaXMudHJhY2tlciA9IG5ldyBNb3VzZVRyYWNrZXIoKTtcbiAgICAgIH0sXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY2xzRHJvcCA9IHRoaXMuJHByb3BzLmNsc0Ryb3AgfHwgXCJ1ay1cIiArIHRoaXMuJG9wdGlvbnMubmFtZTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRHJvcCk7XG5cbiAgICAgICAgaWYgKHRoaXMudG9nZ2xlICYmICF0aGlzLnRhcmdldCkge1xuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy4kY3JlYXRlKCd0b2dnbGUnLCBxdWVyeSh0aGlzLnRvZ2dsZSwgdGhpcy4kZWwpLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuJGVsLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlIH0pLlxuICAgICAgICAgICRlbDtcbiAgICAgICAgICBhdHRyKHRoaXMudGFyZ2V0LCAnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xuICAgICAgICAgIHRoaXMubGF6eWxvYWQodGhpcy50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICBhY3RpdmUkMSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiBcIi5cIiArIHRoaXMuY2xzRHJvcCArIFwiLWNsb3NlXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuICdhW2hyZWZePVwiI1wiXSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmKSB7bGV0IHsgZGVmYXVsdFByZXZlbnRlZCwgY3VycmVudDogeyBoYXNoIH0gfSA9IF9yZWY7XG4gICAgICAgICAgaWYgKCFkZWZhdWx0UHJldmVudGVkICYmIGhhc2ggJiYgIXdpdGhpbihoYXNoLCB0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3Jlc2Nyb2xsJyxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b2dnbGUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlLCB0b2dnbGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KHRvZ2dsZSA9PSBudWxsID8gdm9pZCAwIDogdG9nZ2xlLiRlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZXNob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlLCB0b2dnbGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93KHRvZ2dsZSA9PSBudWxsID8gdm9pZCAwIDogdG9nZ2xlLiRlbCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b2dnbGVoaWRlJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoIW1hdGNoZXModGhpcy4kZWwsICc6Zm9jdXMsOmhvdmVyJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogcG9pbnRlckVudGVyICsgXCIgZm9jdXNpblwiLFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZXModGhpcy5tb2RlLCAnaG92ZXInKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoIWlzVG91Y2goZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6IHBvaW50ZXJMZWF2ZSArIFwiIGZvY3Vzb3V0XCIsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdob3ZlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICghaXNUb3VjaChlKSAmJiBlLnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZWQnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlLCB0b2dnbGVkKSB7XG4gICAgICAgICAgaWYgKCF0b2dnbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuICAgICAgICAgIHRoaXMucG9zaXRpb24oKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBhY3RpdmUkMSA9IHRoaXM7XG5cbiAgICAgICAgICB0aGlzLnRyYWNrZXIuaW5pdCgpO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIFtcbiAgICAgICAgICBvbihcbiAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICBwb2ludGVyRG93bixcbiAgICAgICAgICAoX3JlZjIpID0+IHtsZXQgeyB0YXJnZXQgfSA9IF9yZWYyO3JldHVybiAoXG4gICAgICAgICAgICAgICF3aXRoaW4odGFyZ2V0LCB0aGlzLiRlbCkgJiZcbiAgICAgICAgICAgICAgb25jZShcbiAgICAgICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgICAgIHBvaW50ZXJVcCArIFwiIFwiICsgcG9pbnRlckNhbmNlbCArIFwiIHNjcm9sbFwiLFxuICAgICAgICAgICAgICAoX3JlZjMpID0+IHtsZXQgeyBkZWZhdWx0UHJldmVudGVkLCB0eXBlLCB0YXJnZXQ6IG5ld1RhcmdldCB9ID0gX3JlZjM7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFkZWZhdWx0UHJldmVudGVkICYmXG4gICAgICAgICAgICAgICAgdHlwZSA9PT0gcG9pbnRlclVwICYmXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID09PSBuZXdUYXJnZXQgJiZcbiAgICAgICAgICAgICAgICAhKHRoaXMudGFyZ2V0ICYmIHdpdGhpbih0YXJnZXQsIHRoaXMudGFyZ2V0KSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRydWUpKTt9KSxcblxuXG5cbiAgICAgICAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBvbih3aW5kb3csICdyZXNpemUnLCAoKSA9PiB0aGlzLiRlbWl0KCkpLFxuICAgICAgICAgIG9uKFxuICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgICdzY3JvbGwnLFxuICAgICAgICAgIChfcmVmNCkgPT4ge2xldCB7IHRhcmdldCB9ID0gX3JlZjQ7cmV0dXJuIHRhcmdldC5jb250YWlucyh0aGlzLiRlbCkgJiYgdGhpcy4kZW1pdCgpO30sXG4gICAgICAgICAgdHJ1ZSldKVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAgb25jZSh0aGlzLiRlbCwgJ2hpZGUnLCBoYW5kbGVyLCB7IHNlbGY6IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3JlaGlkZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGUnLFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjUpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY1O1xuICAgICAgICAgIGlmICh0aGlzLiRlbCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBhY3RpdmUkMSA9XG4gICAgICAgICAgICBhY3RpdmUkMSA9PT0gbnVsbCAmJiB3aXRoaW4odGFyZ2V0LCB0aGlzLiRlbCkgJiYgdGhpcy5pc1RvZ2dsZWQoKSA/XG4gICAgICAgICAgICB0aGlzIDpcbiAgICAgICAgICAgIGFjdGl2ZSQxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFjdGl2ZSQxID0gdGhpcy5pc0FjdGl2ZSgpID8gbnVsbCA6IGFjdGl2ZSQxO1xuICAgICAgICAgIHRoaXMudHJhY2tlci5jYW5jZWwoKTtcbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSAmJiAhaGFzQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRW50ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzaG93KHRhcmdldCwgZGVsYXkpIHtpZiAodGFyZ2V0ID09PSB2b2lkIDApIHt0YXJnZXQgPSB0aGlzLnRhcmdldDt9aWYgKGRlbGF5ID09PSB2b2lkIDApIHtkZWxheSA9IHRydWU7fVxuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpICYmIHRhcmdldCAmJiB0aGlzLnRhcmdldCAmJiB0YXJnZXQgIT09IHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3RpdmUkMSkge1xuICAgICAgICAgICAgaWYgKGRlbGF5ICYmIGFjdGl2ZSQxLmlzRGVsYXlpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaG93VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IG1hdGNoZXModGFyZ2V0LCAnOmhvdmVyJykgJiYgdGhpcy5zaG93KCksIDEwKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgICAgIHdoaWxlIChhY3RpdmUkMSAmJiBwcmV2ICE9PSBhY3RpdmUkMSAmJiAhd2l0aGluKHRoaXMuJGVsLCBhY3RpdmUkMS4kZWwpKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBhY3RpdmUkMTtcbiAgICAgICAgICAgICAgYWN0aXZlJDEuaGlkZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyICYmIHBhcmVudCh0aGlzLiRlbCkgIT09IHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmQodGhpcy5jb250YWluZXIsIHRoaXMuJGVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4gdGhpcy50b2dnbGVFbGVtZW50KHRoaXMuJGVsLCB0cnVlKSxcbiAgICAgICAgICBkZWxheSAmJiB0aGlzLmRlbGF5U2hvdyB8fCAwKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGUoZGVsYXkpIHtpZiAoZGVsYXkgPT09IHZvaWQgMCkge2RlbGF5ID0gdHJ1ZTt9XG4gICAgICAgICAgY29uc3QgaGlkZSA9ICgpID0+IHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcblxuICAgICAgICAgIHRoaXMuaXNEZWxheWluZyA9IGdldFBvc2l0aW9uZWRFbGVtZW50cyh0aGlzLiRlbCkuc29tZSgoZWwpID0+XG4gICAgICAgICAgdGhpcy50cmFja2VyLm1vdmVzVG8oZWwpKTtcblxuXG4gICAgICAgICAgaWYgKGRlbGF5ICYmIHRoaXMuaXNEZWxheWluZykge1xuICAgICAgICAgICAgdGhpcy5oaWRlVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuaGlkZSwgNTApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVsYXkgJiYgdGhpcy5kZWxheUhpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZVRpbWVyID0gc2V0VGltZW91dChoaWRlLCB0aGlzLmRlbGF5SGlkZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJUaW1lcnMoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVyKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO1xuICAgICAgICAgIHRoaXMuc2hvd1RpbWVyID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmhpZGVUaW1lciA9IG51bGw7XG4gICAgICAgICAgdGhpcy5pc0RlbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNBY3RpdmUoKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZSQxID09PSB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvc2l0aW9uKCkge1xuICAgICAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gcXVlcnkodGhpcy5ib3VuZGFyeSwgdGhpcy4kZWwpIHx8IHdpbmRvdztcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcm9wICsgXCItc3RhY2tcIik7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRHJvcCArIFwiLWJvdW5kYXJ5XCIsIHRoaXMuYm91bmRhcnlBbGlnbik7XG5cbiAgICAgICAgICBjb25zdCBib3VuZGFyeU9mZnNldCA9IG9mZnNldChib3VuZGFyeSk7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0KHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICBjb25zdCBhbGlnblRvID0gdGhpcy5ib3VuZGFyeUFsaWduID8gYm91bmRhcnlPZmZzZXQgOiB0YXJnZXRPZmZzZXQ7XG5cbiAgICAgICAgICBpZiAodGhpcy5wb3NbMV0gPT09ICdqdXN0aWZ5Jykge1xuICAgICAgICAgICAgY29uc3QgcHJvcCA9IHRoaXMuZ2V0QXhpcygpID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsIHByb3AsIGFsaWduVG9bcHJvcF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgdGhpcy4kZWwub2Zmc2V0V2lkdGggPlxuICAgICAgICAgIE1hdGgubWF4KGJvdW5kYXJ5T2Zmc2V0LnJpZ2h0IC0gYWxpZ25Uby5sZWZ0LCBhbGlnblRvLnJpZ2h0IC0gYm91bmRhcnlPZmZzZXQubGVmdCkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRHJvcCArIFwiLXN0YWNrXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucG9zaXRpb25BdCh0aGlzLiRlbCwgdGhpcy5ib3VuZGFyeUFsaWduID8gYm91bmRhcnkgOiB0aGlzLnRhcmdldCwgYm91bmRhcnkpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbmVkRWxlbWVudHMoZWwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgYXBwbHkoZWwsIChlbCkgPT4gY3NzKGVsLCAncG9zaXRpb24nKSAhPT0gJ3N0YXRpYycgJiYgcmVzdWx0LnB1c2goZWwpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1DdXN0b20gPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzc10sXG5cbiAgICAgIGFyZ3M6ICd0YXJnZXQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhcmdldDogZmFsc2UgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBpbnB1dChfLCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gJChzZWxJbnB1dCwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGF0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGFyZ2V0KF9yZWYsICRlbCkge2xldCB7IHRhcmdldCB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGFyZ2V0ICYmIChcbiAgICAgICAgICAgIHRhcmdldCA9PT0gdHJ1ZSAmJiBwYXJlbnQodGhpcy5pbnB1dCkgPT09ICRlbCAmJiB0aGlzLmlucHV0Lm5leHRFbGVtZW50U2libGluZyB8fFxuICAgICAgICAgICAgJCh0YXJnZXQsICRlbCkpKTtcblxuICAgICAgICB9IH0sXG5cblxuICAgICAgdXBkYXRlKCkge3ZhciBfaW5wdXQkZmlsZXM7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0LCBpbnB1dCB9ID0gdGhpcztcblxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvcHRpb247XG4gICAgICAgIGNvbnN0IHByb3AgPSBpc0lucHV0KHRhcmdldCkgPyAndmFsdWUnIDogJ3RleHRDb250ZW50JztcbiAgICAgICAgY29uc3QgcHJldiA9IHRhcmdldFtwcm9wXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoX2lucHV0JGZpbGVzID0gaW5wdXQuZmlsZXMpICE9IG51bGwgJiYgX2lucHV0JGZpbGVzWzBdID9cbiAgICAgICAgaW5wdXQuZmlsZXNbMF0ubmFtZSA6XG4gICAgICAgIG1hdGNoZXMoaW5wdXQsICdzZWxlY3QnKSAmJiAoXG4gICAgICAgIG9wdGlvbiA9ICQkKCdvcHRpb24nLCBpbnB1dCkuZmlsdGVyKChlbCkgPT4gZWwuc2VsZWN0ZWQpWzBdKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgID8gb3B0aW9uLnRleHRDb250ZW50IDpcbiAgICAgICAgaW5wdXQudmFsdWU7XG5cbiAgICAgICAgaWYgKHByZXYgIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2hhbmdlJyxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Jlc2V0JyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdCh0aGlzLiRlbCwgJ2Zvcm0nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgfSB9XSB9O1xuXG4gICAgdmFyIE1hcmdpbiA9IHtcbiAgICAgIG1peGluczogW1Jlc2l6ZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG1hcmdpbjogU3RyaW5nLFxuICAgICAgICBmaXJzdENvbHVtbjogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWFyZ2luOiAndWstbWFyZ2luLXNtYWxsLXRvcCcsXG4gICAgICAgIGZpcnN0Q29sdW1uOiAndWstZmlyc3QtY29sdW1uJyB9LFxuXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy4kZWwsIHRoaXMuJGVsLmNoaWxkcmVuXTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICBvYnNlcnZlTXV0YXRpb24odGhpcy4kZWwsICgpID0+IHRoaXMuJHJlc2V0KCksIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUgfSkpO1xuXG5cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGNvbnN0IHJvd3MgPSBnZXRSb3dzKHRoaXMuJGVsLmNoaWxkcmVuKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3dzLFxuICAgICAgICAgICAgY29sdW1uczogZ2V0Q29sdW1ucyhyb3dzKSB9O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZikge2xldCB7IGNvbHVtbnMsIHJvd3MgfSA9IF9yZWY7XG4gICAgICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb2x1bW4gb2Ygcm93KSB7XG4gICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGNvbHVtbiwgdGhpcy5tYXJnaW4sIHJvd3NbMF0gIT09IHJvdyk7XG4gICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGNvbHVtbiwgdGhpcy5maXJzdENvbHVtbiwgISF+Y29sdW1uc1swXS5pbmRleE9mKGNvbHVtbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldFJvd3MoaXRlbXMpIHtcbiAgICAgIHJldHVybiBzb3J0QnkoaXRlbXMsICd0b3AnLCAnYm90dG9tJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29sdW1ucyhyb3dzKSB7XG4gICAgICBjb25zdCBjb2x1bW5zID0gW107XG5cbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgY29uc3Qgc29ydGVkID0gc29ydEJ5KHJvdywgJ2xlZnQnLCAncmlnaHQnKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzb3J0ZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb2x1bW5zW2pdID0gY29sdW1uc1tqXSA/IGNvbHVtbnNbal0uY29uY2F0KHNvcnRlZFtqXSkgOiBzb3J0ZWRbal07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzUnRsID8gY29sdW1ucy5yZXZlcnNlKCkgOiBjb2x1bW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnRCeShpdGVtcywgc3RhcnRQcm9wLCBlbmRQcm9wKSB7XG4gICAgICBjb25zdCBzb3J0ZWQgPSBbW11dO1xuXG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIGl0ZW1zKSB7XG4gICAgICAgIGlmICghaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRpbSA9IGdldE9mZnNldChlbCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHNvcnRlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBzb3J0ZWRbaV07XG5cbiAgICAgICAgICBpZiAoIWN1cnJlbnRbMF0pIHtcbiAgICAgICAgICAgIGN1cnJlbnQucHVzaChlbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgc3RhcnREaW07XG4gICAgICAgICAgaWYgKGN1cnJlbnRbMF0ub2Zmc2V0UGFyZW50ID09PSBlbC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIHN0YXJ0RGltID0gZ2V0T2Zmc2V0KGN1cnJlbnRbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaW0gPSBnZXRPZmZzZXQoZWwsIHRydWUpO1xuICAgICAgICAgICAgc3RhcnREaW0gPSBnZXRPZmZzZXQoY3VycmVudFswXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpbVtzdGFydFByb3BdID49IHN0YXJ0RGltW2VuZFByb3BdIC0gMSAmJiBkaW1bc3RhcnRQcm9wXSAhPT0gc3RhcnREaW1bc3RhcnRQcm9wXSkge1xuICAgICAgICAgICAgc29ydGVkLnB1c2goW2VsXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGltW2VuZFByb3BdIC0gMSA+IHN0YXJ0RGltW3N0YXJ0UHJvcF0gfHwgZGltW3N0YXJ0UHJvcF0gPT09IHN0YXJ0RGltW3N0YXJ0UHJvcF0pIHtcbiAgICAgICAgICAgIGN1cnJlbnQucHVzaChlbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgc29ydGVkLnVuc2hpZnQoW2VsXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvcnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRPZmZzZXQoZWxlbWVudCwgb2Zmc2V0KSB7aWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7b2Zmc2V0ID0gZmFsc2U7fVxuICAgICAgbGV0IHsgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0LCBvZmZzZXRIZWlnaHQsIG9mZnNldFdpZHRoIH0gPSBlbGVtZW50O1xuXG4gICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIFtvZmZzZXRUb3AsIG9mZnNldExlZnRdID0gb2Zmc2V0UG9zaXRpb24oZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgICBsZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICBib3R0b206IG9mZnNldFRvcCArIG9mZnNldEhlaWdodCxcbiAgICAgICAgcmlnaHQ6IG9mZnNldExlZnQgKyBvZmZzZXRXaWR0aCB9O1xuXG4gICAgfVxuXG4gICAgdmFyIFNjcm9sbCA9IHtcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmVnaXN0ZXJTY3JvbGxMaXN0ZW5lcih0aGlzLl91aWQsICgpID0+IHRoaXMuJGVtaXQoJ3Njcm9sbCcpKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdW5yZWdpc3RlclNjcm9sbExpc3RlbmVyKHRoaXMuX3VpZCk7XG4gICAgICB9IH07XG5cblxuICAgIGNvbnN0IHNjcm9sbExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdW5iaW5kU2Nyb2xsTGlzdGVuZXI7XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJTY3JvbGxMaXN0ZW5lcihpZCwgbGlzdGVuZXIpIHtcbiAgICAgIHVuYmluZFNjcm9sbExpc3RlbmVyID1cbiAgICAgIHVuYmluZFNjcm9sbExpc3RlbmVyIHx8XG4gICAgICBvbih3aW5kb3csICdzY3JvbGwnLCAoKSA9PiBzY3JvbGxMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKCkpLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6IHRydWUgfSk7XG5cblxuICAgICAgc2Nyb2xsTGlzdGVuZXJzLnNldChpZCwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXJTY3JvbGxMaXN0ZW5lcihpZCkge1xuICAgICAgc2Nyb2xsTGlzdGVuZXJzLmRlbGV0ZShpZCk7XG4gICAgICBpZiAodW5iaW5kU2Nyb2xsTGlzdGVuZXIgJiYgIXNjcm9sbExpc3RlbmVycy5zaXplKSB7XG4gICAgICAgIHVuYmluZFNjcm9sbExpc3RlbmVyKCk7XG4gICAgICAgIHVuYmluZFNjcm9sbExpc3RlbmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ3JpZCA9IHtcbiAgICAgIGV4dGVuZHM6IE1hcmdpbixcblxuICAgICAgbWl4aW5zOiBbQ2xhc3MsIFNjcm9sbF0sXG5cbiAgICAgIG5hbWU6ICdncmlkJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbWFzb25yeTogQm9vbGVhbixcbiAgICAgICAgcGFyYWxsYXg6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWFyZ2luOiAndWstZ3JpZC1tYXJnaW4nLFxuICAgICAgICBjbHNTdGFjazogJ3VrLWdyaWQtc3RhY2snLFxuICAgICAgICBtYXNvbnJ5OiBmYWxzZSxcbiAgICAgICAgcGFyYWxsYXg6IDAgfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMubWFzb25yeSAmJiBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLWZsZXgtdG9wIHVrLWZsZXgtd3JhcC10b3AnKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogW1xuICAgICAge1xuICAgICAgICB3cml0ZShfcmVmKSB7bGV0IHsgY29sdW1ucyB9ID0gX3JlZjtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNTdGFjaywgY29sdW1ucy5sZW5ndGggPCAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICB7XG4gICAgICAgIHJlYWQoZGF0YSkge1xuICAgICAgICAgIGxldCB7IGNvbHVtbnMsIHJvd3MgfSA9IGRhdGE7XG5cbiAgICAgICAgICAvLyBGaWx0ZXIgY29tcG9uZW50IG1ha2VzIGVsZW1lbnRzIHBvc2l0aW9uZWQgYWJzb2x1dGVcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIWNvbHVtbnMubGVuZ3RoIHx8XG4gICAgICAgICAgIXRoaXMubWFzb25yeSAmJiAhdGhpcy5wYXJhbGxheCB8fFxuICAgICAgICAgIHBvc2l0aW9uZWRBYnNvbHV0ZSh0aGlzLiRlbCkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0YS50cmFuc2xhdGVzID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHRyYW5zbGF0ZXMgPSBmYWxzZTtcblxuICAgICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4odGhpcy4kZWwpO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbkhlaWdodHMgPSBnZXRDb2x1bW5IZWlnaHRzKGNvbHVtbnMpO1xuICAgICAgICAgIGNvbnN0IG1hcmdpbiA9IGdldE1hcmdpblRvcChub2RlcywgdGhpcy5tYXJnaW4pICogKHJvd3MubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgY29uc3QgZWxIZWlnaHQgPSBNYXRoLm1heCguLi5jb2x1bW5IZWlnaHRzKSArIG1hcmdpbjtcblxuICAgICAgICAgIGlmICh0aGlzLm1hc29ucnkpIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLm1hcCgoY29sdW1uKSA9PiBzb3J0QnkkMShjb2x1bW4sICdvZmZzZXRUb3AnKSk7XG4gICAgICAgICAgICB0cmFuc2xhdGVzID0gZ2V0VHJhbnNsYXRlcyhyb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcGFkZGluZyA9IE1hdGguYWJzKHRoaXMucGFyYWxsYXgpO1xuICAgICAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gY29sdW1uSGVpZ2h0cy5yZWR1Y2UoXG4gICAgICAgICAgICAobmV3UGFkZGluZywgaGd0LCBpKSA9PlxuICAgICAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgICBuZXdQYWRkaW5nLFxuICAgICAgICAgICAgaGd0ICsgbWFyZ2luICsgKGkgJSAyID8gcGFkZGluZyA6IHBhZGRpbmcgLyA4KSAtIGVsSGVpZ2h0KSxcblxuICAgICAgICAgICAgMCk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4geyBwYWRkaW5nLCBjb2x1bW5zLCB0cmFuc2xhdGVzLCBoZWlnaHQ6IHRyYW5zbGF0ZXMgPyBlbEhlaWdodCA6ICcnIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZjIpIHtsZXQgeyBoZWlnaHQsIHBhZGRpbmcgfSA9IF9yZWYyO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ3BhZGRpbmdCb3R0b20nLCBwYWRkaW5nIHx8ICcnKTtcbiAgICAgICAgICBoZWlnaHQgIT09IGZhbHNlICYmIGNzcyh0aGlzLiRlbCwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0sXG5cblxuICAgICAge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICh0aGlzLnBhcmFsbGF4ICYmIHBvc2l0aW9uZWRBYnNvbHV0ZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Nyb2xsZWQ6IHRoaXMucGFyYWxsYXggP1xuICAgICAgICAgICAgc2Nyb2xsZWRPdmVyKHRoaXMuJGVsKSAqIE1hdGguYWJzKHRoaXMucGFyYWxsYXgpIDpcbiAgICAgICAgICAgIGZhbHNlIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMykge2xldCB7IGNvbHVtbnMsIHNjcm9sbGVkLCB0cmFuc2xhdGVzIH0gPSBfcmVmMztcbiAgICAgICAgICBpZiAoc2Nyb2xsZWQgPT09IGZhbHNlICYmICF0cmFuc2xhdGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW4sIGkpID0+XG4gICAgICAgICAgY29sdW1uLmZvckVhY2goKGVsLCBqKSA9PlxuICAgICAgICAgIGNzcyhcbiAgICAgICAgICBlbCxcbiAgICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICAhc2Nyb2xsZWQgJiYgIXRyYW5zbGF0ZXMgP1xuICAgICAgICAgICcnIDogXCJ0cmFuc2xhdGVZKFwiICsgKFxuXG4gICAgICAgICAgKHRyYW5zbGF0ZXMgJiYgLXRyYW5zbGF0ZXNbaV1bal0pICsgKFxuICAgICAgICAgIHNjcm9sbGVkID8gaSAlIDIgPyBzY3JvbGxlZCA6IHNjcm9sbGVkIC8gOCA6IDApKSArIFwicHgpXCIpKSk7XG5cblxuXG5cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsnc2Nyb2xsJywgJ3Jlc2l6ZSddIH1dIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbmVkQWJzb2x1dGUoZWwpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbihlbCkuc29tZSgoZWwpID0+IGNzcyhlbCwgJ3Bvc2l0aW9uJykgPT09ICdhYnNvbHV0ZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRyYW5zbGF0ZXMocm93cywgY29sdW1ucykge1xuICAgICAgY29uc3Qgcm93SGVpZ2h0cyA9IHJvd3MubWFwKChyb3cpID0+IE1hdGgubWF4KC4uLnJvdy5tYXAoKGVsKSA9PiBlbC5vZmZzZXRIZWlnaHQpKSk7XG5cbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcCgoZWxlbWVudHMpID0+IHtcbiAgICAgICAgbGV0IHByZXYgPSAwO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMubWFwKFxuICAgICAgICAoZWxlbWVudCwgcm93KSA9PlxuICAgICAgICBwcmV2ICs9IHJvdyA/IHJvd0hlaWdodHNbcm93IC0gMV0gLSBlbGVtZW50c1tyb3cgLSAxXS5vZmZzZXRIZWlnaHQgOiAwKTtcblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWFyZ2luVG9wKG5vZGVzLCBjbHMpIHtcbiAgICAgIGNvbnN0IFtub2RlXSA9IG5vZGVzLmZpbHRlcigoZWwpID0+IGhhc0NsYXNzKGVsLCBjbHMpKTtcblxuICAgICAgcmV0dXJuIHRvRmxvYXQobm9kZSA/IGNzcyhub2RlLCAnbWFyZ2luVG9wJykgOiBjc3Mobm9kZXNbMF0sICdwYWRkaW5nTGVmdCcpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb2x1bW5IZWlnaHRzKGNvbHVtbnMpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcCgoY29sdW1uKSA9PiBjb2x1bW4ucmVkdWNlKChzdW0sIGVsKSA9PiBzdW0gKyBlbC5vZmZzZXRIZWlnaHQsIDApKTtcbiAgICB9XG5cbiAgICB2YXIgaGVpZ2h0TWF0Y2ggPSB7XG4gICAgICBtaXhpbnM6IFtSZXNpemVdLFxuXG4gICAgICBhcmdzOiAndGFyZ2V0JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgICAgIHJvdzogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiAnPiAqJyxcbiAgICAgICAgcm93OiB0cnVlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuICQkKHRhcmdldCwgJGVsKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLiRyZXNldCgpO1xuICAgICAgICAgIH0gfSB9LFxuXG5cblxuICAgICAgcmVzaXplVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLiRlbCwgdGhpcy5lbGVtZW50c107XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93czogKHRoaXMucm93ID8gZ2V0Um93cyh0aGlzLmVsZW1lbnRzKSA6IFt0aGlzLmVsZW1lbnRzXSkubWFwKG1hdGNoJDEpIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMikge2xldCB7IHJvd3MgfSA9IF9yZWYyO1xuICAgICAgICAgIGZvciAoY29uc3QgeyBoZWlnaHRzLCBlbGVtZW50cyB9IG9mIHJvd3MpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsLCBpKSA9PiBjc3MoZWwsICdtaW5IZWlnaHQnLCBoZWlnaHRzW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gbWF0Y2gkMShlbGVtZW50cykge1xuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0czogWycnXSwgZWxlbWVudHMgfTtcbiAgICAgIH1cblxuICAgICAgY3NzKGVsZW1lbnRzLCAnbWluSGVpZ2h0JywgJycpO1xuICAgICAgbGV0IGhlaWdodHMgPSBlbGVtZW50cy5tYXAoZ2V0SGVpZ2h0KTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLmhlaWdodHMpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHRzOiBlbGVtZW50cy5tYXAoKGVsLCBpKSA9PiBoZWlnaHRzW2ldLnRvRml4ZWQoMikgPT09IG1heC50b0ZpeGVkKDIpID8gJycgOiBtYXgpLFxuICAgICAgICBlbGVtZW50cyB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SGVpZ2h0KGVsZW1lbnQpIHtcbiAgICAgIGxldCBzdHlsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFpc1Zpc2libGUoZWxlbWVudCkpIHtcbiAgICAgICAgc3R5bGUgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGNzcyhlbGVtZW50LCAnZGlzcGxheScsICdibG9jaycsICdpbXBvcnRhbnQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVpZ2h0ID0gZGltZW5zaW9ucyQxKGVsZW1lbnQpLmhlaWdodCAtIGJveE1vZGVsQWRqdXN0KGVsZW1lbnQsICdoZWlnaHQnLCAnY29udGVudC1ib3gnKTtcblxuICAgICAgaWYgKHN0eWxlICE9PSBmYWxzZSkge1xuICAgICAgICBjc3MoZWxlbWVudCwgJ2Rpc3BsYXknLCBzdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIGhlaWdodFZpZXdwb3J0ID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIFJlc2l6ZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGV4cGFuZDogQm9vbGVhbixcbiAgICAgICAgb2Zmc2V0VG9wOiBCb29sZWFuLFxuICAgICAgICBvZmZzZXRCb3R0b206IEJvb2xlYW4sXG4gICAgICAgIG1pbkhlaWdodDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBleHBhbmQ6IGZhbHNlLFxuICAgICAgICBvZmZzZXRUb3A6IGZhbHNlLFxuICAgICAgICBvZmZzZXRCb3R0b206IGZhbHNlLFxuICAgICAgICBtaW5IZWlnaHQ6IDAgfSxcblxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICAvLyBjaGVjayBmb3Igb2Zmc2V0VG9wIGNoYW5nZVxuICAgICAgICByZXR1cm4gW3RoaXMuJGVsLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoX3JlZikge2xldCB7IG1pbkhlaWdodDogcHJldiB9ID0gX3JlZjtcbiAgICAgICAgICBpZiAoIWlzVmlzaWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgbWluSGVpZ2h0ID0gJyc7XG4gICAgICAgICAgY29uc3QgYm94ID0gYm94TW9kZWxBZGp1c3QodGhpcy4kZWwsICdoZWlnaHQnLCAnY29udGVudC1ib3gnKTtcblxuICAgICAgICAgIGlmICh0aGlzLmV4cGFuZCkge1xuICAgICAgICAgICAgbWluSGVpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICBoZWlnaHQod2luZG93KSAtIChcbiAgICAgICAgICAgIGRpbWVuc2lvbnMkMShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmhlaWdodCAtXG4gICAgICAgICAgICBkaW1lbnNpb25zJDEodGhpcy4kZWwpLmhlaWdodCkgLVxuICAgICAgICAgICAgYm94LFxuICAgICAgICAgICAgMCk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb24gbW9iaWxlIGRldmljZXMgKGlPUyBhbmQgQW5kcm9pZCkgd2luZG93LmlubmVySGVpZ2h0ICE9PSAxMDB2aFxuICAgICAgICAgICAgbWluSGVpZ2h0ID0gJ2NhbGMoMTAwdmgnO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vZmZzZXRUb3ApIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB0b3AgfSA9IG9mZnNldCh0aGlzLiRlbCk7XG4gICAgICAgICAgICAgIG1pbkhlaWdodCArPSB0b3AgPiAwICYmIHRvcCA8IGhlaWdodCh3aW5kb3cpIC8gMiA/IFwiIC0gXCIgKyB0b3AgKyBcInB4XCIgOiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2V0Qm90dG9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIG1pbkhlaWdodCArPSBcIiAtIFwiICsgZGltZW5zaW9ucyQxKHRoaXMuJGVsLm5leHRFbGVtZW50U2libGluZykuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc051bWVyaWModGhpcy5vZmZzZXRCb3R0b20pKSB7XG4gICAgICAgICAgICAgIG1pbkhlaWdodCArPSBcIiAtIFwiICsgdGhpcy5vZmZzZXRCb3R0b20gKyBcInZoXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub2Zmc2V0Qm90dG9tICYmIGVuZHNXaXRoKHRoaXMub2Zmc2V0Qm90dG9tLCAncHgnKSkge1xuICAgICAgICAgICAgICBtaW5IZWlnaHQgKz0gXCIgLSBcIiArIHRvRmxvYXQodGhpcy5vZmZzZXRCb3R0b20pICsgXCJweFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh0aGlzLm9mZnNldEJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IFwiIC0gXCIgKyBkaW1lbnNpb25zJDEocXVlcnkodGhpcy5vZmZzZXRCb3R0b20sIHRoaXMuJGVsKSkuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5IZWlnaHQgKz0gKGJveCA/IFwiIC0gXCIgKyBib3ggKyBcInB4XCIgOiAnJykgKyBcIilcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4geyBtaW5IZWlnaHQsIHByZXYgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMikge2xldCB7IG1pbkhlaWdodCB9ID0gX3JlZjI7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCB7IG1pbkhlaWdodCB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLm1pbkhlaWdodCAmJiB0b0Zsb2F0KGNzcyh0aGlzLiRlbCwgJ21pbkhlaWdodCcpKSA8IHRoaXMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsICdtaW5IZWlnaHQnLCB0aGlzLm1pbkhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cbiAgICB2YXIgU1ZHID0ge1xuICAgICAgYXJnczogJ3NyYycsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGlkOiBCb29sZWFuLFxuICAgICAgICBpY29uOiBTdHJpbmcsXG4gICAgICAgIHNyYzogU3RyaW5nLFxuICAgICAgICBzdHlsZTogU3RyaW5nLFxuICAgICAgICB3aWR0aDogTnVtYmVyLFxuICAgICAgICBoZWlnaHQ6IE51bWJlcixcbiAgICAgICAgcmF0aW86IE51bWJlcixcbiAgICAgICAgY2xhc3M6IFN0cmluZyxcbiAgICAgICAgc3Ryb2tlQW5pbWF0aW9uOiBCb29sZWFuLFxuICAgICAgICBmb2N1c2FibGU6IEJvb2xlYW4sIC8vIElFIDExXG4gICAgICAgIGF0dHJpYnV0ZXM6ICdsaXN0JyB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmF0aW86IDEsXG4gICAgICAgIGluY2x1ZGU6IFsnc3R5bGUnLCAnY2xhc3MnLCAnZm9jdXNhYmxlJ10sXG4gICAgICAgIGNsYXNzOiAnJyxcbiAgICAgICAgc3Ryb2tlQW5pbWF0aW9uOiBmYWxzZSB9LFxuXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY2xhc3MgKz0gJyB1ay1zdmcnO1xuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuaWNvbiAmJiBpbmNsdWRlcyh0aGlzLnNyYywgJyMnKSkge1xuICAgICAgICAgIFt0aGlzLnNyYywgdGhpcy5pY29uXSA9IHRoaXMuc3JjLnNwbGl0KCcjJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN2ZyA9IHRoaXMuZ2V0U3ZnKCkudGhlbigoZWwpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBjb25zdCBzdmcgPSBpbnNlcnRTVkcoZWwsIHRoaXMuJGVsKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3ZnRWwgJiYgc3ZnICE9PSB0aGlzLnN2Z0VsKSB7XG4gICAgICAgICAgICAgIHJlbW92ZSQxKHRoaXMuc3ZnRWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFwcGx5QXR0cmlidXRlcyhzdmcsIGVsKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ZnRWwgPSBzdmc7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBub29wKTtcblxuICAgICAgICBpZiAodGhpcy5zdHJva2VBbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLnN2Zy50aGVuKChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICBhcHBseUFuaW1hdGlvbihlbCk7XG4gICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYnNlcnZlcihcbiAgICAgICAgICAgICAgb2JzZXJ2ZUludGVyc2VjdGlvbihlbCwgKHJlY29yZHMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgYXBwbHlBbmltYXRpb24oZWwpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5zdmcudGhlbigoc3ZnKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1ZvaWRFbGVtZW50KHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgdGhpcy4kZWwuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVtb3ZlJDEoc3ZnKTtcbiAgICAgICAgICB0aGlzLnN2Z0VsID0gbnVsbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdmcgPSBudWxsO1xuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBnZXRTdmcoKSB7XG4gICAgICAgICAgaWYgKGlzVGFnKHRoaXMuJGVsLCAnaW1nJykgJiYgIXRoaXMuJGVsLmNvbXBsZXRlICYmIHRoaXMuJGVsLmxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PlxuICAgICAgICAgICAgb25jZSh0aGlzLiRlbCwgJ2xvYWQnLCAoKSA9PiByZXNvbHZlKHRoaXMuZ2V0U3ZnKCkpKSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcGFyc2VTVkcoYXdhaXQgbG9hZFNWRyh0aGlzLnNyYyksIHRoaXMuaWNvbikgfHwgUHJvbWlzZS5yZWplY3QoJ1NWRyBub3QgZm91bmQuJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXBwbHlBdHRyaWJ1dGVzKGVsLCByZWYpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gdGhpcy4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVzKHRoaXMuaW5jbHVkZSwgcHJvcCkgJiYgcHJvcCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgIGF0dHIoZWwsIHByb3AsIHRoaXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgY29uc3QgW3Byb3AsIHZhbHVlXSA9IHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdLnNwbGl0KCc6JywgMik7XG4gICAgICAgICAgICBhdHRyKGVsLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLmlkKSB7XG4gICAgICAgICAgICByZW1vdmVBdHRyKGVsLCAnaWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwcm9wcyA9IFsnd2lkdGgnLCAnaGVpZ2h0J107XG4gICAgICAgICAgbGV0IGRpbWVuc2lvbnMgPSBwcm9wcy5tYXAoKHByb3ApID0+IHRoaXNbcHJvcF0pO1xuXG4gICAgICAgICAgaWYgKCFkaW1lbnNpb25zLnNvbWUoKHZhbCkgPT4gdmFsKSkge1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IHByb3BzLm1hcCgocHJvcCkgPT4gYXR0cihyZWYsIHByb3ApKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB2aWV3Qm94ID0gYXR0cihyZWYsICd2aWV3Qm94Jyk7XG4gICAgICAgICAgaWYgKHZpZXdCb3ggJiYgIWRpbWVuc2lvbnMuc29tZSgodmFsKSA9PiB2YWwpKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gdmlld0JveC5zcGxpdCgnICcpLnNsaWNlKDIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpbWVuc2lvbnMuZm9yRWFjaCgodmFsLCBpKSA9PiBhdHRyKGVsLCBwcm9wc1tpXSwgdG9GbG9hdCh2YWwpICogdGhpcy5yYXRpbyB8fCBudWxsKSk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGNvbnN0IGxvYWRTVkcgPSBtZW1vaXplKGFzeW5jIChzcmMpID0+IHtcbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGgoc3JjLCAnZGF0YTonKSkge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3JjLnNwbGl0KCcsJylbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoYXdhaXQgZmV0Y2goc3JjKSkudGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlU1ZHKHN2ZywgaWNvbikge3ZhciBfc3ZnO1xuICAgICAgaWYgKGljb24gJiYgaW5jbHVkZXMoc3ZnLCAnPHN5bWJvbCcpKSB7XG4gICAgICAgIHN2ZyA9IHBhcnNlU3ltYm9scyhzdmcsIGljb24pIHx8IHN2ZztcbiAgICAgIH1cblxuICAgICAgc3ZnID0gJChzdmcuc3Vic3RyKHN2Zy5pbmRleE9mKCc8c3ZnJykpKTtcbiAgICAgIHJldHVybiAoKF9zdmcgPSBzdmcpID09IG51bGwgPyB2b2lkIDAgOiBfc3ZnLmhhc0NoaWxkTm9kZXMoKSkgJiYgc3ZnO1xuICAgIH1cblxuICAgIGNvbnN0IHN5bWJvbFJlID0gLzxzeW1ib2woW15dKj9pZD0oWydcIl0pKC4rPylcXDJbXl0qPzxcXC8pc3ltYm9sPi9nO1xuICAgIGNvbnN0IHN5bWJvbHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3ltYm9scyhzdmcsIGljb24pIHtcbiAgICAgIGlmICghc3ltYm9sc1tzdmddKSB7XG4gICAgICAgIHN5bWJvbHNbc3ZnXSA9IHt9O1xuXG4gICAgICAgIHN5bWJvbFJlLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSBzeW1ib2xSZS5leGVjKHN2ZykpIHtcbiAgICAgICAgICBzeW1ib2xzW3N2Z11bbWF0Y2hbM11dID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcIiArIG1hdGNoWzFdICsgXCJzdmc+XCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN5bWJvbHNbc3ZnXVtpY29uXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUFuaW1hdGlvbihlbCkge1xuICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TWF4UGF0aExlbmd0aChlbCk7XG5cbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoJy0tdWstYW5pbWF0aW9uLXN0cm9rZScsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWF4UGF0aExlbmd0aChlbCkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChcbiAgICAgIE1hdGgubWF4KFxuICAgICAgMCxcbiAgICAgIC4uLiQkKCdbc3Ryb2tlXScsIGVsKS5tYXAoKHN0cm9rZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBzdHJva2UuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9KSkpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNlcnRTVkcoZWwsIHJvb3QpIHtcbiAgICAgIGlmIChpc1ZvaWRFbGVtZW50KHJvb3QpIHx8IGlzVGFnKHJvb3QsICdjYW52YXMnKSkge1xuICAgICAgICByb290LmhpZGRlbiA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgbmV4dCA9IHJvb3QubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICByZXR1cm4gZXF1YWxzKGVsLCBuZXh0KSA/IG5leHQgOiBhZnRlcihyb290LCBlbCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhc3QgPSByb290Lmxhc3RFbGVtZW50Q2hpbGQ7XG4gICAgICByZXR1cm4gZXF1YWxzKGVsLCBsYXN0KSA/IGxhc3QgOiBhcHBlbmQocm9vdCwgZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxdWFscyhlbCwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBpc1RhZyhlbCwgJ3N2ZycpICYmIGlzVGFnKG90aGVyLCAnc3ZnJykgJiYgaW5uZXJIVE1MKGVsKSA9PT0gaW5uZXJIVE1MKG90aGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbm5lckhUTUwoZWwpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICBlbC5pbm5lckhUTUwgfHxcbiAgICAgIG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoZWwpLnJlcGxhY2UoLzxzdmcuKj8+KC4qPyk8XFwvc3ZnPi9nLCAnJDEnKSkuXG4gICAgICByZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIH1cblxuICAgIHZhciBjbG9zZUljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjE0XFxcIiBoZWlnaHQ9XFxcIjE0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTQgMTRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjFcXFwiIHkxPVxcXCIxXFxcIiB4Mj1cXFwiMTNcXFwiIHkyPVxcXCIxM1xcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHgxPVxcXCIxM1xcXCIgeTE9XFxcIjFcXFwiIHgyPVxcXCIxXFxcIiB5Mj1cXFwiMTNcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBjbG9zZUxhcmdlID0gXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIHgxPVxcXCIxXFxcIiB5MT1cXFwiMVxcXCIgeDI9XFxcIjE5XFxcIiB5Mj1cXFwiMTlcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiB4MT1cXFwiMTlcXFwiIHkxPVxcXCIxXFxcIiB4Mj1cXFwiMVxcXCIgeTI9XFxcIjE5XFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgbWFya2VyID0gXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjlcXFwiIHk9XFxcIjRcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjExXFxcIi8+PHJlY3QgeD1cXFwiNFxcXCIgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjExXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBuYXZiYXJUb2dnbGVJY29uID0gXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHk9XFxcIjlcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB5PVxcXCIxNVxcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBvdmVybGF5SWNvbiA9IFwiPHN2ZyB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCA0MCA0MFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCIxOVxcXCIgeT1cXFwiMFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiNDBcXFwiLz48cmVjdCB4PVxcXCIwXFxcIiB5PVxcXCIxOVxcXCIgd2lkdGg9XFxcIjQwXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBwYWdpbmF0aW9uTmV4dCA9IFwiPHN2ZyB3aWR0aD1cXFwiN1xcXCIgaGVpZ2h0PVxcXCIxMlxcXCIgdmlld0JveD1cXFwiMCAwIDcgMTJcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIHBvaW50cz1cXFwiMSAxIDYgNiAxIDExXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgcGFnaW5hdGlvblByZXZpb3VzID0gXCI8c3ZnIHdpZHRoPVxcXCI3XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiB2aWV3Qm94PVxcXCIwIDAgNyAxMlxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgcG9pbnRzPVxcXCI2IDEgMSA2IDYgMTFcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzZWFyY2hJY29uID0gXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjlcXFwiIGN5PVxcXCI5XFxcIiByPVxcXCI3XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE0LDE0IEwxOCwxOCBMMTQsMTQgWlxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNlYXJjaExhcmdlID0gXCI8c3ZnIHdpZHRoPVxcXCI0MFxcXCIgaGVpZ2h0PVxcXCI0MFxcXCIgdmlld0JveD1cXFwiMCAwIDQwIDQwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuOFxcXCIgY3g9XFxcIjE3LjVcXFwiIGN5PVxcXCIxNy41XFxcIiByPVxcXCIxNi41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuOFxcXCIgeDE9XFxcIjM4XFxcIiB5MT1cXFwiMzlcXFwiIHgyPVxcXCIyOVxcXCIgeTI9XFxcIjMwXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2VhcmNoTmF2YmFyID0gXCI8c3ZnIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwLjVcXFwiIGN5PVxcXCIxMC41XFxcIiByPVxcXCI5LjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiMjNcXFwiIHkxPVxcXCIyM1xcXCIgeDI9XFxcIjE3XFxcIiB5Mj1cXFwiMTdcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzbGlkZW5hdk5leHQgPSBcIjxzdmcgd2lkdGg9XFxcIjE0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTQgMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIHBvaW50cz1cXFwiMS4yMjUsMjMgMTIuNzc1LDEyIDEuMjI1LDEgXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2xpZGVuYXZOZXh0TGFyZ2UgPSBcIjxzdmcgd2lkdGg9XFxcIjI1XFxcIiBoZWlnaHQ9XFxcIjQwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjUgNDBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIiBwb2ludHM9XFxcIjQuMDAyLDM4LjU0NyAyMi41MjcsMjAuMDI0IDQsMS41IFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNsaWRlbmF2UHJldmlvdXMgPSBcIjxzdmcgd2lkdGg9XFxcIjE0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTQgMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIHBvaW50cz1cXFwiMTIuNzc1LDEgMS4yMjUsMTIgMTIuNzc1LDIzIFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNsaWRlbmF2UHJldmlvdXNMYXJnZSA9IFwiPHN2ZyB3aWR0aD1cXFwiMjVcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNSA0MFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjJcXFwiIHBvaW50cz1cXFwiMjAuNTI3LDEuNSAyLDIwLjAyNCAyMC41MjUsMzguNTQ3IFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNwaW5uZXIgPSBcIjxzdmcgd2lkdGg9XFxcIjMwXFxcIiBoZWlnaHQ9XFxcIjMwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzAgMzBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCIxNVxcXCIgY3k9XFxcIjE1XFxcIiByPVxcXCIxNFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHRvdG9wID0gXCI8c3ZnIHdpZHRoPVxcXCIxOFxcXCIgaGVpZ2h0PVxcXCIxMFxcXCIgdmlld0JveD1cXFwiMCAwIDE4IDEwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBwb2ludHM9XFxcIjEgOSA5IDEgMTcgOSBcXFwiLz48L3N2Zz5cIjtcblxuICAgIGNvbnN0IGljb25zID0ge1xuICAgICAgc3Bpbm5lcixcbiAgICAgIHRvdG9wLFxuICAgICAgbWFya2VyLFxuICAgICAgJ2Nsb3NlLWljb24nOiBjbG9zZUljb24sXG4gICAgICAnY2xvc2UtbGFyZ2UnOiBjbG9zZUxhcmdlLFxuICAgICAgJ25hdmJhci10b2dnbGUtaWNvbic6IG5hdmJhclRvZ2dsZUljb24sXG4gICAgICAnb3ZlcmxheS1pY29uJzogb3ZlcmxheUljb24sXG4gICAgICAncGFnaW5hdGlvbi1uZXh0JzogcGFnaW5hdGlvbk5leHQsXG4gICAgICAncGFnaW5hdGlvbi1wcmV2aW91cyc6IHBhZ2luYXRpb25QcmV2aW91cyxcbiAgICAgICdzZWFyY2gtaWNvbic6IHNlYXJjaEljb24sXG4gICAgICAnc2VhcmNoLWxhcmdlJzogc2VhcmNoTGFyZ2UsXG4gICAgICAnc2VhcmNoLW5hdmJhcic6IHNlYXJjaE5hdmJhcixcbiAgICAgICdzbGlkZW5hdi1uZXh0Jzogc2xpZGVuYXZOZXh0LFxuICAgICAgJ3NsaWRlbmF2LW5leHQtbGFyZ2UnOiBzbGlkZW5hdk5leHRMYXJnZSxcbiAgICAgICdzbGlkZW5hdi1wcmV2aW91cyc6IHNsaWRlbmF2UHJldmlvdXMsXG4gICAgICAnc2xpZGVuYXYtcHJldmlvdXMtbGFyZ2UnOiBzbGlkZW5hdlByZXZpb3VzTGFyZ2UgfTtcblxuXG4gICAgY29uc3QgSWNvbiA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwkMyxcblxuICAgICAgZXh0ZW5kczogU1ZHLFxuXG4gICAgICBhcmdzOiAnaWNvbicsXG5cbiAgICAgIHByb3BzOiBbJ2ljb24nXSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBpbmNsdWRlOiBbJ2ZvY3VzYWJsZSddIH0sXG5cblxuICAgICAgaXNJY29uOiB0cnVlLFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLWljb24nKTtcbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgZ2V0U3ZnKCkge1xuICAgICAgICAgIGNvbnN0IGljb24gPSBnZXRJY29uKHRoaXMuaWNvbik7XG5cbiAgICAgICAgICBpZiAoIWljb24pIHtcbiAgICAgICAgICAgIHRocm93ICdJY29uIG5vdCBmb3VuZC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpY29uO1xuICAgICAgICB9IH0gfTtcblxuICAgIGNvbnN0IEljb25Db21wb25lbnQgPSB7XG4gICAgICBhcmdzOiBmYWxzZSxcblxuICAgICAgZXh0ZW5kczogSWNvbixcblxuICAgICAgZGF0YTogKHZtKSA9PiAoe1xuICAgICAgICBpY29uOiBoeXBoZW5hdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucy5uYW1lKSB9KSxcblxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy4kbmFtZSk7XG4gICAgICB9IH07XG5cblxuICAgIGNvbnN0IFNsaWRlbmF2ID0ge1xuICAgICAgZXh0ZW5kczogSWNvbkNvbXBvbmVudCxcblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsICd1ay1zbGlkZW5hdicpO1xuICAgICAgICBjb25zdCBpY29uID0gdGhpcy4kcHJvcHMuaWNvbjtcbiAgICAgICAgdGhpcy5pY29uID0gaGFzQ2xhc3ModGhpcy4kZWwsICd1ay1zbGlkZW5hdi1sYXJnZScpID8gaWNvbiArIFwiLWxhcmdlXCIgOiBpY29uO1xuICAgICAgfSB9O1xuXG5cbiAgICBjb25zdCBTZWFyY2ggPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLmljb24gPVxuICAgICAgICBoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLXNlYXJjaC1pY29uJykgJiYgcGFyZW50cyh0aGlzLiRlbCwgJy51ay1zZWFyY2gtbGFyZ2UnKS5sZW5ndGggP1xuICAgICAgICAnc2VhcmNoLWxhcmdlJyA6XG4gICAgICAgIHBhcmVudHModGhpcy4kZWwsICcudWstc2VhcmNoLW5hdmJhcicpLmxlbmd0aCA/XG4gICAgICAgICdzZWFyY2gtbmF2YmFyJyA6XG4gICAgICAgIHRoaXMuJHByb3BzLmljb247XG4gICAgICB9IH07XG5cblxuICAgIGNvbnN0IENsb3NlID0ge1xuICAgICAgZXh0ZW5kczogSWNvbkNvbXBvbmVudCxcblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5pY29uID0gXCJjbG9zZS1cIiArIChoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLWNsb3NlLWxhcmdlJykgPyAnbGFyZ2UnIDogJ2ljb24nKTtcbiAgICAgIH0gfTtcblxuXG4gICAgY29uc3QgU3Bpbm5lciA9IHtcbiAgICAgIGV4dGVuZHM6IEljb25Db21wb25lbnQsXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgZ2V0U3ZnKCkge1xuICAgICAgICAgIGNvbnN0IGljb24gPSBhd2FpdCBJY29uLm1ldGhvZHMuZ2V0U3ZnLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5yYXRpbyAhPT0gMSkge1xuICAgICAgICAgICAgY3NzKCQoJ2NpcmNsZScsIGljb24pLCAnc3Ryb2tlV2lkdGgnLCAxIC8gdGhpcy5yYXRpbyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGNvbnN0IHBhcnNlZCA9IHt9O1xuICAgIGZ1bmN0aW9uIGluc3RhbGwkMyhVSWtpdCkge1xuICAgICAgVUlraXQuaWNvbi5hZGQgPSAobmFtZSwgc3ZnKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gaXNTdHJpbmcobmFtZSkgPyB7IFtuYW1lXTogc3ZnIH0gOiBuYW1lO1xuICAgICAgICBlYWNoKGFkZGVkLCAoc3ZnLCBuYW1lKSA9PiB7XG4gICAgICAgICAgaWNvbnNbbmFtZV0gPSBzdmc7XG4gICAgICAgICAgZGVsZXRlIHBhcnNlZFtuYW1lXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKFVJa2l0Ll9pbml0aWFsaXplZCkge1xuICAgICAgICAgIGFwcGx5KGRvY3VtZW50LmJvZHksIChlbCkgPT5cbiAgICAgICAgICBlYWNoKFVJa2l0LmdldENvbXBvbmVudHMoZWwpLCAoY21wKSA9PiB7XG4gICAgICAgICAgICBjbXAuJG9wdGlvbnMuaXNJY29uICYmIGNtcC5pY29uIGluIGFkZGVkICYmIGNtcC4kcmVzZXQoKTtcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJY29uKGljb24pIHtcbiAgICAgIGlmICghaWNvbnNbaWNvbl0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyc2VkW2ljb25dKSB7XG4gICAgICAgIHBhcnNlZFtpY29uXSA9ICQoKGljb25zW2FwcGx5UnRsKGljb24pXSB8fCBpY29uc1tpY29uXSkudHJpbSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZFtpY29uXS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlSdGwoaWNvbikge1xuICAgICAgcmV0dXJuIGlzUnRsID8gc3dhcChzd2FwKGljb24sICdsZWZ0JywgJ3JpZ2h0JyksICdwcmV2aW91cycsICduZXh0JykgOiBpY29uO1xuICAgIH1cblxuICAgIGNvbnN0IG5hdGl2ZUxhenlMb2FkID0gaW5Ccm93c2VyICYmICdsb2FkaW5nJyBpbiBIVE1MSW1hZ2VFbGVtZW50LnByb3RvdHlwZTtcblxuICAgIHZhciBpbWcgPSB7XG4gICAgICBhcmdzOiAnZGF0YVNyYycsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRhdGFTcmM6IFN0cmluZyxcbiAgICAgICAgc291cmNlczogU3RyaW5nLFxuICAgICAgICBvZmZzZXRUb3A6IFN0cmluZyxcbiAgICAgICAgb2Zmc2V0TGVmdDogU3RyaW5nLFxuICAgICAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICAgICAgbG9hZGluZzogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRhU3JjOiAnJyxcbiAgICAgICAgc291cmNlczogZmFsc2UsXG4gICAgICAgIG9mZnNldFRvcDogJzUwdmgnLFxuICAgICAgICBvZmZzZXRMZWZ0OiAnNTB2dycsXG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIGxvYWRpbmc6ICdsYXp5JyB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMubG9hZGluZyAhPT0gJ2xhenknKSB7XG4gICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gW3RoaXMuJGVsLCAuLi5xdWVyeUFsbCh0aGlzLiRwcm9wcy50YXJnZXQsIHRoaXMuJGVsKV07XG5cbiAgICAgICAgaWYgKG5hdGl2ZUxhenlMb2FkICYmIGlzSW1nKHRoaXMuJGVsKSkge1xuICAgICAgICAgIHRoaXMuJGVsLmxvYWRpbmcgPSAnbGF6eSc7XG4gICAgICAgICAgc2V0U3JjQXR0cnModGhpcy4kZWwpO1xuXG4gICAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbnN1cmVTcmNBdHRyaWJ1dGUodGhpcy4kZWwpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJPYnNlcnZlcihcbiAgICAgICAgb2JzZXJ2ZUludGVyc2VjdGlvbihcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICAoZW50cmllcywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByb290TWFyZ2luOiB0b1B4KHRoaXMub2Zmc2V0VG9wLCAnaGVpZ2h0JykgKyBcInB4IFwiICsgdG9QeChcbiAgICAgICAgICB0aGlzLm9mZnNldExlZnQsXG4gICAgICAgICAgJ3dpZHRoJykgKyBcInB4XCIgfSkpO1xuXG5cblxuXG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhLmltYWdlKSB7XG4gICAgICAgICAgdGhpcy5fZGF0YS5pbWFnZS5vbmxvYWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBsb2FkKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9kYXRhLmltYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5pbWFnZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpbWFnZSA9IGlzSW1nKHRoaXMuJGVsKSA/XG4gICAgICAgICAgdGhpcy4kZWwgOlxuICAgICAgICAgIGdldEltYWdlRnJvbUVsZW1lbnQodGhpcy4kZWwsIHRoaXMuZGF0YVNyYywgdGhpcy5zb3VyY2VzKTtcblxuICAgICAgICAgIHJlbW92ZUF0dHIoaW1hZ2UsICdsb2FkaW5nJyk7XG4gICAgICAgICAgc2V0U3JjQXR0cnModGhpcy4kZWwsIGltYWdlLmN1cnJlbnRTcmMpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmltYWdlID0gaW1hZ2U7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIHNldFNyY0F0dHJzKGVsLCBzcmMpIHtcbiAgICAgIGlmIChpc0ltZyhlbCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHBhcmVudChlbCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gaXNQaWN0dXJlKHBhcmVudE5vZGUpID8gY2hpbGRyZW4ocGFyZW50Tm9kZSkgOiBbZWxdO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbCkgPT4gc2V0U291cmNlUHJvcHMoZWwsIGVsKSk7XG4gICAgICB9IGVsc2UgaWYgKHNyYykge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSAhaW5jbHVkZXMoZWwuc3R5bGUuYmFja2dyb3VuZEltYWdlLCBzcmMpO1xuICAgICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICAgY3NzKGVsLCAnYmFja2dyb3VuZEltYWdlJywgXCJ1cmwoXCIgKyBlc2NhcGUoc3JjKSArIFwiKVwiKTtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCBjcmVhdGVFdmVudCgnbG9hZCcsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzcmNQcm9wcyA9IFsnZGF0YS1zcmMnLCAnZGF0YS1zcmNzZXQnLCAnc2l6ZXMnXTtcbiAgICBmdW5jdGlvbiBzZXRTb3VyY2VQcm9wcyhzb3VyY2VFbCwgdGFyZ2V0RWwpIHtcbiAgICAgIHNyY1Byb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhKHNvdXJjZUVsLCBwcm9wKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgYXR0cih0YXJnZXRFbCwgcHJvcC5yZXBsYWNlKC9eKGRhdGEtKSsvLCAnJyksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW1hZ2VGcm9tRWxlbWVudChlbCwgc3JjLCBzb3VyY2VzKSB7XG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgd3JhcEluUGljdHVyZShpbWcsIHNvdXJjZXMpO1xuICAgICAgc2V0U291cmNlUHJvcHMoZWwsIGltZyk7XG4gICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBzZXRTcmNBdHRycyhlbCwgaW1nLmN1cnJlbnRTcmMpO1xuICAgICAgfTtcbiAgICAgIGF0dHIoaW1nLCAnc3JjJywgc3JjKTtcbiAgICAgIHJldHVybiBpbWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcEluUGljdHVyZShpbWcsIHNvdXJjZXMpIHtcbiAgICAgIHNvdXJjZXMgPSBwYXJzZVNvdXJjZXMoc291cmNlcyk7XG5cbiAgICAgIGlmIChzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwaWN0dXJlID0gZnJhZ21lbnQoJzxwaWN0dXJlPicpO1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHJzIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSBmcmFnbWVudCgnPHNvdXJjZT4nKTtcbiAgICAgICAgICBhdHRyKHNvdXJjZSwgYXR0cnMpO1xuICAgICAgICAgIGFwcGVuZChwaWN0dXJlLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZChwaWN0dXJlLCBpbWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU291cmNlcyhzb3VyY2VzKSB7XG4gICAgICBpZiAoIXNvdXJjZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRzV2l0aChzb3VyY2VzLCAnWycpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc291cmNlcyA9IEpTT04ucGFyc2Uoc291cmNlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzb3VyY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZXMgPSBwYXJzZU9wdGlvbnMoc291cmNlcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBcnJheShzb3VyY2VzKSkge1xuICAgICAgICBzb3VyY2VzID0gW3NvdXJjZXNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc291cmNlcy5maWx0ZXIoKHNvdXJjZSkgPT4gIWlzRW1wdHkoc291cmNlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5zdXJlU3JjQXR0cmlidXRlKGVsKSB7XG4gICAgICBpZiAoaXNJbWcoZWwpICYmICFoYXNBdHRyKGVsLCAnc3JjJykpIHtcbiAgICAgICAgYXR0cihlbCwgJ3NyYycsICdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48L3N2Zz4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BpY3R1cmUoZWwpIHtcbiAgICAgIHJldHVybiBpc1RhZyhlbCwgJ3BpY3R1cmUnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0ltZyhlbCkge1xuICAgICAgcmV0dXJuIGlzVGFnKGVsLCAnaW1nJyk7XG4gICAgfVxuXG4gICAgdmFyIE1lZGlhID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbWVkaWE6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1lZGlhOiBmYWxzZSB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgY29uc3QgbWVkaWEgPSB0b01lZGlhKHRoaXMubWVkaWEpO1xuICAgICAgICB0aGlzLm1lZGlhT2JqID0gd2luZG93Lm1hdGNoTWVkaWEobWVkaWEpO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMubWF0Y2hNZWRpYSA9IHRoaXMubWVkaWFPYmoubWF0Y2hlcztcbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCBjcmVhdGVFdmVudCgnbWVkaWFjaGFuZ2UnLCBmYWxzZSwgdHJ1ZSwgW3RoaXMubWVkaWFPYmpdKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2ZmTWVkaWFPYmogPSBvbih0aGlzLm1lZGlhT2JqLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdyZXNpemUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHt2YXIgX3RoaXMkb2ZmTWVkaWFPYmo7XG4gICAgICAgIChfdGhpcyRvZmZNZWRpYU9iaiA9IHRoaXMub2ZmTWVkaWFPYmopID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvZmZNZWRpYU9iai5jYWxsKHRoaXMpO1xuICAgICAgfSB9O1xuXG5cbiAgICBmdW5jdGlvbiB0b01lZGlhKHZhbHVlKSB7XG4gICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGlmIChzdGFydHNXaXRoKHZhbHVlLCAnQCcpKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IFwiYnJlYWtwb2ludC1cIiArIHZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICB2YWx1ZSA9IHRvRmxvYXQoZ2V0Q3NzVmFyKG5hbWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlICYmIGlzTnVtZXJpYyh2YWx1ZSkgPyBcIihtaW4td2lkdGg6IFwiICsgdmFsdWUgKyBcInB4KVwiIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIGxlYWRlciA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBNZWRpYSwgUmVzaXplXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZmlsbDogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBmaWxsOiAnJyxcbiAgICAgICAgY2xzV3JhcHBlcjogJ3VrLWxlYWRlci1maWxsJyxcbiAgICAgICAgY2xzSGlkZTogJ3VrLWxlYWRlci1oaWRlJyxcbiAgICAgICAgYXR0ckZpbGw6ICdkYXRhLWZpbGwnIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZmlsbChfcmVmKSB7bGV0IHsgZmlsbCB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gZmlsbCB8fCBnZXRDc3NWYXIoJ2xlYWRlci1maWxsLWNvbnRlbnQnKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgW3RoaXMud3JhcHBlcl0gPSB3cmFwSW5uZXIodGhpcy4kZWwsIFwiPHNwYW4gY2xhc3M9XFxcIlwiICsgdGhpcy5jbHNXcmFwcGVyICsgXCJcXFwiPlwiKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdW53cmFwKHRoaXMud3JhcHBlci5jaGlsZE5vZGVzKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC50cnVuYyh0aGlzLiRlbC5vZmZzZXRXaWR0aCAvIDIpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgZmlsbDogdGhpcy5maWxsLFxuICAgICAgICAgICAgaGlkZTogIXRoaXMubWF0Y2hNZWRpYSB9O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZjIpIHtsZXQgeyB3aWR0aCwgZmlsbCwgaGlkZSB9ID0gX3JlZjI7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy53cmFwcGVyLCB0aGlzLmNsc0hpZGUsIGhpZGUpO1xuICAgICAgICAgIGF0dHIodGhpcy53cmFwcGVyLCB0aGlzLmF0dHJGaWxsLCBuZXcgQXJyYXkod2lkdGgpLmpvaW4oZmlsbCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cbiAgICBjb25zdCBhY3RpdmUgPSBbXTtcblxuICAgIHZhciBNb2RhbCA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBDb250YWluZXIsIFRvZ2dsYWJsZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHNlbFBhbmVsOiBTdHJpbmcsXG4gICAgICAgIHNlbENsb3NlOiBTdHJpbmcsXG4gICAgICAgIGVzY0Nsb3NlOiBCb29sZWFuLFxuICAgICAgICBiZ0Nsb3NlOiBCb29sZWFuLFxuICAgICAgICBzdGFjazogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY2xzOiAndWstb3BlbicsXG4gICAgICAgIGVzY0Nsb3NlOiB0cnVlLFxuICAgICAgICBiZ0Nsb3NlOiB0cnVlLFxuICAgICAgICBvdmVybGF5OiB0cnVlLFxuICAgICAgICBzdGFjazogZmFsc2UgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBwYW5lbChfcmVmLCAkZWwpIHtsZXQgeyBzZWxQYW5lbCB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gJChzZWxQYW5lbCwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2l0aW9uRWxlbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYW5lbDtcbiAgICAgICAgfSxcblxuICAgICAgICBiZ0Nsb3NlKF9yZWYyKSB7bGV0IHsgYmdDbG9zZSB9ID0gX3JlZjI7XG4gICAgICAgICAgcmV0dXJuIGJnQ2xvc2UgJiYgdGhpcy5wYW5lbDtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGJlZm9yZURpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmIChpbmNsdWRlcyhhY3RpdmUsIHRoaXMpKSB7XG4gICAgICAgICAgdGhpcy50b2dnbGVFbGVtZW50KHRoaXMuJGVsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxDbG9zZTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b2dnbGUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpID09PSBpbmNsdWRlcyhhY3RpdmUsIHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2JlZm9yZXNob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGluY2x1ZGVzKGFjdGl2ZSwgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuc3RhY2sgJiYgYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoYWN0aXZlLm1hcCgobW9kYWwpID0+IG1vZGFsLmhpZGUoKSkpLnRoZW4odGhpcy5zaG93KTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlLnB1c2godGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGNvbnN0IGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgICAgaWYgKHdpZHRoKHdpbmRvdykgPiBkb2NFbC5jbGllbnRXaWR0aCAmJiB0aGlzLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAnb3ZlcmZsb3dZJywgJ3Njcm9sbCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsICd6SW5kZXgnLCB0b0Zsb2F0KGNzcyh0aGlzLiRlbCwgJ3pJbmRleCcpKSArIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFkZENsYXNzKGRvY0VsLCB0aGlzLmNsc1BhZ2UpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuYmdDbG9zZSkge1xuICAgICAgICAgICAgb25jZShcbiAgICAgICAgICAgIHRoaXMuJGVsLFxuICAgICAgICAgICAgJ2hpZGUnLFxuICAgICAgICAgICAgb24oZG9jdW1lbnQsIHBvaW50ZXJEb3duLCAoX3JlZjMpID0+IHtsZXQgeyB0YXJnZXQgfSA9IF9yZWYzO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGxhc3QoYWN0aXZlKSAhPT0gdGhpcyB8fFxuICAgICAgICAgICAgICB0aGlzLm92ZXJsYXkgJiYgIXdpdGhpbih0YXJnZXQsIHRoaXMuJGVsKSB8fFxuICAgICAgICAgICAgICB3aXRoaW4odGFyZ2V0LCB0aGlzLnBhbmVsKSlcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgICAgICBwb2ludGVyVXAgKyBcIiBcIiArIHBvaW50ZXJDYW5jZWwgKyBcIiBzY3JvbGxcIixcbiAgICAgICAgICAgICAgKF9yZWY0KSA9PiB7bGV0IHsgZGVmYXVsdFByZXZlbnRlZCwgdHlwZSwgdGFyZ2V0OiBuZXdUYXJnZXQgfSA9IF9yZWY0O1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhZGVmYXVsdFByZXZlbnRlZCAmJlxuICAgICAgICAgICAgICAgIHR5cGUgPT09IHBvaW50ZXJVcCAmJlxuICAgICAgICAgICAgICAgIHRhcmdldCA9PT0gbmV3VGFyZ2V0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeyBzZWxmOiB0cnVlIH0pO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZXNjQ2xvc2UpIHtcbiAgICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICAgICdoaWRlJyxcbiAgICAgICAgICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3ICYmIGxhc3QoYWN0aXZlKSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3duJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKCFpc0ZvY3VzYWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIGF0dHIodGhpcy4kZWwsICd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghJCgnOmZvY3VzJywgdGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGRlbicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChpbmNsdWRlcyhhY3RpdmUsIHRoaXMpKSB7XG4gICAgICAgICAgICBhY3RpdmUuc3BsaWNlKGFjdGl2ZS5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAnb3ZlcmZsb3dZJywgJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ3pJbmRleCcsICcnKTtcblxuICAgICAgICAgIGlmICghYWN0aXZlLnNvbWUoKG1vZGFsKSA9PiBtb2RhbC5jbHNQYWdlID09PSB0aGlzLmNsc1BhZ2UpKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzUGFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNUb2dnbGVkKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyICYmIHBhcmVudCh0aGlzLiRlbCkgIT09IHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmQodGhpcy5jb250YWluZXIsIHRoaXMuJGVsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnNob3coKS50aGVuKHJlc29sdmUpKSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy50b2dnbGVFbGVtZW50KHRoaXMuJGVsLCB0cnVlLCBhbmltYXRlKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIGZhbHNlLCBhbmltYXRlKHRoaXMpKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gYW5pbWF0ZShfcmVmNSkge2xldCB7IHRyYW5zaXRpb25FbGVtZW50LCBfdG9nZ2xlIH0gPSBfcmVmNTtcbiAgICAgIHJldHVybiAoZWwsIHNob3cpID0+XG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgb25jZShlbCwgJ3Nob3cgaGlkZScsICgpID0+IHtcbiAgICAgICAgZWwuX3JlamVjdCAmJiBlbC5fcmVqZWN0KCk7XG4gICAgICAgIGVsLl9yZWplY3QgPSByZWplY3Q7XG5cbiAgICAgICAgX3RvZ2dsZShlbCwgc2hvdyk7XG5cbiAgICAgICAgY29uc3Qgb2ZmID0gb25jZShcbiAgICAgICAgdHJhbnNpdGlvbkVsZW1lbnQsXG4gICAgICAgICd0cmFuc2l0aW9uc3RhcnQnLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgb25jZSh0cmFuc2l0aW9uRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQgdHJhbnNpdGlvbmNhbmNlbCcsIHJlc29sdmUsIHtcbiAgICAgICAgICAgIHNlbGY6IHRydWUgfSk7XG5cbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB9LFxuICAgICAgICB7IHNlbGY6IHRydWUgfSk7XG5cblxuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIG9mZigpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgdG9Ncyhjc3ModHJhbnNpdGlvbkVsZW1lbnQsICd0cmFuc2l0aW9uRHVyYXRpb24nKSkpO1xuICAgICAgfSkpLlxuICAgICAgdGhlbigoKSA9PiBkZWxldGUgZWwuX3JlamVjdCk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGFsID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCQyLFxuXG4gICAgICBtaXhpbnM6IFtNb2RhbF0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY2xzUGFnZTogJ3VrLW1vZGFsLXBhZ2UnLFxuICAgICAgICBzZWxQYW5lbDogJy51ay1tb2RhbC1kaWFsb2cnLFxuICAgICAgICBzZWxDbG9zZTpcbiAgICAgICAgJy51ay1tb2RhbC1jbG9zZSwgLnVrLW1vZGFsLWNsb3NlLWRlZmF1bHQsIC51ay1tb2RhbC1jbG9zZS1vdXRzaWRlLCAudWstbW9kYWwtY2xvc2UtZnVsbCcgfSxcblxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBpZiAoaGFzQ2xhc3ModGhpcy5wYW5lbCwgJ3VrLW1hcmdpbi1hdXRvLXZlcnRpY2FsJykpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCAndWstZmxleCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGVpZ2h0KHRoaXMuJGVsKTsgLy8gZm9yY2UgcmVmbG93XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRkZW4nLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsICdkaXNwbGF5JywgJycpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuJGVsLCAndWstZmxleCcpO1xuICAgICAgICB9IH1dIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsJDIoX3JlZikge2xldCB7IG1vZGFsIH0gPSBfcmVmO1xuICAgICAgbW9kYWwuZGlhbG9nID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZGlhbG9nID0gbW9kYWwoXCI8ZGl2IGNsYXNzPVxcXCJ1ay1tb2RhbFxcXCI+IDxkaXYgY2xhc3M9XFxcInVrLW1vZGFsLWRpYWxvZ1xcXCI+XCIgK1xuXG4gICAgICAgIGNvbnRlbnQgKyBcIjwvZGl2PiA8L2Rpdj5cIixcblxuICAgICAgICBvcHRpb25zKTtcblxuXG4gICAgICAgIGRpYWxvZy5zaG93KCk7XG5cbiAgICAgICAgb24oXG4gICAgICAgIGRpYWxvZy4kZWwsXG4gICAgICAgICdoaWRkZW4nLFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgZGlhbG9nLiRkZXN0cm95KHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICB7IHNlbGY6IHRydWUgfSk7XG5cblxuICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgICAgfTtcblxuICAgICAgbW9kYWwuYWxlcnQgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3BlbkRpYWxvZyhcbiAgICAgICAgKF9yZWYyKSA9PiB7bGV0IHsgbGFiZWxzIH0gPSBfcmVmMjtyZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJ1ay1tb2RhbC1ib2R5XFxcIj5cIiArIChcbiAgICAgICAgICBpc1N0cmluZyhtZXNzYWdlKSA/IG1lc3NhZ2UgOiBodG1sKG1lc3NhZ2UpKSArIFwiPC9kaXY+IDxkaXYgY2xhc3M9XFxcInVrLW1vZGFsLWZvb3RlciB1ay10ZXh0LXJpZ2h0XFxcIj4gPGJ1dHRvbiBjbGFzcz1cXFwidWstYnV0dG9uIHVrLWJ1dHRvbi1wcmltYXJ5IHVrLW1vZGFsLWNsb3NlXFxcIiBhdXRvZm9jdXM+XCIgK1xuXG5cblxuICAgICAgICAgIGxhYmVscy5vayArIFwiPC9idXR0b24+IDwvZGl2PlwiO30sXG5cblxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAoZGVmZXJyZWQpID0+IGRlZmVycmVkLnJlc29sdmUoKSk7XG5cbiAgICAgIH07XG5cbiAgICAgIG1vZGFsLmNvbmZpcm0gPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3BlbkRpYWxvZyhcbiAgICAgICAgKF9yZWYzKSA9PiB7bGV0IHsgbGFiZWxzIH0gPSBfcmVmMztyZXR1cm4gXCI8Zm9ybT4gPGRpdiBjbGFzcz1cXFwidWstbW9kYWwtYm9keVxcXCI+XCIgKyAoXG4gICAgICAgICAgaXNTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogaHRtbChtZXNzYWdlKSkgKyBcIjwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJ1ay1tb2RhbC1mb290ZXIgdWstdGV4dC1yaWdodFxcXCI+IDxidXR0b24gY2xhc3M9XFxcInVrLWJ1dHRvbiB1ay1idXR0b24tZGVmYXVsdCB1ay1tb2RhbC1jbG9zZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5cIiArXG5cblxuICAgICAgICAgIGxhYmVscy5jYW5jZWwgKyBcIjwvYnV0dG9uPiA8YnV0dG9uIGNsYXNzPVxcXCJ1ay1idXR0b24gdWstYnV0dG9uLXByaW1hcnlcXFwiIGF1dG9mb2N1cz5cIiArXG5cbiAgICAgICAgICBsYWJlbHMub2sgKyBcIjwvYnV0dG9uPiA8L2Rpdj4gPC9mb3JtPlwiO30sXG5cblxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAoZGVmZXJyZWQpID0+IGRlZmVycmVkLnJlamVjdCgpKTtcblxuICAgICAgfTtcblxuICAgICAgbW9kYWwucHJvbXB0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcGVuRGlhbG9nKFxuICAgICAgICAoX3JlZjQpID0+IHtsZXQgeyBsYWJlbHMgfSA9IF9yZWY0O3JldHVybiBcIjxmb3JtIGNsYXNzPVxcXCJ1ay1mb3JtLXN0YWNrZWRcXFwiPiA8ZGl2IGNsYXNzPVxcXCJ1ay1tb2RhbC1ib2R5XFxcIj4gPGxhYmVsPlwiICsgKFxuXG4gICAgICAgICAgaXNTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogaHRtbChtZXNzYWdlKSkgKyBcIjwvbGFiZWw+IDxpbnB1dCBjbGFzcz1cXFwidWstaW5wdXRcXFwiIHZhbHVlPVxcXCJcIiArIChcbiAgICAgICAgICB2YWx1ZSB8fCAnJykgKyBcIlxcXCIgYXV0b2ZvY3VzPiA8L2Rpdj4gPGRpdiBjbGFzcz1cXFwidWstbW9kYWwtZm9vdGVyIHVrLXRleHQtcmlnaHRcXFwiPiA8YnV0dG9uIGNsYXNzPVxcXCJ1ay1idXR0b24gdWstYnV0dG9uLWRlZmF1bHQgdWstbW9kYWwtY2xvc2VcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCI+XCIgK1xuXG5cblxuICAgICAgICAgIGxhYmVscy5jYW5jZWwgKyBcIjwvYnV0dG9uPiA8YnV0dG9uIGNsYXNzPVxcXCJ1ay1idXR0b24gdWstYnV0dG9uLXByaW1hcnlcXFwiPlwiICtcblxuICAgICAgICAgIGxhYmVscy5vayArIFwiPC9idXR0b24+IDwvZGl2PiA8L2Zvcm0+XCI7fSxcblxuXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIChkZWZlcnJlZCkgPT4gZGVmZXJyZWQucmVzb2x2ZShudWxsKSxcbiAgICAgICAgKGRpYWxvZykgPT4gJCgnaW5wdXQnLCBkaWFsb2cuJGVsKS52YWx1ZSk7XG5cbiAgICAgIH07XG5cbiAgICAgIG1vZGFsLmxhYmVscyA9IHtcbiAgICAgICAgb2s6ICdPaycsXG4gICAgICAgIGNhbmNlbDogJ0NhbmNlbCcgfTtcblxuXG4gICAgICBmdW5jdGlvbiBvcGVuRGlhbG9nKHRtcGwsIG9wdGlvbnMsIGhpZGVGbiwgc3VibWl0Rm4pIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgYmdDbG9zZTogZmFsc2UsIGVzY0Nsb3NlOiB0cnVlLCBsYWJlbHM6IG1vZGFsLmxhYmVscywgLi4ub3B0aW9ucyB9O1xuXG4gICAgICAgIGNvbnN0IGRpYWxvZyA9IG1vZGFsLmRpYWxvZyh0bXBsKG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcblxuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcblxuICAgICAgICBvbihkaWFsb2cuJGVsLCAnc3VibWl0JywgJ2Zvcm0nLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHN1Ym1pdEZuID09IG51bGwgPyB2b2lkIDAgOiBzdWJtaXRGbihkaWFsb2cpKTtcbiAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgZGlhbG9nLmhpZGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb24oZGlhbG9nLiRlbCwgJ2hpZGUnLCAoKSA9PiAhcmVzb2x2ZWQgJiYgaGlkZUZuKGRlZmVycmVkKSk7XG5cbiAgICAgICAgZGVmZXJyZWQucHJvbWlzZS5kaWFsb2cgPSBkaWFsb2c7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5hdiA9IHtcbiAgICAgIGV4dGVuZHM6IEFjY29yZGlvbixcblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXRzOiAnPiAudWstcGFyZW50JyxcbiAgICAgICAgdG9nZ2xlOiAnPiBhJyxcbiAgICAgICAgY29udGVudDogJz4gdWwnIH0gfTtcblxuICAgIGNvbnN0IG5hdkl0ZW0gPSAnLnVrLW5hdmJhci1uYXYgPiBsaSA+IGEsIC51ay1uYXZiYXItaXRlbSwgLnVrLW5hdmJhci10b2dnbGUnO1xuXG4gICAgdmFyIG5hdmJhciA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBDb250YWluZXJdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBkcm9wZG93bjogU3RyaW5nLFxuICAgICAgICBtb2RlOiAnbGlzdCcsXG4gICAgICAgIGFsaWduOiBTdHJpbmcsXG4gICAgICAgIG9mZnNldDogTnVtYmVyLFxuICAgICAgICBib3VuZGFyeTogQm9vbGVhbixcbiAgICAgICAgYm91bmRhcnlBbGlnbjogQm9vbGVhbixcbiAgICAgICAgY2xzRHJvcDogU3RyaW5nLFxuICAgICAgICBkZWxheVNob3c6IE51bWJlcixcbiAgICAgICAgZGVsYXlIaWRlOiBOdW1iZXIsXG4gICAgICAgIGRyb3BiYXI6IEJvb2xlYW4sXG4gICAgICAgIGRyb3BiYXJBbmNob3I6IEJvb2xlYW4sXG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRyb3Bkb3duOiBuYXZJdGVtLFxuICAgICAgICBhbGlnbjogaXNSdGwgPyAncmlnaHQnIDogJ2xlZnQnLFxuICAgICAgICBjbHNEcm9wOiAndWstbmF2YmFyLWRyb3Bkb3duJyxcbiAgICAgICAgbW9kZTogdW5kZWZpbmVkLFxuICAgICAgICBvZmZzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVsYXlTaG93OiB1bmRlZmluZWQsXG4gICAgICAgIGRlbGF5SGlkZTogdW5kZWZpbmVkLFxuICAgICAgICBib3VuZGFyeUFsaWduOiB1bmRlZmluZWQsXG4gICAgICAgIGZsaXA6ICd4JyxcbiAgICAgICAgYm91bmRhcnk6IHRydWUsXG4gICAgICAgIGRyb3BiYXI6IGZhbHNlLFxuICAgICAgICBkcm9wYmFyQW5jaG9yOiBmYWxzZSxcbiAgICAgICAgZHVyYXRpb246IDIwMCxcbiAgICAgICAgY29udGFpbmVyOiBmYWxzZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGJvdW5kYXJ5KF9yZWYsICRlbCkge2xldCB7IGJvdW5kYXJ5IH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBib3VuZGFyeSA9PT0gdHJ1ZSA/ICRlbCA6IGJvdW5kYXJ5O1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyb3BiYXJBbmNob3IoX3JlZjIsICRlbCkge2xldCB7IGRyb3BiYXJBbmNob3IgfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiBxdWVyeShkcm9wYmFyQW5jaG9yLCAkZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvcyhfcmVmMykge2xldCB7IGFsaWduIH0gPSBfcmVmMztcbiAgICAgICAgICByZXR1cm4gXCJib3R0b20tXCIgKyBhbGlnbjtcbiAgICAgICAgfSxcblxuICAgICAgICBkcm9wYmFyOiB7XG4gICAgICAgICAgZ2V0KF9yZWY0KSB7bGV0IHsgZHJvcGJhciB9ID0gX3JlZjQ7XG4gICAgICAgICAgICBpZiAoIWRyb3BiYXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyb3BiYXIgPVxuICAgICAgICAgICAgdGhpcy5fZHJvcGJhciB8fFxuICAgICAgICAgICAgcXVlcnkoZHJvcGJhciwgdGhpcy4kZWwpIHx8XG4gICAgICAgICAgICAkKCcrIC51ay1uYXZiYXItZHJvcGJhcicsIHRoaXMuJGVsKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRyb3BiYXIgPyBkcm9wYmFyIDogdGhpcy5fZHJvcGJhciA9ICQoJzxkaXY+PC9kaXY+Jyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGRyb3BiYXIpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGRyb3BiYXIsICd1ay1uYXZiYXItZHJvcGJhcicpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIGRyb3BDb250YWluZXIoXywgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyIHx8ICRlbDtcbiAgICAgICAgfSxcblxuICAgICAgICBkcm9wZG93bnM6IHtcbiAgICAgICAgICBnZXQoX3JlZjUsICRlbCkge2xldCB7IGNsc0Ryb3AgfSA9IF9yZWY1O1xuICAgICAgICAgICAgY29uc3QgZHJvcGRvd25zID0gJCQoXCIuXCIgKyBjbHNEcm9wLCAkZWwpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5kcm9wQ29udGFpbmVyICE9PSAkZWwpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiAkJChcIi5cIiArIGNsc0Ryb3AsIHRoaXMuZHJvcENvbnRhaW5lcikpIHt2YXIgX3RoaXMkZ2V0RHJvcGRvd247XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKF90aGlzJGdldERyb3Bkb3duID0gdGhpcy5nZXREcm9wZG93bihlbCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRnZXREcm9wZG93bi50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmNsdWRlcyhkcm9wZG93bnMsIGVsKSAmJiB0YXJnZXQgJiYgd2l0aGluKHRhcmdldCwgdGhpcy4kZWwpKSB7XG4gICAgICAgICAgICAgICAgICBkcm9wZG93bnMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkcm9wZG93bnM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGRyb3Bkb3ducykge1xuICAgICAgICAgICAgdGhpcy4kY3JlYXRlKFxuICAgICAgICAgICAgJ2Ryb3AnLFxuICAgICAgICAgICAgZHJvcGRvd25zLmZpbHRlcigoZWwpID0+ICF0aGlzLmdldERyb3Bkb3duKGVsKSksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLnRoaXMuJHByb3BzLFxuICAgICAgICAgICAgICBib3VuZGFyeTogdGhpcy5ib3VuZGFyeSxcbiAgICAgICAgICAgICAgcG9zOiB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmRyb3BiYXIgfHwgdGhpcy5vZmZzZXQgfSk7XG5cblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIHRvZ2dsZXMoX3JlZjYsICRlbCkge2xldCB7IGRyb3Bkb3duIH0gPSBfcmVmNjtcbiAgICAgICAgICByZXR1cm4gJCQoZHJvcGRvd24sICRlbCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuZHJvcGJhciAmJiByZW1vdmUkMSh0aGlzLmRyb3BiYXIpO1xuICAgICAgICBkZWxldGUgdGhpcy5fZHJvcGJhcjtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnbW91c2VvdmVyIGZvY3VzaW4nLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3duO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjcpIHtsZXQgeyBjdXJyZW50IH0gPSBfcmVmNztcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICBhY3RpdmUgJiZcbiAgICAgICAgICBpbmNsdWRlcyhhY3RpdmUubW9kZSwgJ2hvdmVyJykgJiZcbiAgICAgICAgICBhY3RpdmUudGFyZ2V0ICYmXG4gICAgICAgICAgIXdpdGhpbihhY3RpdmUudGFyZ2V0LCBjdXJyZW50KSAmJlxuICAgICAgICAgICFhY3RpdmUuaXNEZWxheWluZylcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY3RpdmUuaGlkZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAna2V5ZG93bicsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd247XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgY29uc3QgeyBjdXJyZW50LCBrZXlDb2RlIH0gPSBlO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG5cbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLkRPV04gJiYgaGFzQXR0cihjdXJyZW50LCAnYXJpYS1leHBhbmRlZCcpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmICghYWN0aXZlIHx8IGFjdGl2ZS50YXJnZXQgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY3VycmVudC5jbGljaygpO1xuICAgICAgICAgICAgICBvbmNlKHRoaXMuZHJvcENvbnRhaW5lciwgJ3Nob3cnLCAoX3JlZjgpID0+IHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY4O3JldHVybiAoXG4gICAgICAgICAgICAgICAgICBmb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudCh0YXJnZXQpKTt9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQoYWN0aXZlLiRlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlTmF2SXRlbU5hdmlnYXRpb24oZSwgdGhpcy50b2dnbGVzLCBhY3RpdmUpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAna2V5ZG93bicsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gXCIuXCIgKyB0aGlzLmNsc0Ryb3A7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgY29uc3QgeyBjdXJyZW50LCBrZXlDb2RlIH0gPSBlO1xuXG4gICAgICAgICAgaWYgKCFpbmNsdWRlcyh0aGlzLmRyb3Bkb3ducywgY3VycmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gJCQoc2VsRm9jdXNhYmxlLCBjdXJyZW50KTtcbiAgICAgICAgICBjb25zdCBpID0gZmluZEluZGV4KGVsZW1lbnRzLCAoZWwpID0+IG1hdGNoZXMoZWwsICc6Zm9jdXMnKSk7XG5cbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLlVQKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgZWxlbWVudHNbaSAtIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5ET1dOKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoaSA8IGVsZW1lbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgZWxlbWVudHNbaSArIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5FU0MpIHt2YXIgX2FjdGl2ZSR0YXJnZXQ7XG4gICAgICAgICAgICBhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IChfYWN0aXZlJHRhcmdldCA9IGFjdGl2ZS50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYWN0aXZlJHRhcmdldC5mb2N1cygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZU5hdkl0ZW1OYXZpZ2F0aW9uKGUsIHRoaXMudG9nZ2xlcywgYWN0aXZlKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ21vdXNlbGVhdmUnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGFjdGl2ZSAmJlxuICAgICAgICAgIGluY2x1ZGVzKGFjdGl2ZS5tb2RlLCAnaG92ZXInKSAmJlxuICAgICAgICAgICF0aGlzLmRyb3Bkb3ducy5zb21lKChlbCkgPT4gbWF0Y2hlcyhlbCwgJzpob3ZlcicpKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY3RpdmUuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2JlZm9yZXNob3cnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BDb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfLCBfcmVmOSkge2xldCB7ICRlbCB9ID0gX3JlZjk7XG4gICAgICAgICAgaWYgKCFoYXNDbGFzcygkZWwsIHRoaXMuY2xzRHJvcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXBhcmVudCh0aGlzLmRyb3BiYXIpKSB7XG4gICAgICAgICAgICBhZnRlcih0aGlzLmRyb3BiYXJBbmNob3IgfHwgdGhpcy4kZWwsIHRoaXMuZHJvcGJhcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkQ2xhc3MoJGVsLCB0aGlzLmNsc0Ryb3AgKyBcIi1kcm9wYmFyXCIpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvdycsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF8sIF9yZWYxMCkge2xldCB7ICRlbCwgZGlyIH0gPSBfcmVmMTA7XG4gICAgICAgICAgaWYgKCFoYXNDbGFzcygkZWwsIHRoaXMuY2xzRHJvcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGlyID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXG4gICAgICAgICAgICBvZmZzZXQoJGVsKS5ib3R0b20gLVxuICAgICAgICAgICAgb2Zmc2V0KHRoaXMuZHJvcGJhcikudG9wICtcbiAgICAgICAgICAgIHRvRmxvYXQoY3NzKCRlbCwgJ21hcmdpbkJvdHRvbScpKSxcbiAgICAgICAgICAgICRlbCk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdiZWZvcmVoaWRlJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSwgX3JlZjExKSB7bGV0IHsgJGVsIH0gPSBfcmVmMTE7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICBtYXRjaGVzKHRoaXMuZHJvcGJhciwgJzpob3ZlcicpICYmXG4gICAgICAgICAgKGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLiRlbCkgPT09ICRlbCAmJlxuICAgICAgICAgICF0aGlzLnRvZ2dsZXMuc29tZSgoZWwpID0+IGFjdGl2ZS50YXJnZXQgIT09IGVsICYmIG1hdGNoZXMoZWwsICc6Zm9jdXMnKSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGUnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BDb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfLCBfcmVmMTIpIHtsZXQgeyAkZWwgfSA9IF9yZWYxMjtcbiAgICAgICAgICBpZiAoIWhhc0NsYXNzKCRlbCwgdGhpcy5jbHNEcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG5cbiAgICAgICAgICBpZiAoIWFjdGl2ZSB8fCAoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuJGVsKSA9PT0gJGVsKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbygwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldEFjdGl2ZSgpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlJDEgJiYgd2l0aGluKGFjdGl2ZSQxLnRhcmdldCwgdGhpcy4kZWwpICYmIGFjdGl2ZSQxO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zaXRpb25UbyhuZXdIZWlnaHQsIGVsKSB7XG4gICAgICAgICAgY29uc3QgeyBkcm9wYmFyIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IG9sZEhlaWdodCA9IGlzVmlzaWJsZShkcm9wYmFyKSA/IGhlaWdodChkcm9wYmFyKSA6IDA7XG5cbiAgICAgICAgICBlbCA9IG9sZEhlaWdodCA8IG5ld0hlaWdodCAmJiBlbDtcblxuICAgICAgICAgIGNzcyhlbCwgJ2NsaXAnLCBcInJlY3QoMCxcIiArIGVsLm9mZnNldFdpZHRoICsgXCJweCxcIiArIG9sZEhlaWdodCArIFwicHgsMClcIik7XG5cbiAgICAgICAgICBoZWlnaHQoZHJvcGJhciwgb2xkSGVpZ2h0KTtcblxuICAgICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKFtlbCwgZHJvcGJhcl0pO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChkcm9wYmFyLCB7IGhlaWdodDogbmV3SGVpZ2h0IH0sIHRoaXMuZHVyYXRpb24pLFxuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgeyBjbGlwOiBcInJlY3QoMCxcIiArIGVsLm9mZnNldFdpZHRoICsgXCJweCxcIiArIG5ld0hlaWdodCArIFwicHgsMClcIiB9LFxuICAgICAgICAgIHRoaXMuZHVyYXRpb24pXSkuXG5cblxuICAgICAgICAgIGNhdGNoKG5vb3ApLlxuICAgICAgICAgIHRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY3NzKGVsLCB7IGNsaXA6ICcnIH0pO1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRlKGRyb3BiYXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldERyb3Bkb3duKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJGdldENvbXBvbmVudChlbCwgJ2Ryb3AnKSB8fCB0aGlzLiRnZXRDb21wb25lbnQoZWwsICdkcm9wZG93bicpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBoYW5kbGVOYXZJdGVtTmF2aWdhdGlvbihlLCB0b2dnbGVzLCBhY3RpdmUpIHtcbiAgICAgIGNvbnN0IHsgY3VycmVudCwga2V5Q29kZSB9ID0gZTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IChhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS50YXJnZXQpIHx8IGN1cnJlbnQ7XG4gICAgICBjb25zdCBpID0gdG9nZ2xlcy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgIC8vIExlZnRcbiAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuTEVGVCAmJiBpID4gMCkge1xuICAgICAgICBhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5oaWRlKGZhbHNlKTtcbiAgICAgICAgdG9nZ2xlc1tpIC0gMV0uZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmlnaHRcbiAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuUklHSFQgJiYgaSA8IHRvZ2dsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5oaWRlKGZhbHNlKTtcbiAgICAgICAgdG9nZ2xlc1tpICsgMV0uZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5UQUIpIHtcbiAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgIGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLmhpZGUoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvY3VzRmlyc3RGb2N1c2FibGVFbGVtZW50KGVsKSB7XG4gICAgICBpZiAoISQoJzpmb2N1cycsIGVsKSkge3ZhciBfJDtcbiAgICAgICAgKF8kID0gJChzZWxGb2N1c2FibGUsIGVsKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF8kLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qga2V5TWFwID0ge1xuICAgICAgVEFCOiA5LFxuICAgICAgRVNDOiAyNyxcbiAgICAgIExFRlQ6IDM3LFxuICAgICAgVVA6IDM4LFxuICAgICAgUklHSFQ6IDM5LFxuICAgICAgRE9XTjogNDAgfTtcblxuICAgIHZhciBTd2lwZSA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHN3aXBpbmc6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHN3aXBpbmc6IHRydWUgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBzd2lwZVRhcmdldChwcm9wcywgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuICRlbDtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN3aXBpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckV2ZW50KHRoaXMsIHtcbiAgICAgICAgICBlbDogdGhpcy5zd2lwZVRhcmdldCxcbiAgICAgICAgICBuYW1lOiBwb2ludGVyRG93bixcbiAgICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKCFpc1RvdWNoKGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIFN3aXBlIEdlc3R1cmVcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGdldEV2ZW50UG9zKGUpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gJ3RhZ05hbWUnIGluIGUudGFyZ2V0ID8gZS50YXJnZXQgOiBwYXJlbnQoZS50YXJnZXQpO1xuICAgICAgICAgICAgb25jZShkb2N1bWVudCwgcG9pbnRlclVwICsgXCIgXCIgKyBwb2ludGVyQ2FuY2VsICsgXCIgc2Nyb2xsXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3MoZSk7XG5cbiAgICAgICAgICAgICAgLy8gc3dpcGVcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlLnR5cGUgIT09ICdzY3JvbGwnICYmIHRhcmdldCAmJiB4ICYmIE1hdGguYWJzKHBvcy54IC0geCkgPiAxMDAgfHxcbiAgICAgICAgICAgICAgeSAmJiBNYXRoLmFicyhwb3MueSAtIHkpID4gMTAwKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgJ3N3aXBlJyk7XG4gICAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzd2lwZVwiICsgc3dpcGVEaXJlY3Rpb24ocG9zLngsIHBvcy55LCB4LCB5KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gfSk7XG5cbiAgICAgIH0gfTtcblxuXG4gICAgZnVuY3Rpb24gc3dpcGVEaXJlY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSA+PSBNYXRoLmFicyh5MSAtIHkyKSA/XG4gICAgICB4MSAtIHgyID4gMCA/XG4gICAgICAnTGVmdCcgOlxuICAgICAgJ1JpZ2h0JyA6XG4gICAgICB5MSAtIHkyID4gMCA/XG4gICAgICAnVXAnIDpcbiAgICAgICdEb3duJztcbiAgICB9XG5cbiAgICB2YXIgb2ZmY2FudmFzID0ge1xuICAgICAgbWl4aW5zOiBbTW9kYWwsIFN3aXBlXSxcblxuICAgICAgYXJnczogJ21vZGUnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtb2RlOiBTdHJpbmcsXG4gICAgICAgIGZsaXA6IEJvb2xlYW4sXG4gICAgICAgIG92ZXJsYXk6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1vZGU6ICdzbGlkZScsXG4gICAgICAgIGZsaXA6IGZhbHNlLFxuICAgICAgICBvdmVybGF5OiBmYWxzZSxcbiAgICAgICAgY2xzUGFnZTogJ3VrLW9mZmNhbnZhcy1wYWdlJyxcbiAgICAgICAgY2xzQ29udGFpbmVyOiAndWstb2ZmY2FudmFzLWNvbnRhaW5lcicsXG4gICAgICAgIHNlbFBhbmVsOiAnLnVrLW9mZmNhbnZhcy1iYXInLFxuICAgICAgICBjbHNGbGlwOiAndWstb2ZmY2FudmFzLWZsaXAnLFxuICAgICAgICBjbHNDb250YWluZXJBbmltYXRpb246ICd1ay1vZmZjYW52YXMtY29udGFpbmVyLWFuaW1hdGlvbicsXG4gICAgICAgIGNsc1NpZGViYXJBbmltYXRpb246ICd1ay1vZmZjYW52YXMtYmFyLWFuaW1hdGlvbicsXG4gICAgICAgIGNsc01vZGU6ICd1ay1vZmZjYW52YXMnLFxuICAgICAgICBjbHNPdmVybGF5OiAndWstb2ZmY2FudmFzLW92ZXJsYXknLFxuICAgICAgICBzZWxDbG9zZTogJy51ay1vZmZjYW52YXMtY2xvc2UnLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xzRmxpcChfcmVmKSB7bGV0IHsgZmxpcCwgY2xzRmxpcCB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gZmxpcCA/IGNsc0ZsaXAgOiAnJztcbiAgICAgICAgfSxcblxuICAgICAgICBjbHNPdmVybGF5KF9yZWYyKSB7bGV0IHsgb3ZlcmxheSwgY2xzT3ZlcmxheSB9ID0gX3JlZjI7XG4gICAgICAgICAgcmV0dXJuIG92ZXJsYXkgPyBjbHNPdmVybGF5IDogJyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xzTW9kZShfcmVmMykge2xldCB7IG1vZGUsIGNsc01vZGUgfSA9IF9yZWYzO1xuICAgICAgICAgIHJldHVybiBjbHNNb2RlICsgXCItXCIgKyBtb2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsc1NpZGViYXJBbmltYXRpb24oX3JlZjQpIHtsZXQgeyBtb2RlLCBjbHNTaWRlYmFyQW5pbWF0aW9uIH0gPSBfcmVmNDtcbiAgICAgICAgICByZXR1cm4gbW9kZSA9PT0gJ25vbmUnIHx8IG1vZGUgPT09ICdyZXZlYWwnID8gJycgOiBjbHNTaWRlYmFyQW5pbWF0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsc0NvbnRhaW5lckFuaW1hdGlvbihfcmVmNSkge2xldCB7IG1vZGUsIGNsc0NvbnRhaW5lckFuaW1hdGlvbiB9ID0gX3JlZjU7XG4gICAgICAgICAgcmV0dXJuIG1vZGUgIT09ICdwdXNoJyAmJiBtb2RlICE9PSAncmV2ZWFsJyA/ICcnIDogY2xzQ29udGFpbmVyQW5pbWF0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zaXRpb25FbGVtZW50KF9yZWY2KSB7bGV0IHsgbW9kZSB9ID0gX3JlZjY7XG4gICAgICAgICAgcmV0dXJuIG1vZGUgPT09ICdyZXZlYWwnID8gcGFyZW50KHRoaXMucGFuZWwpIDogdGhpcy5wYW5lbDtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpICYmICFpc1Zpc2libGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0sXG5cblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuICdhW2hyZWZePVwiI1wiXSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfcmVmNykge2xldCB7IGN1cnJlbnQ6IHsgaGFzaCB9LCBkZWZhdWx0UHJldmVudGVkIH0gPSBfcmVmNztcbiAgICAgICAgICBpZiAoIWRlZmF1bHRQcmV2ZW50ZWQgJiYgaGFzaCAmJiAkKGhhc2gsIGRvY3VtZW50LmJvZHkpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b3VjaHN0YXJ0JyxcblxuICAgICAgICBwYXNzaXZlOiB0cnVlLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhbmVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjgpIHtsZXQgeyB0YXJnZXRUb3VjaGVzIH0gPSBfcmVmODtcbiAgICAgICAgICBpZiAodGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50WSA9IHRhcmdldFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b3VjaG1vdmUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b3VjaG1vdmUnLFxuXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhbmVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY2xpZW50WSA9IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZIC0gdGhpcy5jbGllbnRZO1xuICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9ID0gdGhpcy5wYW5lbDtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICBjbGllbnRIZWlnaHQgPj0gc2Nyb2xsSGVpZ2h0IHx8XG4gICAgICAgICAgc2Nyb2xsVG9wID09PSAwICYmIGNsaWVudFkgPiAwIHx8XG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIDw9IGNsaWVudEhlaWdodCAmJiBjbGllbnRZIDwgMClcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlLmNhbmNlbGFibGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlID09PSAncmV2ZWFsJyAmJiAhaGFzQ2xhc3MocGFyZW50KHRoaXMucGFuZWwpLCB0aGlzLmNsc01vZGUpKSB7XG4gICAgICAgICAgICB3cmFwQWxsKHRoaXMucGFuZWwsICc8ZGl2PicpO1xuICAgICAgICAgICAgYWRkQ2xhc3MocGFyZW50KHRoaXMucGFuZWwpLCB0aGlzLmNsc01vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdvdmVyZmxvd1knLCB0aGlzLm92ZXJsYXkgPyAnaGlkZGVuJyA6ICcnKTtcbiAgICAgICAgICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCB0aGlzLmNsc0NvbnRhaW5lciwgdGhpcy5jbHNGbGlwKTtcbiAgICAgICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3RvdWNoLWFjdGlvbicsICdwYW4teSBwaW5jaC16b29tJyk7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAnZGlzcGxheScsICdibG9jaycpO1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc092ZXJsYXkpO1xuICAgICAgICAgIGFkZENsYXNzKFxuICAgICAgICAgIHRoaXMucGFuZWwsXG4gICAgICAgICAgdGhpcy5jbHNTaWRlYmFyQW5pbWF0aW9uLFxuICAgICAgICAgIHRoaXMubW9kZSAhPT0gJ3JldmVhbCcgPyB0aGlzLmNsc01vZGUgOiAnJyk7XG5cblxuICAgICAgICAgIGhlaWdodChkb2N1bWVudC5ib2R5KTsgLy8gZm9yY2UgcmVmbG93XG4gICAgICAgICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgdGhpcy5jbHNDb250YWluZXJBbmltYXRpb24pO1xuXG4gICAgICAgICAgdGhpcy5jbHNDb250YWluZXJBbmltYXRpb24gJiYgc3VwcHJlc3NVc2VyU2NhbGUoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCB0aGlzLmNsc0NvbnRhaW5lckFuaW1hdGlvbik7XG4gICAgICAgICAgY3NzKGRvY3VtZW50LmJvZHksICd0b3VjaC1hY3Rpb24nLCAnJyk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRkZW4nLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLmNsc0NvbnRhaW5lckFuaW1hdGlvbiAmJiByZXN1bWVVc2VyU2NhbGUoKTtcblxuICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdyZXZlYWwnKSB7XG4gICAgICAgICAgICB1bndyYXAodGhpcy5wYW5lbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5wYW5lbCwgdGhpcy5jbHNTaWRlYmFyQW5pbWF0aW9uLCB0aGlzLmNsc01vZGUpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc092ZXJsYXkpO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgdGhpcy5jbHNDb250YWluZXIsIHRoaXMuY2xzRmxpcCk7XG5cbiAgICAgICAgICBjc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnb3ZlcmZsb3dZJywgJycpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc3dpcGVMZWZ0IHN3aXBlUmlnaHQnLFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpICYmIGVuZHNXaXRoKGUudHlwZSwgJ0xlZnQnKSBeIHRoaXMuZmxpcCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dIH07XG5cblxuXG5cbiAgICAvLyBDaHJvbWUgaW4gcmVzcG9uc2l2ZSBtb2RlIHpvb21zIHBhZ2UgdXBvbiBvcGVuaW5nIG9mZmNhbnZhc1xuICAgIGZ1bmN0aW9uIHN1cHByZXNzVXNlclNjYWxlKCkge1xuICAgICAgZ2V0Vmlld3BvcnQoKS5jb250ZW50ICs9ICcsdXNlci1zY2FsYWJsZT0wJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN1bWVVc2VyU2NhbGUoKSB7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0KCk7XG4gICAgICB2aWV3cG9ydC5jb250ZW50ID0gdmlld3BvcnQuY29udGVudC5yZXBsYWNlKC8sdXNlci1zY2FsYWJsZT0wJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydCgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICQoJ21ldGFbbmFtZT1cInZpZXdwb3J0XCJdJywgZG9jdW1lbnQuaGVhZCkgfHwgYXBwZW5kKGRvY3VtZW50LmhlYWQsICc8bWV0YSBuYW1lPVwidmlld3BvcnRcIj4nKSk7XG5cbiAgICB9XG5cbiAgICB2YXIgb3ZlcmZsb3dBdXRvID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIFJlc2l6ZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHNlbENvbnRhaW5lcjogU3RyaW5nLFxuICAgICAgICBzZWxDb250ZW50OiBTdHJpbmcsXG4gICAgICAgIG1pbkhlaWdodDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBzZWxDb250YWluZXI6ICcudWstbW9kYWwnLFxuICAgICAgICBzZWxDb250ZW50OiAnLnVrLW1vZGFsLWRpYWxvZycsXG4gICAgICAgIG1pbkhlaWdodDogMTUwIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29udGFpbmVyKF9yZWYsICRlbCkge2xldCB7IHNlbENvbnRhaW5lciB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdCgkZWwsIHNlbENvbnRhaW5lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGVudChfcmVmMiwgJGVsKSB7bGV0IHsgc2VsQ29udGVudCB9ID0gX3JlZjI7XG4gICAgICAgICAgcmV0dXJuIGNsb3Nlc3QoJGVsLCBzZWxDb250ZW50KTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5jb250YWluZXIsIHRoaXMuY29udGVudF07XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuY29udGVudCB8fCAhdGhpcy5jb250YWluZXIgfHwgIWlzVmlzaWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF4OiBNYXRoLm1heChcbiAgICAgICAgICAgIHRoaXMubWluSGVpZ2h0LFxuICAgICAgICAgICAgaGVpZ2h0KHRoaXMuY29udGFpbmVyKSAtIChkaW1lbnNpb25zJDEodGhpcy5jb250ZW50KS5oZWlnaHQgLSBoZWlnaHQodGhpcy4kZWwpKSkgfTtcblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZjMpIHtsZXQgeyBtYXggfSA9IF9yZWYzO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgeyBtaW5IZWlnaHQ6IHRoaXMubWluSGVpZ2h0LCBtYXhIZWlnaHQ6IG1heCB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSB9O1xuXG4gICAgdmFyIHJlc3BvbnNpdmUgPSB7XG4gICAgICBtaXhpbnM6IFtSZXNpemVdLFxuXG4gICAgICBwcm9wczogWyd3aWR0aCcsICdoZWlnaHQnXSxcblxuICAgICAgcmVzaXplVGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLiRlbCwgcGFyZW50KHRoaXMuJGVsKV07XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCAndWstcmVzcG9uc2l2ZS13aWR0aCcpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgcmV0dXJuIGlzVmlzaWJsZSh0aGlzLiRlbCkgJiYgdGhpcy53aWR0aCAmJiB0aGlzLmhlaWdodCA/XG4gICAgICAgICAgeyB3aWR0aDogd2lkdGgocGFyZW50KHRoaXMuJGVsKSksIGhlaWdodDogdGhpcy5oZWlnaHQgfSA6XG4gICAgICAgICAgZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoZGltKSB7XG4gICAgICAgICAgaGVpZ2h0KFxuICAgICAgICAgIHRoaXMuJGVsLFxuICAgICAgICAgIERpbWVuc2lvbnMuY29udGFpbihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggfSxcblxuICAgICAgICAgIGRpbSkuXG4gICAgICAgICAgaGVpZ2h0KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cbiAgICB2YXIgc2Nyb2xsID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgb2Zmc2V0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG9mZnNldDogMCB9LFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgc2Nyb2xsVG8oZWwpIHtcbiAgICAgICAgICBlbCA9IGVsICYmICQoZWwpIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgICAgICBpZiAodHJpZ2dlcih0aGlzLiRlbCwgJ2JlZm9yZXNjcm9sbCcsIFt0aGlzLCBlbF0pKSB7XG4gICAgICAgICAgICBhd2FpdCBzY3JvbGxJbnRvVmlldyhlbCwgeyBvZmZzZXQ6IHRoaXMub2Zmc2V0IH0pO1xuICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ3Njcm9sbGVkJywgW3RoaXMsIGVsXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGNsaWNrKGUpIHtcbiAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2Nyb2xsVG8oZ2V0VGFyZ2V0RWxlbWVudCh0aGlzLiRlbCkpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBnZXRUYXJnZXRFbGVtZW50KGVsKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGVjb2RlVVJJQ29tcG9uZW50KGVsLmhhc2gpLnN1YnN0cmluZygxKSk7XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbHNweSA9IHtcbiAgICAgIG1peGluczogW1Njcm9sbF0sXG5cbiAgICAgIGFyZ3M6ICdjbHMnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbHM6IFN0cmluZyxcbiAgICAgICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgICAgIGhpZGRlbjogQm9vbGVhbixcbiAgICAgICAgb2Zmc2V0VG9wOiBOdW1iZXIsXG4gICAgICAgIG9mZnNldExlZnQ6IE51bWJlcixcbiAgICAgICAgcmVwZWF0OiBCb29sZWFuLFxuICAgICAgICBkZWxheTogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YTogKCkgPT4gKHtcbiAgICAgICAgY2xzOiAnJyxcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICBvZmZzZXRUb3A6IDAsXG4gICAgICAgIG9mZnNldExlZnQ6IDAsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBpblZpZXdDbGFzczogJ3VrLXNjcm9sbHNweS1pbnZpZXcnIH0pLFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgICAgZ2V0KF9yZWYsICRlbCkge2xldCB7IHRhcmdldCB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgPyAkJCh0YXJnZXQsICRlbCkgOiBbJGVsXTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goZWxlbWVudHMsIHByZXYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGRlbikge1xuICAgICAgICAgICAgICBjc3MoZmlsdGVyJDEoZWxlbWVudHMsIFwiOm5vdCguXCIgKyB0aGlzLmluVmlld0NsYXNzICsgXCIpXCIpLCAndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgdGhpcy4kcmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0gfSxcblxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5fZGF0YS5lbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKFxuICAgICAgICB0aGlzLmVsZW1lbnRzLFxuICAgICAgICAocmVjb3JkcykgPT4ge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fZGF0YS5lbGVtZW50cztcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0OiBlbCwgaXNJbnRlcnNlY3RpbmcgfSBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRzLmhhcyhlbCkpIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMuc2V0KGVsLCB7XG4gICAgICAgICAgICAgICAgY2xzOiBkYXRhKGVsLCAndWstc2Nyb2xsc3B5LWNsYXNzJykgfHwgdGhpcy5jbHMgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlbGVtZW50cy5nZXQoZWwpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcGVhdCAmJiBzdGF0ZS5zaG93KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5zaG93ID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcm9vdE1hcmdpbjogdG9QeCh0aGlzLm9mZnNldFRvcCwgJ2hlaWdodCcpIC0gMSArIFwicHggXCIgKyAoXG4gICAgICAgICAgdG9QeCh0aGlzLm9mZnNldExlZnQsICd3aWR0aCcpIC0gMSkgKyBcInB4XCIgfSxcblxuXG4gICAgICAgIGZhbHNlKSk7XG5cblxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtlbCwgc3RhdGVdIG9mIHRoaXMuX2RhdGEuZWxlbWVudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIHRoaXMuaW5WaWV3Q2xhc3MsIChzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuY2xzKSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogW1xuICAgICAge1xuICAgICAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZWwsIHN0YXRlXSBvZiBkYXRhLmVsZW1lbnRzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNob3cgJiYgIXN0YXRlLmludmlldyAmJiAhc3RhdGUucXVldWVkKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnF1ZXVlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZGF0YS5wcm9taXNlID0gKGRhdGEucHJvbWlzZSB8fCBQcm9taXNlLnJlc29sdmUoKSkuXG4gICAgICAgICAgICAgIHRoZW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGhpcy5kZWxheSkpKS5cbiAgICAgICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGUoZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgc3RhdGUucXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5zaG93ICYmIHN0YXRlLmludmlldyAmJiAhc3RhdGUucXVldWVkICYmIHRoaXMucmVwZWF0KSB7XG4gICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGVsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGUoZWwsIGludmlldykge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fZGF0YS5lbGVtZW50cy5nZXQoZWwpO1xuXG4gICAgICAgICAgc3RhdGUub2ZmID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5vZmYoKTtcblxuICAgICAgICAgIGNzcyhlbCwgJ3Zpc2liaWxpdHknLCAhaW52aWV3ICYmIHRoaXMuaGlkZGVuID8gJ2hpZGRlbicgOiAnJyk7XG5cbiAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcy5pblZpZXdDbGFzcywgaW52aWV3KTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgc3RhdGUuY2xzKTtcblxuICAgICAgICAgIGlmICgvXFxidWstYW5pbWF0aW9uLS8udGVzdChzdGF0ZS5jbHMpKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVBbmltYXRpb25DbGFzc2VzID0gKCkgPT4gcmVtb3ZlQ2xhc3NlcyhlbCwgJ3VrLWFuaW1hdGlvbi1bXFxcXHctXSsnKTtcbiAgICAgICAgICAgIGlmIChpbnZpZXcpIHtcbiAgICAgICAgICAgICAgc3RhdGUub2ZmID0gb25jZShlbCwgJ2FuaW1hdGlvbmNhbmNlbCBhbmltYXRpb25lbmQnLCByZW1vdmVBbmltYXRpb25DbGFzc2VzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbW92ZUFuaW1hdGlvbkNsYXNzZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmlnZ2VyKGVsLCBpbnZpZXcgPyAnaW52aWV3JyA6ICdvdXR2aWV3Jyk7XG5cbiAgICAgICAgICBzdGF0ZS5pbnZpZXcgPSBpbnZpZXc7XG5cbiAgICAgICAgICB0aGlzLiR1cGRhdGUoZWwpO1xuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBzY3JvbGxzcHlOYXYgPSB7XG4gICAgICBtaXhpbnM6IFtTY3JvbGxdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbHM6IFN0cmluZyxcbiAgICAgICAgY2xvc2VzdDogU3RyaW5nLFxuICAgICAgICBzY3JvbGw6IEJvb2xlYW4sXG4gICAgICAgIG92ZXJmbG93OiBCb29sZWFuLFxuICAgICAgICBvZmZzZXQ6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY2xzOiAndWstYWN0aXZlJyxcbiAgICAgICAgY2xvc2VzdDogZmFsc2UsXG4gICAgICAgIHNjcm9sbDogZmFsc2UsXG4gICAgICAgIG92ZXJmbG93OiB0cnVlLFxuICAgICAgICBvZmZzZXQ6IDAgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBsaW5rczoge1xuICAgICAgICAgIGdldChfLCAkZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkJCgnYVtocmVmXj1cIiNcIl0nLCAkZWwpLmZpbHRlcigoZWwpID0+IGVsLmhhc2gpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChsaW5rcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsKSB7XG4gICAgICAgICAgICAgIHRoaXMuJGNyZWF0ZSgnc2Nyb2xsJywgbGlua3MsIHsgb2Zmc2V0OiB0aGlzLm9mZnNldCB8fCAwIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIGVsZW1lbnRzKF9yZWYpIHtsZXQgeyBjbG9zZXN0OiBzZWxlY3RvciB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdCh0aGlzLmxpbmtzLCBzZWxlY3RvciB8fCAnKicpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgdXBkYXRlOiBbXG4gICAgICB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0cyA9IHRoaXMubGlua3MubWFwKGdldFRhcmdldEVsZW1lbnQpLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB0YXJnZXRzO1xuXG4gICAgICAgICAgaWYgKCFsZW5ndGggfHwgIWlzVmlzaWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBbc2Nyb2xsRWxlbWVudF0gPSBzY3JvbGxQYXJlbnRzKHRhcmdldHMsIC9hdXRvfHNjcm9sbC8sIHRydWUpO1xuICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQgfSA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICAgICAgY29uc3QgbWF4ID0gc2Nyb2xsSGVpZ2h0IC0gZ2V0Vmlld3BvcnRDbGllbnRIZWlnaHQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICAgICAgbGV0IGFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbFRvcCA9PT0gbWF4KSB7XG4gICAgICAgICAgICBhY3RpdmUgPSBsZW5ndGggLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGFyZ2V0cykge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG9mZnNldCh0YXJnZXRzW2ldKS50b3AgLVxuICAgICAgICAgICAgICBvZmZzZXQoZ2V0Vmlld3BvcnQkMShzY3JvbGxFbGVtZW50KSkudG9wIC1cbiAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPlxuICAgICAgICAgICAgICAwKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWN0aXZlID0gK2k7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhY3RpdmUgPT09IGZhbHNlICYmIHRoaXMub3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgYWN0aXZlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4geyBhY3RpdmUgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMikge2xldCB7IGFjdGl2ZSB9ID0gX3JlZjI7XG4gICAgICAgICAgY29uc3QgY2hhbmdlZCA9IGFjdGl2ZSAhPT0gZmFsc2UgJiYgIWhhc0NsYXNzKHRoaXMuZWxlbWVudHNbYWN0aXZlXSwgdGhpcy5jbHMpO1xuXG4gICAgICAgICAgdGhpcy5saW5rcy5mb3JFYWNoKChlbCkgPT4gZWwuYmx1cigpKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5lbGVtZW50cykge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy5lbGVtZW50c1tpXSwgdGhpcy5jbHMsICtpID09PSBhY3RpdmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnYWN0aXZlJywgW2FjdGl2ZSwgdGhpcy5lbGVtZW50c1thY3RpdmVdXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydzY3JvbGwnLCAncmVzaXplJ10gfV0gfTtcblxuICAgIHZhciBzdGlja3kgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgTWVkaWEsIFJlc2l6ZSwgU2Nyb2xsXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcG9zaXRpb246IFN0cmluZyxcbiAgICAgICAgdG9wOiBudWxsLFxuICAgICAgICBib3R0b206IEJvb2xlYW4sXG4gICAgICAgIG9mZnNldDogU3RyaW5nLFxuICAgICAgICBhbmltYXRpb246IFN0cmluZyxcbiAgICAgICAgY2xzQWN0aXZlOiBTdHJpbmcsXG4gICAgICAgIGNsc0luYWN0aXZlOiBTdHJpbmcsXG4gICAgICAgIGNsc0ZpeGVkOiBTdHJpbmcsXG4gICAgICAgIGNsc0JlbG93OiBTdHJpbmcsXG4gICAgICAgIHNlbFRhcmdldDogU3RyaW5nLFxuICAgICAgICBzaG93T25VcDogQm9vbGVhbixcbiAgICAgICAgdGFyZ2V0T2Zmc2V0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBib3R0b206IGZhbHNlLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGFuaW1hdGlvbjogJycsXG4gICAgICAgIGNsc0FjdGl2ZTogJ3VrLWFjdGl2ZScsXG4gICAgICAgIGNsc0luYWN0aXZlOiAnJyxcbiAgICAgICAgY2xzRml4ZWQ6ICd1ay1zdGlja3ktZml4ZWQnLFxuICAgICAgICBjbHNCZWxvdzogJ3VrLXN0aWNreS1iZWxvdycsXG4gICAgICAgIHNlbFRhcmdldDogJycsXG4gICAgICAgIHNob3dPblVwOiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0T2Zmc2V0OiBmYWxzZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHNlbFRhcmdldChfcmVmLCAkZWwpIHtsZXQgeyBzZWxUYXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIHNlbFRhcmdldCAmJiAkKHNlbFRhcmdldCwgJGVsKSB8fCAkZWw7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID1cbiAgICAgICAgJCgnKyAudWstc3RpY2t5LXBsYWNlaG9sZGVyJywgdGhpcy4kZWwpIHx8XG4gICAgICAgICQoJzxkaXYgY2xhc3M9XCJ1ay1zdGlja3ktcGxhY2Vob2xkZXJcIj48L2Rpdj4nKTtcbiAgICAgICAgdGhpcy5pc0ZpeGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKGZhbHNlKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaXhlZCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuc2VsVGFyZ2V0LCB0aGlzLmNsc0luYWN0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZSQxKHRoaXMucGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnbG9hZCBoYXNoY2hhbmdlIHBvcHN0YXRlJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRPZmZzZXQgIT09IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKCFsb2NhdGlvbi5oYXNoIHx8IHNjcm9sbFRvcCh3aW5kb3cpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmFzdGRvbS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE9mZnNldCA9IG9mZnNldCgkKGxvY2F0aW9uLmhhc2gpKTtcbiAgICAgICAgICAgIGNvbnN0IGVsT2Zmc2V0ID0gb2Zmc2V0KHRoaXMuJGVsKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNGaXhlZCAmJiBpbnRlcnNlY3RSZWN0KHRhcmdldE9mZnNldCwgZWxPZmZzZXQpKSB7XG4gICAgICAgICAgICAgIHNjcm9sbFRvcChcbiAgICAgICAgICAgICAgd2luZG93LFxuICAgICAgICAgICAgICB0YXJnZXRPZmZzZXQudG9wIC1cbiAgICAgICAgICAgICAgZWxPZmZzZXQuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgdG9QeCh0aGlzLnRhcmdldE9mZnNldCwgJ2hlaWdodCcpIC1cbiAgICAgICAgICAgICAgdG9QeCh0aGlzLm9mZnNldCwgJ2hlaWdodCcpKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgdXBkYXRlOiBbXG4gICAgICB7XG4gICAgICAgIHJlYWQoX3JlZjIsIHR5cGVzKSB7bGV0IHsgaGVpZ2h0OiBoZWlnaHQkMSwgbWFyZ2luIH0gPSBfcmVmMjtcbiAgICAgICAgICB0aGlzLmluYWN0aXZlID0gIXRoaXMubWF0Y2hNZWRpYSB8fCAhaXNWaXNpYmxlKHRoaXMuJGVsKTtcblxuICAgICAgICAgIGlmICh0aGlzLmluYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaGlkZSA9IHRoaXMuYWN0aXZlICYmIHR5cGVzLmhhcygncmVzaXplJyk7XG4gICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLnNlbFRhcmdldCwgJ3RyYW5zaXRpb24nLCAnMHMnKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGhlaWdodCQxID0gb2Zmc2V0KHRoaXMuJGVsKS5oZWlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4gPSBjc3ModGhpcy4kZWwsICdtYXJnaW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICBmYXN0ZG9tLndyaXRlKCgpID0+IGNzcyh0aGlzLnNlbFRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLmlzRml4ZWQgPyB0aGlzLnBsYWNlaG9sZGVyIDogdGhpcy4kZWw7XG4gICAgICAgICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gaGVpZ2h0KHdpbmRvdyk7XG5cbiAgICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2F1dG8nICYmIGhlaWdodCQxID4gd2luZG93SGVpZ2h0KSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9ICdib3R0b20nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBvZmZzZXQkMSA9IHRvUHgodGhpcy5vZmZzZXQsICdoZWlnaHQnLCByZWZlcmVuY2VFbGVtZW50KTtcbiAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICBvZmZzZXQkMSArPSB3aW5kb3dIZWlnaHQgLSBoZWlnaHQkMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IE1hdGgubWF4KDAsIGhlaWdodCQxICsgb2Zmc2V0JDEgLSB3aW5kb3dIZWlnaHQpO1xuICAgICAgICAgIGNvbnN0IHRvcE9mZnNldCA9IG9mZnNldChyZWZlcmVuY2VFbGVtZW50KS50b3A7XG5cbiAgICAgICAgICBjb25zdCB0b3AgPSBwYXJzZVByb3AodGhpcy50b3AsIHRoaXMuJGVsLCB0b3BPZmZzZXQpO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IHBhcnNlUHJvcCh0aGlzLmJvdHRvbSwgdGhpcy4kZWwsIHRvcE9mZnNldCArIGhlaWdodCQxLCB0cnVlKTtcblxuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgodG9wLCB0b3BPZmZzZXQpIC0gb2Zmc2V0JDE7XG4gICAgICAgICAgY29uc3QgZW5kID0gYm90dG9tID9cbiAgICAgICAgICBib3R0b20gLSBvZmZzZXQodGhpcy4kZWwpLmhlaWdodCArIG92ZXJmbG93IC0gb2Zmc2V0JDEgOlxuICAgICAgICAgIGdldFNjcm9sbGluZ0VsZW1lbnQodGhpcy4kZWwpLnNjcm9sbEhlaWdodCAtIHdpbmRvd0hlaWdodDtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0JDEsXG4gICAgICAgICAgICBvdmVyZmxvdyxcbiAgICAgICAgICAgIHRvcE9mZnNldCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0JDEsXG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICB3aWR0aDogZGltZW5zaW9ucyQxKHJlZmVyZW5jZUVsZW1lbnQpLndpZHRoLFxuICAgICAgICAgICAgdG9wOiBvZmZzZXRQb3NpdGlvbihyZWZlcmVuY2VFbGVtZW50KVswXSB9O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZjMpIHtsZXQgeyBoZWlnaHQsIG1hcmdpbiB9ID0gX3JlZjM7XG4gICAgICAgICAgY29uc3QgeyBwbGFjZWhvbGRlciB9ID0gdGhpcztcblxuICAgICAgICAgIGNzcyhwbGFjZWhvbGRlciwgeyBoZWlnaHQsIG1hcmdpbiB9KTtcblxuICAgICAgICAgIGlmICghd2l0aGluKHBsYWNlaG9sZGVyLCBkb2N1bWVudCkpIHtcbiAgICAgICAgICAgIGFmdGVyKHRoaXMuJGVsLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICBwbGFjZWhvbGRlci5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICB7XG4gICAgICAgIHJlYWQoX3JlZjQpXG5cblxuXG5cblxuXG4gICAgICAgIHtsZXQgeyBzY3JvbGw6IHByZXZTY3JvbGwgPSAwLCBkaXI6IHByZXZEaXIgPSAnZG93bicsIG92ZXJmbG93LCBvdmVyZmxvd1Njcm9sbCA9IDAsIHN0YXJ0LCBlbmQgfSA9IF9yZWY0O1xuICAgICAgICAgIGNvbnN0IHNjcm9sbCA9IHNjcm9sbFRvcCh3aW5kb3cpO1xuICAgICAgICAgIGNvbnN0IGRpciA9IHByZXZTY3JvbGwgPD0gc2Nyb2xsID8gJ2Rvd24nIDogJ3VwJztcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICBwcmV2RGlyLFxuICAgICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgICAgcHJldlNjcm9sbCxcbiAgICAgICAgICAgIG9mZnNldFBhcmVudFRvcDogb2Zmc2V0KHRoaXMuJGVsLm9mZnNldFBhcmVudCkudG9wLFxuICAgICAgICAgICAgb3ZlcmZsb3dTY3JvbGw6IGNsYW1wKFxuICAgICAgICAgICAgb3ZlcmZsb3dTY3JvbGwgKyBjbGFtcChzY3JvbGwsIHN0YXJ0LCBlbmQpIC0gY2xhbXAocHJldlNjcm9sbCwgc3RhcnQsIGVuZCksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3ZlcmZsb3cpIH07XG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKGRhdGEsIHR5cGVzKSB7XG4gICAgICAgICAgY29uc3QgaXNTY3JvbGxVcGRhdGUgPSB0eXBlcy5oYXMoJ3Njcm9sbCcpO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGluaXRUaW1lc3RhbXAgPSAwLFxuICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgcHJldkRpcixcbiAgICAgICAgICAgIHNjcm9sbCxcbiAgICAgICAgICAgIHByZXZTY3JvbGwgPSAwLFxuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICB0b3BPZmZzZXQsXG4gICAgICAgICAgICBoZWlnaHQgfSA9XG4gICAgICAgICAgZGF0YTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICBzY3JvbGwgPCAwIHx8XG4gICAgICAgICAgc2Nyb2xsID09PSBwcmV2U2Nyb2xsICYmIGlzU2Nyb2xsVXBkYXRlIHx8XG4gICAgICAgICAgdGhpcy5zaG93T25VcCAmJiAhaXNTY3JvbGxVcGRhdGUgJiYgIXRoaXMuaXNGaXhlZClcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBpZiAobm93IC0gaW5pdFRpbWVzdGFtcCA+IDMwMCB8fCBkaXIgIT09IHByZXZEaXIpIHtcbiAgICAgICAgICAgIGRhdGEuaW5pdFNjcm9sbCA9IHNjcm9sbDtcbiAgICAgICAgICAgIGRhdGEuaW5pdFRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5zaG93T25VcCAmJlxuICAgICAgICAgICF0aGlzLmlzRml4ZWQgJiZcbiAgICAgICAgICBNYXRoLmFicyhkYXRhLmluaXRTY3JvbGwgLSBzY3JvbGwpIDw9IDMwICYmXG4gICAgICAgICAgTWF0aC5hYnMocHJldlNjcm9sbCAtIHNjcm9sbCkgPD0gMTApXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmluYWN0aXZlIHx8XG4gICAgICAgICAgc2Nyb2xsIDwgc3RhcnQgfHxcbiAgICAgICAgICB0aGlzLnNob3dPblVwICYmIChcbiAgICAgICAgICBzY3JvbGwgPD0gc3RhcnQgfHxcbiAgICAgICAgICBkaXIgPT09ICdkb3duJyAmJiBpc1Njcm9sbFVwZGF0ZSB8fFxuICAgICAgICAgIGRpciA9PT0gJ3VwJyAmJiAhdGhpcy5pc0ZpeGVkICYmIHNjcm9sbCA8PSB0b3BPZmZzZXQgKyBoZWlnaHQpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0ZpeGVkKSB7XG4gICAgICAgICAgICAgIGlmIChBbmltYXRpb24uaW5Qcm9ncmVzcyh0aGlzLiRlbCkgJiYgdG9wID4gc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uLmNhbmNlbCh0aGlzLiRlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaXNGaXhlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb24gJiYgc2Nyb2xsID4gdG9wT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIEFuaW1hdGlvbi5jYW5jZWwodGhpcy4kZWwpO1xuICAgICAgICAgICAgICBBbmltYXRpb24ub3V0KHRoaXMuJGVsLCB0aGlzLmFuaW1hdGlvbikudGhlbigoKSA9PiB0aGlzLmhpZGUoKSwgbm9vcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNGaXhlZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYW5pbWF0aW9uICYmIHNjcm9sbCA+IHRvcE9mZnNldCkge1xuICAgICAgICAgICAgQW5pbWF0aW9uLmNhbmNlbCh0aGlzLiRlbCk7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgIEFuaW1hdGlvbi5pbih0aGlzLiRlbCwgdGhpcy5hbmltYXRpb24pLmNhdGNoKG5vb3ApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZScsICdzY3JvbGwnXSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICB0aGlzLmlzRml4ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlKCkge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNGaXhlZCwgdGhpcy5jbHNCZWxvdyk7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCB7IHBvc2l0aW9uOiAnJywgdG9wOiAnJywgd2lkdGg6ICcnIH0pO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGUoKSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgc2Nyb2xsID0gMCxcbiAgICAgICAgICAgIG92ZXJmbG93LFxuICAgICAgICAgICAgb3ZlcmZsb3dTY3JvbGwgPSAwLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB0b3BPZmZzZXQsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBvZmZzZXRQYXJlbnRUb3AgfSA9XG4gICAgICAgICAgdGhpcy5fZGF0YTtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSBzdGFydCAhPT0gMCB8fCBzY3JvbGwgPiBzdGFydDtcbiAgICAgICAgICBsZXQgcG9zaXRpb24gPSAnZml4ZWQnO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbCA+IGVuZCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGVuZCAtIG9mZnNldFBhcmVudFRvcDtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBvdmVyZmxvd1Njcm9sbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjc3ModGhpcy4kZWwsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgdG9wOiBvZmZzZXQgKyBcInB4XCIsXG4gICAgICAgICAgICB3aWR0aCB9KTtcblxuXG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmUoYWN0aXZlKTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNCZWxvdywgc2Nyb2xsID4gdG9wT2Zmc2V0ICsgaGVpZ2h0KTtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNGaXhlZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0QWN0aXZlKGFjdGl2ZSkge1xuICAgICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICByZXBsYWNlQ2xhc3ModGhpcy5zZWxUYXJnZXQsIHRoaXMuY2xzSW5hY3RpdmUsIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgICAgIHByZXYgIT09IGFjdGl2ZSAmJiB0cmlnZ2VyKHRoaXMuJGVsLCAnYWN0aXZlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxhY2VDbGFzcyh0aGlzLnNlbFRhcmdldCwgdGhpcy5jbHNBY3RpdmUsIHRoaXMuY2xzSW5hY3RpdmUpO1xuICAgICAgICAgICAgcHJldiAhPT0gYWN0aXZlICYmIHRyaWdnZXIodGhpcy4kZWwsICdpbmFjdGl2ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wKHZhbHVlLCBlbCwgcHJvcE9mZnNldCwgcGFkZGluZykge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5tYXRjaCgvXi0/XFxkLykpIHtcbiAgICAgICAgcmV0dXJuIHByb3BPZmZzZXQgKyB0b1B4KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlZkVsZW1lbnQgPSB2YWx1ZSA9PT0gdHJ1ZSA/IHBhcmVudChlbCkgOiBxdWVyeSh2YWx1ZSwgZWwpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG9mZnNldChyZWZFbGVtZW50KS5ib3R0b20gLSAoXG4gICAgICAgICAgcGFkZGluZyAmJiByZWZFbGVtZW50ICYmIHdpdGhpbihlbCwgcmVmRWxlbWVudCkgP1xuICAgICAgICAgIHRvRmxvYXQoY3NzKHJlZkVsZW1lbnQsICdwYWRkaW5nQm90dG9tJykpIDpcbiAgICAgICAgICAwKSk7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU3dpdGNoZXIgPSB7XG4gICAgICBtaXhpbnM6IFtMYXp5bG9hZCwgU3dpcGUsIFRvZ2dsYWJsZV0sXG5cbiAgICAgIGFyZ3M6ICdjb25uZWN0JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29ubmVjdDogU3RyaW5nLFxuICAgICAgICB0b2dnbGU6IFN0cmluZyxcbiAgICAgICAgaXRlbU5hdjogU3RyaW5nLFxuICAgICAgICBhY3RpdmU6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29ubmVjdDogJ34udWstc3dpdGNoZXInLFxuICAgICAgICB0b2dnbGU6ICc+ICogPiA6Zmlyc3QtY2hpbGQnLFxuICAgICAgICBpdGVtTmF2OiBmYWxzZSxcbiAgICAgICAgYWN0aXZlOiAwLFxuICAgICAgICBjbHM6ICd1ay1hY3RpdmUnLFxuICAgICAgICBhdHRySXRlbTogJ3VrLXN3aXRjaGVyLWl0ZW0nIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29ubmVjdHM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgY29ubmVjdCB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUFsbChjb25uZWN0LCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChjb25uZWN0cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3dpcGluZykge1xuICAgICAgICAgICAgICBjc3MoY29ubmVjdHMsICd0b3VjaC1hY3Rpb24nLCAncGFuLXkgcGluY2gtem9vbScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdHMuZm9yRWFjaCgoZWwpID0+XG4gICAgICAgICAgICBjaGlsZHJlbihlbCkuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHRvZ2dsZUNsYXNzKGNoaWxkLCB0aGlzLmNscywgaSA9PT0gaW5kZXgpKSk7XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0sXG5cblxuICAgICAgICB0b2dnbGVzOiB7XG4gICAgICAgICAgZ2V0KF9yZWYyLCAkZWwpIHtsZXQgeyB0b2dnbGUgfSA9IF9yZWYyO1xuICAgICAgICAgICAgcmV0dXJuICQkKHRvZ2dsZSwgJGVsKS5maWx0ZXIoXG4gICAgICAgICAgICAoZWwpID0+ICFtYXRjaGVzKGVsLCAnLnVrLWRpc2FibGVkICosIC51ay1kaXNhYmxlZCwgW2Rpc2FibGVkXScpKTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCh0b2dnbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmluZGV4KCk7XG4gICAgICAgICAgICB0aGlzLnNob3cofmFjdGl2ZSA/IGFjdGl2ZSA6IHRvZ2dsZXNbdGhpcy5hY3RpdmVdIHx8IHRvZ2dsZXNbMF0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbih0aGlzLiRlbCkuZmlsdGVyKChjaGlsZCkgPT5cbiAgICAgICAgICB0aGlzLnRvZ2dsZXMuc29tZSgodG9nZ2xlKSA9PiB3aXRoaW4odG9nZ2xlLCBjaGlsZCkpKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHN3aXBlVGFyZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RzO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmxhenlsb2FkKHRoaXMuJGVsLCB0aGlzLmNvbm5lY3RzKTtcblxuICAgICAgICAvLyBjaGVjayBmb3IgY29ubmVjdHNcbiAgICAgICAgcmVhZHkoKCkgPT4gdGhpcy4kZW1pdCgpKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93KGUuY3VycmVudCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdHMuY29uY2F0KHRoaXMuaXRlbU5hdiA/IHF1ZXJ5QWxsKHRoaXMuaXRlbU5hdiwgdGhpcy4kZWwpIDogW10pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiBcIltcIiArIHRoaXMuYXR0ckl0ZW0gKyBcIl0sW2RhdGEtXCIgKyB0aGlzLmF0dHJJdGVtICsgXCJdXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvdyhkYXRhKGUuY3VycmVudCwgdGhpcy5hdHRySXRlbSkpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc3dpcGVSaWdodCBzd2lwZUxlZnQnLFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zd2lwaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjMpIHtsZXQgeyB0eXBlIH0gPSBfcmVmMztcbiAgICAgICAgICB0aGlzLnNob3coZW5kc1dpdGgodHlwZSwgJ0xlZnQnKSA/ICduZXh0JyA6ICdwcmV2aW91cycpO1xuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBpbmRleCgpIHtcbiAgICAgICAgICByZXR1cm4gZmluZEluZGV4KHRoaXMuY2hpbGRyZW4sIChlbCkgPT4gaGFzQ2xhc3MoZWwsIHRoaXMuY2xzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvdyhpdGVtKSB7XG4gICAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gZ2V0SW5kZXgoaXRlbSwgdGhpcy50b2dnbGVzLCBwcmV2KTtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSBnZXRJbmRleCh0aGlzLmNoaWxkcmVuW25leHRdLCBjaGlsZHJlbih0aGlzLiRlbCkpO1xuICAgICAgICAgIGNoaWxkcmVuKHRoaXMuJGVsKS5mb3JFYWNoKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY2hpbGQsIHRoaXMuY2xzLCBhY3RpdmUgPT09IGkpO1xuICAgICAgICAgICAgYXR0cih0aGlzLnRvZ2dsZXNbaV0sICdhcmlhLWV4cGFuZGVkJywgYWN0aXZlID09PSBpKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IGFuaW1hdGUgPSBwcmV2ID49IDAgJiYgcHJldiAhPT0gbmV4dDtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RzLmZvckVhY2goYXN5bmMgKF9yZWY0KSA9PiB7bGV0IHsgY2hpbGRyZW4gfSA9IF9yZWY0O1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50b2dnbGVFbGVtZW50KFxuICAgICAgICAgICAgdG9Ob2RlcyhjaGlsZHJlbikuZmlsdGVyKChjaGlsZCkgPT4gaGFzQ2xhc3MoY2hpbGQsIHRoaXMuY2xzKSksXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGFuaW1hdGUpO1xuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQoY2hpbGRyZW5bYWN0aXZlXSwgdHJ1ZSwgYW5pbWF0ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIHRhYiA9IHtcbiAgICAgIG1peGluczogW0NsYXNzXSxcblxuICAgICAgZXh0ZW5kczogU3dpdGNoZXIsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG1lZGlhOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBtZWRpYTogOTYwLFxuICAgICAgICBhdHRySXRlbTogJ3VrLXRhYi1pdGVtJyB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgY29uc3QgY2xzID0gaGFzQ2xhc3ModGhpcy4kZWwsICd1ay10YWItbGVmdCcpID9cbiAgICAgICAgJ3VrLXRhYi1sZWZ0JyA6XG4gICAgICAgIGhhc0NsYXNzKHRoaXMuJGVsLCAndWstdGFiLXJpZ2h0JykgP1xuICAgICAgICAndWstdGFiLXJpZ2h0JyA6XG4gICAgICAgIGZhbHNlO1xuXG4gICAgICAgIGlmIChjbHMpIHtcbiAgICAgICAgICB0aGlzLiRjcmVhdGUoJ3RvZ2dsZScsIHRoaXMuJGVsLCB7IGNscywgbW9kZTogJ21lZGlhJywgbWVkaWE6IHRoaXMubWVkaWEgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gfTtcblxuICAgIGNvbnN0IEtFWV9TUEFDRSA9IDMyO1xuXG4gICAgdmFyIHRvZ2dsZSA9IHtcbiAgICAgIG1peGluczogW0xhenlsb2FkLCBNZWRpYSwgVG9nZ2xhYmxlXSxcblxuICAgICAgYXJnczogJ3RhcmdldCcsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGhyZWY6IFN0cmluZyxcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICBtb2RlOiAnbGlzdCcsXG4gICAgICAgIHF1ZXVlZDogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaHJlZjogZmFsc2UsXG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIG1vZGU6ICdjbGljaycsXG4gICAgICAgIHF1ZXVlZDogdHJ1ZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgIGdldChfcmVmLCAkZWwpIHtsZXQgeyBocmVmLCB0YXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgICB0YXJnZXQgPSBxdWVyeUFsbCh0YXJnZXQgfHwgaHJlZiwgJGVsKTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQubGVuZ3RoICYmIHRhcmdldCB8fCBbJGVsXTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFyaWEoKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0gfSxcblxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKCFpbmNsdWRlcyh0aGlzLm1vZGUsICdtZWRpYScpICYmICFpc0ZvY3VzYWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICBhdHRyKHRoaXMuJGVsLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXp5bG9hZCh0aGlzLiRlbCwgdGhpcy50YXJnZXQpO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciB0YXJnZXRcbiAgICAgICAgcmVhZHkoKCkgPT4gdGhpcy4kZW1pdCgpKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyRG93bixcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ2hvdmVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKCFpc1RvdWNoKGUpIHx8IHRoaXMuX3Nob3dTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENsaWNraW5nIGEgYnV0dG9uIGRvZXMgbm90IGdpdmUgaXQgZm9jdXMgb24gYWxsIGJyb3dzZXJzIGFuZCBwbGF0Zm9ybXNcbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvYnV0dG9uI2NsaWNraW5nX2FuZF9mb2N1c1xuICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdmb2N1cycpO1xuICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgcG9pbnRlckRvd24sXG4gICAgICAgICAgKCkgPT4gdHJpZ2dlcih0aGlzLiRlbCwgJ2JsdXInKSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIChlKSA9PiAhd2l0aGluKGUudGFyZ2V0LCB0aGlzLiRlbCkpO1xuXG5cbiAgICAgICAgICAvLyBQcmV2ZW50IGluaXRpYWwgY2xpY2sgdG8gcHJldmVudCBkb3VibGUgdG9nZ2xlIHRocm91Z2ggZm9jdXMgKyBjbGlja1xuICAgICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLm1vZGUsICdjbGljaycpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50Q2xpY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogcG9pbnRlckVudGVyICsgXCIgXCIgKyBwb2ludGVyTGVhdmUgKyBcIiBmb2N1cyBibHVyXCIsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdob3ZlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChpc1RvdWNoKGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc2hvdyA9IGluY2x1ZGVzKFtwb2ludGVyRW50ZXIsICdmb2N1cyddLCBlLnR5cGUpO1xuICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gYXR0cih0aGlzLiRlbCwgJ2FyaWEtZXhwYW5kZWQnKTtcblxuICAgICAgICAgIC8vIFNraXAgaGlkZSBpZiBzdGlsbCBob3ZlcmVkIG9yIGZvY3VzZWRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXNob3cgJiYgKFxuICAgICAgICAgIGUudHlwZSA9PT0gcG9pbnRlckxlYXZlICYmIG1hdGNoZXModGhpcy4kZWwsICc6Zm9jdXMnKSB8fFxuICAgICAgICAgIGUudHlwZSA9PT0gJ2JsdXInICYmIG1hdGNoZXModGhpcy4kZWwsICc6aG92ZXInKSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNraXAgaWYgc3RhdGUgZG9lcyBub3QgY2hhbmdlIGUuZy4gaG92ZXIgKyBmb2N1cyByZWNlaXZlZFxuICAgICAgICAgIGlmICh0aGlzLl9zaG93U3RhdGUgJiYgc2hvdyAmJiBleHBhbmRlZCAhPT0gdGhpcy5fc2hvd1N0YXRlKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgcmVzZXQgaWYgc3RhdGUgaGFzIGNoYW5nZWQgdGhyb3VnaCBjbGlja1xuICAgICAgICAgICAgaWYgKCFzaG93KSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3dTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc2hvd1N0YXRlID0gc2hvdyA/IGV4cGFuZGVkIDogbnVsbDtcblxuICAgICAgICAgIHRoaXMudG9nZ2xlKFwidG9nZ2xlXCIgKyAoc2hvdyA/ICdzaG93JyA6ICdoaWRlJykpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAna2V5ZG93bicsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdjbGljaycpICYmICFpc1RhZyh0aGlzLiRlbCwgJ2lucHV0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZX1NQQUNFKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLiRlbC5jbGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ2NsaWNrJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3ByZXZlbnRDbGljaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXZlbnRDbGljayA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGxpbms7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGNsb3Nlc3QoZS50YXJnZXQsICdhW2hyZWY9XCIjXCJdLCBhW2hyZWY9XCJcIl0nKSB8fFxuICAgICAgICAgIChsaW5rID0gY2xvc2VzdChlLnRhcmdldCwgJ2FbaHJlZl0nKSkgJiYgKFxuICAgICAgICAgIGF0dHIodGhpcy4kZWwsICdhcmlhLWV4cGFuZGVkJykgIT09ICd0cnVlJyB8fFxuICAgICAgICAgIGxpbmsuaGFzaCAmJiBtYXRjaGVzKHRoaXMudGFyZ2V0LCBsaW5rLmhhc2gpKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZWQnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSwgdG9nZ2xlZCkge1xuICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy50YXJnZXRbMF0pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXJpYSh0b2dnbGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdtZWRpYWNoYW5nZScsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdtZWRpYScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUsIG1lZGlhT2JqKSB7XG4gICAgICAgICAgaWYgKG1lZGlhT2JqLm1hdGNoZXMgXiB0aGlzLmlzVG9nZ2xlZCh0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyB0b2dnbGUodHlwZSkge1xuICAgICAgICAgIGlmICghdHJpZ2dlcih0aGlzLnRhcmdldCwgdHlwZSB8fCAndG9nZ2xlJywgW3RoaXNdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5xdWV1ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy50YXJnZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGxlYXZpbmcgPSB0aGlzLnRhcmdldC5maWx0ZXIoKGVsKSA9PiBoYXNDbGFzcyhlbCwgdGhpcy5jbHNMZWF2ZSkpO1xuXG4gICAgICAgICAgaWYgKGxlYXZpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlzTGVhdmluZyA9IGluY2x1ZGVzKGxlYXZpbmcsIGVsKTtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGVFbGVtZW50KGVsLCBpc0xlYXZpbmcsIGlzTGVhdmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdG9nZ2xlZCA9IHRoaXMudGFyZ2V0LmZpbHRlcih0aGlzLmlzVG9nZ2xlZCk7XG4gICAgICAgICAgYXdhaXQgdGhpcy50b2dnbGVFbGVtZW50KHRvZ2dsZWQsIGZhbHNlKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQoXG4gICAgICAgICAgdGhpcy50YXJnZXQuZmlsdGVyKChlbCkgPT4gIWluY2x1ZGVzKHRvZ2dsZWQsIGVsKSksXG4gICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVBcmlhKHRvZ2dsZWQpIHtcbiAgICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5tb2RlLCAnbWVkaWEnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0dHIoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnLFxuICAgICAgICAgIGlzQm9vbGVhbih0b2dnbGVkKSA/IHRvZ2dsZWQgOiB0aGlzLmlzVG9nZ2xlZCh0aGlzLnRhcmdldCkpO1xuXG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIGNvbXBvbmVudHMkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBBY2NvcmRpb246IEFjY29yZGlvbixcbiAgICAgICAgQWxlcnQ6IGFsZXJ0LFxuICAgICAgICBDb3ZlcjogY292ZXIsXG4gICAgICAgIERyb3A6IGRyb3AsXG4gICAgICAgIERyb3Bkb3duOiBkcm9wLFxuICAgICAgICBGb3JtQ3VzdG9tOiBmb3JtQ3VzdG9tLFxuICAgICAgICBHcmlkOiBncmlkLFxuICAgICAgICBIZWlnaHRNYXRjaDogaGVpZ2h0TWF0Y2gsXG4gICAgICAgIEhlaWdodFZpZXdwb3J0OiBoZWlnaHRWaWV3cG9ydCxcbiAgICAgICAgSWNvbjogSWNvbixcbiAgICAgICAgSW1nOiBpbWcsXG4gICAgICAgIExlYWRlcjogbGVhZGVyLFxuICAgICAgICBNYXJnaW46IE1hcmdpbixcbiAgICAgICAgTW9kYWw6IG1vZGFsLFxuICAgICAgICBOYXY6IG5hdixcbiAgICAgICAgTmF2YmFyOiBuYXZiYXIsXG4gICAgICAgIE9mZmNhbnZhczogb2ZmY2FudmFzLFxuICAgICAgICBPdmVyZmxvd0F1dG86IG92ZXJmbG93QXV0byxcbiAgICAgICAgUmVzcG9uc2l2ZTogcmVzcG9uc2l2ZSxcbiAgICAgICAgU2Nyb2xsOiBzY3JvbGwsXG4gICAgICAgIFNjcm9sbHNweTogc2Nyb2xsc3B5LFxuICAgICAgICBTY3JvbGxzcHlOYXY6IHNjcm9sbHNweU5hdixcbiAgICAgICAgU3RpY2t5OiBzdGlja3ksXG4gICAgICAgIFN2ZzogU1ZHLFxuICAgICAgICBTd2l0Y2hlcjogU3dpdGNoZXIsXG4gICAgICAgIFRhYjogdGFiLFxuICAgICAgICBUb2dnbGU6IHRvZ2dsZSxcbiAgICAgICAgVmlkZW86IFZpZGVvLFxuICAgICAgICBDbG9zZTogQ2xvc2UsXG4gICAgICAgIFNwaW5uZXI6IFNwaW5uZXIsXG4gICAgICAgIFNsaWRlbmF2TmV4dDogU2xpZGVuYXYsXG4gICAgICAgIFNsaWRlbmF2UHJldmlvdXM6IFNsaWRlbmF2LFxuICAgICAgICBTZWFyY2hJY29uOiBTZWFyY2gsXG4gICAgICAgIE1hcmtlcjogSWNvbkNvbXBvbmVudCxcbiAgICAgICAgTmF2YmFyVG9nZ2xlSWNvbjogSWNvbkNvbXBvbmVudCxcbiAgICAgICAgT3ZlcmxheUljb246IEljb25Db21wb25lbnQsXG4gICAgICAgIFBhZ2luYXRpb25OZXh0OiBJY29uQ29tcG9uZW50LFxuICAgICAgICBQYWdpbmF0aW9uUHJldmlvdXM6IEljb25Db21wb25lbnQsXG4gICAgICAgIFRvdG9wOiBJY29uQ29tcG9uZW50XG4gICAgfSk7XG5cbiAgICAvLyByZWdpc3RlciBjb21wb25lbnRzXG4gICAgZWFjaChjb21wb25lbnRzJDEsIChjb21wb25lbnQsIG5hbWUpID0+IFVJa2l0LmNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpKTtcblxuICAgIC8vIGNvcmUgZnVuY3Rpb25hbGl0eVxuICAgIFVJa2l0LnVzZShDb3JlKTtcblxuICAgIGJvb3QoVUlraXQpO1xuXG4gICAgY29uc3QgdW5pdHMgPSBbJ2RheXMnLCAnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ107XG5cbiAgICB2YXIgY291bnRkb3duID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3NdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBkYXRlOiBTdHJpbmcsXG4gICAgICAgIGNsc1dyYXBwZXI6IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZGF0ZTogJycsXG4gICAgICAgIGNsc1dyYXBwZXI6ICcudWstY291bnRkb3duLSV1bml0JScgfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuZGF0ZSA9IERhdGUucGFyc2UodGhpcy4kcHJvcHMuZGF0ZSk7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Zpc2liaWxpdHljaGFuZ2UnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLnVwZGF0ZSwgMTAwMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RvcCgpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgICBjb25zdCB0aW1lc3BhbiA9IGdldFRpbWVTcGFuKHRoaXMuZGF0ZSk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZGF0ZSB8fCB0aW1lc3Bhbi50b3RhbCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICAgICAgdGltZXNwYW4uZGF5cyA9IHRpbWVzcGFuLmhvdXJzID0gdGltZXNwYW4ubWludXRlcyA9IHRpbWVzcGFuLnNlY29uZHMgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoY29uc3QgdW5pdCBvZiB1bml0cykge1xuICAgICAgICAgICAgY29uc3QgZWwgPSAkKHRoaXMuY2xzV3JhcHBlci5yZXBsYWNlKCcldW5pdCUnLCB1bml0KSwgdGhpcy4kZWwpO1xuXG4gICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGlnaXRzID0gU3RyaW5nKE1hdGgudHJ1bmModGltZXNwYW5bdW5pdF0pKTtcblxuICAgICAgICAgICAgZGlnaXRzID0gZGlnaXRzLmxlbmd0aCA8IDIgPyBcIjBcIiArIGRpZ2l0cyA6IGRpZ2l0cztcblxuICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSBkaWdpdHMpIHtcbiAgICAgICAgICAgICAgZGlnaXRzID0gZGlnaXRzLnNwbGl0KCcnKTtcblxuICAgICAgICAgICAgICBpZiAoZGlnaXRzLmxlbmd0aCAhPT0gZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaHRtbChlbCwgZGlnaXRzLm1hcCgoKSA9PiAnPHNwYW4+PC9zcGFuPicpLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRpZ2l0cy5mb3JFYWNoKChkaWdpdCwgaSkgPT4gZWwuY2hpbGRyZW5baV0udGV4dENvbnRlbnQgPSBkaWdpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBnZXRUaW1lU3BhbihkYXRlKSB7XG4gICAgICBjb25zdCB0b3RhbCA9IGRhdGUgLSBEYXRlLm5vdygpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3RhbCxcbiAgICAgICAgc2Vjb25kczogdG90YWwgLyAxMDAwICUgNjAsXG4gICAgICAgIG1pbnV0ZXM6IHRvdGFsIC8gMTAwMCAvIDYwICUgNjAsXG4gICAgICAgIGhvdXJzOiB0b3RhbCAvIDEwMDAgLyA2MCAvIDYwICUgMjQsXG4gICAgICAgIGRheXM6IHRvdGFsIC8gMTAwMCAvIDYwIC8gNjAgLyAyNCB9O1xuXG4gICAgfVxuXG4gICAgY29uc3QgY2xzTGVhdmUgPSAndWstdHJhbnNpdGlvbi1sZWF2ZSc7XG4gICAgY29uc3QgY2xzRW50ZXIgPSAndWstdHJhbnNpdGlvbi1lbnRlcic7XG5cbiAgICBmdW5jdGlvbiBmYWRlKGFjdGlvbiwgdGFyZ2V0LCBkdXJhdGlvbiwgc3RhZ2dlcikge2lmIChzdGFnZ2VyID09PSB2b2lkIDApIHtzdGFnZ2VyID0gMDt9XG4gICAgICBjb25zdCBpbmRleCA9IHRyYW5zaXRpb25JbmRleCh0YXJnZXQsIHRydWUpO1xuICAgICAgY29uc3QgcHJvcHNJbiA9IHsgb3BhY2l0eTogMSB9O1xuICAgICAgY29uc3QgcHJvcHNPdXQgPSB7IG9wYWNpdHk6IDAgfTtcblxuICAgICAgY29uc3Qgd3JhcEluZGV4Rm4gPSAoZm4pID0+ICgpID0+IGluZGV4ID09PSB0cmFuc2l0aW9uSW5kZXgodGFyZ2V0KSA/IGZuKCkgOiBQcm9taXNlLnJlamVjdCgpO1xuXG4gICAgICBjb25zdCBsZWF2ZUZuID0gd3JhcEluZGV4Rm4oKCkgPT4ge1xuICAgICAgICBhZGRDbGFzcyh0YXJnZXQsIGNsc0xlYXZlKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgIGdldFRyYW5zaXRpb25Ob2Rlcyh0YXJnZXQpLm1hcChcbiAgICAgICAgKGNoaWxkLCBpKSA9PlxuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgKCkgPT5cbiAgICAgICAgVHJhbnNpdGlvbi5zdGFydChjaGlsZCwgcHJvcHNPdXQsIGR1cmF0aW9uIC8gMiwgJ2Vhc2UnKS50aGVuKFxuICAgICAgICByZXNvbHZlKSxcblxuICAgICAgICBpICogc3RhZ2dlcikpKSkuXG5cblxuXG4gICAgICAgIHRoZW4oKCkgPT4gcmVtb3ZlQ2xhc3ModGFyZ2V0LCBjbHNMZWF2ZSkpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVudGVyRm4gPSB3cmFwSW5kZXhGbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZEhlaWdodCA9IGhlaWdodCh0YXJnZXQpO1xuXG4gICAgICAgIGFkZENsYXNzKHRhcmdldCwgY2xzRW50ZXIpO1xuICAgICAgICBhY3Rpb24oKTtcblxuICAgICAgICBjc3MoY2hpbGRyZW4odGFyZ2V0KSwgeyBvcGFjaXR5OiAwIH0pO1xuXG4gICAgICAgIC8vIEVuc3VyZSBVSWtpdCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbih0YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IGhlaWdodCh0YXJnZXQpO1xuXG4gICAgICAgICAgLy8gRW5zdXJlIEdyaWQgY2VsbHMgZG8gbm90IHN0cmV0Y2ggd2hlbiBoZWlnaHQgaXMgYXBwbGllZFxuICAgICAgICAgIGNzcyh0YXJnZXQsICdhbGlnbkNvbnRlbnQnLCAnZmxleC1zdGFydCcpO1xuICAgICAgICAgIGhlaWdodCh0YXJnZXQsIG9sZEhlaWdodCk7XG5cbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uTm9kZXMgPSBnZXRUcmFuc2l0aW9uTm9kZXModGFyZ2V0KTtcbiAgICAgICAgICBjc3Mobm9kZXMsIHByb3BzT3V0KTtcblxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25zID0gdHJhbnNpdGlvbk5vZGVzLm1hcChcbiAgICAgICAgICAoY2hpbGQsIGkpID0+XG4gICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQoY2hpbGQsIHByb3BzSW4sIGR1cmF0aW9uIC8gMiwgJ2Vhc2UnKS50aGVuKFxuICAgICAgICAgIHJlc29sdmUpLFxuXG4gICAgICAgICAgaSAqIHN0YWdnZXIpKSk7XG5cblxuXG5cbiAgICAgICAgICBpZiAob2xkSGVpZ2h0ICE9PSBuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zLnB1c2goXG4gICAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgeyBoZWlnaHQ6IG5ld0hlaWdodCB9LFxuICAgICAgICAgICAgZHVyYXRpb24gLyAyICsgdHJhbnNpdGlvbk5vZGVzLmxlbmd0aCAqIHN0YWdnZXIsXG4gICAgICAgICAgICAnZWFzZScpKTtcblxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgUHJvbWlzZS5hbGwodHJhbnNpdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModGFyZ2V0LCBjbHNFbnRlcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHRyYW5zaXRpb25JbmRleCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIGNzcyh0YXJnZXQsIHsgaGVpZ2h0OiAnJywgYWxpZ25Db250ZW50OiAnJyB9KTtcbiAgICAgICAgICAgICAgY3NzKG5vZGVzLCB7IG9wYWNpdHk6ICcnIH0pO1xuICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0LmRhdGFzZXQudHJhbnNpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGhhc0NsYXNzKHRhcmdldCwgY2xzTGVhdmUpID9cbiAgICAgIHdhaXRUcmFuc2l0aW9uZW5kKHRhcmdldCkudGhlbihlbnRlckZuKSA6XG4gICAgICBoYXNDbGFzcyh0YXJnZXQsIGNsc0VudGVyKSA/XG4gICAgICB3YWl0VHJhbnNpdGlvbmVuZCh0YXJnZXQpLnRoZW4obGVhdmVGbikudGhlbihlbnRlckZuKSA6XG4gICAgICBsZWF2ZUZuKCkudGhlbihlbnRlckZuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uSW5kZXgodGFyZ2V0LCBuZXh0KSB7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICB0YXJnZXQuZGF0YXNldC50cmFuc2l0aW9uID0gMSArIHRyYW5zaXRpb25JbmRleCh0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9OdW1iZXIodGFyZ2V0LmRhdGFzZXQudHJhbnNpdGlvbikgfHwgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YWl0VHJhbnNpdGlvbmVuZCh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIGNoaWxkcmVuKHRhcmdldCkuXG4gICAgICBmaWx0ZXIoVHJhbnNpdGlvbi5pblByb2dyZXNzKS5cbiAgICAgIG1hcChcbiAgICAgIChlbCkgPT5cbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBvbmNlKGVsLCAndHJhbnNpdGlvbmVuZCB0cmFuc2l0aW9uY2FuY2VsZWQnLCByZXNvbHZlKSkpKTtcblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbk5vZGVzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldFJvd3MoY2hpbGRyZW4odGFyZ2V0KSkucmVkdWNlKFxuICAgICAgKG5vZGVzLCByb3cpID0+XG4gICAgICBub2Rlcy5jb25jYXQoXG4gICAgICBzb3J0QnkkMShcbiAgICAgIHJvdy5maWx0ZXIoKGVsKSA9PiBpc0luVmlldyhlbCkpLFxuICAgICAgJ29mZnNldExlZnQnKSksXG5cblxuICAgICAgW10pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2xpZGUgKGFjdGlvbiwgdGFyZ2V0LCBkdXJhdGlvbikge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgbGV0IG5vZGVzID0gY2hpbGRyZW4odGFyZ2V0KTtcblxuICAgICAgICAvLyBHZXQgY3VycmVudCBzdGF0ZVxuICAgICAgICBjb25zdCBjdXJyZW50UHJvcHMgPSBub2Rlcy5tYXAoKGVsKSA9PiBnZXRQcm9wcyhlbCwgdHJ1ZSkpO1xuICAgICAgICBjb25zdCB0YXJnZXRQcm9wcyA9IGNzcyh0YXJnZXQsIFsnaGVpZ2h0JywgJ3BhZGRpbmcnXSk7XG5cbiAgICAgICAgLy8gQ2FuY2VsIHByZXZpb3VzIGFuaW1hdGlvbnNcbiAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwodGFyZ2V0KTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChUcmFuc2l0aW9uLmNhbmNlbCk7XG4gICAgICAgIHJlc2V0KHRhcmdldCk7XG5cbiAgICAgICAgLy8gQWRkaW5nLCBzb3J0aW5nLCByZW1vdmluZyBub2Rlc1xuICAgICAgICBhY3Rpb24oKTtcblxuICAgICAgICAvLyBGaW5kIG5ldyBub2Rlc1xuICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZHJlbih0YXJnZXQpLmZpbHRlcigoZWwpID0+ICFpbmNsdWRlcyhub2RlcywgZWwpKSk7XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgdXBkYXRlIHRvIHByb3BhZ2F0ZVxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAvLyBGb3JjZSB1cGRhdGVcbiAgICAgICAgICBmYXN0ZG9tLmZsdXNoKCk7XG5cbiAgICAgICAgICAvLyBHZXQgbmV3IHN0YXRlXG4gICAgICAgICAgY29uc3QgdGFyZ2V0UHJvcHNUbyA9IGNzcyh0YXJnZXQsIFsnaGVpZ2h0JywgJ3BhZGRpbmcnXSk7XG4gICAgICAgICAgY29uc3QgW3Byb3BzVG8sIHByb3BzRnJvbV0gPSBnZXRUcmFuc2l0aW9uUHJvcHModGFyZ2V0LCBub2RlcywgY3VycmVudFByb3BzKTtcblxuICAgICAgICAgIC8vIFJlc2V0IHRvIHByZXZpb3VzIHN0YXRlXG4gICAgICAgICAgbm9kZXMuZm9yRWFjaCgoZWwsIGkpID0+IHByb3BzRnJvbVtpXSAmJiBjc3MoZWwsIHByb3BzRnJvbVtpXSkpO1xuICAgICAgICAgIGNzcyh0YXJnZXQsIHsgZGlzcGxheTogJ2Jsb2NrJywgLi4udGFyZ2V0UHJvcHMgfSk7XG5cbiAgICAgICAgICAvLyBTdGFydCB0cmFuc2l0aW9ucyBvbiBuZXh0IGZyYW1lXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25zID0gbm9kZXMuXG4gICAgICAgICAgICBtYXAoXG4gICAgICAgICAgICAoZWwsIGkpID0+XG4gICAgICAgICAgICBwYXJlbnQoZWwpID09PSB0YXJnZXQgJiZcbiAgICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQoZWwsIHByb3BzVG9baV0sIGR1cmF0aW9uLCAnZWFzZScpKS5cblxuICAgICAgICAgICAgY29uY2F0KFRyYW5zaXRpb24uc3RhcnQodGFyZ2V0LCB0YXJnZXRQcm9wc1RvLCBkdXJhdGlvbiwgJ2Vhc2UnKSk7XG5cbiAgICAgICAgICAgIFByb21pc2UuYWxsKHRyYW5zaXRpb25zKS5cbiAgICAgICAgICAgIHRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAoZWwsIGkpID0+XG4gICAgICAgICAgICAgIHBhcmVudChlbCkgPT09IHRhcmdldCAmJlxuICAgICAgICAgICAgICBjc3MoZWwsICdkaXNwbGF5JywgcHJvcHNUb1tpXS5vcGFjaXR5ID09PSAwID8gJ25vbmUnIDogJycpKTtcblxuICAgICAgICAgICAgICByZXNldCh0YXJnZXQpO1xuICAgICAgICAgICAgfSwgbm9vcCkuXG4gICAgICAgICAgICB0aGVuKHJlc29sdmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByb3BzKGVsLCBvcGFjaXR5KSB7XG4gICAgICBjb25zdCB6SW5kZXggPSBjc3MoZWwsICd6SW5kZXgnKTtcblxuICAgICAgcmV0dXJuIGlzVmlzaWJsZShlbCkgP1xuICAgICAge1xuICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgb3BhY2l0eTogb3BhY2l0eSA/IGNzcyhlbCwgJ29wYWNpdHknKSA6ICcwJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgekluZGV4OiB6SW5kZXggPT09ICdhdXRvJyA/IGluZGV4KGVsKSA6IHpJbmRleCxcbiAgICAgICAgLi4uZ2V0UG9zaXRpb25XaXRoTWFyZ2luKGVsKSB9IDpcblxuICAgICAgZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblByb3BzKHRhcmdldCwgbm9kZXMsIGN1cnJlbnRQcm9wcykge1xuICAgICAgY29uc3QgcHJvcHNUbyA9IG5vZGVzLm1hcCgoZWwsIGkpID0+XG4gICAgICBwYXJlbnQoZWwpICYmIGkgaW4gY3VycmVudFByb3BzID9cbiAgICAgIGN1cnJlbnRQcm9wc1tpXSA/XG4gICAgICBpc1Zpc2libGUoZWwpID9cbiAgICAgIGdldFBvc2l0aW9uV2l0aE1hcmdpbihlbCkgOlxuICAgICAgeyBvcGFjaXR5OiAwIH0gOlxuICAgICAgeyBvcGFjaXR5OiBpc1Zpc2libGUoZWwpID8gMSA6IDAgfSA6XG4gICAgICBmYWxzZSk7XG5cblxuICAgICAgY29uc3QgcHJvcHNGcm9tID0gcHJvcHNUby5tYXAoKHByb3BzLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBwYXJlbnQobm9kZXNbaV0pID09PSB0YXJnZXQgJiYgKGN1cnJlbnRQcm9wc1tpXSB8fCBnZXRQcm9wcyhub2Rlc1tpXSkpO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICBkZWxldGUgZnJvbS5vcGFjaXR5O1xuICAgICAgICB9IGVsc2UgaWYgKCEoJ29wYWNpdHknIGluIHByb3BzKSkge1xuICAgICAgICAgIGNvbnN0IHsgb3BhY2l0eSB9ID0gZnJvbTtcblxuICAgICAgICAgIGlmIChvcGFjaXR5ICUgMSkge1xuICAgICAgICAgICAgcHJvcHMub3BhY2l0eSA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmcm9tLm9wYWNpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFtwcm9wc1RvLCBwcm9wc0Zyb21dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0KGVsKSB7XG4gICAgICBjc3MoZWwuY2hpbGRyZW4sIHtcbiAgICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgICAgbGVmdDogJycsXG4gICAgICAgIG9wYWNpdHk6ICcnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnJyxcbiAgICAgICAgcG9zaXRpb246ICcnLFxuICAgICAgICB0b3A6ICcnLFxuICAgICAgICBtYXJnaW5Ub3A6ICcnLFxuICAgICAgICBtYXJnaW5MZWZ0OiAnJyxcbiAgICAgICAgdHJhbnNmb3JtOiAnJyxcbiAgICAgICAgd2lkdGg6ICcnLFxuICAgICAgICB6SW5kZXg6ICcnIH0pO1xuXG4gICAgICBjc3MoZWwsIHsgaGVpZ2h0OiAnJywgZGlzcGxheTogJycsIHBhZGRpbmc6ICcnIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uV2l0aE1hcmdpbihlbCkge1xuICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBvZmZzZXQoZWwpO1xuICAgICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IHBvc2l0aW9uKGVsKTtcbiAgICAgIGNvbnN0IHsgbWFyZ2luTGVmdCwgbWFyZ2luVG9wIH0gPSBjc3MoZWwsIFsnbWFyZ2luVG9wJywgJ21hcmdpbkxlZnQnXSk7XG5cbiAgICAgIHJldHVybiB7IHRvcCwgbGVmdCwgaGVpZ2h0LCB3aWR0aCwgbWFyZ2luTGVmdCwgbWFyZ2luVG9wLCB0cmFuc2Zvcm06ICcnIH07XG4gICAgfVxuXG4gICAgdmFyIEFuaW1hdGUgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBkdXJhdGlvbjogTnVtYmVyLFxuICAgICAgICBhbmltYXRpb246IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGR1cmF0aW9uOiAxNTAsXG4gICAgICAgIGFuaW1hdGlvbjogJ3NsaWRlJyB9LFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYW5pbWF0ZShhY3Rpb24sIHRhcmdldCkge2lmICh0YXJnZXQgPT09IHZvaWQgMCkge3RhcmdldCA9IHRoaXMuJGVsO31cbiAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5hbmltYXRpb247XG4gICAgICAgICAgY29uc3QgYW5pbWF0aW9uRm4gPVxuICAgICAgICAgIG5hbWUgPT09ICdmYWRlJyA/XG4gICAgICAgICAgZmFkZSA6XG4gICAgICAgICAgbmFtZSA9PT0gJ2RlbGF5ZWQtZmFkZScgP1xuICAgICAgICAgIGZ1bmN0aW9uICgpIHtmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHthcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO31yZXR1cm4gZmFkZSguLi5hcmdzLCA0MCk7fSA6XG4gICAgICAgICAgbmFtZSA/XG4gICAgICAgICAgc2xpZGUgOlxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uRm4oYWN0aW9uLCB0YXJnZXQsIHRoaXMuZHVyYXRpb24pLnRoZW4oXG4gICAgICAgICAgKCkgPT4gdGhpcy4kdXBkYXRlKHRhcmdldCwgJ3Jlc2l6ZScpLFxuICAgICAgICAgIG5vb3ApO1xuXG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIGZpbHRlciA9IHtcbiAgICAgIG1peGluczogW0FuaW1hdGVdLFxuXG4gICAgICBhcmdzOiAndGFyZ2V0JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGFyZ2V0OiBCb29sZWFuLFxuICAgICAgICBzZWxBY3RpdmU6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgc2VsQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgYXR0ckl0ZW06ICd1ay1maWx0ZXItY29udHJvbCcsXG4gICAgICAgIGNsczogJ3VrLWFjdGl2ZScsXG4gICAgICAgIGR1cmF0aW9uOiAyNTAgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICB0b2dnbGVzOiB7XG4gICAgICAgICAgZ2V0KF9yZWYsICRlbCkge2xldCB7IGF0dHJJdGVtIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuICQkKFwiW1wiICsgYXR0ckl0ZW0gKyBcIl0sW2RhdGEtXCIgKyBhdHRySXRlbSArIFwiXVwiLCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsQWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVzID0gJCQodGhpcy5zZWxBY3RpdmUsIHRoaXMuJGVsKTtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGVzLmZvckVhY2goKGVsKSA9PiB0b2dnbGVDbGFzcyhlbCwgdGhpcy5jbHMsIGluY2x1ZGVzKGFjdGl2ZXMsIGVsKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgICAgZ2V0KF9yZWYyLCAkZWwpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWYyO1xuICAgICAgICAgICAgcmV0dXJuICQkKHRhcmdldCArIFwiID4gKlwiLCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChsaXN0LCBvbGQpIHtcbiAgICAgICAgICAgIGlmIChvbGQgJiYgIWlzRXF1YWxMaXN0KGxpc3QsIG9sZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSB9LFxuXG5cblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiW1wiICsgdGhpcy5hdHRySXRlbSArIFwiXSxbZGF0YS1cIiArIHRoaXMuYXR0ckl0ZW0gKyBcIl1cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5hcHBseShlLmN1cnJlbnQpO1xuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhcHBseShlbCkge1xuICAgICAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IG1lcmdlU3RhdGUoZWwsIHRoaXMuYXR0ckl0ZW0sIHRoaXMuZ2V0U3RhdGUoKSk7XG5cbiAgICAgICAgICBpZiAoIWlzRXF1YWxTdGF0ZShwcmV2U3RhdGUsIG5ld1N0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldFN0YXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZXMuXG4gICAgICAgICAgZmlsdGVyKChpdGVtKSA9PiBoYXNDbGFzcyhpdGVtLCB0aGlzLmNscykpLlxuICAgICAgICAgIHJlZHVjZSgoc3RhdGUsIGVsKSA9PiBtZXJnZVN0YXRlKGVsLCB0aGlzLmF0dHJJdGVtLCBzdGF0ZSksIHtcbiAgICAgICAgICAgIGZpbHRlcjogeyAnJzogJycgfSxcbiAgICAgICAgICAgIHNvcnQ6IFtdIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0U3RhdGUoc3RhdGUsIGFuaW1hdGUpIHtpZiAoYW5pbWF0ZSA9PT0gdm9pZCAwKSB7YW5pbWF0ZSA9IHRydWU7fVxuICAgICAgICAgIHN0YXRlID0geyBmaWx0ZXI6IHsgJyc6ICcnIH0sIHNvcnQ6IFtdLCAuLi5zdGF0ZSB9O1xuXG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2JlZm9yZUZpbHRlcicsIFt0aGlzLCBzdGF0ZV0pO1xuXG4gICAgICAgICAgdGhpcy50b2dnbGVzLmZvckVhY2goKGVsKSA9PlxuICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLmNscywgISFtYXRjaEZpbHRlcihlbCwgdGhpcy5hdHRySXRlbSwgc3RhdGUpKSk7XG5cblxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICQkKHRoaXMudGFyZ2V0LCB0aGlzLiRlbCkubWFwKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgICAgICAgICBhcHBseVN0YXRlKHN0YXRlLCB0YXJnZXQsIGNoaWxkcmVuKHRhcmdldCkpO1xuICAgICAgICAgICAgICB0aGlzLiR1cGRhdGUodGhpcy4kZWwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRlID8gdGhpcy5hbmltYXRlKGZpbHRlckZuLCB0YXJnZXQpIDogZmlsdGVyRm4oKTtcbiAgICAgICAgICB9KSkuXG4gICAgICAgICAgdGhlbigoKSA9PiB0cmlnZ2VyKHRoaXMuJGVsLCAnYWZ0ZXJGaWx0ZXInLCBbdGhpc10pKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgICBmYXN0ZG9tLndyaXRlKCgpID0+IHRoaXMuc2V0U3RhdGUodGhpcy5nZXRTdGF0ZSgpLCBmYWxzZSkpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBnZXRGaWx0ZXIoZWwsIGF0dHIpIHtcbiAgICAgIHJldHVybiBwYXJzZU9wdGlvbnMoZGF0YShlbCwgYXR0ciksIFsnZmlsdGVyJ10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRXF1YWxTdGF0ZShzdGF0ZUEsIHN0YXRlQikge1xuICAgICAgcmV0dXJuIFsnZmlsdGVyJywgJ3NvcnQnXS5ldmVyeSgocHJvcCkgPT4gaXNFcXVhbChzdGF0ZUFbcHJvcF0sIHN0YXRlQltwcm9wXSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5U3RhdGUoc3RhdGUsIHRhcmdldCwgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3Ioc3RhdGUpO1xuXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKChlbCkgPT4gY3NzKGVsLCAnZGlzcGxheScsIHNlbGVjdG9yICYmICFtYXRjaGVzKGVsLCBzZWxlY3RvcikgPyAnbm9uZScgOiAnJykpO1xuXG4gICAgICBjb25zdCBbc29ydCwgb3JkZXJdID0gc3RhdGUuc29ydDtcblxuICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgY29uc3Qgc29ydGVkID0gc29ydEl0ZW1zKGNoaWxkcmVuLCBzb3J0LCBvcmRlcik7XG4gICAgICAgIGlmICghaXNFcXVhbChzb3J0ZWQsIGNoaWxkcmVuKSkge1xuICAgICAgICAgIGFwcGVuZCh0YXJnZXQsIHNvcnRlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZVN0YXRlKGVsLCBhdHRyLCBzdGF0ZSkge1xuICAgICAgY29uc3QgZmlsdGVyQnkgPSBnZXRGaWx0ZXIoZWwsIGF0dHIpO1xuICAgICAgY29uc3QgeyBmaWx0ZXIsIGdyb3VwLCBzb3J0LCBvcmRlciA9ICdhc2MnIH0gPSBmaWx0ZXJCeTtcblxuICAgICAgaWYgKGZpbHRlciB8fCBpc1VuZGVmaW5lZChzb3J0KSkge1xuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuZmlsdGVyWycnXTtcbiAgICAgICAgICAgIHN0YXRlLmZpbHRlcltncm91cF0gPSBmaWx0ZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5maWx0ZXJbZ3JvdXBdO1xuXG4gICAgICAgICAgICBpZiAoaXNFbXB0eShzdGF0ZS5maWx0ZXIpIHx8ICcnIGluIHN0YXRlLmZpbHRlcikge1xuICAgICAgICAgICAgICBzdGF0ZS5maWx0ZXIgPSB7ICcnOiBmaWx0ZXIgfHwgJycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuZmlsdGVyID0geyAnJzogZmlsdGVyIHx8ICcnIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1VuZGVmaW5lZChzb3J0KSkge1xuICAgICAgICBzdGF0ZS5zb3J0ID0gW3NvcnQsIG9yZGVyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRmlsdGVyKFxuICAgIGVsLFxuICAgIGF0dHIsIF9yZWYzKVxuXG4gICAge2xldCB7IGZpbHRlcjogc3RhdGVGaWx0ZXIgPSB7ICcnOiAnJyB9LCBzb3J0OiBbc3RhdGVTb3J0LCBzdGF0ZU9yZGVyXSB9ID0gX3JlZjM7XG4gICAgICBjb25zdCB7IGZpbHRlciA9ICcnLCBncm91cCA9ICcnLCBzb3J0LCBvcmRlciA9ICdhc2MnIH0gPSBnZXRGaWx0ZXIoZWwsIGF0dHIpO1xuXG4gICAgICByZXR1cm4gaXNVbmRlZmluZWQoc29ydCkgP1xuICAgICAgZ3JvdXAgaW4gc3RhdGVGaWx0ZXIgJiYgZmlsdGVyID09PSBzdGF0ZUZpbHRlcltncm91cF0gfHxcbiAgICAgICFmaWx0ZXIgJiYgZ3JvdXAgJiYgIShncm91cCBpbiBzdGF0ZUZpbHRlcikgJiYgIXN0YXRlRmlsdGVyWycnXSA6XG4gICAgICBzdGF0ZVNvcnQgPT09IHNvcnQgJiYgc3RhdGVPcmRlciA9PT0gb3JkZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFcXVhbExpc3QobGlzdEEsIGxpc3RCKSB7XG4gICAgICByZXR1cm4gbGlzdEEubGVuZ3RoID09PSBsaXN0Qi5sZW5ndGggJiYgbGlzdEEuZXZlcnkoKGVsKSA9PiB+bGlzdEIuaW5kZXhPZihlbCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlbGVjdG9yKF9yZWY0KSB7bGV0IHsgZmlsdGVyIH0gPSBfcmVmNDtcbiAgICAgIGxldCBzZWxlY3RvciA9ICcnO1xuICAgICAgZWFjaChmaWx0ZXIsICh2YWx1ZSkgPT4gc2VsZWN0b3IgKz0gdmFsdWUgfHwgJycpO1xuICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnRJdGVtcyhub2Rlcywgc29ydCwgb3JkZXIpIHtcbiAgICAgIHJldHVybiBbLi4ubm9kZXNdLnNvcnQoXG4gICAgICAoYSwgYikgPT5cbiAgICAgIGRhdGEoYSwgc29ydCkubG9jYWxlQ29tcGFyZShkYXRhKGIsIHNvcnQpLCB1bmRlZmluZWQsIHsgbnVtZXJpYzogdHJ1ZSB9KSAqIChcbiAgICAgIG9yZGVyID09PSAnYXNjJyB8fCAtMSkpO1xuXG4gICAgfVxuXG4gICAgdmFyIEFuaW1hdGlvbnMkMiA9IHtcbiAgICAgIHNsaWRlOiB7XG4gICAgICAgIHNob3coZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IHRyYW5zZm9ybTogdHJhbnNsYXRlKGRpciAqIC0xMDApIH0sIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSB9XTtcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlZChjdXJyZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCwgZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKGRpciAqIC0xMDAgKiBwZXJjZW50KSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoZGlyICogMTAwICogKDEgLSBwZXJjZW50KSkgfV07XG5cbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlZChlbCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKGNzcyhlbCwgJ3RyYW5zZm9ybScpLnNwbGl0KCcsJylbNF0gLyBlbC5vZmZzZXRXaWR0aCkgfHwgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUodmFsdWUsIHVuaXQpIHtpZiAodmFsdWUgPT09IHZvaWQgMCkge3ZhbHVlID0gMDt9aWYgKHVuaXQgPT09IHZvaWQgMCkge3VuaXQgPSAnJSc7fVxuICAgICAgdmFsdWUgKz0gdmFsdWUgPyB1bml0IDogJyc7XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUzZChcIiArIHZhbHVlICsgXCIsIDAsIDApXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGUzZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwic2NhbGUzZChcIiArIHZhbHVlICsgXCIsIFwiICsgdmFsdWUgKyBcIiwgMSlcIjtcbiAgICB9XG5cbiAgICB2YXIgQW5pbWF0aW9ucyQxID0ge1xuICAgICAgLi4uQW5pbWF0aW9ucyQyLFxuICAgICAgZmFkZToge1xuICAgICAgICBzaG93KCkge1xuICAgICAgICAgIHJldHVybiBbeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9XTtcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIGNzcyhjdXJyZW50LCAnb3BhY2l0eScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDEgLSBwZXJjZW50IH0sIHsgb3BhY2l0eTogcGVyY2VudCB9XTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogc2NhbGUzZCgxIC0gMC4yKSB9LFxuICAgICAgICAgIHsgb3BhY2l0eTogMSwgdHJhbnNmb3JtOiBzY2FsZTNkKDEpIH1dO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyY2VudChjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLSBjc3MoY3VycmVudCwgJ29wYWNpdHknKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgeyBvcGFjaXR5OiAxIC0gcGVyY2VudCwgdHJhbnNmb3JtOiBzY2FsZTNkKDEgLSAwLjIgKiBwZXJjZW50KSB9LFxuICAgICAgICAgIHsgb3BhY2l0eTogcGVyY2VudCwgdHJhbnNmb3JtOiBzY2FsZTNkKDEgLSAwLjIgKyAwLjIgKiBwZXJjZW50KSB9XTtcblxuICAgICAgICB9IH0gfTtcblxuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25lciQxKHByZXYsIG5leHQsIGRpciwgX3JlZikge2xldCB7IGFuaW1hdGlvbiwgZWFzaW5nIH0gPSBfcmVmO1xuICAgICAgY29uc3QgeyBwZXJjZW50LCB0cmFuc2xhdGUsIHNob3cgPSBub29wIH0gPSBhbmltYXRpb247XG4gICAgICBjb25zdCBwcm9wcyA9IHNob3coZGlyKTtcbiAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpcixcblxuICAgICAgICBzaG93KGR1cmF0aW9uLCBwZXJjZW50LCBsaW5lYXIpIHtpZiAocGVyY2VudCA9PT0gdm9pZCAwKSB7cGVyY2VudCA9IDA7fVxuICAgICAgICAgIGNvbnN0IHRpbWluZyA9IGxpbmVhciA/ICdsaW5lYXInIDogZWFzaW5nO1xuICAgICAgICAgIGR1cmF0aW9uIC09IE1hdGgucm91bmQoZHVyYXRpb24gKiBjbGFtcChwZXJjZW50LCAtMSwgMSkpO1xuXG4gICAgICAgICAgdGhpcy50cmFuc2xhdGUocGVyY2VudCk7XG5cbiAgICAgICAgICB0cmlnZ2VyVXBkYXRlJDEobmV4dCwgJ2l0ZW1pbicsIHsgcGVyY2VudCwgZHVyYXRpb24sIHRpbWluZywgZGlyIH0pO1xuICAgICAgICAgIHRyaWdnZXJVcGRhdGUkMShwcmV2LCAnaXRlbW91dCcsIHsgcGVyY2VudDogMSAtIHBlcmNlbnQsIGR1cmF0aW9uLCB0aW1pbmcsIGRpciB9KTtcblxuICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KG5leHQsIHByb3BzWzFdLCBkdXJhdGlvbiwgdGltaW5nKSxcbiAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KHByZXYsIHByb3BzWzBdLCBkdXJhdGlvbiwgdGltaW5nKV0pLlxuICAgICAgICAgIHRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgIH0sIG5vb3ApO1xuXG4gICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKFtuZXh0LCBwcmV2XSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzWzBdKSB7XG4gICAgICAgICAgICBjc3MoW25leHQsIHByZXZdLCBwcm9wLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZvcndhcmQoZHVyYXRpb24sIHBlcmNlbnQpIHtpZiAocGVyY2VudCA9PT0gdm9pZCAwKSB7cGVyY2VudCA9IHRoaXMucGVyY2VudCgpO31cbiAgICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbChbbmV4dCwgcHJldl0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNob3coZHVyYXRpb24sIHBlcmNlbnQsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgICAgY29uc3QgcHJvcHMgPSB0cmFuc2xhdGUocGVyY2VudCwgZGlyKTtcbiAgICAgICAgICBjc3MobmV4dCwgcHJvcHNbMV0pO1xuICAgICAgICAgIGNzcyhwcmV2LCBwcm9wc1swXSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSQxKG5leHQsICdpdGVtdHJhbnNsYXRlaW4nLCB7IHBlcmNlbnQsIGRpciB9KTtcbiAgICAgICAgICB0cmlnZ2VyVXBkYXRlJDEocHJldiwgJ2l0ZW10cmFuc2xhdGVvdXQnLCB7IHBlcmNlbnQ6IDEgLSBwZXJjZW50LCBkaXIgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyY2VudCgpIHtcbiAgICAgICAgICByZXR1cm4gcGVyY2VudChwcmV2IHx8IG5leHQsIG5leHQsIGRpcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGlzdGFuY2UoKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYub2Zmc2V0V2lkdGg7XG4gICAgICAgIH0gfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXJVcGRhdGUkMShlbCwgdHlwZSwgZGF0YSkge1xuICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIFNsaWRlckF1dG9wbGF5ID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYXV0b3BsYXk6IEJvb2xlYW4sXG4gICAgICAgIGF1dG9wbGF5SW50ZXJ2YWw6IE51bWJlcixcbiAgICAgICAgcGF1c2VPbkhvdmVyOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICAgIGF1dG9wbGF5SW50ZXJ2YWw6IDcwMDAsXG4gICAgICAgIHBhdXNlT25Ib3ZlcjogdHJ1ZSB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5hdXRvcGxheSAmJiB0aGlzLnN0YXJ0QXV0b3BsYXkoKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5zdG9wQXV0b3BsYXkoKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgYXR0cih0aGlzLnNsaWRlcywgJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Zpc2liaWxpdHljaGFuZ2UnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXV0b3BsYXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BBdXRvcGxheSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0QXV0b3BsYXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHN0YXJ0QXV0b3BsYXkoKSB7XG4gICAgICAgICAgdGhpcy5zdG9wQXV0b3BsYXkoKTtcblxuICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICghdGhpcy5kcmFnZ2FibGUgfHwgISQoJzpmb2N1cycsIHRoaXMuJGVsKSkgJiYgKFxuICAgICAgICAgICF0aGlzLnBhdXNlT25Ib3ZlciB8fCAhbWF0Y2hlcyh0aGlzLiRlbCwgJzpob3ZlcicpKSAmJlxuICAgICAgICAgICF0aGlzLnN0YWNrLmxlbmd0aCAmJlxuICAgICAgICAgIHRoaXMuc2hvdygnbmV4dCcpLFxuICAgICAgICAgIHRoaXMuYXV0b3BsYXlJbnRlcnZhbCk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzdG9wQXV0b3BsYXkoKSB7XG4gICAgICAgICAgdGhpcy5pbnRlcnZhbCAmJiBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBTbGlkZXJEcmFnID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZHJhZ2dhYmxlOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIHRocmVzaG9sZDogMTAgfSxcblxuXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ3N0YXJ0JywgJ21vdmUnLCAnZW5kJ10pIHtcbiAgICAgICAgICBjb25zdCBmbiA9IHRoaXNba2V5XTtcbiAgICAgICAgICB0aGlzW2tleV0gPSAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXZlbnRQb3MoZSkueCAqIChpc1J0bCA/IC0xIDogMSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJldlBvcyA9IHBvcyA9PT0gdGhpcy5wb3MgPyB0aGlzLnByZXZQb3MgOiB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuXG4gICAgICAgICAgICBmbihlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogcG9pbnRlckRvd24sXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsU2xpZGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAhdGhpcy5kcmFnZ2FibGUgfHxcbiAgICAgICAgICAhaXNUb3VjaChlKSAmJiBoYXNUZXh0Tm9kZXNPbmx5KGUudGFyZ2V0KSB8fFxuICAgICAgICAgIGNsb3Nlc3QoZS50YXJnZXQsIHNlbElucHV0KSB8fFxuICAgICAgICAgIGUuYnV0dG9uID4gMCB8fFxuICAgICAgICAgIHRoaXMubGVuZ3RoIDwgMilcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGFydChlKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2RyYWdzdGFydCcsXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICB0aGlzLmRyYWcgPSB0aGlzLnBvcztcblxuICAgICAgICAgIGlmICh0aGlzLl90cmFuc2l0aW9uZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGVyY2VudCA9IHRoaXMuX3RyYW5zaXRpb25lci5wZXJjZW50KCk7XG4gICAgICAgICAgICB0aGlzLmRyYWcgKz0gdGhpcy5fdHJhbnNpdGlvbmVyLmdldERpc3RhbmNlKCkgKiB0aGlzLnBlcmNlbnQgKiB0aGlzLmRpcjtcblxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyLnRyYW5zbGF0ZSh0aGlzLnBlcmNlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXZJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb24oZG9jdW1lbnQsIHBvaW50ZXJNb3ZlLCB0aGlzLm1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG5cbiAgICAgICAgICAvLyAnaW5wdXQnIGV2ZW50IGlzIHRyaWdnZXJlZCBieSB2aWRlbyBjb250cm9sc1xuICAgICAgICAgIG9uKGRvY3VtZW50LCBwb2ludGVyVXAgKyBcIiBcIiArIHBvaW50ZXJDYW5jZWwgKyBcIiBpbnB1dFwiLCB0aGlzLmVuZCwgdHJ1ZSk7XG5cbiAgICAgICAgICBjc3ModGhpcy5saXN0LCAndXNlclNlbGVjdCcsICdub25lJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZShlKSB7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnBvcyAtIHRoaXMuZHJhZztcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICBkaXN0YW5jZSA9PT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJldlBvcyA9PT0gdGhpcy5wb3MgfHxcbiAgICAgICAgICAhdGhpcy5kcmFnZ2luZyAmJiBNYXRoLmFicyhkaXN0YW5jZSkgPCB0aGlzLnRocmVzaG9sZClcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcHJldmVudCBjbGljayBldmVudFxuICAgICAgICAgIGNzcyh0aGlzLmxpc3QsICdwb2ludGVyRXZlbnRzJywgJ25vbmUnKTtcblxuICAgICAgICAgIGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRpciA9IGRpc3RhbmNlIDwgMCA/IDEgOiAtMTtcblxuICAgICAgICAgIGNvbnN0IHsgc2xpZGVzIH0gPSB0aGlzO1xuICAgICAgICAgIGxldCB7IHByZXZJbmRleCB9ID0gdGhpcztcbiAgICAgICAgICBsZXQgZGlzID0gTWF0aC5hYnMoZGlzdGFuY2UpO1xuICAgICAgICAgIGxldCBuZXh0SW5kZXggPSB0aGlzLmdldEluZGV4KHByZXZJbmRleCArIHRoaXMuZGlyLCBwcmV2SW5kZXgpO1xuICAgICAgICAgIGxldCB3aWR0aCA9IHRoaXMuX2dldERpc3RhbmNlKHByZXZJbmRleCwgbmV4dEluZGV4KSB8fCBzbGlkZXNbcHJldkluZGV4XS5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgIHdoaWxlIChuZXh0SW5kZXggIT09IHByZXZJbmRleCAmJiBkaXMgPiB3aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnIC09IHdpZHRoICogdGhpcy5kaXI7XG5cbiAgICAgICAgICAgIHByZXZJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIGRpcyAtPSB3aWR0aDtcbiAgICAgICAgICAgIG5leHRJbmRleCA9IHRoaXMuZ2V0SW5kZXgocHJldkluZGV4ICsgdGhpcy5kaXIsIHByZXZJbmRleCk7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX2dldERpc3RhbmNlKHByZXZJbmRleCwgbmV4dEluZGV4KSB8fCBzbGlkZXNbcHJldkluZGV4XS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBlcmNlbnQgPSBkaXMgLyB3aWR0aDtcblxuICAgICAgICAgIGNvbnN0IHByZXYgPSBzbGlkZXNbcHJldkluZGV4XTtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gc2xpZGVzW25leHRJbmRleF07XG4gICAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuaW5kZXggIT09IG5leHRJbmRleDtcbiAgICAgICAgICBjb25zdCBlZGdlID0gcHJldkluZGV4ID09PSBuZXh0SW5kZXg7XG5cbiAgICAgICAgICBsZXQgaXRlbVNob3duO1xuXG4gICAgICAgICAgW3RoaXMuaW5kZXgsIHRoaXMucHJldkluZGV4XS5cbiAgICAgICAgICBmaWx0ZXIoKGkpID0+ICFpbmNsdWRlcyhbbmV4dEluZGV4LCBwcmV2SW5kZXhdLCBpKSkuXG4gICAgICAgICAgZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICAgICAgdHJpZ2dlcihzbGlkZXNbaV0sICdpdGVtaGlkZGVuJywgW3RoaXNdKTtcblxuICAgICAgICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgICAgICAgaXRlbVNob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gcHJldkluZGV4ICYmIHRoaXMucHJldkluZGV4ICE9PSBwcmV2SW5kZXggfHwgaXRlbVNob3duKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKHNsaWRlc1t0aGlzLmluZGV4XSwgJ2l0ZW1zaG93bicsIFt0aGlzXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkluZGV4ID0gcHJldkluZGV4O1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcblxuICAgICAgICAgICAgIWVkZ2UgJiYgdHJpZ2dlcihwcmV2LCAnYmVmb3JlaXRlbWhpZGUnLCBbdGhpc10pO1xuICAgICAgICAgICAgdHJpZ2dlcihuZXh0LCAnYmVmb3JlaXRlbXNob3cnLCBbdGhpc10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lciA9IHRoaXMuX3RyYW5zbGF0ZShNYXRoLmFicyh0aGlzLnBlcmNlbnQpLCBwcmV2LCAhZWRnZSAmJiBuZXh0KTtcblxuICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAhZWRnZSAmJiB0cmlnZ2VyKHByZXYsICdpdGVtaGlkZScsIFt0aGlzXSk7XG4gICAgICAgICAgICB0cmlnZ2VyKG5leHQsICdpdGVtc2hvdycsIFt0aGlzXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIHBvaW50ZXJNb3ZlLCB0aGlzLm1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgb2ZmKGRvY3VtZW50LCBwb2ludGVyVXAgKyBcIiBcIiArIHBvaW50ZXJDYW5jZWwgKyBcIiBpbnB1dFwiLCB0aGlzLmVuZCwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSB0aGlzLnByZXZJbmRleCkge1xuICAgICAgICAgICAgICB0aGlzLnBlcmNlbnQgPSAxIC0gdGhpcy5wZXJjZW50O1xuICAgICAgICAgICAgICB0aGlzLmRpciAqPSAtMTtcbiAgICAgICAgICAgICAgdGhpcy5fc2hvdyhmYWxzZSwgdGhpcy5pbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lciA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBkaXJDaGFuZ2UgPVxuICAgICAgICAgICAgICAoaXNSdGwgPyB0aGlzLmRpciAqIChpc1J0bCA/IDEgOiAtMSkgOiB0aGlzLmRpcikgPCAwID09PVxuICAgICAgICAgICAgICB0aGlzLnByZXZQb3MgPiB0aGlzLnBvcztcbiAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGRpckNoYW5nZSA/IHRoaXMuaW5kZXggOiB0aGlzLnByZXZJbmRleDtcblxuICAgICAgICAgICAgICBpZiAoZGlyQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJjZW50ID0gMSAtIHRoaXMucGVyY2VudDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc2hvdyhcbiAgICAgICAgICAgICAgdGhpcy5kaXIgPiAwICYmICFkaXJDaGFuZ2UgfHwgdGhpcy5kaXIgPCAwICYmIGRpckNoYW5nZSA/XG4gICAgICAgICAgICAgICduZXh0JyA6XG4gICAgICAgICAgICAgICdwcmV2aW91cycsXG4gICAgICAgICAgICAgIHRydWUpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3NzKHRoaXMubGlzdCwgeyB1c2VyU2VsZWN0OiAnJywgcG9pbnRlckV2ZW50czogJycgfSk7XG5cbiAgICAgICAgICB0aGlzLmRyYWcgPSB0aGlzLnBlcmNlbnQgPSBudWxsO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBoYXNUZXh0Tm9kZXNPbmx5KGVsKSB7XG4gICAgICByZXR1cm4gIWVsLmNoaWxkcmVuLmxlbmd0aCAmJiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgU2xpZGVyTmF2ID0ge1xuICAgICAgZGF0YToge1xuICAgICAgICBzZWxOYXY6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgbmF2KF9yZWYsICRlbCkge2xldCB7IHNlbE5hdiB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gJChzZWxOYXYsICRlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VsTmF2SXRlbShfcmVmMikge2xldCB7IGF0dHJJdGVtIH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gXCJbXCIgKyBhdHRySXRlbSArIFwiXSxbZGF0YS1cIiArIGF0dHJJdGVtICsgXCJdXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmF2SXRlbXMoXywgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuICQkKHRoaXMuc2VsTmF2SXRlbSwgJGVsKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5uYXYgJiYgdGhpcy5sZW5ndGggIT09IHRoaXMubmF2LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgaHRtbChcbiAgICAgICAgICAgIHRoaXMubmF2LFxuICAgICAgICAgICAgdGhpcy5zbGlkZXMuXG4gICAgICAgICAgICBtYXAoKF8sIGkpID0+IFwiPGxpIFwiICsgdGhpcy5hdHRySXRlbSArIFwiPVxcXCJcIiArIGkgKyBcIlxcXCI+PGEgaHJlZj48L2E+PC9saT5cIikuXG4gICAgICAgICAgICBqb2luKCcnKSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm5hdkl0ZW1zLmNvbmNhdCh0aGlzLm5hdikuZm9yRWFjaCgoZWwpID0+IGVsICYmIChlbC5oaWRkZW4gPSAhdGhpcy5tYXhJbmRleCkpO1xuXG4gICAgICAgICAgdGhpcy51cGRhdGVOYXYoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxOYXZJdGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3coZGF0YShlLmN1cnJlbnQsIHRoaXMuYXR0ckl0ZW0pKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2l0ZW1zaG93JyxcbiAgICAgICAgaGFuZGxlcjogJ3VwZGF0ZU5hdicgfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHVwZGF0ZU5hdigpIHtcbiAgICAgICAgICBjb25zdCBpID0gdGhpcy5nZXRWYWxpZEluZGV4KCk7XG4gICAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLm5hdkl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBjbWQgPSBkYXRhKGVsLCB0aGlzLmF0dHJJdGVtKTtcblxuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzQWN0aXZlLCB0b051bWJlcihjbWQpID09PSBpKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAndWstaW52aXNpYmxlJyxcbiAgICAgICAgICAgIHRoaXMuZmluaXRlICYmIChcbiAgICAgICAgICAgIGNtZCA9PT0gJ3ByZXZpb3VzJyAmJiBpID09PSAwIHx8IGNtZCA9PT0gJ25leHQnICYmIGkgPj0gdGhpcy5tYXhJbmRleCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBTbGlkZXIgPSB7XG4gICAgICBtaXhpbnM6IFtTbGlkZXJBdXRvcGxheSwgU2xpZGVyRHJhZywgU2xpZGVyTmF2LCBSZXNpemVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbHNBY3RpdmF0ZWQ6IEJvb2xlYW4sXG4gICAgICAgIGVhc2luZzogU3RyaW5nLFxuICAgICAgICBpbmRleDogTnVtYmVyLFxuICAgICAgICBmaW5pdGU6IEJvb2xlYW4sXG4gICAgICAgIHZlbG9jaXR5OiBOdW1iZXIsXG4gICAgICAgIHNlbFNsaWRlczogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YTogKCkgPT4gKHtcbiAgICAgICAgZWFzaW5nOiAnZWFzZScsXG4gICAgICAgIGZpbml0ZTogZmFsc2UsXG4gICAgICAgIHZlbG9jaXR5OiAxLFxuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgcHJldkluZGV4OiAtMSxcbiAgICAgICAgc3RhY2s6IFtdLFxuICAgICAgICBwZXJjZW50OiAwLFxuICAgICAgICBjbHNBY3RpdmU6ICd1ay1hY3RpdmUnLFxuICAgICAgICBjbHNBY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgICBUcmFuc2l0aW9uZXI6IGZhbHNlLFxuICAgICAgICB0cmFuc2l0aW9uT3B0aW9uczoge30gfSksXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnByZXZJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5nZXRWYWxpZEluZGV4KHRoaXMuJHByb3BzLmluZGV4KTtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLnNsaWRlcywgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZHVyYXRpb24oX3JlZiwgJGVsKSB7bGV0IHsgdmVsb2NpdHkgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIHNwZWVkVXAoJGVsLm9mZnNldFdpZHRoIC8gdmVsb2NpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxpc3QoX3JlZjIsICRlbCkge2xldCB7IHNlbExpc3QgfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiAkKHNlbExpc3QsICRlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4SW5kZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZWxTbGlkZXMoX3JlZjMpIHtsZXQgeyBzZWxMaXN0LCBzZWxTbGlkZXMgfSA9IF9yZWYzO1xuICAgICAgICAgIHJldHVybiBzZWxMaXN0ICsgXCIgXCIgKyAoc2VsU2xpZGVzIHx8ICc+IConKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzbGlkZXM6IHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQodGhpcy5zZWxTbGlkZXMsIHRoaXMuJGVsKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLiRyZXNldCgpO1xuICAgICAgICAgIH0gfSxcblxuXG4gICAgICAgIGxlbmd0aCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zbGlkZXMubGVuZ3RoO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzaG93KGluZGV4LCBmb3JjZSkge2lmIChmb3JjZSA9PT0gdm9pZCAwKSB7Zm9yY2UgPSBmYWxzZTt9XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgfHwgIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBzdGFjayB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCBxdWV1ZUluZGV4ID0gZm9yY2UgPyAwIDogc3RhY2subGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhY2suc3BsaWNlKHF1ZXVlSW5kZXgsIDEpO1xuXG4gICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2hvdyhzdGFjay5zaGlmdCgpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc3RhY2tbZm9yY2UgPyAndW5zaGlmdCcgOiAncHVzaCddKGluZGV4KTtcblxuICAgICAgICAgIGlmICghZm9yY2UgJiYgc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIuZm9yd2FyZChNYXRoLm1pbih0aGlzLmR1cmF0aW9uLCAyMDApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByZXZJbmRleCA9IHRoaXMuZ2V0SW5kZXgodGhpcy5pbmRleCk7XG4gICAgICAgICAgY29uc3QgcHJldiA9IGhhc0NsYXNzKHRoaXMuc2xpZGVzLCB0aGlzLmNsc0FjdGl2ZSkgJiYgdGhpcy5zbGlkZXNbcHJldkluZGV4XTtcbiAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmdldEluZGV4KGluZGV4LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5zbGlkZXNbbmV4dEluZGV4XTtcblxuICAgICAgICAgIGlmIChwcmV2ID09PSBuZXh0KSB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZGlyID0gZ2V0RGlyZWN0aW9uKGluZGV4LCBwcmV2SW5kZXgpO1xuICAgICAgICAgIHRoaXMucHJldkluZGV4ID0gcHJldkluZGV4O1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBuZXh0SW5kZXg7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgcHJldiAmJiAhdHJpZ2dlcihwcmV2LCAnYmVmb3JlaXRlbWhpZGUnLCBbdGhpc10pIHx8XG4gICAgICAgICAgIXRyaWdnZXIobmV4dCwgJ2JlZm9yZWl0ZW1zaG93JywgW3RoaXMsIHByZXZdKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5wcmV2SW5kZXg7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9zaG93KHByZXYsIG5leHQsIGZvcmNlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHByZXYgJiYgdHJpZ2dlcihwcmV2LCAnaXRlbWhpZGRlbicsIFt0aGlzXSk7XG4gICAgICAgICAgICB0cmlnZ2VyKG5leHQsICdpdGVtc2hvd24nLCBbdGhpc10pO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnNob3coc3RhY2suc2hpZnQoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHByZXYgJiYgdHJpZ2dlcihwcmV2LCAnaXRlbWhpZGUnLCBbdGhpc10pO1xuICAgICAgICAgIHRyaWdnZXIobmV4dCwgJ2l0ZW1zaG93JywgW3RoaXNdKTtcblxuICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEluZGV4KGluZGV4LCBwcmV2KSB7aWYgKGluZGV4ID09PSB2b2lkIDApIHtpbmRleCA9IHRoaXMuaW5kZXg7fWlmIChwcmV2ID09PSB2b2lkIDApIHtwcmV2ID0gdGhpcy5pbmRleDt9XG4gICAgICAgICAgcmV0dXJuIGNsYW1wKGdldEluZGV4KGluZGV4LCB0aGlzLnNsaWRlcywgcHJldiwgdGhpcy5maW5pdGUpLCAwLCB0aGlzLm1heEluZGV4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRWYWxpZEluZGV4KGluZGV4LCBwcmV2SW5kZXgpIHtpZiAoaW5kZXggPT09IHZvaWQgMCkge2luZGV4ID0gdGhpcy5pbmRleDt9aWYgKHByZXZJbmRleCA9PT0gdm9pZCAwKSB7cHJldkluZGV4ID0gdGhpcy5wcmV2SW5kZXg7fVxuICAgICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4KGluZGV4LCBwcmV2SW5kZXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG93KHByZXYsIG5leHQsIGZvcmNlKSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gdGhpcy5fZ2V0VHJhbnNpdGlvbmVyKHByZXYsIG5leHQsIHRoaXMuZGlyLCB7XG4gICAgICAgICAgICBlYXNpbmc6IGZvcmNlID9cbiAgICAgICAgICAgIG5leHQub2Zmc2V0V2lkdGggPCA2MDAgP1xuICAgICAgICAgICAgJ2N1YmljLWJlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KScgLyogZWFzZU91dFF1YWQgKi8gOlxuICAgICAgICAgICAgJ2N1YmljLWJlemllcigwLjE2NSwgMC44NCwgMC40NCwgMSknIC8qIGVhc2VPdXRRdWFydCAqLyA6XG4gICAgICAgICAgICB0aGlzLmVhc2luZyxcbiAgICAgICAgICAgIC4uLnRoaXMudHJhbnNpdGlvbk9wdGlvbnMgfSk7XG5cblxuICAgICAgICAgIGlmICghZm9yY2UgJiYgIXByZXYpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gdGhpcy5zdGFjaztcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbmVyW2xlbmd0aCA+IDEgPyAnZm9yd2FyZCcgOiAnc2hvdyddKFxuICAgICAgICAgIGxlbmd0aCA+IDEgPyBNYXRoLm1pbih0aGlzLmR1cmF0aW9uLCA3NSArIDc1IC8gKGxlbmd0aCAtIDEpKSA6IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGhpcy5wZXJjZW50KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXREaXN0YW5jZShwcmV2LCBuZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zaXRpb25lcihwcmV2LCBwcmV2ICE9PSBuZXh0ICYmIG5leHQpLmdldERpc3RhbmNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3RyYW5zbGF0ZShwZXJjZW50LCBwcmV2LCBuZXh0KSB7aWYgKHByZXYgPT09IHZvaWQgMCkge3ByZXYgPSB0aGlzLnByZXZJbmRleDt9aWYgKG5leHQgPT09IHZvaWQgMCkge25leHQgPSB0aGlzLmluZGV4O31cbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uZXIgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIocHJldiAhPT0gbmV4dCA/IHByZXYgOiBmYWxzZSwgbmV4dCk7XG4gICAgICAgICAgdHJhbnNpdGlvbmVyLnRyYW5zbGF0ZShwZXJjZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRUcmFuc2l0aW9uZXIoXG4gICAgICAgIHByZXYsXG4gICAgICAgIG5leHQsXG4gICAgICAgIGRpcixcbiAgICAgICAgb3B0aW9ucylcbiAgICAgICAge2lmIChwcmV2ID09PSB2b2lkIDApIHtwcmV2ID0gdGhpcy5wcmV2SW5kZXg7fWlmIChuZXh0ID09PSB2b2lkIDApIHtuZXh0ID0gdGhpcy5pbmRleDt9aWYgKGRpciA9PT0gdm9pZCAwKSB7ZGlyID0gdGhpcy5kaXIgfHwgMTt9aWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge29wdGlvbnMgPSB0aGlzLnRyYW5zaXRpb25PcHRpb25zO31cbiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuVHJhbnNpdGlvbmVyKFxuICAgICAgICAgIGlzTnVtYmVyKHByZXYpID8gdGhpcy5zbGlkZXNbcHJldl0gOiBwcmV2LFxuICAgICAgICAgIGlzTnVtYmVyKG5leHQpID8gdGhpcy5zbGlkZXNbbmV4dF0gOiBuZXh0LFxuICAgICAgICAgIGRpciAqIChpc1J0bCA/IC0xIDogMSksXG4gICAgICAgICAgb3B0aW9ucyk7XG5cbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKGluZGV4LCBwcmV2SW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gJ25leHQnID8gMSA6IGluZGV4ID09PSAncHJldmlvdXMnID8gLTEgOiBpbmRleCA8IHByZXZJbmRleCA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGVlZFVwKHgpIHtcbiAgICAgIHJldHVybiAwLjUgKiB4ICsgMzAwOyAvLyBwYXJhYm9sYSB0aHJvdWdoICg0MDAsNTAwOyA2MDAsNjAwOyAxODAwLDEyMDApXG4gICAgfVxuXG4gICAgdmFyIFNsaWRlc2hvdyA9IHtcbiAgICAgIG1peGluczogW1NsaWRlcl0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGFuaW1hdGlvbjogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBhbmltYXRpb246ICdzbGlkZScsXG4gICAgICAgIGNsc0FjdGl2YXRlZDogJ3VrLXRyYW5zaXRpb24tYWN0aXZlJyxcbiAgICAgICAgQW5pbWF0aW9uczogQW5pbWF0aW9ucyQyLFxuICAgICAgICBUcmFuc2l0aW9uZXI6IFRyYW5zaXRpb25lciQxIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYW5pbWF0aW9uKF9yZWYpIHtsZXQgeyBhbmltYXRpb24sIEFuaW1hdGlvbnMgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIHsgLi4uKEFuaW1hdGlvbnNbYW5pbWF0aW9uXSB8fCBBbmltYXRpb25zLnNsaWRlKSwgbmFtZTogYW5pbWF0aW9uIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgYW5pbWF0aW9uOiB0aGlzLmFuaW1hdGlvbiB9O1xuICAgICAgICB9IH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGJlZm9yZWl0ZW1zaG93KF9yZWYyKSB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmMjtcbiAgICAgICAgICBhZGRDbGFzcyh0YXJnZXQsIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtc2hvd24oX3JlZjMpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWYzO1xuICAgICAgICAgIGFkZENsYXNzKHRhcmdldCwgdGhpcy5jbHNBY3RpdmF0ZWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGl0ZW1oaWRkZW4oX3JlZjQpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY0O1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRhcmdldCwgdGhpcy5jbHNBY3RpdmUsIHRoaXMuY2xzQWN0aXZhdGVkKTtcbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgTGlnaHRib3hQYW5lbCA9IHtcbiAgICAgIG1peGluczogW0NvbnRhaW5lciwgTW9kYWwsIFRvZ2dsYWJsZSwgU2xpZGVzaG93XSxcblxuICAgICAgZnVuY3Rpb25hbDogdHJ1ZSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZGVsYXlDb250cm9sczogTnVtYmVyLFxuICAgICAgICBwcmVsb2FkOiBOdW1iZXIsXG4gICAgICAgIHZpZGVvQXV0b3BsYXk6IEJvb2xlYW4sXG4gICAgICAgIHRlbXBsYXRlOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiAoKSA9PiAoe1xuICAgICAgICBwcmVsb2FkOiAxLFxuICAgICAgICB2aWRlb0F1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgZGVsYXlDb250cm9sczogMzAwMCxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBjbHM6ICd1ay1vcGVuJyxcbiAgICAgICAgY2xzUGFnZTogJ3VrLWxpZ2h0Ym94LXBhZ2UnLFxuICAgICAgICBzZWxMaXN0OiAnLnVrLWxpZ2h0Ym94LWl0ZW1zJyxcbiAgICAgICAgYXR0ckl0ZW06ICd1ay1saWdodGJveC1pdGVtJyxcbiAgICAgICAgc2VsQ2xvc2U6ICcudWstY2xvc2UtbGFyZ2UnLFxuICAgICAgICBzZWxDYXB0aW9uOiAnLnVrLWxpZ2h0Ym94LWNhcHRpb24nLFxuICAgICAgICBwYXVzZU9uSG92ZXI6IGZhbHNlLFxuICAgICAgICB2ZWxvY2l0eTogMixcbiAgICAgICAgQW5pbWF0aW9uczogQW5pbWF0aW9ucyQxLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJ1ay1saWdodGJveCB1ay1vdmVyZmxvdy1oaWRkZW5cXFwiPiA8dWwgY2xhc3M9XFxcInVrLWxpZ2h0Ym94LWl0ZW1zXFxcIj48L3VsPiA8ZGl2IGNsYXNzPVxcXCJ1ay1saWdodGJveC10b29sYmFyIHVrLXBvc2l0aW9uLXRvcCB1ay10ZXh0LXJpZ2h0IHVrLXRyYW5zaXRpb24tc2xpZGUtdG9wIHVrLXRyYW5zaXRpb24tb3BhcXVlXFxcIj4gPGJ1dHRvbiBjbGFzcz1cXFwidWstbGlnaHRib3gtdG9vbGJhci1pY29uIHVrLWNsb3NlLWxhcmdlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIHVrLWNsb3NlPjwvYnV0dG9uPiA8L2Rpdj4gPGEgY2xhc3M9XFxcInVrLWxpZ2h0Ym94LWJ1dHRvbiB1ay1wb3NpdGlvbi1jZW50ZXItbGVmdCB1ay1wb3NpdGlvbi1tZWRpdW0gdWstdHJhbnNpdGlvbi1mYWRlXFxcIiBocmVmIHVrLXNsaWRlbmF2LXByZXZpb3VzIHVrLWxpZ2h0Ym94LWl0ZW09XFxcInByZXZpb3VzXFxcIj48L2E+IDxhIGNsYXNzPVxcXCJ1ay1saWdodGJveC1idXR0b24gdWstcG9zaXRpb24tY2VudGVyLXJpZ2h0IHVrLXBvc2l0aW9uLW1lZGl1bSB1ay10cmFuc2l0aW9uLWZhZGVcXFwiIGhyZWYgdWstc2xpZGVuYXYtbmV4dCB1ay1saWdodGJveC1pdGVtPVxcXCJuZXh0XFxcIj48L2E+IDxkaXYgY2xhc3M9XFxcInVrLWxpZ2h0Ym94LXRvb2xiYXIgdWstbGlnaHRib3gtY2FwdGlvbiB1ay1wb3NpdGlvbi1ib3R0b20gdWstdGV4dC1jZW50ZXIgdWstdHJhbnNpdGlvbi1zbGlkZS1ib3R0b20gdWstdHJhbnNpdGlvbi1vcGFxdWVcXFwiPjwvZGl2PiA8L2Rpdj5cIiB9KSxcblxuXG5cblxuXG5cblxuXG5cblxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgY29uc3QgJGVsID0gJCh0aGlzLnRlbXBsYXRlKTtcbiAgICAgICAgY29uc3QgbGlzdCA9ICQodGhpcy5zZWxMaXN0LCAkZWwpO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKCkgPT4gYXBwZW5kKGxpc3QsICc8bGk+JykpO1xuXG4gICAgICAgIHRoaXMuJG1vdW50KGFwcGVuZCh0aGlzLmNvbnRhaW5lciwgJGVsKSk7XG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBjYXB0aW9uKF9yZWYsICRlbCkge2xldCB7IHNlbENhcHRpb24gfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICQoc2VsQ2FwdGlvbiwgJGVsKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyTW92ZSArIFwiIFwiICsgcG9pbnRlckRvd24gKyBcIiBrZXlkb3duXCIsXG5cbiAgICAgICAgaGFuZGxlcjogJ3Nob3dDb250cm9scycgfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxTbGlkZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvd24nLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLnNob3dDb250cm9scygpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuaGlkZUNvbnRyb2xzKCk7XG5cbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLnNsaWRlcywgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICAgIFRyYW5zaXRpb24uc3RvcCh0aGlzLnNsaWRlcyk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRkZW4nLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLiRkZXN0cm95KHRydWUpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAna2V5dXAnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNUb2dnbGVkKHRoaXMuJGVsKSB8fCAhdGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgdGhpcy5zaG93KCdwcmV2aW91cycpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgIHRoaXMuc2hvdygnbmV4dCcpO1xuICAgICAgICAgICAgICBicmVhazt9XG5cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2JlZm9yZWl0ZW1zaG93JyxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIHRydWUsIGZhbHNlKTtcblxuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gQW5pbWF0aW9ucyQxWydzY2FsZSddO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGUudGFyZ2V0LCB0aGlzLmNsc0FjdGl2ZSk7XG4gICAgICAgICAgdGhpcy5zdGFjay5zcGxpY2UoMSwgMCwgdGhpcy5pbmRleCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpdGVtc2hvdycsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBodG1sKHRoaXMuY2FwdGlvbiwgdGhpcy5nZXRJdGVtKCkuY2FwdGlvbiB8fCAnJyk7XG5cbiAgICAgICAgICBmb3IgKGxldCBqID0gLXRoaXMucHJlbG9hZDsgaiA8PSB0aGlzLnByZWxvYWQ7IGorKykge1xuICAgICAgICAgICAgdGhpcy5sb2FkSXRlbSh0aGlzLmluZGV4ICsgaik7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaXRlbXNob3duJyxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gdGhpcy4kcHJvcHMuZHJhZ2dhYmxlO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaXRlbWxvYWQnLFxuXG4gICAgICAgIGFzeW5jIGhhbmRsZXIoXywgaXRlbSkge1xuICAgICAgICAgIGNvbnN0IHsgc291cmNlOiBzcmMsIHR5cGUsIGFsdCA9ICcnLCBwb3N0ZXIsIGF0dHJzID0ge30gfSA9IGl0ZW07XG5cbiAgICAgICAgICB0aGlzLnNldEl0ZW0oaXRlbSwgJzxzcGFuIHVrLXNwaW5uZXI+PC9zcGFuPicpO1xuXG4gICAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgbWF0Y2hlcztcbiAgICAgICAgICBjb25zdCBpZnJhbWVBdHRycyA9IHtcbiAgICAgICAgICAgIGZyYW1lYm9yZGVyOiAnMCcsXG4gICAgICAgICAgICBhbGxvdzogJ2F1dG9wbGF5JyxcbiAgICAgICAgICAgIGFsbG93ZnVsbHNjcmVlbjogJycsXG4gICAgICAgICAgICBzdHlsZTogJ21heC13aWR0aDogMTAwJTsgYm94LXNpemluZzogYm9yZGVyLWJveDsnLFxuICAgICAgICAgICAgJ3VrLXJlc3BvbnNpdmUnOiAnJyxcbiAgICAgICAgICAgICd1ay12aWRlbyc6IFwiXCIgKyB0aGlzLnZpZGVvQXV0b3BsYXkgfTtcblxuXG4gICAgICAgICAgLy8gSW1hZ2VcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZSA9PT0gJ2ltYWdlJyB8fFxuICAgICAgICAgIHNyYy5tYXRjaCgvXFwuKGF2aWZ8anBlP2d8amZpZnxhP3BuZ3xnaWZ8c3ZnfHdlYnApKCR8XFw/KS9pKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGF3YWl0IGdldEltYWdlKHNyYywgYXR0cnMuc3Jjc2V0LCBhdHRycy5zaXplKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtKGl0ZW0sIGNyZWF0ZUVsKCdpbWcnLCB7IHNyYywgd2lkdGgsIGhlaWdodCwgYWx0LCAuLi5hdHRycyB9KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3IoaXRlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZpZGVvXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndmlkZW8nIHx8IHNyYy5tYXRjaCgvXFwuKG1wNHx3ZWJtfG9ndikoJHxcXD8pL2kpKSB7XG4gICAgICAgICAgICBjb25zdCB2aWRlbyA9IGNyZWF0ZUVsKCd2aWRlbycsIHtcbiAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICBwb3N0ZXIsXG4gICAgICAgICAgICAgIGNvbnRyb2xzOiAnJyxcbiAgICAgICAgICAgICAgcGxheXNpbmxpbmU6ICcnLFxuICAgICAgICAgICAgICAndWstdmlkZW8nOiBcIlwiICsgdGhpcy52aWRlb0F1dG9wbGF5LFxuICAgICAgICAgICAgICAuLi5hdHRycyB9KTtcblxuXG4gICAgICAgICAgICBvbih2aWRlbywgJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgICBhdHRyKHZpZGVvLCB7IHdpZHRoOiB2aWRlby52aWRlb1dpZHRoLCBoZWlnaHQ6IHZpZGVvLnZpZGVvSGVpZ2h0IH0pO1xuICAgICAgICAgICAgICB0aGlzLnNldEl0ZW0oaXRlbSwgdmlkZW8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvbih2aWRlbywgJ2Vycm9yJywgKCkgPT4gdGhpcy5zZXRFcnJvcihpdGVtKSk7XG5cbiAgICAgICAgICAgIC8vIElmcmFtZVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2lmcmFtZScgfHwgc3JjLm1hdGNoKC9cXC4oaHRtbHxwaHApKCR8XFw/KS9pKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRJdGVtKFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGNyZWF0ZUVsKCdpZnJhbWUnLCB7XG4gICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgZnJhbWVib3JkZXI6ICcwJyxcbiAgICAgICAgICAgICAgYWxsb3dmdWxsc2NyZWVuOiAnJyxcbiAgICAgICAgICAgICAgY2xhc3M6ICd1ay1saWdodGJveC1pZnJhbWUnLFxuICAgICAgICAgICAgICAuLi5hdHRycyB9KSk7XG5cblxuXG4gICAgICAgICAgICAvLyBZb3VUdWJlXG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBtYXRjaGVzID0gc3JjLm1hdGNoKFxuICAgICAgICAgIC9cXC9cXC8oPzouKj95b3V0dWJlKC1ub2Nvb2tpZSk/XFwuLio/Wz8mXXY9fHlvdXR1XFwuYmVcXC8pKFtcXHctXXsxMX0pWyY/XT8oLiopPy8pKVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRJdGVtKFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGNyZWF0ZUVsKCdpZnJhbWUnLCB7XG4gICAgICAgICAgICAgIHNyYzogXCJodHRwczovL3d3dy55b3V0dWJlXCIgKyAobWF0Y2hlc1sxXSB8fCAnJykgKyBcIi5jb20vZW1iZWQvXCIgKyBtYXRjaGVzWzJdICsgKFxuICAgICAgICAgICAgICBtYXRjaGVzWzNdID8gXCI/XCIgKyBtYXRjaGVzWzNdIDogJycpLFxuXG4gICAgICAgICAgICAgIHdpZHRoOiAxOTIwLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDEwODAsXG4gICAgICAgICAgICAgIC4uLmlmcmFtZUF0dHJzLFxuICAgICAgICAgICAgICAuLi5hdHRycyB9KSk7XG5cblxuXG4gICAgICAgICAgICAvLyBWaW1lb1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlcyA9IHNyYy5tYXRjaCgvXFwvXFwvLio/dmltZW9cXC5bYS16XStcXC8oXFxkKylbJj9dPyguKik/LykpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gYXdhaXQgKFxuICAgICAgICAgICAgICBhd2FpdCBmZXRjaChcImh0dHBzOi8vdmltZW8uY29tL2FwaS9vZW1iZWQuanNvbj9tYXh3aWR0aD0xOTIwJnVybD1cIiArXG4gICAgICAgICAgICAgIGVuY29kZVVSSShcbiAgICAgICAgICAgICAgc3JjKSxcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdvbWl0JyB9KSkuXG5cblxuICAgICAgICAgICAgICBqc29uKCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtKFxuICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICBjcmVhdGVFbCgnaWZyYW1lJywge1xuICAgICAgICAgICAgICAgIHNyYzogXCJodHRwczovL3BsYXllci52aW1lby5jb20vdmlkZW8vXCIgKyBtYXRjaGVzWzFdICsgKFxuICAgICAgICAgICAgICAgIG1hdGNoZXNbMl0gPyBcIj9cIiArIG1hdGNoZXNbMl0gOiAnJyksXG5cbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgLi4uaWZyYW1lQXR0cnMsXG4gICAgICAgICAgICAgICAgLi4uYXR0cnMgfSkpO1xuXG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRFcnJvcihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGxvYWRJdGVtKGluZGV4KSB7aWYgKGluZGV4ID09PSB2b2lkIDApIHtpbmRleCA9IHRoaXMuaW5kZXg7fVxuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldEl0ZW0oaW5kZXgpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmdldFNsaWRlKGl0ZW0pLmNoaWxkRWxlbWVudENvdW50KSB7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnaXRlbWxvYWQnLCBbaXRlbV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRJdGVtKGluZGV4KSB7aWYgKGluZGV4ID09PSB2b2lkIDApIHtpbmRleCA9IHRoaXMuaW5kZXg7fVxuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zW2dldEluZGV4KGluZGV4LCB0aGlzLnNsaWRlcyldO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEl0ZW0oaXRlbSwgY29udGVudCkge1xuICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdpdGVtbG9hZGVkJywgW3RoaXMsIGh0bWwodGhpcy5nZXRTbGlkZShpdGVtKSwgY29udGVudCldKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTbGlkZShpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVzW3RoaXMuaXRlbXMuaW5kZXhPZihpdGVtKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RXJyb3IoaXRlbSkge1xuICAgICAgICAgIHRoaXMuc2V0SXRlbShpdGVtLCAnPHNwYW4gdWstaWNvbj1cImljb246IGJvbHQ7IHJhdGlvOiAyXCI+PC9zcGFuPicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3dDb250cm9scygpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb250cm9sc1RpbWVyKTtcbiAgICAgICAgICB0aGlzLmNvbnRyb2xzVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuaGlkZUNvbnRyb2xzLCB0aGlzLmRlbGF5Q29udHJvbHMpO1xuXG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsICd1ay1hY3RpdmUnLCAndWstdHJhbnNpdGlvbi1hY3RpdmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlQ29udHJvbHMoKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsICd1ay1hY3RpdmUnLCAndWstdHJhbnNpdGlvbi1hY3RpdmUnKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRWwodGFnLCBhdHRycykge1xuICAgICAgY29uc3QgZWwgPSBmcmFnbWVudChcIjxcIiArIHRhZyArIFwiPlwiKTtcbiAgICAgIGF0dHIoZWwsIGF0dHJzKTtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICB2YXIgbGlnaHRib3ggPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsJDEsXG5cbiAgICAgIHByb3BzOiB7IHRvZ2dsZTogU3RyaW5nIH0sXG5cbiAgICAgIGRhdGE6IHsgdG9nZ2xlOiAnYScgfSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdG9nZ2xlczoge1xuICAgICAgICAgIGdldChfcmVmLCAkZWwpIHtsZXQgeyB0b2dnbGUgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gJCQodG9nZ2xlLCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH0gfSB9LFxuXG5cblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZSArIFwiOm5vdCgudWstZGlzYWJsZWQpXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvdyhlLmN1cnJlbnQpO1xuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzaG93KGluZGV4KSB7XG4gICAgICAgICAgY29uc3QgaXRlbXMgPSB1bmlxdWVCeSh0aGlzLnRvZ2dsZXMubWFwKHRvSXRlbSksICdzb3VyY2UnKTtcblxuICAgICAgICAgIGlmIChpc0VsZW1lbnQoaW5kZXgpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNvdXJjZSB9ID0gdG9JdGVtKGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gZmluZEluZGV4KGl0ZW1zLCAoX3JlZjIpID0+IHtsZXQgeyBzb3VyY2U6IHNyYyB9ID0gX3JlZjI7cmV0dXJuIHNvdXJjZSA9PT0gc3JjO30pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucGFuZWwgPSB0aGlzLnBhbmVsIHx8IHRoaXMuJGNyZWF0ZSgnbGlnaHRib3hQYW5lbCcsIHsgLi4udGhpcy4kcHJvcHMsIGl0ZW1zIH0pO1xuXG4gICAgICAgICAgb24odGhpcy5wYW5lbC4kZWwsICdoaWRkZW4nLCAoKSA9PiB0aGlzLnBhbmVsID0gZmFsc2UpO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFuZWwuc2hvdyhpbmRleCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZSgpIHt2YXIgX3RoaXMkcGFuZWw7XG4gICAgICAgICAgcmV0dXJuIChfdGhpcyRwYW5lbCA9IHRoaXMucGFuZWwpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwYW5lbC5oaWRlKCk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwkMShVSWtpdCwgTGlnaHRib3gpIHtcbiAgICAgIGlmICghVUlraXQubGlnaHRib3hQYW5lbCkge1xuICAgICAgICBVSWtpdC5jb21wb25lbnQoJ2xpZ2h0Ym94UGFuZWwnLCBMaWdodGJveFBhbmVsKTtcbiAgICAgIH1cblxuICAgICAgYXNzaWduKExpZ2h0Ym94LnByb3BzLCBVSWtpdC5jb21wb25lbnQoJ2xpZ2h0Ym94UGFuZWwnKS5vcHRpb25zLnByb3BzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0l0ZW0oZWwpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB7fTtcblxuICAgICAgZm9yIChjb25zdCBhdHRyIG9mIFsnaHJlZicsICdjYXB0aW9uJywgJ3R5cGUnLCAncG9zdGVyJywgJ2FsdCcsICdhdHRycyddKSB7XG4gICAgICAgIGl0ZW1bYXR0ciA9PT0gJ2hyZWYnID8gJ3NvdXJjZScgOiBhdHRyXSA9IGRhdGEoZWwsIGF0dHIpO1xuICAgICAgfVxuXG4gICAgICBpdGVtLmF0dHJzID0gcGFyc2VPcHRpb25zKGl0ZW0uYXR0cnMpO1xuXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICB2YXIgbm90aWZpY2F0aW9uID0ge1xuICAgICAgbWl4aW5zOiBbQ29udGFpbmVyXSxcblxuICAgICAgZnVuY3Rpb25hbDogdHJ1ZSxcblxuICAgICAgYXJnczogWydtZXNzYWdlJywgJ3N0YXR1cyddLFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1lc3NhZ2U6ICcnLFxuICAgICAgICBzdGF0dXM6ICcnLFxuICAgICAgICB0aW1lb3V0OiA1MDAwLFxuICAgICAgICBncm91cDogbnVsbCxcbiAgICAgICAgcG9zOiAndG9wLWNlbnRlcicsXG4gICAgICAgIGNsc0NvbnRhaW5lcjogJ3VrLW5vdGlmaWNhdGlvbicsXG4gICAgICAgIGNsc0Nsb3NlOiAndWstbm90aWZpY2F0aW9uLWNsb3NlJyxcbiAgICAgICAgY2xzTXNnOiAndWstbm90aWZpY2F0aW9uLW1lc3NhZ2UnIH0sXG5cblxuICAgICAgaW5zdGFsbCxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgbWFyZ2luUHJvcChfcmVmKSB7bGV0IHsgcG9zIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBcIm1hcmdpblwiICsgKHN0YXJ0c1dpdGgocG9zLCAndG9wJykgPyAnVG9wJyA6ICdCb3R0b20nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydFByb3BzKCkge1xuICAgICAgICAgIHJldHVybiB7IG9wYWNpdHk6IDAsIFt0aGlzLm1hcmdpblByb3BdOiAtdGhpcy4kZWwub2Zmc2V0SGVpZ2h0IH07XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPVxuICAgICAgICAkKFwiLlwiICsgdGhpcy5jbHNDb250YWluZXIgKyBcIi1cIiArIHRoaXMucG9zLCB0aGlzLmNvbnRhaW5lcikgfHxcbiAgICAgICAgYXBwZW5kKFxuICAgICAgICB0aGlzLmNvbnRhaW5lciwgXCI8ZGl2IGNsYXNzPVxcXCJcIiArXG4gICAgICAgIHRoaXMuY2xzQ29udGFpbmVyICsgXCIgXCIgKyB0aGlzLmNsc0NvbnRhaW5lciArIFwiLVwiICsgdGhpcy5wb3MgKyBcIlxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IGJsb2NrXFxcIj48L2Rpdj5cIik7XG5cblxuICAgICAgICB0aGlzLiRtb3VudChcbiAgICAgICAgYXBwZW5kKFxuICAgICAgICBjb250YWluZXIsIFwiPGRpdiBjbGFzcz1cXFwiXCIgK1xuICAgICAgICB0aGlzLmNsc01zZyArICh0aGlzLnN0YXR1cyA/IFwiIFwiICsgdGhpcy5jbHNNc2cgKyBcIi1cIiArIHRoaXMuc3RhdHVzIDogJycpICsgXCJcXFwiPiA8YSBocmVmIGNsYXNzPVxcXCJcIiArXG4gICAgICAgIHRoaXMuY2xzQ2xvc2UgKyBcIlxcXCIgZGF0YS11ay1jbG9zZT48L2E+IDxkaXY+XCIgK1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKyBcIjwvZGl2PiA8L2Rpdj5cIikpO1xuXG5cblxuICAgICAgfSxcblxuICAgICAgYXN5bmMgY29ubmVjdGVkKCkge1xuICAgICAgICBjb25zdCBtYXJnaW4gPSB0b0Zsb2F0KGNzcyh0aGlzLiRlbCwgdGhpcy5tYXJnaW5Qcm9wKSk7XG4gICAgICAgIGF3YWl0IFRyYW5zaXRpb24uc3RhcnQoY3NzKHRoaXMuJGVsLCB0aGlzLnN0YXJ0UHJvcHMpLCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBbdGhpcy5tYXJnaW5Qcm9wXTogbWFyZ2luIH0pO1xuXG5cbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuY2xvc2UsIHRoaXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBjbGljayhlKSB7XG4gICAgICAgICAgaWYgKGNsb3Nlc3QoZS50YXJnZXQsICdhW2hyZWY9XCIjXCJdLGFbaHJlZj1cIlwiXScpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBbcG9pbnRlckVudGVyXSgpIHtcbiAgICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBbcG9pbnRlckxlYXZlXSgpIHtcbiAgICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCh0aGlzLmNsb3NlLCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgY2xvc2UoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgY29uc3QgcmVtb3ZlRm4gPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudChlbCk7XG5cbiAgICAgICAgICAgIHRyaWdnZXIoZWwsICdjbG9zZScsIFt0aGlzXSk7XG4gICAgICAgICAgICByZW1vdmUkMShlbCk7XG5cbiAgICAgICAgICAgIGlmICghKGNvbnRhaW5lciAhPSBudWxsICYmIGNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpKSB7XG4gICAgICAgICAgICAgIHJlbW92ZSQxKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIGF3YWl0IFRyYW5zaXRpb24uc3RhcnQodGhpcy4kZWwsIHRoaXMuc3RhcnRQcm9wcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVtb3ZlRm4odGhpcy4kZWwpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKFVJa2l0KSB7XG4gICAgICBVSWtpdC5ub3RpZmljYXRpb24uY2xvc2VBbGwgPSBmdW5jdGlvbiAoZ3JvdXAsIGltbWVkaWF0ZSkge1xuICAgICAgICBhcHBseShkb2N1bWVudC5ib2R5LCAoZWwpID0+IHtcbiAgICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBVSWtpdC5nZXRDb21wb25lbnQoZWwsICdub3RpZmljYXRpb24nKTtcbiAgICAgICAgICBpZiAobm90aWZpY2F0aW9uICYmICghZ3JvdXAgfHwgZ3JvdXAgPT09IG5vdGlmaWNhdGlvbi5ncm91cCkpIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5jbG9zZShpbW1lZGlhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgeDogdHJhbnNmb3JtRm4sXG4gICAgICB5OiB0cmFuc2Zvcm1GbixcbiAgICAgIHJvdGF0ZTogdHJhbnNmb3JtRm4sXG4gICAgICBzY2FsZTogdHJhbnNmb3JtRm4sXG4gICAgICBjb2xvcjogY29sb3JGbixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JGbixcbiAgICAgIGJvcmRlckNvbG9yOiBjb2xvckZuLFxuICAgICAgYmx1cjogZmlsdGVyRm4sXG4gICAgICBodWU6IGZpbHRlckZuLFxuICAgICAgZm9wYWNpdHk6IGZpbHRlckZuLFxuICAgICAgZ3JheXNjYWxlOiBmaWx0ZXJGbixcbiAgICAgIGludmVydDogZmlsdGVyRm4sXG4gICAgICBzYXR1cmF0ZTogZmlsdGVyRm4sXG4gICAgICBzZXBpYTogZmlsdGVyRm4sXG4gICAgICBvcGFjaXR5OiBjc3NQcm9wRm4sXG4gICAgICBzdHJva2U6IHN0cm9rZUZuLFxuICAgICAgYmd4OiBiYWNrZ3JvdW5kRm4sXG4gICAgICBiZ3k6IGJhY2tncm91bmRGbiB9O1xuXG5cbiAgICBjb25zdCB7IGtleXMgfSA9IE9iamVjdDtcblxuICAgIHZhciBQYXJhbGxheCA9IHtcbiAgICAgIG1peGluczogW01lZGlhXSxcblxuICAgICAgcHJvcHM6IGZpbGxPYmplY3Qoa2V5cyhwcm9wcyksICdsaXN0JyksXG5cbiAgICAgIGRhdGE6IGZpbGxPYmplY3Qoa2V5cyhwcm9wcyksIHVuZGVmaW5lZCksXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHByb3BzKHByb3BlcnRpZXMsICRlbCkge1xuICAgICAgICAgIHJldHVybiBrZXlzKHByb3BzKS5yZWR1Y2UoKHJlc3VsdCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChwcm9wZXJ0aWVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBwcm9wc1twcm9wXShwcm9wLCAkZWwsIHByb3BlcnRpZXNbcHJvcF0uc2xpY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBsb2FkKCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgZWFjaCh0aGlzLmdldENzcygwKSwgKF8sIHByb3ApID0+IGNzcyh0aGlzLiRlbCwgcHJvcCwgJycpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDc3MocGVyY2VudCkge1xuICAgICAgICAgIGNvbnN0IGNzcyA9IHsgdHJhbnNmb3JtOiAnJywgZmlsdGVyOiAnJyB9O1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB0aGlzLnByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzW3Byb3BdKGNzcywgcGVyY2VudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjc3M7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgY29uc3QgdW5pdCA9IGdldFVuaXQoc3RvcHMpIHx8IHsgeDogJ3B4JywgeTogJ3B4Jywgcm90YXRlOiAnZGVnJyB9W3Byb3BdIHx8ICcnO1xuICAgICAgbGV0IHRyYW5zZm9ybUZuO1xuXG4gICAgICBpZiAocHJvcCA9PT0gJ3gnIHx8IHByb3AgPT09ICd5Jykge1xuICAgICAgICBwcm9wID0gXCJ0cmFuc2xhdGVcIiArIHVjZmlyc3QocHJvcCk7XG4gICAgICAgIHRyYW5zZm9ybUZuID0gKHN0b3ApID0+IHRvRmxvYXQodG9GbG9hdChzdG9wKS50b0ZpeGVkKHVuaXQgPT09ICdweCcgPyAwIDogNikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQocHJvcCA9PT0gJ3NjYWxlJyA/IDEgOiAwKTtcbiAgICAgIH1cblxuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzLCB0cmFuc2Zvcm1Gbik7XG5cbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNzcy50cmFuc2Zvcm0gKz0gXCIgXCIgKyBwcm9wICsgXCIoXCIgKyBnZXRWYWx1ZShzdG9wcywgcGVyY2VudCkgKyB1bml0ICsgXCIpXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbG9yRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoZ2V0Q3NzVmFsdWUoZWwsIHByb3AsICcnKSk7XG4gICAgICB9XG5cbiAgICAgIHN0b3BzID0gcGFyc2VTdG9wcyhzdG9wcywgKHN0b3ApID0+IHBhcnNlQ29sb3IoZWwsIHN0b3ApKTtcblxuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmQsIHBdID0gZ2V0U3RvcChzdG9wcywgcGVyY2VudCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3RhcnQuXG4gICAgICAgIG1hcCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICB2YWx1ZSArPSBwICogKGVuZFtpXSAtIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gaSA9PT0gMyA/IHRvRmxvYXQodmFsdWUpIDogcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgfSkuXG4gICAgICAgIGpvaW4oJywnKTtcbiAgICAgICAgY3NzW3Byb3BdID0gXCJyZ2JhKFwiICsgdmFsdWUgKyBcIilcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb2xvcihlbCwgY29sb3IpIHtcbiAgICAgIHJldHVybiBnZXRDc3NWYWx1ZShlbCwgJ2NvbG9yJywgY29sb3IpLlxuICAgICAgc3BsaXQoL1soKSxdL2cpLlxuICAgICAgc2xpY2UoMSwgLTEpLlxuICAgICAgY29uY2F0KDEpLlxuICAgICAgc2xpY2UoMCwgNCkuXG4gICAgICBtYXAodG9GbG9hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVuaXQgPSBnZXRVbml0KHN0b3BzKSB8fCB7IGJsdXI6ICdweCcsIGh1ZTogJ2RlZycgfVtwcm9wXSB8fCAnJSc7XG4gICAgICBwcm9wID0geyBmb3BhY2l0eTogJ29wYWNpdHknLCBodWU6ICdodWUtcm90YXRlJyB9W3Byb3BdIHx8IHByb3A7XG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMpO1xuXG4gICAgICByZXR1cm4gKGNzcywgcGVyY2VudCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgICAgY3NzLmZpbHRlciArPSBcIiBcIiArIHByb3AgKyBcIihcIiArICh2YWx1ZSArIHVuaXQpICsgXCIpXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNzc1Byb3BGbihwcm9wLCBlbCwgc3RvcHMpIHtcbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdChnZXRDc3NWYWx1ZShlbCwgcHJvcCwgJycpKTtcbiAgICAgIH1cblxuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzKTtcblxuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY3NzW3Byb3BdID0gZ2V0VmFsdWUoc3RvcHMsIHBlcmNlbnQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJva2VGbihwcm9wLCBlbCwgc3RvcHMpIHtcbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdCgwKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdW5pdCA9IGdldFVuaXQoc3RvcHMpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TWF4UGF0aExlbmd0aChlbCk7XG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMucmV2ZXJzZSgpLCAoc3RvcCkgPT4ge1xuICAgICAgICBzdG9wID0gdG9GbG9hdChzdG9wKTtcbiAgICAgICAgcmV0dXJuIHVuaXQgPT09ICclJyA/IHN0b3AgKiBsZW5ndGggLyAxMDAgOiBzdG9wO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghc3RvcHMuc29tZSgoX3JlZikgPT4ge2xldCBbdmFsdWVdID0gX3JlZjtyZXR1cm4gdmFsdWU7fSkpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICB9XG5cbiAgICAgIGNzcyhlbCwgJ3N0cm9rZURhc2hhcnJheScsIGxlbmd0aCk7XG5cbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNzcy5zdHJva2VEYXNob2Zmc2V0ID0gZ2V0VmFsdWUoc3RvcHMsIHBlcmNlbnQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiYWNrZ3JvdW5kRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoMCk7XG4gICAgICB9XG5cbiAgICAgIHByb3AgPSBwcm9wLnN1YnN0cigtMSk7XG4gICAgICBjb25zdCBhdHRyID0gcHJvcCA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzLCAoc3RvcCkgPT4gdG9QeChzdG9wLCBhdHRyLCBlbCkpO1xuXG4gICAgICBjb25zdCBiZ1BvcyA9IGdldENzc1ZhbHVlKGVsLCBcImJhY2tncm91bmQtcG9zaXRpb24tXCIgKyBwcm9wLCAnJyk7XG5cbiAgICAgIHJldHVybiBnZXRDc3NWYWx1ZShlbCwgJ2JhY2tncm91bmRTaXplJywgJycpID09PSAnY292ZXInID9cbiAgICAgIGJhY2tncm91bmRDb3ZlckZuKHByb3AsIGVsLCBzdG9wcywgYmdQb3MsIGF0dHIpIDpcbiAgICAgIHNldEJhY2tncm91bmRQb3NGbihwcm9wLCBzdG9wcywgYmdQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhY2tncm91bmRDb3ZlckZuKHByb3AsIGVsLCBzdG9wcywgYmdQb3MsIGF0dHIpIHtcbiAgICAgIGNvbnN0IGRpbUltYWdlID0gZ2V0QmFja2dyb3VuZEltYWdlRGltZW5zaW9ucyhlbCk7XG5cbiAgICAgIGlmICghZGltSW1hZ2Uud2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlcyA9IHN0b3BzLm1hcCgoX3JlZjIpID0+IHtsZXQgW3ZhbHVlXSA9IF9yZWYyO3JldHVybiB2YWx1ZTt9KTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKC4uLnZhbHVlcyk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heCguLi52YWx1ZXMpO1xuICAgICAgY29uc3QgZG93biA9IHZhbHVlcy5pbmRleE9mKG1pbikgPCB2YWx1ZXMuaW5kZXhPZihtYXgpO1xuXG4gICAgICBjb25zdCBkaWZmID0gbWF4IC0gbWluO1xuICAgICAgbGV0IHBvcyA9IChkb3duID8gLWRpZmYgOiAwKSAtIChkb3duID8gbWluIDogbWF4KTtcblxuICAgICAgY29uc3QgZGltRWwgPSB7XG4gICAgICAgIHdpZHRoOiBlbC5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbC5vZmZzZXRIZWlnaHQgfTtcblxuXG4gICAgICBjb25zdCBiYXNlRGltID0gRGltZW5zaW9ucy5jb3ZlcihkaW1JbWFnZSwgZGltRWwpO1xuICAgICAgY29uc3Qgc3BhbiA9IGJhc2VEaW1bYXR0cl0gLSBkaW1FbFthdHRyXTtcblxuICAgICAgaWYgKHNwYW4gPCBkaWZmKSB7XG4gICAgICAgIGRpbUVsW2F0dHJdID0gYmFzZURpbVthdHRyXSArIGRpZmYgLSBzcGFuO1xuICAgICAgfSBlbHNlIGlmIChzcGFuID4gZGlmZikge1xuICAgICAgICBjb25zdCBwb3NQZXJjZW50YWdlID0gZGltRWxbYXR0cl0gLyB0b1B4KGJnUG9zLCBhdHRyLCBlbCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHBvc1BlcmNlbnRhZ2UpIHtcbiAgICAgICAgICBwb3MgLT0gKHNwYW4gLSBkaWZmKSAvIHBvc1BlcmNlbnRhZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZGltID0gRGltZW5zaW9ucy5jb3ZlcihkaW1JbWFnZSwgZGltRWwpO1xuXG4gICAgICBjb25zdCBmbiA9IHNldEJhY2tncm91bmRQb3NGbihwcm9wLCBzdG9wcywgcG9zICsgXCJweFwiKTtcbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGZuKGNzcywgcGVyY2VudCk7XG4gICAgICAgIGNzcy5iYWNrZ3JvdW5kU2l6ZSA9IGRpbS53aWR0aCArIFwicHggXCIgKyBkaW0uaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBjc3MuYmFja2dyb3VuZFJlcGVhdCA9ICduby1yZXBlYXQnO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRCYWNrZ3JvdW5kUG9zRm4ocHJvcCwgc3RvcHMsIHBvcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjc3MsIHBlcmNlbnQpIHtcbiAgICAgICAgY3NzW1wiYmFja2dyb3VuZC1wb3NpdGlvbi1cIiArIHByb3BdID0gXCJjYWxjKFwiICsgcG9zICsgXCIgKyBcIiArIGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KSArIFwicHgpXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kSW1hZ2VEaW1lbnNpb25zKGVsKSB7XG4gICAgICBjb25zdCBzcmMgPSBjc3MoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKS5yZXBsYWNlKC9ebm9uZXx1cmxcXChbXCInXT8oLis/KVtcIiddP1xcKSQvLCAnJDEnKTtcblxuICAgICAgaWYgKGRpbWVuc2lvbnNbc3JjXSkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uc1tzcmNdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XG5cbiAgICAgICAgaWYgKCFpbWFnZS5uYXR1cmFsV2lkdGgpIHtcbiAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkaW1lbnNpb25zW3NyY10gPSB0b0RpbWVuc2lvbnMoaW1hZ2UpO1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQoJ2xvYWQnLCBmYWxzZSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRvRGltZW5zaW9ucyhpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbWVuc2lvbnNbc3JjXSA9IHRvRGltZW5zaW9ucyhpbWFnZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EaW1lbnNpb25zKGltYWdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogaW1hZ2UubmF0dXJhbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltYWdlLm5hdHVyYWxIZWlnaHQgfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RvcHMoc3RvcHMsIGZuKSB7aWYgKGZuID09PSB2b2lkIDApIHtmbiA9IHRvRmxvYXQ7fVxuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gc3RvcHM7XG4gICAgICBsZXQgbnVsbEluZGV4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IFt2YWx1ZSwgcGVyY2VudF0gPSBpc1N0cmluZyhzdG9wc1tpXSkgPyBzdG9wc1tpXS50cmltKCkuc3BsaXQoJyAnKSA6IFtzdG9wc1tpXV07XG4gICAgICAgIHZhbHVlID0gZm4odmFsdWUpO1xuICAgICAgICBwZXJjZW50ID0gcGVyY2VudCA/IHRvRmxvYXQocGVyY2VudCkgLyAxMDAgOiBudWxsO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgaWYgKHBlcmNlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3ZhbHVlLCAwXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpZiAocGVyY2VudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50ICE9PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbdmFsdWUsIHBlcmNlbnRdKTtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFt2YWx1ZSwgcGVyY2VudF0pO1xuXG4gICAgICAgIGlmIChwZXJjZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgbnVsbEluZGV4Kys7XG4gICAgICAgIH0gZWxzZSBpZiAobnVsbEluZGV4KSB7XG4gICAgICAgICAgY29uc3QgbGVmdFBlcmNlbnQgPSByZXN1bHRbaSAtIG51bGxJbmRleCAtIDFdWzFdO1xuICAgICAgICAgIGNvbnN0IHAgPSAocGVyY2VudCAtIGxlZnRQZXJjZW50KSAvIChudWxsSW5kZXggKyAxKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gbnVsbEluZGV4OyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICByZXN1bHRbaSAtIGpdWzFdID0gbGVmdFBlcmNlbnQgKyBwICogKG51bGxJbmRleCAtIGogKyAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBudWxsSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RvcChzdG9wcywgcGVyY2VudCkge1xuICAgICAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgoc3RvcHMuc2xpY2UoMSksIChfcmVmMykgPT4ge2xldCBbLCB0YXJnZXRQZXJjZW50XSA9IF9yZWYzO3JldHVybiBwZXJjZW50IDw9IHRhcmdldFBlcmNlbnQ7fSkgKyAxO1xuICAgICAgcmV0dXJuIFtcbiAgICAgIHN0b3BzW2luZGV4IC0gMV1bMF0sXG4gICAgICBzdG9wc1tpbmRleF1bMF0sXG4gICAgICAocGVyY2VudCAtIHN0b3BzW2luZGV4IC0gMV1bMV0pIC8gKHN0b3BzW2luZGV4XVsxXSAtIHN0b3BzW2luZGV4IC0gMV1bMV0pXTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZCwgcF0gPSBnZXRTdG9wKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgIHJldHVybiBpc051bWJlcihzdGFydCkgPyBzdGFydCArIE1hdGguYWJzKHN0YXJ0IC0gZW5kKSAqIHAgKiAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogK2VuZDtcbiAgICB9XG5cbiAgICBjb25zdCB1bml0UmUgPSAvXi0/XFxkKyhbXlxcc10qKS87XG4gICAgZnVuY3Rpb24gZ2V0VW5pdChzdG9wcywgZGVmYXVsdFVuaXQpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RvcCBvZiBzdG9wcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN0b3AubWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3AubWF0Y2godW5pdFJlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmYXVsdFVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q3NzVmFsdWUoZWwsIHByb3AsIHZhbHVlKSB7XG4gICAgICBjb25zdCBwcmV2ID0gZWwuc3R5bGVbcHJvcF07XG4gICAgICBjb25zdCB2YWwgPSBjc3MoY3NzKGVsLCBwcm9wLCB2YWx1ZSksIHByb3ApO1xuICAgICAgZWwuc3R5bGVbcHJvcF0gPSBwcmV2O1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWxsT2JqZWN0KGtleXMsIHZhbHVlKSB7XG4gICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKGRhdGEsIHByb3ApID0+IHtcbiAgICAgICAgZGF0YVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYWxsYXggPSB7XG4gICAgICBtaXhpbnM6IFtQYXJhbGxheCwgUmVzaXplLCBTY3JvbGxdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICAgICAgdmlld3BvcnQ6IE51bWJlciwgLy8gRGVwcmVjYXRlZFxuICAgICAgICBlYXNpbmc6IE51bWJlcixcbiAgICAgICAgc3RhcnQ6IFN0cmluZyxcbiAgICAgICAgZW5kOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIHZpZXdwb3J0OiAxLFxuICAgICAgICBlYXNpbmc6IDEsXG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IDAgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICB0YXJnZXQoX3JlZiwgJGVsKSB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBnZXRPZmZzZXRFbGVtZW50KHRhcmdldCAmJiBxdWVyeSh0YXJnZXQsICRlbCkgfHwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydChfcmVmMikge2xldCB7IHN0YXJ0IH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gdG9QeChzdGFydCwgJ2hlaWdodCcsIHRoaXMudGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmQoX3JlZjMpIHtsZXQgeyBlbmQsIHZpZXdwb3J0IH0gPSBfcmVmMztcbiAgICAgICAgICByZXR1cm4gdG9QeChcbiAgICAgICAgICBlbmQgfHwgKHZpZXdwb3J0ID0gKDEgLSB2aWV3cG9ydCkgKiAxMDApICYmIHZpZXdwb3J0ICsgXCJ2aCtcIiArIHZpZXdwb3J0ICsgXCIlXCIsXG4gICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgdGhpcy50YXJnZXQsXG4gICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKF9yZWY0LCB0eXBlcykge2xldCB7IHBlcmNlbnQgfSA9IF9yZWY0O1xuICAgICAgICAgIGlmICghdHlwZXMuaGFzKCdzY3JvbGwnKSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5tYXRjaE1lZGlhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJldiA9IHBlcmNlbnQ7XG4gICAgICAgICAgcGVyY2VudCA9IGVhc2Uoc2Nyb2xsZWRPdmVyKHRoaXMudGFyZ2V0LCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCksIHRoaXMuZWFzaW5nKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwZXJjZW50LFxuICAgICAgICAgICAgc3R5bGU6IHByZXYgPT09IHBlcmNlbnQgPyBmYWxzZSA6IHRoaXMuZ2V0Q3NzKHBlcmNlbnQpIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmNSkge2xldCB7IHN0eWxlIH0gPSBfcmVmNTtcbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hNZWRpYSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0eWxlICYmIGNzcyh0aGlzLiRlbCwgc3R5bGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydzY3JvbGwnLCAncmVzaXplJ10gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGVhc2UocGVyY2VudCwgZWFzaW5nKSB7XG4gICAgICByZXR1cm4gZWFzaW5nID49IDAgPyBNYXRoLnBvdyhwZXJjZW50LCBlYXNpbmcgKyAxKSA6IDEgLSBNYXRoLnBvdygxIC0gcGVyY2VudCwgLWVhc2luZyArIDEpO1xuICAgIH1cblxuICAgIC8vIFNWRyBlbGVtZW50cyBkbyBub3QgaW5oZXJpdCBmcm9tIEhUTUxFbGVtZW50XG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0RWxlbWVudChlbCkge1xuICAgICAgcmV0dXJuIGVsID8gJ29mZnNldFRvcCcgaW4gZWwgPyBlbCA6IGdldE9mZnNldEVsZW1lbnQocGFyZW50KGVsKSkgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIFNsaWRlclJlYWN0aXZlID0ge1xuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHdyaXRlKCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCB8fCB0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldFZhbGlkSW5kZXgodGhpcy5pbmRleCk7XG5cbiAgICAgICAgICBpZiAoIX50aGlzLnByZXZJbmRleCB8fCB0aGlzLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zaG93KGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuICAgIHZhciBTbGlkZXJQcmVsb2FkID0ge1xuICAgICAgbWl4aW5zOiBbTGF6eWxvYWRdLFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMubGF6eWxvYWQodGhpcy5zbGlkZXMsIHRoaXMuZ2V0QWRqYWNlbnRTbGlkZXMpO1xuICAgICAgfSB9O1xuXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbmVyIChwcmV2LCBuZXh0LCBkaXIsIF9yZWYpIHtsZXQgeyBjZW50ZXIsIGVhc2luZywgbGlzdCB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG5cbiAgICAgIGNvbnN0IGZyb20gPSBwcmV2ID9cbiAgICAgIGdldExlZnQocHJldiwgbGlzdCwgY2VudGVyKSA6XG4gICAgICBnZXRMZWZ0KG5leHQsIGxpc3QsIGNlbnRlcikgKyBkaW1lbnNpb25zJDEobmV4dCkud2lkdGggKiBkaXI7XG4gICAgICBjb25zdCB0byA9IG5leHQgP1xuICAgICAgZ2V0TGVmdChuZXh0LCBsaXN0LCBjZW50ZXIpIDpcbiAgICAgIGZyb20gKyBkaW1lbnNpb25zJDEocHJldikud2lkdGggKiBkaXIgKiAoaXNSdGwgPyAtMSA6IDEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXIsXG5cbiAgICAgICAgc2hvdyhkdXJhdGlvbiwgcGVyY2VudCwgbGluZWFyKSB7aWYgKHBlcmNlbnQgPT09IHZvaWQgMCkge3BlcmNlbnQgPSAwO31cbiAgICAgICAgICBjb25zdCB0aW1pbmcgPSBsaW5lYXIgPyAnbGluZWFyJyA6IGVhc2luZztcbiAgICAgICAgICBkdXJhdGlvbiAtPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogY2xhbXAocGVyY2VudCwgLTEsIDEpKTtcblxuICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHBlcmNlbnQpO1xuXG4gICAgICAgICAgcGVyY2VudCA9IHByZXYgPyBwZXJjZW50IDogY2xhbXAocGVyY2VudCwgMCwgMSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSh0aGlzLmdldEl0ZW1JbigpLCAnaXRlbWluJywgeyBwZXJjZW50LCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSk7XG4gICAgICAgICAgcHJldiAmJlxuICAgICAgICAgIHRyaWdnZXJVcGRhdGUodGhpcy5nZXRJdGVtSW4odHJ1ZSksICdpdGVtb3V0Jywge1xuICAgICAgICAgICAgcGVyY2VudDogMSAtIHBlcmNlbnQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZyxcbiAgICAgICAgICAgIGRpciB9KTtcblxuXG4gICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChcbiAgICAgICAgICBsaXN0LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLXRvICogKGlzUnRsID8gLTEgOiAxKSwgJ3B4JykgfSxcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmcpLlxuICAgICAgICAgIHRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgbm9vcCk7XG5cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwobGlzdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgY3NzKGxpc3QsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yd2FyZChkdXJhdGlvbiwgcGVyY2VudCkge2lmIChwZXJjZW50ID09PSB2b2lkIDApIHtwZXJjZW50ID0gdGhpcy5wZXJjZW50KCk7fVxuICAgICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKGxpc3QpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNob3coZHVyYXRpb24sIHBlcmNlbnQsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmdldERpc3RhbmNlKCkgKiBkaXIgKiAoaXNSdGwgPyAtMSA6IDEpO1xuXG4gICAgICAgICAgY3NzKFxuICAgICAgICAgIGxpc3QsXG4gICAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICAgdHJhbnNsYXRlKFxuICAgICAgICAgIGNsYW1wKFxuICAgICAgICAgIC10byArIChkaXN0YW5jZSAtIGRpc3RhbmNlICogcGVyY2VudCksXG4gICAgICAgICAgLWdldFdpZHRoKGxpc3QpLFxuICAgICAgICAgIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCkgKiAoXG4gICAgICAgICAgaXNSdGwgPyAtMSA6IDEpLFxuICAgICAgICAgICdweCcpKTtcblxuXG5cbiAgICAgICAgICBjb25zdCBhY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVzKCk7XG4gICAgICAgICAgY29uc3QgaXRlbUluID0gdGhpcy5nZXRJdGVtSW4oKTtcbiAgICAgICAgICBjb25zdCBpdGVtT3V0ID0gdGhpcy5nZXRJdGVtSW4odHJ1ZSk7XG5cbiAgICAgICAgICBwZXJjZW50ID0gcHJldiA/IGNsYW1wKHBlcmNlbnQsIC0xLCAxKSA6IDA7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHNsaWRlIG9mIGNoaWxkcmVuKGxpc3QpKSB7XG4gICAgICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IGluY2x1ZGVzKGFjdGl2ZXMsIHNsaWRlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW4gPSBzbGlkZSA9PT0gaXRlbUluO1xuICAgICAgICAgICAgY29uc3QgaXNPdXQgPSBzbGlkZSA9PT0gaXRlbU91dDtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZUluID1cbiAgICAgICAgICAgIGlzSW4gfHxcbiAgICAgICAgICAgICFpc091dCAmJiAoXG4gICAgICAgICAgICBpc0FjdGl2ZSB8fFxuICAgICAgICAgICAgZGlyICogKGlzUnRsID8gLTEgOiAxKSA9PT0gLTEgXlxuICAgICAgICAgICAgZ2V0RWxMZWZ0KHNsaWRlLCBsaXN0KSA+IGdldEVsTGVmdChwcmV2IHx8IG5leHQpKTtcblxuICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZShzbGlkZSwgXCJpdGVtdHJhbnNsYXRlXCIgKyAodHJhbnNsYXRlSW4gPyAnaW4nIDogJ291dCcpLCB7XG4gICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgcGVyY2VudDogaXNPdXQgPyAxIC0gcGVyY2VudCA6IGlzSW4gPyBwZXJjZW50IDogaXNBY3RpdmUgPyAxIDogMCB9KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhcbiAgICAgICAgICAoY3NzKGxpc3QsICd0cmFuc2Zvcm0nKS5zcGxpdCgnLCcpWzRdICogKGlzUnRsID8gLTEgOiAxKSArIGZyb20pIC8gKHRvIC0gZnJvbSkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGlzdGFuY2UoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvIC0gZnJvbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SXRlbUluKG91dCkge2lmIChvdXQgPT09IHZvaWQgMCkge291dCA9IGZhbHNlO31cbiAgICAgICAgICBsZXQgYWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlcygpO1xuICAgICAgICAgIGxldCBuZXh0QWN0aXZlcyA9IGluVmlldyhsaXN0LCBnZXRMZWZ0KG5leHQgfHwgcHJldiwgbGlzdCwgY2VudGVyKSk7XG5cbiAgICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gYWN0aXZlcztcbiAgICAgICAgICAgIGFjdGl2ZXMgPSBuZXh0QWN0aXZlcztcbiAgICAgICAgICAgIG5leHRBY3RpdmVzID0gdGVtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV4dEFjdGl2ZXNbZmluZEluZGV4KG5leHRBY3RpdmVzLCAoZWwpID0+ICFpbmNsdWRlcyhhY3RpdmVzLCBlbCkpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBY3RpdmVzKCkge1xuICAgICAgICAgIHJldHVybiBpblZpZXcobGlzdCwgZ2V0TGVmdChwcmV2IHx8IG5leHQsIGxpc3QsIGNlbnRlcikpO1xuICAgICAgICB9IH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMZWZ0KGVsLCBsaXN0LCBjZW50ZXIpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBnZXRFbExlZnQoZWwsIGxpc3QpO1xuXG4gICAgICByZXR1cm4gY2VudGVyID8gbGVmdCAtIGNlbnRlckVsKGVsLCBsaXN0KSA6IE1hdGgubWluKGxlZnQsIGdldE1heChsaXN0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWF4KGxpc3QpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBnZXRXaWR0aChsaXN0KSAtIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2lkdGgobGlzdCkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuKGxpc3QpLnJlZHVjZSgocmlnaHQsIGVsKSA9PiBkaW1lbnNpb25zJDEoZWwpLndpZHRoICsgcmlnaHQsIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlbnRlckVsKGVsLCBsaXN0KSB7XG4gICAgICByZXR1cm4gZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoIC8gMiAtIGRpbWVuc2lvbnMkMShlbCkud2lkdGggLyAyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVsTGVmdChlbCwgbGlzdCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZWwgJiZcbiAgICAgICAgKHBvc2l0aW9uKGVsKS5sZWZ0ICsgKGlzUnRsID8gZGltZW5zaW9ucyQxKGVsKS53aWR0aCAtIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCA6IDApKSAqIChcbiAgICAgICAgaXNSdGwgPyAtMSA6IDEpIHx8XG4gICAgICAgIDApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5WaWV3KGxpc3QsIGxpc3RMZWZ0KSB7XG4gICAgICBsaXN0TGVmdCAtPSAxO1xuICAgICAgY29uc3QgbGlzdFdpZHRoID0gZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoO1xuICAgICAgY29uc3QgbGlzdFJpZ2h0ID0gbGlzdExlZnQgKyBsaXN0V2lkdGggKyAyO1xuXG4gICAgICByZXR1cm4gY2hpbGRyZW4obGlzdCkuZmlsdGVyKChzbGlkZSkgPT4ge1xuICAgICAgICBjb25zdCBzbGlkZUxlZnQgPSBnZXRFbExlZnQoc2xpZGUsIGxpc3QpO1xuICAgICAgICBjb25zdCBzbGlkZVJpZ2h0ID0gc2xpZGVMZWZ0ICsgTWF0aC5taW4oZGltZW5zaW9ucyQxKHNsaWRlKS53aWR0aCwgbGlzdFdpZHRoKTtcblxuICAgICAgICByZXR1cm4gc2xpZGVMZWZ0ID49IGxpc3RMZWZ0ICYmIHNsaWRlUmlnaHQgPD0gbGlzdFJpZ2h0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZShlbCwgdHlwZSwgZGF0YSkge1xuICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIHNsaWRlciA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBTbGlkZXIsIFNsaWRlclJlYWN0aXZlLCBTbGlkZXJQcmVsb2FkXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2VudGVyOiBCb29sZWFuLFxuICAgICAgICBzZXRzOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjZW50ZXI6IGZhbHNlLFxuICAgICAgICBzZXRzOiBmYWxzZSxcbiAgICAgICAgYXR0ckl0ZW06ICd1ay1zbGlkZXItaXRlbScsXG4gICAgICAgIHNlbExpc3Q6ICcudWstc2xpZGVyLWl0ZW1zJyxcbiAgICAgICAgc2VsTmF2OiAnLnVrLXNsaWRlci1uYXYnLFxuICAgICAgICBjbHNDb250YWluZXI6ICd1ay1zbGlkZXItY29udGFpbmVyJyxcbiAgICAgICAgVHJhbnNpdGlvbmVyIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYXZnV2lkdGgoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFdpZHRoKHRoaXMubGlzdCkgLyB0aGlzLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pdGUoX3JlZikge2xldCB7IGZpbml0ZSB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZmluaXRlIHx8XG4gICAgICAgICAgICBNYXRoLmNlaWwoZ2V0V2lkdGgodGhpcy5saXN0KSkgPFxuICAgICAgICAgICAgTWF0aC50cnVuYyhkaW1lbnNpb25zJDEodGhpcy5saXN0KS53aWR0aCArIGdldE1heEVsV2lkdGgodGhpcy5saXN0KSArIHRoaXMuY2VudGVyKSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBtYXhJbmRleCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZmluaXRlIHx8IHRoaXMuY2VudGVyICYmICF0aGlzLnNldHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdCh0aGlzLnNldHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBsZnQgPSAwO1xuICAgICAgICAgIGNvbnN0IG1heCA9IGdldE1heCh0aGlzLmxpc3QpO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KHRoaXMuc2xpZGVzLCAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChsZnQgPj0gbWF4KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZnQgKz0gZGltZW5zaW9ucyQxKGVsKS53aWR0aDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB+aW5kZXggPyBpbmRleCA6IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRzKF9yZWYyKSB7bGV0IHsgc2V0czogZW5hYmxlZCB9ID0gX3JlZjI7XG4gICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICAgIGNvbnN0IHNldHMgPSBbXTtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpLndpZHRoO1xuICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5zbGlkZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlV2lkdGggPSBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbaV0pLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAobGVmdCArIHNsaWRlV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGVmdCA8IHdpZHRoIC8gMiAmJlxuICAgICAgICAgICAgICBsZWZ0ICsgc2xpZGVXaWR0aCArIGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1sraSArIDFdKS53aWR0aCAvIDIgPiB3aWR0aCAvIDIpXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZXRzLnB1c2goK2kpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB3aWR0aCAvIDIgLSBzbGlkZVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgIHNldHMucHVzaChNYXRoLm1pbigraSwgdGhpcy5tYXhJbmRleCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0ICs9IHNsaWRlV2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5jZW50ZXIsXG4gICAgICAgICAgICBsaXN0OiB0aGlzLmxpc3QgfTtcblxuICAgICAgICB9IH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNDb250YWluZXIsICEkKFwiLlwiICsgdGhpcy5jbHNDb250YWluZXIsIHRoaXMuJGVsKSk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgd3JpdGUoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLm5hdkl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRvTnVtYmVyKGRhdGEoZWwsIHRoaXMuYXR0ckl0ZW0pKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZWwuaGlkZGVuID1cbiAgICAgICAgICAgICAgIXRoaXMubWF4SW5kZXggfHxcbiAgICAgICAgICAgICAgaW5kZXggPiB0aGlzLm1heEluZGV4IHx8XG4gICAgICAgICAgICAgIHRoaXMuc2V0cyAmJiAhaW5jbHVkZXModGhpcy5zZXRzLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMubGVuZ3RoICYmICF0aGlzLmRyYWdnaW5nICYmICF0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZW9yZGVyKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGUoMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVDbGFzc2VzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGJlZm9yZWl0ZW1zaG93KGUpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXMuZHJhZ2dpbmcgJiZcbiAgICAgICAgICB0aGlzLnNldHMgJiZcbiAgICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA8IDIgJiZcbiAgICAgICAgICAhaW5jbHVkZXModGhpcy5zZXRzLCB0aGlzLmluZGV4KSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5nZXRWYWxpZEluZGV4KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKFxuICAgICAgICAgIHRoaXMuaW5kZXggLVxuICAgICAgICAgIHRoaXMucHJldkluZGV4ICsgKFxuICAgICAgICAgIHRoaXMuZGlyID4gMCAmJiB0aGlzLmluZGV4IDwgdGhpcy5wcmV2SW5kZXggfHxcbiAgICAgICAgICB0aGlzLmRpciA8IDAgJiYgdGhpcy5pbmRleCA+IHRoaXMucHJldkluZGV4ID9cbiAgICAgICAgICAodGhpcy5tYXhJbmRleCArIDEpICogdGhpcy5kaXIgOlxuICAgICAgICAgIDApKTtcblxuXG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nICYmIGRpZmYgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSgxLCAwLCB0aGlzLmRpciA+IDAgPyAnbmV4dCcgOiAncHJldmlvdXMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGluZGV4ID1cbiAgICAgICAgICB0aGlzLmRpciA8IDAgfHwgIXRoaXMuc2xpZGVzW3RoaXMucHJldkluZGV4XSA/IHRoaXMuaW5kZXggOiB0aGlzLnByZXZJbmRleDtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID1cbiAgICAgICAgICBzcGVlZFVwKHRoaXMuYXZnV2lkdGggLyB0aGlzLnZlbG9jaXR5KSAqIChcbiAgICAgICAgICBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbaW5kZXhdKS53aWR0aCAvIHRoaXMuYXZnV2lkdGgpO1xuXG4gICAgICAgICAgdGhpcy5yZW9yZGVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbXNob3coKSB7XG4gICAgICAgICAgaWYgKH50aGlzLnByZXZJbmRleCkge1xuICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy5fZ2V0VHJhbnNpdGlvbmVyKCkuZ2V0SXRlbUluKCksIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbXNob3duKCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZlQ2xhc3NlcygpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICByZW9yZGVyKCkge1xuICAgICAgICAgIGlmICh0aGlzLmZpbml0ZSkge1xuICAgICAgICAgICAgY3NzKHRoaXMuc2xpZGVzLCAnb3JkZXInLCAnJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRpciA+IDAgJiYgdGhpcy5zbGlkZXNbdGhpcy5wcmV2SW5kZXhdID8gdGhpcy5wcmV2SW5kZXggOiB0aGlzLmluZGV4O1xuXG4gICAgICAgICAgdGhpcy5zbGlkZXMuZm9yRWFjaCgoc2xpZGUsIGkpID0+XG4gICAgICAgICAgY3NzKFxuICAgICAgICAgIHNsaWRlLFxuICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgdGhpcy5kaXIgPiAwICYmIGkgPCBpbmRleCA/IDEgOiB0aGlzLmRpciA8IDAgJiYgaSA+PSB0aGlzLmluZGV4ID8gLTEgOiAnJykpO1xuXG5cblxuICAgICAgICAgIGlmICghdGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5zbGlkZXNbaW5kZXhdO1xuICAgICAgICAgIGxldCB3aWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpLndpZHRoIC8gMiAtIGRpbWVuc2lvbnMkMShuZXh0KS53aWR0aCAvIDI7XG4gICAgICAgICAgbGV0IGogPSAwO1xuXG4gICAgICAgICAgd2hpbGUgKHdpZHRoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IHRoaXMuZ2V0SW5kZXgoLS1qICsgaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5zbGlkZXNbc2xpZGVJbmRleF07XG5cbiAgICAgICAgICAgIGNzcyhzbGlkZSwgJ29yZGVyJywgc2xpZGVJbmRleCA+IGluZGV4ID8gLTIgOiAtMSk7XG4gICAgICAgICAgICB3aWR0aCAtPSBkaW1lbnNpb25zJDEoc2xpZGUpLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVBY3RpdmVDbGFzc2VzKCkge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZXMgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIodGhpcy5pbmRleCkuZ2V0QWN0aXZlcygpO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUNsYXNzZXMgPSBbXG4gICAgICAgICAgdGhpcy5jbHNBY3RpdmUsXG4gICAgICAgICAgKCF0aGlzLnNldHMgfHwgaW5jbHVkZXModGhpcy5zZXRzLCB0b0Zsb2F0KHRoaXMuaW5kZXgpKSkgJiYgdGhpcy5jbHNBY3RpdmF0ZWQgfHxcbiAgICAgICAgICAnJ107XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHNsaWRlIG9mIHRoaXMuc2xpZGVzKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzbGlkZSwgYWN0aXZlQ2xhc3NlcywgaW5jbHVkZXMoYWN0aXZlcywgc2xpZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VmFsaWRJbmRleChpbmRleCwgcHJldkluZGV4KSB7aWYgKGluZGV4ID09PSB2b2lkIDApIHtpbmRleCA9IHRoaXMuaW5kZXg7fWlmIChwcmV2SW5kZXggPT09IHZvaWQgMCkge3ByZXZJbmRleCA9IHRoaXMucHJldkluZGV4O31cbiAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoaW5kZXgsIHByZXZJbmRleCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuc2V0cykge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBwcmV2O1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVzKHRoaXMuc2V0cywgaW5kZXgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldiA9IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmdldEluZGV4KGluZGV4ICsgdGhpcy5kaXIsIHByZXZJbmRleCk7XG4gICAgICAgICAgfSB3aGlsZSAoaW5kZXggIT09IHByZXYpO1xuXG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFkamFjZW50U2xpZGVzKCkge1xuICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSAtd2lkdGg7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSB3aWR0aCAqIDI7XG4gICAgICAgICAgY29uc3Qgc2xpZGVXaWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1t0aGlzLmluZGV4XSkud2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2xpZGVMZWZ0ID0gdGhpcy5jZW50ZXIgPyB3aWR0aCAvIDIgLSBzbGlkZVdpZHRoIC8gMiA6IDA7XG4gICAgICAgICAgY29uc3Qgc2xpZGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBbLTEsIDFdKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExlZnQgPSBzbGlkZUxlZnQgKyAoaSA+IDAgPyBzbGlkZVdpZHRoIDogMCk7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5zbGlkZXNbdGhpcy5nZXRJbmRleCh0aGlzLmluZGV4ICsgaSArIGorKyAqIGkpXTtcbiAgICAgICAgICAgICAgY3VycmVudExlZnQgKz0gZGltZW5zaW9ucyQxKHNsaWRlKS53aWR0aCAqIGk7XG4gICAgICAgICAgICAgIHNsaWRlcy5hZGQoc2xpZGUpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5zbGlkZXMubGVuZ3RoID4gaiAmJiBjdXJyZW50TGVmdCA+IGxlZnQgJiYgY3VycmVudExlZnQgPCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHNsaWRlcyk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldE1heEVsV2lkdGgobGlzdCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIC4uLmNoaWxkcmVuKGxpc3QpLm1hcCgoZWwpID0+IGRpbWVuc2lvbnMkMShlbCkud2lkdGgpKTtcbiAgICB9XG5cbiAgICB2YXIgc2xpZGVyUGFyYWxsYXggPSB7XG4gICAgICBtaXhpbnM6IFtQYXJhbGxheF0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2VsSXRlbTogJyFsaScgfSxcblxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLml0ZW0gPSBxdWVyeSh0aGlzLnNlbEl0ZW0sIHRoaXMuJGVsKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5pdGVtID0gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnaXRlbWluIGl0ZW1vdXQnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF9yZWYpIHtsZXQgeyB0eXBlLCBkZXRhaWw6IHsgcGVyY2VudCwgZHVyYXRpb24sIHRpbWluZywgZGlyIH0gfSA9IF9yZWY7XG4gICAgICAgICAgZmFzdGRvbS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzRnJvbSA9IHRoaXMuZ2V0Q3NzKGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkpO1xuICAgICAgICAgICAgY29uc3QgcHJvcHNUbyA9IHRoaXMuZ2V0Q3NzKGlzSW4odHlwZSkgPyAwLjUgOiBkaXIgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgcHJvcHNGcm9tKTtcbiAgICAgICAgICAgICAgVHJhbnNpdGlvbi5zdGFydCh0aGlzLiRlbCwgcHJvcHNUbywgZHVyYXRpb24sIHRpbWluZykuY2F0Y2gobm9vcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RyYW5zaXRpb25jYW5jZWxlZCB0cmFuc2l0aW9uZW5kJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbCh0aGlzLiRlbCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpdGVtdHJhbnNsYXRlaW4gaXRlbXRyYW5zbGF0ZW91dCcsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjIpIHtsZXQgeyB0eXBlLCBkZXRhaWw6IHsgcGVyY2VudCwgZGlyIH0gfSA9IF9yZWYyO1xuICAgICAgICAgIGZhc3Rkb20ucmVhZCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuZ2V0Q3NzKGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkpO1xuICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiBjc3ModGhpcy4kZWwsIHByb3BzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gfV0gfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIGlzSW4odHlwZSkge1xuICAgICAgcmV0dXJuIGVuZHNXaXRoKHR5cGUsICdpbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkge1xuICAgICAgcGVyY2VudCAvPSAyO1xuXG4gICAgICByZXR1cm4gaXNJbih0eXBlKSBeIGRpciA8IDAgPyBwZXJjZW50IDogMSAtIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdmFyIEFuaW1hdGlvbnMgPSB7XG4gICAgICAuLi5BbmltYXRpb25zJDIsXG4gICAgICBmYWRlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAsIHpJbmRleDogMCB9LCB7IHpJbmRleDogLTEgfV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyY2VudChjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLSBjc3MoY3VycmVudCwgJ29wYWNpdHknKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCkge1xuICAgICAgICAgIHJldHVybiBbeyBvcGFjaXR5OiAxIC0gcGVyY2VudCwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogc2NhbGUzZCgxICsgMC41KSwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIGNzcyhjdXJyZW50LCAnb3BhY2l0eScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IG9wYWNpdHk6IDEgLSBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSArIDAuNSAqIHBlcmNlbnQpLCB6SW5kZXg6IDAgfSxcbiAgICAgICAgICB7IHpJbmRleDogLTEgfV07XG5cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHB1bGw6IHtcbiAgICAgICAgc2hvdyhkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/XG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzApLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpLCB6SW5kZXg6IDAgfV0gOlxuXG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSwgekluZGV4OiAtMSB9XTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCwgbmV4dCwgZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgPyAxIC0gdHJhbnNsYXRlZChuZXh0KSA6IHRyYW5zbGF0ZWQoY3VycmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQsIGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID9cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgzMCAqIHBlcmNlbnQpLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTAwICogKDEgLSBwZXJjZW50KSksIHpJbmRleDogMCB9XSA6XG5cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtcGVyY2VudCAqIDEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzAgKiAoMSAtIHBlcmNlbnQpKSwgekluZGV4OiAtMSB9XTtcblxuICAgICAgICB9IH0sXG5cblxuICAgICAgcHVzaDoge1xuICAgICAgICBzaG93KGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID9cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxMDApLCB6SW5kZXg6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKCksIHpJbmRleDogLTEgfV0gOlxuXG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTMwKSwgekluZGV4OiAtMSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSwgekluZGV4OiAwIH1dO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyY2VudChjdXJyZW50LCBuZXh0LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyID4gMCA/IDEgLSB0cmFuc2xhdGVkKG5leHQpIDogdHJhbnNsYXRlZChjdXJyZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCwgZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgP1xuICAgICAgICAgIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKHBlcmNlbnQgKiAxMDApLCB6SW5kZXg6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC0zMCAqICgxIC0gcGVyY2VudCkpLCB6SW5kZXg6IC0xIH1dIDpcblxuICAgICAgICAgIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC0zMCAqIHBlcmNlbnQpLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxMDAgKiAoMSAtIHBlcmNlbnQpKSwgekluZGV4OiAwIH1dO1xuXG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIHNsaWRlc2hvdyA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBTbGlkZXNob3csIFNsaWRlclJlYWN0aXZlLCBTbGlkZXJQcmVsb2FkXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcmF0aW86IFN0cmluZyxcbiAgICAgICAgbWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgICAgIG1heEhlaWdodDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICByYXRpbzogJzE2OjknLFxuICAgICAgICBtaW5IZWlnaHQ6IGZhbHNlLFxuICAgICAgICBtYXhIZWlnaHQ6IGZhbHNlLFxuICAgICAgICBzZWxMaXN0OiAnLnVrLXNsaWRlc2hvdy1pdGVtcycsXG4gICAgICAgIGF0dHJJdGVtOiAndWstc2xpZGVzaG93LWl0ZW0nLFxuICAgICAgICBzZWxOYXY6ICcudWstc2xpZGVzaG93LW5hdicsXG4gICAgICAgIEFuaW1hdGlvbnMgfSxcblxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnJhdGlvLnNwbGl0KCc6JykubWFwKE51bWJlcik7XG5cbiAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKiB0aGlzLmxpc3Qub2Zmc2V0V2lkdGggLyB3aWR0aCB8fCAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLm1pbkhlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5tYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IGhlaWdodDogaGVpZ2h0IC0gYm94TW9kZWxBZGp1c3QodGhpcy5saXN0LCAnaGVpZ2h0JywgJ2NvbnRlbnQtYm94JykgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmKSB7bGV0IHsgaGVpZ2h0IH0gPSBfcmVmO1xuICAgICAgICAgIGhlaWdodCA+IDAgJiYgY3NzKHRoaXMubGlzdCwgJ21pbkhlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBnZXRBZGphY2VudFNsaWRlcygpIHtcbiAgICAgICAgICByZXR1cm4gWzEsIC0xXS5tYXAoKGkpID0+IHRoaXMuc2xpZGVzW3RoaXMuZ2V0SW5kZXgodGhpcy5pbmRleCArIGkpXSk7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIHNvcnRhYmxlID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIEFuaW1hdGVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBncm91cDogU3RyaW5nLFxuICAgICAgICB0aHJlc2hvbGQ6IE51bWJlcixcbiAgICAgICAgY2xzSXRlbTogU3RyaW5nLFxuICAgICAgICBjbHNQbGFjZWhvbGRlcjogU3RyaW5nLFxuICAgICAgICBjbHNEcmFnOiBTdHJpbmcsXG4gICAgICAgIGNsc0RyYWdTdGF0ZTogU3RyaW5nLFxuICAgICAgICBjbHNCYXNlOiBTdHJpbmcsXG4gICAgICAgIGNsc05vRHJhZzogU3RyaW5nLFxuICAgICAgICBjbHNFbXB0eTogU3RyaW5nLFxuICAgICAgICBjbHNDdXN0b206IFN0cmluZyxcbiAgICAgICAgaGFuZGxlOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGdyb3VwOiBmYWxzZSxcbiAgICAgICAgdGhyZXNob2xkOiA1LFxuICAgICAgICBjbHNJdGVtOiAndWstc29ydGFibGUtaXRlbScsXG4gICAgICAgIGNsc1BsYWNlaG9sZGVyOiAndWstc29ydGFibGUtcGxhY2Vob2xkZXInLFxuICAgICAgICBjbHNEcmFnOiAndWstc29ydGFibGUtZHJhZycsXG4gICAgICAgIGNsc0RyYWdTdGF0ZTogJ3VrLWRyYWcnLFxuICAgICAgICBjbHNCYXNlOiAndWstc29ydGFibGUnLFxuICAgICAgICBjbHNOb0RyYWc6ICd1ay1zb3J0YWJsZS1ub2RyYWcnLFxuICAgICAgICBjbHNFbXB0eTogJ3VrLXNvcnRhYmxlLWVtcHR5JyxcbiAgICAgICAgY2xzQ3VzdG9tOiAnJyxcbiAgICAgICAgaGFuZGxlOiBmYWxzZSxcbiAgICAgICAgcG9zOiB7fSB9LFxuXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnaW5pdCcsICdzdGFydCcsICdtb3ZlJywgJ2VuZCddKSB7XG4gICAgICAgICAgY29uc3QgZm4gPSB0aGlzW2tleV07XG4gICAgICAgICAgdGhpc1trZXldID0gKGUpID0+IHtcbiAgICAgICAgICAgIGFzc2lnbih0aGlzLnBvcywgZ2V0RXZlbnRQb3MoZSkpO1xuICAgICAgICAgICAgZm4oZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIG5hbWU6IHBvaW50ZXJEb3duLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgaGFuZGxlcjogJ2luaXQnIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdGFyZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAodGhpcy4kZWwudEJvZGllcyB8fCBbdGhpcy4kZWxdKVswXTtcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtcygpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4odGhpcy50YXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRW1wdHk6IHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLml0ZW1zKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goZW1wdHkpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmNsc0VtcHR5LCBlbXB0eSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgaGFuZGxlczoge1xuICAgICAgICAgIGdldChfcmVmLCBlbCkge2xldCB7IGhhbmRsZSB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUgPyAkJChoYW5kbGUsIGVsKSA6IHRoaXMuaXRlbXM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGhhbmRsZXMsIHByZXYpIHtcbiAgICAgICAgICAgIGNzcyhwcmV2LCB7IHRvdWNoQWN0aW9uOiAnJywgdXNlclNlbGVjdDogJycgfSk7XG4gICAgICAgICAgICBjc3MoaGFuZGxlcywgeyB0b3VjaEFjdGlvbjogaGFzVG91Y2ggPyAnbm9uZScgOiAnJywgdXNlclNlbGVjdDogJ25vbmUnIH0pOyAvLyB0b3VjaEFjdGlvbiBzZXQgdG8gJ25vbmUnIGNhdXNlcyBhIHBlcmZvcm1hbmNlIGRyb3AgaW4gQ2hyb21lIDgwXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9IH0sXG5cblxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgd3JpdGUoZGF0YSkge1xuICAgICAgICAgIGlmICghdGhpcy5kcmFnIHx8ICFwYXJlbnQodGhpcy5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBwb3M6IHsgeCwgeSB9LFxuICAgICAgICAgICAgb3JpZ2luOiB7IG9mZnNldFRvcCwgb2Zmc2V0TGVmdCB9LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgfSA9XG4gICAgICAgICAgdGhpcztcblxuICAgICAgICAgIGNzcyh0aGlzLmRyYWcsIHtcbiAgICAgICAgICAgIHRvcDogeSAtIG9mZnNldFRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHggLSBvZmZzZXRMZWZ0IH0pO1xuXG5cbiAgICAgICAgICBjb25zdCBzb3J0YWJsZSA9IHRoaXMuZ2V0U29ydGFibGUoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KSk7XG5cbiAgICAgICAgICBpZiAoIXNvcnRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBpdGVtcyB9ID0gc29ydGFibGU7XG5cbiAgICAgICAgICBpZiAoaXRlbXMuc29tZShUcmFuc2l0aW9uLmluUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZmluZFRhcmdldChpdGVtcywgeyB4LCB5IH0pO1xuXG4gICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCAmJiAoIXRhcmdldCB8fCB0YXJnZXQgPT09IHBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5nZXRTb3J0YWJsZShwbGFjZWhvbGRlcik7XG4gICAgICAgICAgY29uc3QgaW5zZXJ0VGFyZ2V0ID0gZmluZEluc2VydFRhcmdldChcbiAgICAgICAgICBzb3J0YWJsZS50YXJnZXQsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBzb3J0YWJsZSA9PT0gcHJldmlvdXMgJiYgZGF0YS5tb3ZlZCAhPT0gdGFyZ2V0KTtcblxuXG4gICAgICAgICAgaWYgKGluc2VydFRhcmdldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5zZXJ0VGFyZ2V0ICYmIHBsYWNlaG9sZGVyID09PSBpbnNlcnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc29ydGFibGUgIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgICBwcmV2aW91cy5yZW1vdmUocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgZGF0YS5tb3ZlZCA9IHRhcmdldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEubW92ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc29ydGFibGUuaW5zZXJ0KHBsYWNlaG9sZGVyLCBpbnNlcnRUYXJnZXQpO1xuXG4gICAgICAgICAgdGhpcy50b3VjaGVkLmFkZChzb3J0YWJsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ21vdmUnXSB9LFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgaW5pdChlKSB7XG4gICAgICAgICAgY29uc3QgeyB0YXJnZXQsIGJ1dHRvbiwgZGVmYXVsdFByZXZlbnRlZCB9ID0gZTtcbiAgICAgICAgICBjb25zdCBbcGxhY2Vob2xkZXJdID0gdGhpcy5pdGVtcy5maWx0ZXIoKGVsKSA9PiB3aXRoaW4odGFyZ2V0LCBlbCkpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICFwbGFjZWhvbGRlciB8fFxuICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgfHxcbiAgICAgICAgICBidXR0b24gPiAwIHx8XG4gICAgICAgICAgaXNJbnB1dCh0YXJnZXQpIHx8XG4gICAgICAgICAgd2l0aGluKHRhcmdldCwgXCIuXCIgKyB0aGlzLmNsc05vRHJhZykgfHxcbiAgICAgICAgICB0aGlzLmhhbmRsZSAmJiAhd2l0aGluKHRhcmdldCwgdGhpcy5oYW5kbGUpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB0aGlzLnRvdWNoZWQgPSBuZXcgU2V0KFt0aGlzXSk7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgIHRoaXMub3JpZ2luID0geyB0YXJnZXQsIGluZGV4OiBpbmRleChwbGFjZWhvbGRlciksIC4uLnRoaXMucG9zIH07XG5cbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlck1vdmUsIHRoaXMubW92ZSk7XG4gICAgICAgICAgb24oZG9jdW1lbnQsIHBvaW50ZXJVcCwgdGhpcy5lbmQpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnQoZSkge1xuICAgICAgICAgIHRoaXMuZHJhZyA9IGFwcGVuZERyYWcodGhpcy4kY29udGFpbmVyLCB0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gdGhpcy5wbGFjZWhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy5vcmlnaW4sIHsgb2Zmc2V0TGVmdDogdGhpcy5wb3MueCAtIGxlZnQsIG9mZnNldFRvcDogdGhpcy5wb3MueSAtIHRvcCB9KTtcblxuICAgICAgICAgIGFkZENsYXNzKHRoaXMuZHJhZywgdGhpcy5jbHNEcmFnLCB0aGlzLmNsc0N1c3RvbSk7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5wbGFjZWhvbGRlciwgdGhpcy5jbHNQbGFjZWhvbGRlcik7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5pdGVtcywgdGhpcy5jbHNJdGVtKTtcbiAgICAgICAgICBhZGRDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzRHJhZ1N0YXRlKTtcblxuICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdzdGFydCcsIFt0aGlzLCB0aGlzLnBsYWNlaG9sZGVyXSk7XG5cbiAgICAgICAgICB0cmFja1Njcm9sbCh0aGlzLnBvcyk7XG5cbiAgICAgICAgICB0aGlzLm1vdmUoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZShlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZykge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnbW92ZScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgTWF0aC5hYnModGhpcy5wb3MueCAtIHRoaXMub3JpZ2luLngpID4gdGhpcy50aHJlc2hvbGQgfHxcbiAgICAgICAgICBNYXRoLmFicyh0aGlzLnBvcy55IC0gdGhpcy5vcmlnaW4ueSkgPiB0aGlzLnRocmVzaG9sZClcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgb2ZmKGRvY3VtZW50LCBwb2ludGVyTW92ZSwgdGhpcy5tb3ZlKTtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIHBvaW50ZXJVcCwgdGhpcy5lbmQpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1bnRyYWNrU2Nyb2xsKCk7XG5cbiAgICAgICAgICBjb25zdCBzb3J0YWJsZSA9IHRoaXMuZ2V0U29ydGFibGUodGhpcy5wbGFjZWhvbGRlcik7XG5cbiAgICAgICAgICBpZiAodGhpcyA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9yaWdpbi5pbmRleCAhPT0gaW5kZXgodGhpcy5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ21vdmVkJywgW3RoaXMsIHRoaXMucGxhY2Vob2xkZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJpZ2dlcihzb3J0YWJsZS4kZWwsICdhZGRlZCcsIFtzb3J0YWJsZSwgdGhpcy5wbGFjZWhvbGRlcl0pO1xuICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ3JlbW92ZWQnLCBbdGhpcywgdGhpcy5wbGFjZWhvbGRlcl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdzdG9wJywgW3RoaXMsIHRoaXMucGxhY2Vob2xkZXJdKTtcblxuICAgICAgICAgIHJlbW92ZSQxKHRoaXMuZHJhZyk7XG4gICAgICAgICAgdGhpcy5kcmFnID0gbnVsbDtcblxuICAgICAgICAgIGZvciAoY29uc3QgeyBjbHNQbGFjZWhvbGRlciwgY2xzSXRlbSB9IG9mIHRoaXMudG91Y2hlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzb3J0YWJsZSBvZiB0aGlzLnRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc29ydGFibGUuaXRlbXMsIGNsc1BsYWNlaG9sZGVyLCBjbHNJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50b3VjaGVkID0gbnVsbDtcbiAgICAgICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzRHJhZ1N0YXRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnQoZWxlbWVudCwgdGFyZ2V0KSB7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5pdGVtcywgdGhpcy5jbHNJdGVtKTtcblxuICAgICAgICAgIGNvbnN0IGluc2VydCA9ICgpID0+IHRhcmdldCA/IGJlZm9yZSh0YXJnZXQsIGVsZW1lbnQpIDogYXBwZW5kKHRoaXMudGFyZ2V0LCBlbGVtZW50KTtcblxuICAgICAgICAgIHRoaXMuYW5pbWF0ZShpbnNlcnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZShlbGVtZW50KSB7XG4gICAgICAgICAgaWYgKCF3aXRoaW4oZWxlbWVudCwgdGhpcy50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5hbmltYXRlKCgpID0+IHJlbW92ZSQxKGVsZW1lbnQpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTb3J0YWJsZShlbGVtZW50KSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3Qgc29ydGFibGUgPSB0aGlzLiRnZXRDb21wb25lbnQoZWxlbWVudCwgJ3NvcnRhYmxlJyk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHNvcnRhYmxlICYmIChcbiAgICAgICAgICAgIHNvcnRhYmxlID09PSB0aGlzIHx8IHRoaXMuZ3JvdXAgIT09IGZhbHNlICYmIHNvcnRhYmxlLmdyb3VwID09PSB0aGlzLmdyb3VwKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNvcnRhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGVsZW1lbnQgPSBwYXJlbnQoZWxlbWVudCkpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBsZXQgdHJhY2tUaW1lcjtcbiAgICBmdW5jdGlvbiB0cmFja1Njcm9sbChwb3MpIHtcbiAgICAgIGxldCBsYXN0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHRyYWNrVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGxldCB7IHgsIHkgfSA9IHBvcztcbiAgICAgICAgeSArPSBzY3JvbGxUb3Aod2luZG93KTtcblxuICAgICAgICBjb25zdCBkaXN0ID0gKERhdGUubm93KCkgLSBsYXN0KSAqIDAuMztcbiAgICAgICAgbGFzdCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgc2Nyb2xsUGFyZW50cyhkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHBvcy55KSwgL2F1dG98c2Nyb2xsLykuXG4gICAgICAgIHJldmVyc2UoKS5cbiAgICAgICAgc29tZSgoc2Nyb2xsRWwpID0+IHtcbiAgICAgICAgICBsZXQgeyBzY3JvbGxUb3A6IHNjcm9sbCwgc2Nyb2xsSGVpZ2h0IH0gPSBzY3JvbGxFbDtcblxuICAgICAgICAgIGNvbnN0IHsgdG9wLCBib3R0b20sIGhlaWdodCB9ID0gb2Zmc2V0KGdldFZpZXdwb3J0JDEoc2Nyb2xsRWwpKTtcblxuICAgICAgICAgIGlmICh0b3AgPCB5ICYmIHRvcCArIDM1ID4geSkge1xuICAgICAgICAgICAgc2Nyb2xsIC09IGRpc3Q7XG4gICAgICAgICAgfSBlbHNlIGlmIChib3R0b20gPiB5ICYmIGJvdHRvbSAtIDM1IDwgeSkge1xuICAgICAgICAgICAgc2Nyb2xsICs9IGRpc3Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsID4gMCAmJiBzY3JvbGwgPCBzY3JvbGxIZWlnaHQgLSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHNjcm9sbFRvcChzY3JvbGxFbCwgc2Nyb2xsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCAxNSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW50cmFja1Njcm9sbCgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodHJhY2tUaW1lcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kRHJhZyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGNsb25lID0gYXBwZW5kKFxuICAgICAgY29udGFpbmVyLFxuICAgICAgZWxlbWVudC5vdXRlckhUTUwucmVwbGFjZSgvKF48KSg/OmxpfHRyKXwoPzpsaXx0cikoXFwvPiQpL2csICckMWRpdiQyJykpO1xuXG5cbiAgICAgIGNzcyhjbG9uZSwgJ21hcmdpbicsICcwJywgJ2ltcG9ydGFudCcpO1xuICAgICAgY3NzKGNsb25lLCB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgcGFkZGluZzogY3NzKGVsZW1lbnQsICdwYWRkaW5nJykgfSk7XG5cblxuICAgICAgaGVpZ2h0KGNsb25lLmZpcnN0RWxlbWVudENoaWxkLCBoZWlnaHQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkpO1xuXG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZFRhcmdldChpdGVtcywgcG9pbnQpIHtcbiAgICAgIHJldHVybiBpdGVtc1tmaW5kSW5kZXgoaXRlbXMsIChpdGVtKSA9PiBwb2ludEluUmVjdChwb2ludCwgaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kSW5zZXJ0VGFyZ2V0KGxpc3QsIHRhcmdldCwgcGxhY2Vob2xkZXIsIHgsIHksIHNhbWVMaXN0KSB7XG4gICAgICBpZiAoIWNoaWxkcmVuKGxpc3QpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoIXNhbWVMaXN0KSB7XG4gICAgICAgIGlmICghaXNIb3Jpem9udGFsKGxpc3QsIHBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgIHJldHVybiB5IDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIgPyB0YXJnZXQgOiB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGxhY2Vob2xkZXJSZWN0ID0gcGxhY2Vob2xkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzYW1lUm93ID0gbGluZXNJbnRlcnNlY3QoXG4gICAgICBbcmVjdC50b3AsIHJlY3QuYm90dG9tXSxcbiAgICAgIFtwbGFjZWhvbGRlclJlY3QudG9wLCBwbGFjZWhvbGRlclJlY3QuYm90dG9tXSk7XG5cblxuICAgICAgY29uc3QgcG9pbnRlclBvcyA9IHNhbWVSb3cgPyB4IDogeTtcbiAgICAgIGNvbnN0IGxlbmd0aFByb3AgPSBzYW1lUm93ID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgY29uc3Qgc3RhcnRQcm9wID0gc2FtZVJvdyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgY29uc3QgZW5kUHJvcCA9IHNhbWVSb3cgPyAncmlnaHQnIDogJ2JvdHRvbSc7XG5cbiAgICAgIGNvbnN0IGRpZmYgPVxuICAgICAgcGxhY2Vob2xkZXJSZWN0W2xlbmd0aFByb3BdIDwgcmVjdFtsZW5ndGhQcm9wXSA/XG4gICAgICByZWN0W2xlbmd0aFByb3BdIC0gcGxhY2Vob2xkZXJSZWN0W2xlbmd0aFByb3BdIDpcbiAgICAgIDA7XG5cbiAgICAgIGlmIChwbGFjZWhvbGRlclJlY3Rbc3RhcnRQcm9wXSA8IHJlY3Rbc3RhcnRQcm9wXSkge1xuICAgICAgICBpZiAoZGlmZiAmJiBwb2ludGVyUG9zIDwgcmVjdFtzdGFydFByb3BdICsgZGlmZikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZiAmJiBwb2ludGVyUG9zID4gcmVjdFtlbmRQcm9wXSAtIGRpZmYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSG9yaXpvbnRhbChsaXN0LCBwbGFjZWhvbGRlcikge1xuICAgICAgY29uc3Qgc2luZ2xlID0gY2hpbGRyZW4obGlzdCkubGVuZ3RoID09PSAxO1xuXG4gICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgIGFwcGVuZChsaXN0LCBwbGFjZWhvbGRlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGl0ZW1zID0gY2hpbGRyZW4obGlzdCk7XG4gICAgICBjb25zdCBpc0hvcml6b250YWwgPSBpdGVtcy5zb21lKChlbCwgaSkgPT4ge1xuICAgICAgICBjb25zdCByZWN0QSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gaXRlbXMuc2xpY2UoaSArIDEpLnNvbWUoKGVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVjdEIgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICByZXR1cm4gIWxpbmVzSW50ZXJzZWN0KFtyZWN0QS5sZWZ0LCByZWN0QS5yaWdodF0sIFtyZWN0Qi5sZWZ0LCByZWN0Qi5yaWdodF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgIHJlbW92ZSQxKHBsYWNlaG9sZGVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzSG9yaXpvbnRhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lc0ludGVyc2VjdChsaW5lQSwgbGluZUIpIHtcbiAgICAgIHJldHVybiBsaW5lQVsxXSA+IGxpbmVCWzBdICYmIGxpbmVCWzFdID4gbGluZUFbMF07XG4gICAgfVxuXG4gICAgdmFyIHRvb2x0aXAgPSB7XG4gICAgICBtaXhpbnM6IFtDb250YWluZXIsIFRvZ2dsYWJsZSwgUG9zaXRpb25dLFxuXG4gICAgICBhcmdzOiAndGl0bGUnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBkZWxheTogTnVtYmVyLFxuICAgICAgICB0aXRsZTogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBwb3M6ICd0b3AnLFxuICAgICAgICB0aXRsZTogJycsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBhbmltYXRpb246IFsndWstYW5pbWF0aW9uLXNjYWxlLXVwJ10sXG4gICAgICAgIGR1cmF0aW9uOiAxMDAsXG4gICAgICAgIGNsczogJ3VrLWFjdGl2ZScgfSxcblxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLl9oYXNUaXRsZSA9IGhhc0F0dHIodGhpcy4kZWwsICd0aXRsZScpO1xuICAgICAgICBhdHRyKHRoaXMuJGVsLCAndGl0bGUnLCAnJyk7XG4gICAgICAgIHRoaXMudXBkYXRlQXJpYShmYWxzZSk7XG4gICAgICAgIG1ha2VGb2N1c2FibGUodGhpcy4kZWwpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgYXR0cih0aGlzLiRlbCwgJ3RpdGxlJywgdGhpcy5faGFzVGl0bGUgPyB0aGlzLnRpdGxlIDogbnVsbCk7XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKHRoaXMudG9vbHRpcCB8fCBudWxsKSB8fCAhdGhpcy50aXRsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3VuYmluZCA9IG9uY2UoXG4gICAgICAgICAgZG9jdW1lbnQsIFwic2hvdyBrZXlkb3duIFwiICtcbiAgICAgICAgICBwb2ludGVyRG93bixcbiAgICAgICAgICB0aGlzLmhpZGUsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgKGUpID0+XG4gICAgICAgICAgZS50eXBlID09PSBwb2ludGVyRG93biAmJiAhd2l0aGluKGUudGFyZ2V0LCB0aGlzLiRlbCkgfHxcbiAgICAgICAgICBlLnR5cGUgPT09ICdrZXlkb3duJyAmJiBlLmtleUNvZGUgPT09IDI3IHx8XG4gICAgICAgICAgZS50eXBlID09PSAnc2hvdycgJiYgZS5kZXRhaWxbMF0gIT09IHRoaXMgJiYgZS5kZXRhaWxbMF0uJG5hbWUgPT09IHRoaXMuJG5hbWUpO1xuXG5cbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zaG93VGltZXIpO1xuICAgICAgICAgIHRoaXMuc2hvd1RpbWVyID0gc2V0VGltZW91dCh0aGlzLl9zaG93LCB0aGlzLmRlbGF5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhc3luYyBoaWRlKCkge1xuICAgICAgICAgIGlmIChtYXRjaGVzKHRoaXMuJGVsLCAnaW5wdXQ6Zm9jdXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lcik7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuaXNUb2dnbGVkKHRoaXMudG9vbHRpcCB8fCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLnRvb2x0aXAsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgcmVtb3ZlJDEodGhpcy50b29sdGlwKTtcbiAgICAgICAgICB0aGlzLnRvb2x0aXAgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX3VuYmluZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG93KCkge1xuICAgICAgICAgIHRoaXMudG9vbHRpcCA9IGFwcGVuZChcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lciwgXCI8ZGl2IGNsYXNzPVxcXCJ1ay1cIiArXG4gICAgICAgICAgdGhpcy4kb3B0aW9ucy5uYW1lICsgXCJcXFwiPiA8ZGl2IGNsYXNzPVxcXCJ1ay1cIiArXG4gICAgICAgICAgdGhpcy4kb3B0aW9ucy5uYW1lICsgXCItaW5uZXJcXFwiPlwiICsgdGhpcy50aXRsZSArIFwiPC9kaXY+IDwvZGl2PlwiKTtcblxuXG5cbiAgICAgICAgICBvbih0aGlzLnRvb2x0aXAsICd0b2dnbGVkJywgKGUsIHRvZ2dsZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXJpYSh0b2dnbGVkKTtcblxuICAgICAgICAgICAgaWYgKCF0b2dnbGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkF0KHRoaXMudG9vbHRpcCwgdGhpcy4kZWwpO1xuXG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9XG4gICAgICAgICAgICB0aGlzLmdldEF4aXMoKSA9PT0gJ3knID9cbiAgICAgICAgICAgIGZsaXBQb3NpdGlvbih0aGlzLmRpcikgKyBcIi1cIiArIHRoaXMuYWxpZ24gOlxuICAgICAgICAgICAgdGhpcy5hbGlnbiArIFwiLVwiICsgZmxpcFBvc2l0aW9uKHRoaXMuZGlyKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLnRvb2x0aXAsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUFyaWEodG9nZ2xlZCkge1xuICAgICAgICAgIGF0dHIodGhpcy4kZWwsICdhcmlhLWV4cGFuZGVkJywgdG9nZ2xlZCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgZm9jdXM6ICdzaG93JyxcbiAgICAgICAgYmx1cjogJ2hpZGUnLFxuXG4gICAgICAgIFtwb2ludGVyRW50ZXIgKyBcIiBcIiArIHBvaW50ZXJMZWF2ZV0oZSkge1xuICAgICAgICAgIGlmICghaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgdGhpc1tlLnR5cGUgPT09IHBvaW50ZXJFbnRlciA/ICdzaG93JyA6ICdoaWRlJ10oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2xpY2tpbmcgYSBidXR0b24gZG9lcyBub3QgZ2l2ZSBpdCBmb2N1cyBvbiBhbGwgYnJvd3NlcnMgYW5kIHBsYXRmb3Jtc1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvYnV0dG9uI2NsaWNraW5nX2FuZF9mb2N1c1xuICAgICAgICBbcG9pbnRlckRvd25dKGUpIHtcbiAgICAgICAgICBpZiAoaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBtYWtlRm9jdXNhYmxlKGVsKSB7XG4gICAgICBpZiAoIWlzRm9jdXNhYmxlKGVsKSkge1xuICAgICAgICBhdHRyKGVsLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1cGxvYWQgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBhbGxvdzogU3RyaW5nLFxuICAgICAgICBjbHNEcmFnb3ZlcjogU3RyaW5nLFxuICAgICAgICBjb25jdXJyZW50OiBOdW1iZXIsXG4gICAgICAgIG1heFNpemU6IE51bWJlcixcbiAgICAgICAgbWV0aG9kOiBTdHJpbmcsXG4gICAgICAgIG1pbWU6IFN0cmluZyxcbiAgICAgICAgbXNnSW52YWxpZE1pbWU6IFN0cmluZyxcbiAgICAgICAgbXNnSW52YWxpZE5hbWU6IFN0cmluZyxcbiAgICAgICAgbXNnSW52YWxpZFNpemU6IFN0cmluZyxcbiAgICAgICAgbXVsdGlwbGU6IEJvb2xlYW4sXG4gICAgICAgIG5hbWU6IFN0cmluZyxcbiAgICAgICAgcGFyYW1zOiBPYmplY3QsXG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdXJsOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGFsbG93OiBmYWxzZSxcbiAgICAgICAgY2xzRHJhZ292ZXI6ICd1ay1kcmFnb3ZlcicsXG4gICAgICAgIGNvbmN1cnJlbnQ6IDEsXG4gICAgICAgIG1heFNpemU6IDAsXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBtaW1lOiBmYWxzZSxcbiAgICAgICAgbXNnSW52YWxpZE1pbWU6ICdJbnZhbGlkIEZpbGUgVHlwZTogJXMnLFxuICAgICAgICBtc2dJbnZhbGlkTmFtZTogJ0ludmFsaWQgRmlsZSBOYW1lOiAlcycsXG4gICAgICAgIG1zZ0ludmFsaWRTaXplOiAnSW52YWxpZCBGaWxlIFNpemU6ICVzIEtpbG9ieXRlcyBNYXgnLFxuICAgICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgICAgIG5hbWU6ICdmaWxlc1tdJyxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgdHlwZTogJycsXG4gICAgICAgIHVybDogJycsXG4gICAgICAgIGFib3J0OiBub29wLFxuICAgICAgICBiZWZvcmVBbGw6IG5vb3AsXG4gICAgICAgIGJlZm9yZVNlbmQ6IG5vb3AsXG4gICAgICAgIGNvbXBsZXRlOiBub29wLFxuICAgICAgICBjb21wbGV0ZUFsbDogbm9vcCxcbiAgICAgICAgZXJyb3I6IG5vb3AsXG4gICAgICAgIGZhaWw6IG5vb3AsXG4gICAgICAgIGxvYWQ6IG5vb3AsXG4gICAgICAgIGxvYWRFbmQ6IG5vb3AsXG4gICAgICAgIGxvYWRTdGFydDogbm9vcCxcbiAgICAgICAgcHJvZ3Jlc3M6IG5vb3AgfSxcblxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgY2hhbmdlKGUpIHtcbiAgICAgICAgICBpZiAoIW1hdGNoZXMoZS50YXJnZXQsICdpbnB1dFt0eXBlPVwiZmlsZVwiXScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKGUudGFyZ2V0LmZpbGVzKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZChlLnRhcmdldC5maWxlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZS50YXJnZXQudmFsdWUgPSAnJztcbiAgICAgICAgfSxcblxuICAgICAgICBkcm9wKGUpIHtcbiAgICAgICAgICBzdG9wKGUpO1xuXG4gICAgICAgICAgY29uc3QgdHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgICAgICAgIGlmICghKHRyYW5zZmVyICE9IG51bGwgJiYgdHJhbnNmZXIuZmlsZXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRHJhZ292ZXIpO1xuXG4gICAgICAgICAgdGhpcy51cGxvYWQodHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdlbnRlcihlKSB7XG4gICAgICAgICAgc3RvcChlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmFnb3ZlcihlKSB7XG4gICAgICAgICAgc3RvcChlKTtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcmFnb3Zlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJhZ2xlYXZlKGUpIHtcbiAgICAgICAgICBzdG9wKGUpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0RyYWdvdmVyKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgdXBsb2FkKGZpbGVzKSB7XG4gICAgICAgICAgZmlsZXMgPSB0b0FycmF5KGZpbGVzKTtcblxuICAgICAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ3VwbG9hZCcsIFtmaWxlc10pO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhTaXplICYmIHRoaXMubWF4U2l6ZSAqIDEwMDAgPCBmaWxlLnNpemUpIHtcbiAgICAgICAgICAgICAgdGhpcy5mYWlsKHRoaXMubXNnSW52YWxpZFNpemUucmVwbGFjZSgnJXMnLCB0aGlzLm1heFNpemUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvdyAmJiAhbWF0Y2godGhpcy5hbGxvdywgZmlsZS5uYW1lKSkge1xuICAgICAgICAgICAgICB0aGlzLmZhaWwodGhpcy5tc2dJbnZhbGlkTmFtZS5yZXBsYWNlKCclcycsIHRoaXMuYWxsb3cpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5taW1lICYmICFtYXRjaCh0aGlzLm1pbWUsIGZpbGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5mYWlsKHRoaXMubXNnSW52YWxpZE1pbWUucmVwbGFjZSgnJXMnLCB0aGlzLm1pbWUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgZmlsZXMgPSBmaWxlcy5zbGljZSgwLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJlZm9yZUFsbCh0aGlzLCBmaWxlcyk7XG5cbiAgICAgICAgICBjb25zdCBjaHVua3MgPSBjaHVuayhmaWxlcywgdGhpcy5jb25jdXJyZW50KTtcbiAgICAgICAgICBjb25zdCB1cGxvYWQgPSBhc3luYyAoZmlsZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4gZGF0YS5hcHBlbmQodGhpcy5uYW1lLCBmaWxlKSk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMucGFyYW1zKSB7XG4gICAgICAgICAgICAgIGRhdGEuYXBwZW5kKGtleSwgdGhpcy5wYXJhbXNba2V5XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHhociA9IGF3YWl0IGFqYXgodGhpcy51cmwsIHtcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgYmVmb3JlU2VuZDogKGVudikgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgeyB4aHIgfSA9IGVudjtcbiAgICAgICAgICAgICAgICAgIHhoci51cGxvYWQgJiYgb24oeGhyLnVwbG9hZCwgJ3Byb2dyZXNzJywgdGhpcy5wcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgWydsb2FkU3RhcnQnLCAnbG9hZCcsICdsb2FkRW5kJywgJ2Fib3J0J10pIHtcbiAgICAgICAgICAgICAgICAgICAgb24oeGhyLCB0eXBlLnRvTG93ZXJDYXNlKCksIHRoaXNbdHlwZV0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZW5kKGVudik7XG4gICAgICAgICAgICAgICAgfSB9KTtcblxuXG4gICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoeGhyKTtcblxuICAgICAgICAgICAgICBpZiAoY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZChjaHVua3Muc2hpZnQoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFsbCh4aHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGF3YWl0IHVwbG9hZChjaHVua3Muc2hpZnQoKSk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIG1hdGNoKHBhdHRlcm4sIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLm1hdGNoKFxuICAgICAgbmV3IFJlZ0V4cChcIl5cIiArXG4gICAgICBwYXR0ZXJuLlxuICAgICAgcmVwbGFjZSgvXFwvL2csICdcXFxcLycpLlxuICAgICAgcmVwbGFjZSgvXFwqXFwqL2csICcoXFxcXC9bXlxcXFwvXSspKicpLlxuICAgICAgcmVwbGFjZSgvXFwqL2csICdbXlxcXFwvXSsnKS5cbiAgICAgIHJlcGxhY2UoLygoPyFcXFxcKSlcXD8vZywgJyQxLicpICsgXCIkXCIsXG4gICAgICAnaScpKTtcblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2h1bmsoZmlsZXMsIHNpemUpIHtcbiAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkgKz0gc2l6ZSkge1xuICAgICAgICBjaHVua3MucHVzaChmaWxlcy5zbGljZShpLCBpICsgc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNodW5rcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdG9wKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgQ291bnRkb3duOiBjb3VudGRvd24sXG4gICAgICAgIEZpbHRlcjogZmlsdGVyLFxuICAgICAgICBMaWdodGJveDogbGlnaHRib3gsXG4gICAgICAgIExpZ2h0Ym94UGFuZWw6IExpZ2h0Ym94UGFuZWwsXG4gICAgICAgIE5vdGlmaWNhdGlvbjogbm90aWZpY2F0aW9uLFxuICAgICAgICBQYXJhbGxheDogcGFyYWxsYXgsXG4gICAgICAgIFNsaWRlcjogc2xpZGVyLFxuICAgICAgICBTbGlkZXJQYXJhbGxheDogc2xpZGVyUGFyYWxsYXgsXG4gICAgICAgIFNsaWRlc2hvdzogc2xpZGVzaG93LFxuICAgICAgICBTbGlkZXNob3dQYXJhbGxheDogc2xpZGVyUGFyYWxsYXgsXG4gICAgICAgIFNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgVG9vbHRpcDogdG9vbHRpcCxcbiAgICAgICAgVXBsb2FkOiB1cGxvYWRcbiAgICB9KTtcblxuICAgIGVhY2goY29tcG9uZW50cywgKGNvbXBvbmVudCwgbmFtZSkgPT4gVUlraXQuY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkpO1xuXG4gICAgcmV0dXJuIFVJa2l0O1xuXG59KSk7XG4iXX0=
